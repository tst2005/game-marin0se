do require("package").preload["musicloader"] = (function() local package;return function(...)-- <pack musicloader> --
music = {
	loaded = {},
	pitch = 1,
	list = {
		"overworld.ogg",
		"underground.ogg",
		"castle.ogg",
		"underwater.ogg",
		"starmusic.ogg",
		"outofbounds.ogg",
	},
	list_fast = {
		"overworld-fast.ogg",
		"underground-fast.ogg",
		"castle-fast.ogg",
		"underwater-fast.ogg",
		"starmusic-fast.ogg",
	},
}


function getfilepath(name)
	for i=1,#soundsearchdirs-1 do
		--@NOTE: This is making the assumption that the direct file link is at the end.
		local p = soundsearchdirs[i] % {mappack=mappack,file=name,soundpack=soundpack}
		if love.filesystem.isFile(p) then
			return p
		end
	end
end

function music:load(name)
	local filepath = getfilepath(name)
	if not filepath then
		print(string.format("can't load music %q: can't find file!", name))
		return false
	end
	
	if not self.loaded[filepath] then
		local loaded, source = pcall(love.audio.newSource, filepath, "stream")
		if loaded then
			-- all music should loop
			source:setRelative(true)
			source:setPosition(0,0,0)
			source:setVelocity(0,0,0)
			source:setLooping(true)
			source:setPitch(self.pitch)
			self.loaded[name] = source
		else
			print(string.format("can't load music %q: can't create source!", filepath))
			return false
		end
	end
	
	return true
end

function music:play(name, fast)
	if fast then
		local newname = name:sub(0, -5) .. "-fast" .. name:sub(-4)
		if getfilepath(newname) then
			name = newname
		end
	end
	
	-- try to load source from disk if it hasn't been loaded already
	if not self.loaded[name] and not self:load(name) then
		return
	end
	
	if self.loaded[name] then
		if soundenabled then
			self.loaded[name]:stop()
			self.loaded[name]:rewind()
			self.loaded[name]:play()
		end
	end
end

function music:stop(name, fast)
	if fast then
		local newname = name:sub(0, -5) .. "-fast" .. name:sub(-4)
		if getfilepath(newname) then
			name = newname
		end
	end
	
	if self.loaded[name] then
		self.loaded[name]:stop()
	end
end

function music:update()
	for filepath, source in pairs(self.loaded) do
		source:setPitch(self.pitch)
	end
end
end end)()end;
do require("package").preload["miniblock"] = (function() local package;return function(...)-- <pack miniblock> --
miniblock = class("miniblock")

function miniblock:init(x, y, i)
	self.x = x+math.random()*0.8-0.4
	self.y = y
	self.i = i
	self.speedy = -10
	
	self.timer = math.pi*1.5
end

function miniblock:update(dt)
	self.speedy = self.speedy + yacceleration*dt
	--check for collision
	local x = math.floor(self.x)+1
	local y = math.floor(self.y+self.speedy*dt)+1
	
	if inmap(x, y) and self.speedy > 0 and tilequads[map[x][y][1]]:getproperty("collision", x, y) then
		self.y = math.ceil(self.y)
		self.speedy = 0
		self.timer = self.timer + dt*3
	end
	
	if self.timer > 5 then
		--check for player pickup
		for i = 1, players do
			local x = objects["player"][i].x+objects["player"][i].width
			local y = objects["player"][i].y+objects["player"][i].height
			
			if math.abs(self.x-x) + math.abs(self.y-y) < 1 then
				if collectblock(self.i) then
					return true
				end
			end
		end
	end
	
	self.y = self.y + self.speedy*dt
	
	if self.y > 16 then
		return true
	end
	
	return false
end

function miniblock:draw()
	local img = customtilesimg
	if self.i <= smbtilecount then
		img = smbtilesimg
	elseif self.i <= smbtilecount+portaltilecount then
		img = portaltilesimg
	end
	
	local yadd = math.sin(self.timer)*0.1+0.15
	love.graphics.draw(img, tilequads[self.i]:quad(), math.floor((self.x-xscroll)*16*scale), math.floor((self.y-yscroll-.5-yadd)*16*scale), 0, scale/2, scale/2, 8, 16)
end
end end)()end;
do require("package").preload["libs.tserial"] = (function() local package;return function(...)-- <pack libs.tserial> --
--- Tserial v1.51d, a simple table serializer which turns tables into Lua script
-- @author Taehl (SelfMadeSpirit@gmail.com)
Tserial = {}
TSerial = Tserial	-- for backwards-compatibility

--- Serializes a table into a string, in form of Lua script.
-- @param t table to be serialized (may not contain any circular reference)
-- @param drop if true, unserializable types will be silently dropped instead of raising errors
-- if drop is a function, it will be called to serialize unsupported types
-- if drop is a table, it will be used as a serialization table (where {[value] = serial})
-- @param indent if true, output "human readable" mode with newlines and indentation (for debug)
-- @return string recreating given table
function Tserial.pack(t, drop, indent)
	assert(type(t) == "table", "Can only Tserial.pack tables.")
	local s, empty, indent = "{"..(indent and "\n" or ""), true, indent and math.max(type(indent)=="number" and indent or 0,0)
	local function proc(k,v, omitKey)	-- encode a key/value pair
		empty = nil	-- helps ensure empty tables return as "{}"
		local tk, tv, skip = type(k), type(v)
		if type(drop)=="table" and drop[k] then k = "["..drop[k].."]"
		elseif tk == "boolean" then k = k and "[true]" or "[false]"
		elseif tk == "string" then
			local f = string.format("%q",k)
			if f ~= '"'..k..'"' or string.find(k, " ") then k = '['..f..']' end
		elseif tk == "number" then k = "["..k.."]"
		elseif tk == "table" then k = "["..Tserial.pack(k, drop, indent and indent+1).."]"
		elseif type(drop) == "function" then k = "["..string.format("%q",drop(k)).."]"
		elseif drop then skip = true
		else error("Attempted to Tserial.pack a table with an invalid key: "..tostring(k))
		end
		if type(drop)=="table" and drop[v] then v = drop[v]
		elseif tv == "boolean" then v = v and "true" or "false"
		elseif tv == "string" then v = string.format("%q", v)
		elseif tv == "number" then	-- no change needed
		elseif tv == "table" then v = Tserial.pack(v, drop, indent and indent+1)
		elseif type(drop) == "function" then v = string.format("%q",drop(v))
		elseif drop then skip = true
		else error("Attempted to Tserial.pack a table with an invalid value: "..tostring(v))
		end
		if not skip then return string.rep("\t",indent or 0)..(omitKey and "" or k.."=")..v..","..(indent and "\n" or "") end
		return ""
	end
	local l, did=-1,{} repeat l=l+1 until t[l+1]==nil	-- #t "can" lie!
	for i=1,l do s = s..proc(i, t[i], true) did[i]=true end	-- use ordered values when possible for better string
	for k, v in pairs(t) do if not did[k] then s = s..proc(k, v) end end
	if not empty then s = string.sub(s,1,string.len(s)-1) end
	if indent then s = string.sub(s,1,string.len(s)-1).."\n" end
	return s..string.rep("\t",(indent or 1)-1).."}"
end

--- Loads a table into memory from a string (like those output by Tserial.pack)
-- @param s a string of Lua defining a table, such as "{2,4,8,ex='ample'}"
-- @param safe if true, all extraneous parts of the string will be removed, leaving only a table (prevents running anomalous code when unpacking untrusted strings). Will also cause malformed tables to quietly return nil and an error message, instead of throwing an error (so your program can't be crashed with a bad string)
-- @return a table recreated from the given string.
function Tserial.unpack(s, safe)
	if safe then s = string.match(s, "(%b{})") end
	assert(type(s) == "string", "Can only Tserial.unpack strings.")
	local f, result = loadstring("Tserial.table="..s)
	if not safe then assert(f,result) elseif not f then return nil, result end
	result = f()
	local t = Tserial.table
	Tserial.table = nil
	return t, result
end
end end)()end;
do require("package").preload["libs.TLbind"] = (function() local package;return function(...)-- <pack libs.TLbind> --
--- TLbind v1.3, a simple system for creating professional control schemes
-- @author Taehl (SelfMadeSpirit@gmail.com), with contributions from smrq


local update
--- Gives a new instance of TLbind settings and control.
-- Good for OOP, multi-player split-screen with their own controls, etc.
-- Use: P1.bind, P1.control = TLbind.giveInstance( aTableOfBinds )
-- @param binds table specifies inputs, controls, and settings
-- @return b, a fresh new control instance (for changing settings)
-- @return b.control, the table to check if a control is being used
-- @return b.control.tap, where controls are only true for one frame when first used
-- @return b.control.release, where controls are only true for one frame when released
local function giveInstance( binds )
	--- The binds table specifies inputs, controls, and settings
	-- @class table
	-- @name binds
	-- @field useKeyboard if true, process keyboard input
	-- @field useMouse if true, process mouse input
	-- @field useJoystick if true, process joystick input
	-- @field deadzone clip analogue deadzoneAxes pairs to 0 when under this number (must be >= 0 and < 1)
	-- @field pairedAxes [joystick#][index#] = {axis#1, axis#2}
	-- @field deadzoneAxes [index#] = {"analogue 1", "analogue 2"} (note: pairs will also be normalized, which fixes the common "running diagonally is faster" bug)
	-- @field keys [KeyConstant] = "control"
	-- @field mouseAxes {"x control", "y control"}
	-- @field mouseBtns [MouseConstant] = "control"
	-- @field joyAxes [joystick#][axis#] = "control"
	-- @field joyBtns [joystick#][button#] = "control"
	-- @field joyBalls [joystick#][ball#] = {"x control", "y control"}
	-- @field joyHats [joystick#][hat#] = {"l control", "r control", "u control", "d control"}
	-- @field maps [analogue] = {"negative digital", "positive digital"}
	local b = {
		useKeyboard = true, useMouse = false, useJoystick = true, 
		deadzone = 0.1, keys = {}, mouseAxes = {}, mouseBtns = {}, 
		joyAxes = {}, joyBtns = {}, joyBalls = {}, joyHats = {}, 
		deadzoneAxes = {}, maps = {}, pairedAxes = {}
	}
	
	if binds then		-- use supplied binds, if given (safer to copy than directly reference!)
		local function tableCombine( a, b )
			local t = {}
			for k, v in pairs(a) do if type(v)=="table" then t[k]=tableCombine(v) else t[k]=v end end
			if b then for k, v in pairs(b) do if type(v)=="table" then t[k]=tableCombine(v) else t[k]=v end end end
			return t
		end
		b = tableCombine(b, binds)
	end
	b.update = update
	b.control = {tap={},release={}}
	
	-- The callbacks are .controlPressed and .controlReleased (they work just like Love's callbacks)
	-- Use: function TLbind.controlPressed(control) if control=="jump" then doJump() end end
	return b, b.control, b.control.tap, b.control.release
end


--- In love.update(), :update() on each bind instance.
-- You'll probably want to add TLbind:update() to your love.update().
-- @param b table a control instance, such as the default TLbind
update = function(b)
	local control, tap, release = b.control, b.control.tap, b.control.release
	-- Reset controls
	for k,v in pairs(control) do if type(v)~="table" then control[k] = false end end
	
	-- Check key inputs (if enabled)
	if b.useKeyboard then
		assert(love.keyboard, "TLbind was told to use keyboard input, but love.keyboard isn't available! (Check conf.lua)")
		for k,v in pairs(b.keys) do
			local t={}
			if type(v)=="table" then
				t=v
			else
				t={v}
			end
			for k2,v2 in pairs(t) do
				control[v2] = control[v2] or love.keyboard.isDown(k)
			end
		end
	end
	
	-- Check joystick inputs (if enabled)
	if b.useJoystick then
		assert(love.joystick, "TLbind was told to use joystick input, but love.joystick isn't available! (Check conf.lua)")
		local lj = love.joystick
		local js = lj.getJoysticks()
		for j,binds in pairs(b.joyAxes) do 
			for k,v in pairs(binds) do
				local t={}
				if type(v)=="table" then
					t=v
				else
					t={v}
				end
				for k2,v2 in pairs(t) do
					control[v2] = control[v2] or js[j]:getAxis(k)
				end
			end
		end
		for j,binds in pairs(b.joyBtns) do
			for k,v in pairs(binds) do
				local t={}
				if type(v)=="table" then
					t=v
				else
					t={v}
				end
				for k2,v2 in pairs(t) do
					if js[j] then
						--[[@TODO: 
							Refactor this later, we're doing this check so that when someone
							launches the game without a joystick plugged in it doesn't crash
							because controls are defined for a joystick.
						]]
						control[v2] = control[v2] or js[j]:isDown(k)
					end
				end
			end
		end
		-- balls are missing in love0.9.1, goodbye balls
		--for j,binds in pairs(b.joyBalls) do
		--	for k,v in pairs(binds) do
		--		control[v[1]], control[v[2]] = js[j]:getBall(k)
		--	end
		--end
		for j,binds in pairs(b.joyHats) do
			for k,v in pairs(binds) do
				local t={}
				if type(v)=="table" then
					t=v
				else
					t={v}
				end
				local z = js[j]:getHat(k)
				for k2,v2 in pairs(t) do
					if string.sub(z,1,1)=="l" then 
						control[v2[1]]=true
					elseif string.sub(z,1,1)=="r" then
						control[v2[2]]=true 
					end
					if string.sub(z,-1)=="u" then
						control[v2[3]]=true
					elseif string.sub(z,-1)=="d" then
						control[v2[4]]=true
					end
				end
			end
		end
	end
	
	-- Check mouse inputs (if enabled)
	if b.useMouse then
		assert(love.mouse, "TLbind was told to use mouse input, but love.mouse isn't available! (Check conf.lua)")
		for k,v in pairs(b.mouseBtns) do
			local t={}
			if type(v)=="table" then
				t=v
			else
				t={v}
			end
			for k2,v2 in pairs(t) do
				control[v2] = control[v2] or love.mouse.isDown(k)
			end
		end
		
		-- Get screen metrics, to convert pixel coordinates into normals (treating the center of the screen as (0,0) )
		local w, h = love.graphics.getWidth(), love.graphics.getHeight()
		local ws, hs = w*.5, h*.5
		local wt, ht = ws, w*.5-(w-h)*.5
		-- Set mouse axes if they haven't already gotten input
		local mA1, mA2 = control[b.mouseAxes[1]], control[b.mouseAxes[2]]
		if b.mouseAxes[1]~=nil or b.mouseAxes[2]~=nil then
			if (mA1==0 and mA2==0) then
				control[b.mouseAxes[1]], control[b.mouseAxes[2]] = (love.mouse.getX()-wt)/hs, (love.mouse.getY()-ht)/hs
			end
		end
	end
	
	-- Apply scaled radial deadzone on desired axis pairs (requires normalizing them too)
	
	--[[for j,binds in pairs(b.deadzoneAxes) do 
		for k,v in pairs(binds) do
			local t={}
			if type(v)=="table" then
				t=v
			else
				t={v}
			end
			for k2,v2 in pairs(t) do
				control[v2] = control[v2] or js[j]:getAxis(k)
			end
		end
	end]]
	
	local lj = love.joystick
	local js = lj.getJoysticks()
	for j,index in pairs(b.pairedAxes) do
		-- j is the controller number
		-- index is the pair doesn't mean much
		for k,tpairs in pairs(index) do
			-- k isn't important
			-- tpairs is the data
			if js[j] then
				--@TODO: See above todo.
				local x, y = js[j]:getAxis(tpairs[1]), js[j]:getAxis(tpairs[2])
				if x and y then
					local l = (x*x+y*y)^.5
					if l > 1 then x,y,l = x/l, y/l, 1 end
					if l<b.deadzone then
						control[b.deadzoneAxes[j][tpairs[1]]], control[b.deadzoneAxes[j][tpairs[2]]] = 0, 0
					else
						local n = ((l-b.deadzone)/(1-b.deadzone))
						control[b.deadzoneAxes[j][tpairs[1]]], control[b.deadzoneAxes[j][tpairs[2]]] = x*n, y*n
					end
				end
			end
		end
	end
	
	-- Impose digital controls onto analogue controls and vice versa (binding first if needed)
	for a,d in pairs(b.maps) do
		if type(controls[a])=="boolean" then 
			if controls[a] then
				controls[a]=1
			else 
				controls[a]=0
			end
		elseif type(controls[a])=="nil" then 
			controls[a]=0 
		end
		--print("tier1", a, d)
		for h,o in pairs(d) do
			--print("tier2", h, o)
			--for k,v in pairs(o) do
				local t={}
				if type(o)=="table" then
					t=o
				else
					t={o}
				end
				if control[a]~= nil then
					for k2,v2 in pairs(t) do
						--print("tier3", k2, v2)
						-- I think this is how maps?!
						--if control[d[1]]--[[ then control[a]=-1 elseif control[d[2]]--[[ then control[a]=1 end
						if h==1 and control[a]<-b.deadzone then
							--print("valueneg", control[a], v2)
							control[v2]=true 
						elseif h==2 and control[a]>b.deadzone then
							--print("valuepos", control[a], v2)
							control[v2]=true
						end
					end
				end
			--end
		end
		--if control[d[1]]--[[ then control[a]=-1 elseif control[d[2]]--[[ then control[a]=1 end
		--if control[a]<0 then control[d[1]]--[[=true elseif control[a]>0 then control[d[2]]--[[=true end]]
	end
	
	-- Detect controls being tapped and released
	for k,v in pairs(control) do
		if v then
			release[k] = false
			if tap[k]==false then 
				tap[k]=true
				if b.controlPressed then
					b.controlPressed(k)
				end
			elseif tap[k]==true then
				tap[k]=nil
			end
		else
			tap[k] = false
			if release[k]==false then
				release[k]=true 
				if b.controlReleased then
					b.controlReleased(k)
				end
			elseif release[k]==true then
				release[k]=nil
			end
		end
	end
end


--- Default binds are assigned to global var TLbind
-- Example: Open a menu when escape is pressed
-- function love.load() TLbind.keys.escape = "menu" end
-- function love.update() if TLcontrol.tap.menu then openMenu() end end
TLbind = giveInstance({giveInstance=giveInstance})
return TLbind, TLbind.control, TLbind.control.tap, TLbind.control.release
end end)()end;
do require("package").preload["libs.von"] = (function() local package;return function(...)-- <pack libs.von> --
--[[	vON 1.1.1

	Copyright 2012-2013 Alexandru-Mihai Maftei
					aka Vercas

	You may use this for any purpose as long as:
	-	You don't remove this copyright notice.
	-	You don't claim this to be your own.
	-	You properly credit the author (Vercas) if you publish your work based on (and/or using) this.

	If you modify the code for any purpose, the above obligations still apply.

	Instead of copying this code over for sharing, rather use the link:
		https://dl.dropbox.com/u/1217587/GMod/Lua/von.lua

	The author may not be held responsible for any damage or losses directly or indirectly caused by
	the use of vON.

	If you disagree with the above, don't use the code.

-----------------------------------------------------------------------------------------------------------------------------
	
	Thanks to the following people for their contribution:
		-	Divran						Suggested improvements for making the code quicker.
										Suggested an excellent new way of deserializing strings.
										Lead me to finding an extreme flaw in string parsing.
		-	pennerlord					Provided some performance tests to help me improve the code.
		-	Chessnut					Reported bug with handling of nil values when deserializing array components.

-----------------------------------------------------------------------------------------------------------------------------
	
	The value types supported in this release of vON are:
		-	table
		-	number
		-	boolean
		-	string
		-	nil

	These are the native Lua types one would normally serialize.

-----------------------------------------------------------------------------------------------------------------------------
	
	New in this version:
		-	Fixed problem with handling of nils in array tables.
--]]

local _deserialize, _serialize, _d_meta, _s_meta, d_findVariable, s_anyVariable
local sub, gsub, find, insert, concat, error, tonumber, tostring, type, next = string.sub, string.gsub, string.find, table.insert, table.concat, error, tonumber, tostring, type, next

--	This is kept away from the table for speed.
function d_findVariable(s, i, len, lastType)
	local i, c, typeRead, val = i or 1

	--	Keep looping through the string.
	while true do
		--	Stop at the end. Throw an error. This function MUST NOT meet the end!
		if i > len then
			error("vON: Reached end of string, cannot form proper variable.")
		end

		--	Cache the character. Nobody wants to look for the same character ten times.
		c = sub(s, i, i)

		--	If it just read a type definition, then a variable HAS to come after it.
		if typeRead then
			--	Attempt to deserialize a variable of the freshly read type.
			val, i = _deserialize[lastType](s, i, len)
			--	Return the value read, the index of the last processed character, and the type of the last read variable.
			return val, i, lastType

		--	@ means nil. It should not even appear in the output string of the serializer. Nils are useless to store.
		elseif c == "@" then
			return nil, i, lastType

		--	n means a number will follow. Base 10... :C
		elseif c == "n" then
			lastType = "number"
			typeRead = true

		--	b means boolean flags.
		elseif c == "b" then
			lastType = "boolean"
			typeRead = true

		--	" means the start of a string.
		elseif c == "\"" then
			lastType = "string"
			typeRead = true

		--	{ means the start of a table!
		elseif c == "{" then
			lastType = "table"
			typeRead = true

		--	If no type has been found, attempt to deserialize the last type read.
		elseif lastType then
			val, i = _deserialize[lastType](s, i, len)
			return val, i, lastType

		--	This will occur if the very first character in the vON code is wrong.
		else
			error("vON: Malformed data... Can't find a proper type definition. Char#" .. i .. ":" .. c)
		end

		--	Move the pointer one step forward.
		i = i + 1
	end
end

--	This is kept away from the table for speed.
--	Yeah, crapload of parameters.
function s_anyVariable(data, lastType, isNumeric, isKey, isLast, nice, indent)

	--	Basically, if the type changes.
	if lastType ~= type(data) then
		--	Remember the new type. Caching the type is useless.
		lastType = type(data)

		--	Return the serialized data and the (new) last type.
		--	The second argument, which is true now, means that the data type was just changed.
		if _serialize[lastType]==nil then
			assert(false, "Tried to serialize a '"..lastType.."'!")
		end
		return _serialize[lastType](data, true, isNumeric, isKey, isLast, nice, indent), lastType
	end

	--	Otherwise, simply serialize the data.
	return _serialize[lastType](data, false, isNumeric, isKey, isLast, nice, indent), lastType
end

_deserialize = {

--	Well, tables are very loose...
--	The first table doesn't have to begin and end with { and }.
	["table"] = function(s, i, len, unnecessaryEnd)
		local ret, numeric, i, c, lastType, val, ind, expectValue, key = {}, true, i or 1, nil, nil, nil, 1
		--	Locals, locals, locals, locals, locals, locals, locals, locals and locals.

		--	Keep looping.
		while true do
			--	Until it meets the end.
			if i > len then
				--	Yeah, if the end is unnecessary, it won't spit an error. The main chunk doesn't require an end, for example.
				if unnecessaryEnd then
					return ret, i

				--	Otherwise, the data has to be damaged.
				else
					error("vON: Reached end of string, incomplete table definition.")
				end
			end

			--	Cache the character.
			c = sub(s, i, i)
			--print(i, "table char:", c, tostring(unnecessaryEnd))

			--	If it's the end of a table definition, return.
			if c == "}" then
				return ret, i

			--	If it's the component separator, switch to key:value pairs.
			elseif c == "~" then
				numeric = false

			elseif c == ";" then
				--	Lol, nothing!
				--	Remenant from numbers, for faster parsing.

			--	OK, now, if it's on the numeric component, simply add everything encountered.
			elseif numeric then
				--	Find a variable and it's value
				val, i, lastType = d_findVariable(s, i, len, lastType)
				--	Add it to the table.
				ret[ind] = val

				ind = ind + 1

			--	Otherwise, if it's the key:value component...
			else
				--	If a value is expected...
				if expectValue then
					--	Read it.
					val, i, lastType = d_findVariable(s, i, len, lastType)
					--	Add it?
					ret[key] = val
					--	Clean up.
					expectValue, key = false, nil

				--	If it's the separator...
				elseif c == ":" then
					--	Expect a value next.
					expectValue = true

				--	But, if there's a key read already...
				elseif key then
					--	Then this is malformed.
					error("vON: Malformed table... Two keys declared successively? Char#" .. i .. ":" .. c)

				--	Otherwise the key will be read.
				else
					--	I love multi-return and multi-assignement.
					key, i, lastType = d_findVariable(s, i, len, lastType)
				end
			end

			i = i + 1
		end

		return nil, i
	end,


--	Numbers are weakly defined.
--	The declaration is not very explicit. It'll do it's best to parse the number.
--	Has various endings: \n, }, ~, : and ;, some of which will force the table deserializer to go one char backwards.
	["number"] = function(s, i, len)
		local i, a = i or 1
		--	Locals, locals, locals, locals

		a = find(s, "[;:}~]", i)

		if a then
			return tonumber(sub(s, i, a - 1)), a - 1
		end

		error("vON: Number definition started... Found no end.")
	end,


--	A boolean is A SINGLE CHARACTER, either 1 for true or 0 for false.
--	Any other attempt at boolean declaration will result in a failure.
	["boolean"] = function(s, i, len)
		local c = sub(s,i,i)
		--	Only one character is needed.

		--	If it's 1, then it's true
		if c == "1" then
			return true, i

		--	If it's 0, then it's false.
		elseif c == "0" then
			return false, i
		end

		--	Any other supposely "boolean" is just a sign of malformed data.
		error("vON: Invalid value on boolean type... Char#" .. i .. ": " .. c)
	end,


--	Strings are very easy to parse and also very explicit.
--	" simply marks the type of a string.
--	Then it is parsed until an unescaped " is countered.
	["string"] = function(s, i, len)
		local res, i, a = "", i or 1
		--	Locals, locals, locals, locals

		while true do
			a = find(s, "\"", i, true)

			if a then
				if sub(s, a - 1, a - 1) == "\\" then
					res = res .. sub(s, i, a - 2) .. "\""
					i = a + 1
				else
					return res .. sub(s, i, a - 2), a
				end
			else
				error("vON: String definition started... Found no end.")
			end
		end
	end
}


_serialize = {

--	Uh. Nothing to comment.
--	Shitload of parameters.
--	Makes shit faster than simply passing it around in locals.
--	table.concat works better than normal concatenations WITH LARGE-ISH STRINGS ONLY.
	["table"] = function(data, mustInitiate, isNumeric, isKey, isLast, first)
		--print(string.format("data: %s; mustInitiate: %s; isKey: %s; isLast: %s; nice: %s; indent: %s; first: %s", tostring(data), tostring(mustInitiate), tostring(isKey), tostring(isLast), tostring(nice), tostring(indent), tostring(first)))

		local result, keyvals, len, keyvalsLen, keyvalsProgress, val, lastType, newIndent, indentString = {}, {}, #data, 0, 0
		--	Locals, locals, locals, locals, locals, locals, locals, locals, locals and locals.

		--	First thing to be done is separate the numeric and key:value components of the given table in two tables.
		--	pairs(data) is slower than next, data as far as my tests tell me.
		for k, v in next, data do
			--	Skip the numeric keyz.
			if type(k) ~= "number" or k < 1 or k > len then
				keyvals[#keyvals + 1] = k
			end
		end

		keyvalsLen = #keyvals

		--	Main chunk - no initial character.
		if not first then
			result[#result + 1] = "{"
		end

		--	Add numeric values.
		if len > 0 then
			for i = 1, len do
				val, lastType = s_anyVariable(data[i], lastType, true, false, i == len and not first, false, 0)
				result[#result + 1] = val
			end
		end

		--	If there are key:value pairs.
		if keyvalsLen > 0 then
			--	Insert delimiter.
			result[#result + 1] = "~"

			--	Insert key:value pairs.
			for _i = 1, keyvalsLen do
				keyvalsProgress = keyvalsProgress + 1

				val, lastType = s_anyVariable(keyvals[_i], lastType, false, true, false, false, 0)

				result[#result + 1] = val..":"

				val, lastType = s_anyVariable(data[keyvals[_i]], lastType, false, false, keyvalsProgress == keyvalsLen and not first, false, 0)
				
				result[#result + 1] = val
			end
		end

		--	Main chunk needs no ending character.
		if not first then
			result[#result + 1] = "}"
		end

		return concat(result)
	end,


--	Normal concatenations is a lot faster with small strings than table.concat
--	Also, not so branched-ish.
	["number"] = function(data, mustInitiate, isNumeric, isKey, isLast)
		--	If a number hasn't been written before, add the type prefix.
		if mustInitiate then
			if isKey or isLast then
				return "n"..data
			else
				return "n"..data..";"
			end
		end

		if isKey or isLast then
			return "n"..data
		else
			return "n"..data..";"
		end
	end,


--	I hope gsub is fast enough.
	["string"] = function(data, mustInitiate, isNumeric, isKey, isLast)
		return "\"" .. gsub(data, "\"", "\\\"") .. "v\""
	end,
	
--	Throw this shit straight in the garbage.
	["userdata"] = function(data, mustInitiate, isNumeric, isKey, isLast)
		return "@"
	end,
	["function"] = function(data, mustInitiate, isNumeric, isKey, isLast)
		return "@"
	end,

--	Fastest.
	["boolean"] = function(data, mustInitiate, isNumeric, isKey, isLast)
		--	Prefix if we must.
		if mustInitiate then
			if data then
				return "b1"
			else
				return "b0"
			end
		end

		if data then
			return "1"
		else
			return "0"
		end
	end,


--	Fastest.
	["nil"] = function(data, mustInitiate, isNumeric, isKey, isLast)
		return "@"
	end
}

local _s_table = _serialize.table
local _d_table = _deserialize.table

_d_meta = {
	__call = function(self, str)
		if type(str) == "string" then
			return _d_table(str, nil, #str, true)
		end
		error("vON: You must deserialize a string, not a "..type(str))
	end
}
_s_meta = {
	__call = function(self, data)
		if type(data) == "table" then
			return _s_table(data, nil, nil, nil, nil, true)
		end
		error("vON: You must serialize a table, not a "..type(data))
	end
}

von = {}

von.deserialize = setmetatable(_deserialize,_d_meta)
von.serialize = setmetatable(_serialize,_s_meta)
end end)()end;
do require("package").preload["libs.https"] = (function() local package;return function(...)-- <pack libs.https> --
----------------------------------------------------------------------------
-- LuaSec 0.4.1
-- Copyright (C) 2009-2011 PUC-Rio
--
-- Author: Pablo Musa
-- Author: Tomas Guisasola
---------------------------------------------------------------------------

local socket = require("socket")
local ssl    = require("ssl")
local ltn12  = require("ltn12")
local http   = require("socket.http")
local url    = require("socket.url")

local table  = require("table")
local string = require("string")

local try          = socket.try
local type         = type
local pairs        = pairs
local getmetatable = getmetatable

module("ssl.https")

_VERSION   = "0.4.1"
_COPYRIGHT = "LuaSec 0.4.1 - Copyright (C) 2009-2011 PUC-Rio"

-- Default settings
PORT = 443

local cfg = {
  protocol = "tlsv1",
  options  = "all",
  verify   = "none",
}

--------------------------------------------------------------------
-- Auxiliar Functions
--------------------------------------------------------------------

-- Insert default HTTPS port.
local function default_https_port(u)
   return url.build(url.parse(u, {port = PORT}))
end

-- Convert an URL to a table according to Luasocket needs.
local function urlstring_totable(url, body, result_table)
   url = {
      url = default_https_port(url),
      method = body and "POST" or "GET",
      sink = ltn12.sink.table(result_table)
   }
   if body then
      url.source = ltn12.source.string(body)
      url.headers = {
         ["content-length"] = #body,
         ["content-type"] = "application/x-www-form-urlencoded",
      }
   end
   return url
end

-- Forward calls to the real connection object.
local function reg(conn)
   local mt = getmetatable(conn.sock).__index
   for name, method in pairs(mt) do
      if type(method) == "function" then
         conn[name] = function (self, ...)
                         return method(self.sock, ...)
                      end
      end
   end
end

-- Return a function which performs the SSL/TLS connection.
local function tcp(params)
   params = params or {}
   -- Default settings
   for k, v in pairs(cfg) do 
      params[k] = params[k] or v
   end
   -- Force client mode
   params.mode = "client"
   -- 'create' function for LuaSocket
   return function ()
      local conn = {}
      conn.sock = try(socket.tcp())
      local st = getmetatable(conn.sock).__index.settimeout
      function conn:settimeout(...)
         return st(self.sock, ...)
      end
      -- Replace TCP's connection function
      function conn:connect(host, port)
         try(self.sock:connect(host, port))
         self.sock = try(ssl.wrap(self.sock, params))
         try(self.sock:dohandshake())
         reg(self, getmetatable(self.sock))
         return 1
      end
      return conn
  end
end

--------------------------------------------------------------------
-- Main Function
--------------------------------------------------------------------

-- Make a HTTP request over secure connection.  This function receives
--  the same parameters of LuaSocket's HTTP module (except 'proxy' and
--  'redirect') plus LuaSec parameters.
--
-- @param url mandatory (string or table)
-- @param body optional (string)
-- @return (string if url == string or 1), code, headers, status
--
function request(url, body)
  local result_table = {}
  local stringrequest = type(url) == "string"
  if stringrequest then
    url = urlstring_totable(url, body, result_table)
  else
    url.url = default_https_port(url.url)
  end
  if http.PROXY or url.proxy then
    return nil, "proxy not supported"
  elseif url.redirect then
    return nil, "redirect not supported"
  elseif url.create then
    return nil, "create function not permitted"
  end
  -- New 'create' function to establish a secure connection
  url.create = tcp(url)
  local res, code, headers, status = http.request(url)
  if res and stringrequest then
    return table.concat(result_table), code, headers, status
  end
  return res, code, headers, status
end
end end)()end;
do require("package").preload["libs.ssl"] = (function() local package;return function(...)-- <pack libs.ssl> --
------------------------------------------------------------------------------
-- LuaSec 0.4.1
-- Copyright (C) 2006-2011 Bruno Silvestre
--
------------------------------------------------------------------------------

local core    = require("ssl.core")
local context = require("ssl.context")
local x509    = require("ssl.x509")

module("ssl", package.seeall)

_VERSION   = "0.5.PR"
_COPYRIGHT = core.copyright()

-- Export
loadcertificate = x509.load

-- We must prevent the contexts to be collected before the connections,
-- otherwise the C registry will be cleared.
local registry = setmetatable({}, {__mode="k"})

--
--
--
local function optexec(func, param, ctx)
  if param then
    if type(param) == "table" then
      return func(ctx, unpack(param))
    else
      return func(ctx, param)
    end
  end
  return true
end

--
--
--
function newcontext(cfg)
   local succ, msg, ctx
   -- Create the context
   ctx, msg = context.create(cfg.protocol)
   if not ctx then return nil, msg end
   -- Mode
   succ, msg = context.setmode(ctx, cfg.mode)
   if not succ then return nil, msg end
   -- Load the key
   if cfg.key then
      if cfg.password and
         type(cfg.password) ~= "function" and
         type(cfg.password) ~= "string"
      then
         return nil, "invalid password type"
      end
      succ, msg = context.loadkey(ctx, cfg.key, cfg.password)
      if not succ then return nil, msg end
   end
   -- Load the certificate
   if cfg.certificate then
      succ, msg = context.loadcert(ctx, cfg.certificate)
      if not succ then return nil, msg end
   end
   -- Load the CA certificates
   if cfg.cafile or cfg.capath then
      succ, msg = context.locations(ctx, cfg.cafile, cfg.capath)
      if not succ then return nil, msg end
   end
   -- Set SSL ciphers
   if cfg.ciphers then
      succ, msg = context.setcipher(ctx, cfg.ciphers)
      if not succ then return nil, msg end
   end
   -- Set the verification options
   succ, msg = optexec(context.setverify, cfg.verify, ctx)
   if not succ then return nil, msg end
   -- Set SSL options
   succ, msg = optexec(context.setoptions, cfg.options, ctx)
   if not succ then return nil, msg end
   -- Set the depth for certificate verification
   if cfg.depth then
      succ, msg = context.setdepth(ctx, cfg.depth)
      if not succ then return nil, msg end
   end

   -- NOTE: Setting DH parameters and elliptic curves needs to come after
   -- setoptions(), in case the user has specified the single_{dh,ecdh}_use
   -- options.

   -- Set DH parameters
   if cfg.dhparam then
      if type(cfg.dhparam) ~= "function" then
         return nil, "invalid DH parameter type"
      end
      context.setdhparam(ctx, cfg.dhparam)
   end
   -- Set elliptic curve
   if cfg.curve then
      succ, msg = context.setcurve(ctx, cfg.curve)
      if not succ then return nil, msg end
   end
   -- Set extra verification options
   if cfg.verifyext and ctx.setverifyext then
      succ, msg = optexec(ctx.setverifyext, cfg.verifyext, ctx)
      if not succ then return nil, msg end
   end

   return ctx
end

--
--
--
function wrap(sock, cfg)
   local ctx, msg
   if type(cfg) == "table" then
      ctx, msg = newcontext(cfg)
      if not ctx then return nil, msg end
   else
      ctx = cfg
   end
   local s, msg = core.create(ctx)
   if s then
      core.setfd(s, sock:getfd())
      sock:setfd(core.invalidfd)
      registry[s] = ctx
      return s
   end
   return nil, msg 
end

--
-- Extract connection information.
--
local function info(ssl, field)
  local str, comp, err, protocol
  comp, err = core.compression(ssl)
  if err then
    return comp, err
  end
  -- Avoid parser
  if field == "compression" then
    return comp
  end
  local info = {compression = comp}
  str, info.bits, info.algbits, protocol = core.info(ssl)
  if str then
    info.cipher, info.protocol, info.key,
    info.authentication, info.encryption, info.mac =
        string.match(str, 
          "^(%S+)%s+(%S+)%s+Kx=(%S+)%s+Au=(%S+)%s+Enc=(%S+)%s+Mac=(%S+)")
    info.export = (string.match(str, "%sexport%s*$") ~= nil)
  end
  if protocol then
    info.protocol = protocol
  end
  if field then
    return info[field]
  end
  -- Empty?
  return ( (next(info)) and info )
end

--
-- Set method for SSL connections.
--
core.setmethod("info", info)

end end)()end;
do require("package").preload["libs.lurker"] = (function() local package;return function(...)-- <pack libs.lurker> --
--
-- lurker 
--
-- Copyright (c) 2014, rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

-- Assumes lume is in the same directory as this file
local lume = require((...):gsub("[^/.\\]+$", "lume"))

local lurker = { _version = "1.0.1" }


local dir = love.filesystem.enumerate or love.filesystem.getDirectoryItems
local isdir = love.filesystem.isDirectory
local time = love.timer.getTime or os.time
local lastmodified = love.filesystem.getLastModified

local lovecallbacknames = {
  "update",
  "load",
  "draw",
  "mousepressed",
  "mousereleased",
  "keypressed",
  "keyreleased",
  "focus",
  "quit",
}


function lurker.init()
  lurker.print("Initing lurker")
  lurker.path = "."
  lurker.preswap = function() end
  lurker.postswap = function() end
  lurker.interval = .5
  lurker.protected = true
  lurker.quiet = false
  lurker.lastscan = 0
  lurker.lasterrorfile = nil
  lurker.files = {}
  lurker.funcwrappers = {}
  lurker.lovefuncs = {}
  lurker.state = "init"
  lume.each(lurker.getchanged(), lurker.resetfile)
  return lurker
end


function lurker.print(...)
  print("[lurker] " .. lume.format(...))
end


function lurker.listdir(path, recursive, skipdotfiles)
  path = (path == ".") and "" or path
  local function fullpath(x) return path .. "/" .. x end
  local t = {}
  for _, f in pairs(lume.map(dir(path), fullpath)) do
    if not skipdotfiles or not f:match("/%.[^/]*$") then
      if recursive and isdir(f) then
        lume.merge(t, lurker.listdir(f, true, true))
      else
        table.insert(t, lume.trim(f, "/"))
      end
    end
  end
  return t
end


function lurker.initwrappers()
  for _, v in pairs(lovecallbacknames) do
    lurker.funcwrappers[v] = function(...)
      local args = {...}
      xpcall(function()
        return lurker.lovefuncs[v] and lurker.lovefuncs[v](unpack(args))
      end, lurker.onerror)
    end
    lurker.lovefuncs[v] = love[v]
  end
  lurker.updatewrappers()
end


function lurker.updatewrappers()
  for _, v in pairs(lovecallbacknames) do
    if love[v] ~= lurker.funcwrappers[v] then
      lurker.lovefuncs[v] = love[v]
      love[v] = lurker.funcwrappers[v]
    end
  end
end


function lurker.onerror(e, nostacktrace)
  lurker.print("An error occurred; switching to error state")
  lurker.state = "error"
 
  -- Release mouse
  local setgrab = love.mouse.setGrab or love.mouse.setGrabbed
  setgrab(false)

  -- Set up callbacks
  for _, v in pairs(lovecallbacknames) do
    love[v] = function() end
  end

  love.update = lurker.update

  love.keypressed = function(k)
    if k == "escape" then
      lurker.print("Exiting...")
      love.event.quit()
    end
  end

  local stacktrace = nostacktrace and "" or
                     lume.trim((debug.traceback("", 2):gsub("\t", "")))
  local msg = lume.format("{1}\n\n{2}", {e, stacktrace})
  local colors = { 0xFF1E1E2C, 0xFFF0A3A3, 0xFF92B5B0, 0xFF66666A, 0xFFCDCDCD }
  love.graphics.reset()
  love.graphics.setFont(love.graphics.newFont(12))

  love.draw = function()
    local pad = 25
    local width = love.graphics.getWidth()
    local function drawhr(pos, color1, color2)
      local animpos = lume.smooth(pad, width - pad - 8, lume.pingpong(time()))
      if color1 then love.graphics.setColor(lume.rgba(color1)) end
      love.graphics.rectangle("fill", pad, pos, width - pad*2, 1)
      if color2 then love.graphics.setColor(lume.rgba(color2)) end
      love.graphics.rectangle("fill", animpos, pos, 8, 1)
    end
    local function drawtext(str, x, y, color, limit)
      love.graphics.setColor(lume.rgba(color))
      love.graphics[limit and "printf" or "print"](str, x, y, limit)
    end
    love.graphics.setBackgroundColor(lume.rgba(colors[1]))
    love.graphics.clear()
    drawtext("An error has occurred", pad, pad, colors[2])
    drawtext("lurker", width - love.graphics.getFont():getWidth("lurker") - 
             pad, pad, colors[4])
    drawhr(pad + 32, colors[4], colors[5])
    drawtext("If you fix the problem and update the file the program will " ..
             "resume", pad, pad + 46, colors[3])
    drawhr(pad + 72, colors[4], colors[5])
    drawtext(msg, pad, pad + 90, colors[5], width - pad * 2)
    love.graphics.reset()
  end
end


function lurker.exitinitstate()
  lurker.state = "normal"
  if lurker.protected then
    lurker.initwrappers()
  end
end


function lurker.exiterrorstate()
  lurker.state = "normal"
  for _, v in pairs(lovecallbacknames) do
    love[v] = lurker.funcwrappers[v]
  end
end


function lurker.update() 
  if lurker.state == "init" then
    lurker.exitinitstate()
  end
  local diff = time() - lurker.lastscan
  if diff > lurker.interval then
    lurker.lastscan = lurker.lastscan + diff
    local changed = lurker.scan()
    if #changed > 0 and lurker.lasterrorfile then
      local f = lurker.lasterrorfile
      lurker.lasterrorfile = nil
      lurker.hotswapfile(f)
    end
  end
end


function lurker.getchanged()
  local function fn(f)
    return f:match("%.lua$") and lurker.files[f] ~= lastmodified(f)
  end
  return lume.filter(lurker.listdir(lurker.path, true, true), fn)
end


function lurker.modname(f)
  return (f:gsub("%.lua$", ""):gsub("[/\\]", "."))
end


function lurker.resetfile(f)
  lurker.files[f] = lastmodified(f)
end


function lurker.hotswapfile(f)
  lurker.print("Hotswapping '{1}'...", {f})
  if lurker.state == "error" then 
    lurker.exiterrorstate()
  end
  lurker.preswap(f)
  local modname = lurker.modname(f)
  local t, ok, err = lume.time(lume.hotswap, modname)
  if ok then
    lurker.print("Swapped '{1}' in {2} secs", {f, t})
  else 
    lurker.print("Failed to swap '{1}' : {2}", {f, err})
    if not lurker.quiet and lurker.protected then
      lurker.lasterrorfile = f
      lurker.onerror(err, true)
      lurker.resetfile(f)
      return
    end
  end
  lurker.resetfile(f)
  lurker.postswap(f)
  if lurker.protected then
    lurker.updatewrappers()
  end
end


function lurker.scan()
  if lurker.state == "init" then
    lurker.exitinitstate()
  end
  local changed = lurker.getchanged()
  lume.each(changed, lurker.hotswapfile)
  return changed
end


return lurker.init()
end end)()end;
do require("package").preload["libs.filter"] = (function() local package;return function(...)-- <pack libs.filter> --
--[[
	EntranceJew made this.
	
	It's a generic filtering system because iteration is old fashioned.
	
	We sacrifice performance for redundancy removal.
]]

filter = {}

-- if everything is valid, return true
function filter.runAll(iterable, filterFunc, ...)
	for k,v in pairs(iterable) do
		if not filterFunc(v, ...) then 
			return false
		end
	end
	return true
end

-- if anything is valid, return true
function filter.runAny(iterable, filterFunc, ...)
	for k,v in pairs(iterable) do
		if filterFunc(v, ...) then 
			return true
		end
	end
	return false
end

-- multis expect multiple tabularized calls for filter.run*

-- if all the filters return true, so do we
function filter.multiAll(ftype, ...)
	for k,v in pairs({...}) do
		if filter["run"..ftype](unpack(v)) then
			return true
		end
	end
	return false
end

-- if any of the filters return true, so do we
function filter.multiAny(ftype, ...)
	for k,v in pairs({...}) do
		if filter["run"..ftype](unpack(v)) then
			return true
		end
	end
	return false
end
end end)()end;
do require("package").preload["libs.JSON"] = (function() local package;return function(...)-- <pack libs.JSON> --
-- -*- coding: utf-8 -*-
--
-- Copyright 2010-2012 Jeffrey Friedl
-- http://regex.info/blog/
--
local VERSION = 20111207.5  -- version history at end of file
local OBJDEF = { VERSION = VERSION }

--
-- Simple JSON encoding and decoding in pure Lua.
-- http://www.json.org/
--
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability
--
--
-- DECODING
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local lua_value = JSON:decode(raw_json_text)
--
--   If the JSON text is for an object or an array, e.g.
--     { "what": "books", "count": 3 }
--   or
--     [ "Larry", "Curly", "Moe" ]
--
--   the result is a Lua table, e.g.
--     { what = "books", count = 3 }
--   or
--     { "Larry", "Curly", "Moe" }
--
--
--   The encode and decode routines accept an optional second argument, "etc", which is not used
--   during encoding or decoding, but upon error is passed along to error handlers. It can be of any
--   type (including nil).
--
--   With most errors during decoding, this code calls
--
--      JSON:onDecodeError(message, text, location, etc)
--
--   with a message about the error, and if known, the JSON text being parsed and the byte count
--   where the problem was discovered. You can replace the default JSON:onDecodeError() with your
--   own function.
--
--   The default onDecodeError() merely augments the message with data about the text and the
--   location if known (and if a second 'etc' argument had been provided to decode(), its value is
--   tacked onto the message as well), and then calls JSON.assert(), which itself defaults to Lua's
--   built-in assert(), and can also be overridden.
--
--   For example, in an Adobe Lightroom plugin, you might use something like
--
--          function JSON:onDecodeError(message, text, location, etc)
--             LrErrors.throwUserError("Internal Error: invalid JSON data")
--          end
--
--   or even just
--
--          function JSON.assert(message)
--             LrErrors.throwUserError("Internal Error: " .. message)
--          end
--
--   If JSON:decode() is passed a nil, this is called instead:
--
--      JSON:onDecodeOfNilError(message, nil, nil, etc)
--
--   and if JSON:decode() is passed HTML instead of JSON, this is called:
--
--      JSON:onDecodeOfHTMLError(message, text, nil, etc)
--
--   The use of the fourth 'etc' argument allows stronger coordination between decoding and error
--   reporting, especially when you provide your own error-handling routines. Continuing with the
--   the Adobe Lightroom plugin example:
--
--          function JSON:onDecodeError(message, text, location, etc)
--             local note = "Internal Error: invalid JSON data"
--             if type(etc) = 'table' and etc.photo then
--                note = note .. " while processing for " .. etc.photo:getFormattedMetadata('fileName')
--             end
--             LrErrors.throwUserError(note)
--          end
--
--            :
--            :
--
--          for i, photo in ipairs(photosToProcess) do
--               :             
--               :             
--               local data = JSON:decode(someJsonText, { photo = photo })
--               :             
--               :             
--          end
--
--
--
--

-- DECODING AND STRICT TYPES
--
--   Because both JSON objects and JSON arrays are converted to Lua tables, it's not normally
--   possible to tell which a Lua table came from, or guarantee decode-encode round-trip
--   equivalency.
--
--   However, if you enable strictTypes, e.g.
--
--      JSON = (loadfile "JSON.lua")() --load the routines
--      JSON.strictTypes = true
--
--   then the Lua table resulting from the decoding of a JSON object or JSON array is marked via Lua
--   metatable, so that when re-encoded with JSON:encode() it ends up as the appropriate JSON type.
--
--   (This is not the default because other routines may not work well with tables that have a
--   metatable set, for example, Lightroom API calls.)
--
--
-- ENCODING
--
--   JSON = (loadfile "JSON.lua")() -- one-time load of the routines
--
--   local raw_json_text    = JSON:encode(lua_table_or_value)
--   local pretty_json_text = JSON:encode_pretty(lua_table_or_value) -- "pretty printed" version for human readability

--   On error during encoding, this code calls:
--
--    JSON:onEncodeError(message, etc)
--
--   which you can override in your local JSON object.
--
--
-- SUMMARY OF METHODS YOU CAN OVERRIDE IN YOUR LOCAL LUA JSON OBJECT
--
--    assert
--    onDecodeError
--    onDecodeOfNilError
--    onDecodeOfHTMLError
--    onEncodeError
--
--  If you want to create a separate Lua JSON object with its own error handlers,
--  you can reload JSON.lua or use the :new() method.
--
---------------------------------------------------------------------------


local author = "-[ JSON.lua package by Jeffrey Friedl (http://regex.info/blog/lua/json), version " .. tostring(VERSION) .. " ]-"
local isArray  = { __tostring = function() return "JSON array"  end }    isArray.__index  = isArray
local isObject = { __tostring = function() return "JSON object" end }    isObject.__index = isObject


function OBJDEF:newArray(tbl)
   return setmetatable(tbl or {}, isArray)
end

function OBJDEF:newObject(tbl)
   return setmetatable(tbl or {}, isObject)
end

local function unicode_codepoint_as_utf8(codepoint)
   --
   -- codepoint is a number
   --
   if codepoint <= 127 then
      return string.char(codepoint)

   elseif codepoint <= 2047 then
      --
      -- 110yyyxx 10xxxxxx         <-- useful notation from http://en.wikipedia.org/wiki/Utf8
      --
      local highpart = math.floor(codepoint / 0x40)
      local lowpart  = codepoint - (0x40 * highpart)
      return string.char(0xC0 + highpart,
                         0x80 + lowpart)

   elseif codepoint <= 65535 then
      --
      -- 1110yyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x1000)
      local remainder = codepoint - 0x1000 * highpart
      local midpart   = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midpart

      highpart = 0xE0 + highpart
      midpart  = 0x80 + midpart
      lowpart  = 0x80 + lowpart

      --
      -- Check for an invalid character (thanks Andy R. at Adobe).
      -- See table 3.7, page 93, in http://www.unicode.org/versions/Unicode5.2.0/ch03.pdf#G28070
      --
      if ( highpart == 0xE0 and midpart < 0xA0 ) or
         ( highpart == 0xED and midpart > 0x9F ) or
         ( highpart == 0xF0 and midpart < 0x90 ) or
         ( highpart == 0xF4 and midpart > 0x8F )
      then
         return "?"
      else
         return string.char(highpart,
                            midpart,
                            lowpart)
      end

   else
      --
      -- 11110zzz 10zzyyyy 10yyyyxx 10xxxxxx
      --
      local highpart  = math.floor(codepoint / 0x40000)
      local remainder = codepoint - 0x40000 * highpart
      local midA      = math.floor(remainder / 0x1000)
      remainder       = remainder - 0x1000 * midA
      local midB      = math.floor(remainder / 0x40)
      local lowpart   = remainder - 0x40 * midB

      return string.char(0xF0 + highpart,
                         0x80 + midA,
                         0x80 + midB,
                         0x80 + lowpart)
   end
end

function OBJDEF:onDecodeError(message, text, location, etc)
   if text then
      if location then
         message = string.format("%s at char %d of: %s", message, location, text)
      else
         message = string.format("%s: %s", message, text)
      end
   end
   if etc ~= nil then
      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

OBJDEF.onDecodeOfNilError  = OBJDEF.onDecodeError
OBJDEF.onDecodeOfHTMLError = OBJDEF.onDecodeError

function OBJDEF:onEncodeError(message, etc)
   if etc ~= nil then
      message = message .. " (" .. OBJDEF:encode(etc) .. ")"
   end

   if self.assert then
      self.assert(false, message)
   else
      assert(false, message)
   end
end

local function grok_number(self, text, start, etc)
   --
   -- Grab the integer part
   --
   local integer_part = text:match('^-?[1-9]%d*', start)
                     or text:match("^-?0",        start)

   if not integer_part then
      self:onDecodeError("expected number", text, start, etc)
   end

   local i = start + integer_part:len()

   --
   -- Grab an optional decimal part
   --
   local decimal_part = text:match('^%.%d+', i) or ""

   i = i + decimal_part:len()

   --
   -- Grab an optional exponential part
   --
   local exponent_part = text:match('^[eE][-+]?%d+', i) or ""

   i = i + exponent_part:len()

   local full_number_text = integer_part .. decimal_part .. exponent_part
   local as_number = tonumber(full_number_text)

   if not as_number then
      self:onDecodeError("bad number", text, start, etc)
   end

   return as_number, i
end


local function grok_string(self, text, start, etc)

   if text:sub(start,start) ~= '"' then
      self:onDecodeError("expected string's opening quote", text, start, etc)
   end

   local i = start + 1 -- +1 to bypass the initial quote
   local text_len = text:len()
   local VALUE = ""
   while i <= text_len do
      local c = text:sub(i,i)
      if c == '"' then
         return VALUE, i + 1
      end
      if c ~= '\\' then
         VALUE = VALUE .. c
         i = i + 1
      elseif text:match('^\\b', i) then
         VALUE = VALUE .. "\b"
         i = i + 2
      elseif text:match('^\\f', i) then
         VALUE = VALUE .. "\f"
         i = i + 2
      elseif text:match('^\\n', i) then
         VALUE = VALUE .. "\n"
         i = i + 2
      elseif text:match('^\\r', i) then
         VALUE = VALUE .. "\r"
         i = i + 2
      elseif text:match('^\\t', i) then
         VALUE = VALUE .. "\t"
         i = i + 2
      else
         local hex = text:match('^\\u([0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
         if hex then
            i = i + 6 -- bypass what we just read

            -- We have a Unicode codepoint. It could be standalone, or if in the proper range and
            -- followed by another in a specific range, it'll be a two-code surrogate pair.
            local codepoint = tonumber(hex, 16)
            if codepoint >= 0xD800 and codepoint <= 0xDBFF then
               -- it's a hi surrogate... see whether we have a following low
               local lo_surrogate = text:match('^\\u([dD][cdefCDEF][0123456789aAbBcCdDeEfF][0123456789aAbBcCdDeEfF])', i)
               if lo_surrogate then
                  i = i + 6 -- bypass the low surrogate we just read
                  codepoint = 0x2400 + (codepoint - 0xD800) * 0x400 + tonumber(lo_surrogate, 16)
               else
                  -- not a proper low, so we'll just leave the first codepoint as is and spit it out.
               end
            end
            VALUE = VALUE .. unicode_codepoint_as_utf8(codepoint)

         else

            -- just pass through what's escaped
            VALUE = VALUE .. text:match('^\\(.)', i)
            i = i + 2
         end
      end
   end

   self:onDecodeError("unclosed string", text, start, etc)
end

local function skip_whitespace(text, start)

   local match_start, match_end = text:find("^[ \n\r\t]+", start) -- [http://www.ietf.org/rfc/rfc4627.txt] Section 2
   if match_end then
      return match_end + 1
   else
      return start
   end
end

local grok_one -- assigned later

local function grok_object(self, text, start, etc)
   if not text:sub(start,start) == '{' then
      self:onDecodeError("expected '{'", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '{'

   local VALUE = self.strictTypes and self:newObject { } or { }

   if text:sub(i,i) == '}' then
      return VALUE, i + 1
   end
   local text_len = text:len()
   while i <= text_len do
      local key, new_i = grok_string(self, text, i, etc)

      i = skip_whitespace(text, new_i)

      if text:sub(i, i) ~= ':' then
         self:onDecodeError("expected colon", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)

      local val, new_i = grok_one(self, text, i)

      VALUE[key] = val

      --
      -- Expect now either '}' to end things, or a ',' to allow us to continue.
      --
      i = skip_whitespace(text, new_i)

      local c = text:sub(i,i)

      if c == '}' then
         return VALUE, i + 1
      end

      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '}'", text, i, etc)
      end

      i = skip_whitespace(text, i + 1)
   end

   self:onDecodeError("unclosed '{'", text, start, etc)
end

local function grok_array(self, text, start, etc)
   if not text:sub(start,start) == '[' then
      self:onDecodeError("expected '['", text, start, etc)
   end

   local i = skip_whitespace(text, start + 1) -- +1 to skip the '['
   local VALUE = self.strictTypes and self:newArray { } or { }
   if text:sub(i,i) == ']' then
      return VALUE, i + 1
   end

   local text_len = text:len()
   while i <= text_len do
      local val, new_i = grok_one(self, text, i)

      table.insert(VALUE, val)

      i = skip_whitespace(text, new_i)

      --
      -- Expect now either ']' to end things, or a ',' to allow us to continue.
      --
      local c = text:sub(i,i)
      if c == ']' then
         return VALUE, i + 1
      end
      if text:sub(i, i) ~= ',' then
         self:onDecodeError("expected comma or '['", text, i, etc)
      end
      i = skip_whitespace(text, i + 1)
   end
   self:onDecodeError("unclosed '['", text, start, etc)
end


grok_one = function(self, text, start, etc)
   -- Skip any whitespace
   start = skip_whitespace(text, start)

   if start > text:len() then
      self:onDecodeError("unexpected end of string", text, nil, etc)
   end

   if text:find('^"', start) then
      return grok_string(self, text, start, etc)

   elseif text:find('^[-0123456789 ]', start) then
      return grok_number(self, text, start, etc)

   elseif text:find('^%{', start) then
      return grok_object(self, text, start, etc)

   elseif text:find('^%[', start) then
      return grok_array(self, text, start, etc)

   elseif text:find('^true', start) then
      return true, start + 4

   elseif text:find('^false', start) then
      return false, start + 5

   elseif text:find('^null', start) then
      return nil, start + 4

   else
      self:onDecodeError("can't parse JSON", text, start, etc)
   end
end

function OBJDEF:decode(text, etc)
   if type(self) ~= 'table' or self.__index ~= OBJDEF then
      OBJDEF:onDecodeError("JSON:decode must be called in method format", nil, nil, etc)
   end

   if text == nil then
      self:onDecodeOfNilError(string.format("nil passed to JSON:decode()"), nil, nil, etc)
   elseif type(text) ~= 'string' then
      self:onDecodeError(string.format("expected string argument to JSON:decode(), got %s", type(text)), nil, nil, etc)
   end

   if text:match('^%s*$') then
      return nil
   end

   if text:match('^%s*<') then
      -- Can't be JSON... we'll assume it's HTML
      self:onDecodeOfHTMLError(string.format("html passed to JSON:decode()"), text, nil, etc)
   end

   --
   -- Ensure that it's not UTF-32 or UTF-16.
   -- Those are perfectly valid encodings for JSON (as per RFC 4627 section 3),
   -- but this package can't handle them.
   --
   if text:sub(1,1):byte() == 0 or (text:len() >= 2 and text:sub(2,2):byte() == 0) then
      self:onDecodeError("JSON package groks only UTF-8, sorry", text, nil, etc)
   end

   local success, value = pcall(grok_one, self, text, 1, etc)
   if success then
      return value
   else
      -- should never get here... JSON parse errors should have been caught earlier
      assert(false, value)
      return nil
   end
end

local function backslash_replacement_function(c)
   if c == "\n" then
      return "\\n"
   elseif c == "\r" then
      return "\\r"
   elseif c == "\t" then
      return "\\t"
   elseif c == "\b" then
      return "\\b"
   elseif c == "\f" then
      return "\\f"
   elseif c == '"' then
      return '\\"'
   elseif c == '\\' then
      return '\\\\'
   else
      return string.format("\\u%04x", c:byte())
   end
end

local chars_to_be_escaped_in_JSON_string
   = '['
   ..    '"'    -- class sub-pattern to match a double quote
   ..    '%\\'  -- class sub-pattern to match a backslash
   ..    '%z'   -- class sub-pattern to match a null
   ..    '\001' .. '-' .. '\031' -- class sub-pattern to match control characters
   .. ']'

local function json_string_literal(value)
   local newval = value:gsub(chars_to_be_escaped_in_JSON_string, backslash_replacement_function)
   return '"' .. newval .. '"'
end

local function object_or_array(self, T, etc)
   --
   -- We need to inspect all the keys... if there are any strings, we'll convert to a JSON
   -- object. If there are only numbers, it's a JSON array.
   --
   -- If we'll be converting to a JSON object, we'll want to sort the keys so that the
   -- end result is deterministic.
   --
   local string_keys = { }
   local seen_number_key = false
   local maximum_number_key

   for key in pairs(T) do
      if type(key) == 'number' then
         seen_number_key = true
         if not maximum_number_key or maximum_number_key < key then
            maximum_number_key = key
         end
      elseif type(key) == 'string' then
         table.insert(string_keys, key)
      else
         self:onEncodeError("can't encode table with a key of type " .. type(key), etc)
      end
   end

   if seen_number_key and #string_keys > 0 then
      --
      -- Mixed key types... don't know what to do, so bail
      --
      self:onEncodeError("a table with both numeric and string keys could be an object or array; aborting", etc)

   elseif #string_keys == 0  then
      --
      -- An array
      --
      if seen_number_key then
         return nil, maximum_number_key -- an array
      else
         --
         -- An empty table...
         --
         if tostring(T) == "JSON array" then
            return nil
         elseif tostring(T) == "JSON object" then
            return { }
         else
            -- have to guess, so we'll pick array, since empty arrays are likely more common than empty objects
            return nil
         end
      end
   else
      --
      -- An object, so return a list of keys
      --
      table.sort(string_keys)
      return string_keys
   end
end

--
-- Encode
--
local encode_value -- must predeclare because it calls itself
function encode_value(self, value, parents, etc)


   if value == nil then
      return 'null'
   end

   if type(value) == 'string' then
      return json_string_literal(value)
   elseif type(value) == 'number' then
      if value ~= value then
         --
         -- NaN (Not a Number).
         -- JSON has no NaN, so we have to fudge the best we can. This should really be a package option.
         --
         return "null"
      elseif value >= math.huge then
         --
         -- Positive infinity. JSON has no INF, so we have to fudge the best we can. This should
         -- really be a package option. Note: at least with some implementations, positive infinity
         -- is both ">= math.huge" and "<= -math.huge", which makes no sense but that's how it is.
         -- Negative infinity is properly "<= -math.huge". So, we must be sure to check the ">="
         -- case first.
         --
         return "1e+9999"
      elseif value <= -math.huge then
         --
         -- Negative infinity.
         -- JSON has no INF, so we have to fudge the best we can. This should really be a package option.
         --
         return "-1e+9999"
      else
         return tostring(value)
      end
   elseif type(value) == 'boolean' then
      return tostring(value)

   elseif type(value) ~= 'table' then
      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)

   else
      --
      -- A table to be converted to either a JSON object or array.
      --
      local T = value

      if parents[T] then
         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
      else
         parents[T] = true
      end

      local result_value

      local object_keys, maximum_number_key = object_or_array(self, T, etc)
      if maximum_number_key then
         --
         -- An array...
         --
         local ITEMS = { }
         for i = 1, maximum_number_key do
            table.insert(ITEMS, encode_value(self, T[i], parents, etc))
         end

         result_value = "[" .. table.concat(ITEMS, ",") .. "]"
      elseif object_keys then
         --
         -- An object
         --

         --
         -- We'll always sort the keys, so that comparisons can be made on
         -- the results, etc. The actual order is not particularly
         -- important (e.g. it doesn't matter what character set we sort
         -- as); it's only important that it be deterministic... the same
         -- every time.
         --
         local PARTS = { }
         for _, key in ipairs(object_keys) do
            local encoded_key = encode_value(self, tostring(key), parents, etc)
            local encoded_val = encode_value(self, T[key],        parents, etc)
            table.insert(PARTS, string.format("%s:%s", encoded_key, encoded_val))
         end
         result_value = "{" .. table.concat(PARTS, ",") .. "}"
      else
         --
         -- An empty array/object... we'll treat it as an array, though it should really be an option
         --
         result_value = "[]"
      end

      parents[T] = false
      return result_value
   end
end

local encode_pretty_value -- must predeclare because it calls itself
function encode_pretty_value(self, value, parents, indent, etc)

   if type(value) == 'string' then
      return json_string_literal(value)

   elseif type(value) == 'number' then
      return tostring(value)

   elseif type(value) == 'boolean' then
      return tostring(value)

   elseif type(value) == 'nil' then
      return 'null'

   elseif type(value) ~= 'table' then
      self:onEncodeError("can't convert " .. type(value) .. " to JSON", etc)

   else
      --
      -- A table to be converted to either a JSON object or array.
      --
      local T = value

      if parents[T] then
         self:onEncodeError("table " .. tostring(T) .. " is a child of itself", etc)
      end
      parents[T] = true

      local result_value

      local object_keys = object_or_array(self, T, etc)
      if not object_keys then
         --
         -- An array...
         --
         local ITEMS = { }
         for i = 1, #T do
            table.insert(ITEMS, encode_pretty_value(self, T[i], parents, indent, etc))
         end

         result_value = "[ " .. table.concat(ITEMS, ", ") .. " ]"

      else

         --
         -- An object -- can keys be numbers?
         --

         local KEYS = { }
         local max_key_length = 0
         for _, key in ipairs(object_keys) do
            local encoded = encode_pretty_value(self, tostring(key), parents, "", etc)
            max_key_length = math.max(max_key_length, #encoded)
            table.insert(KEYS, encoded)
         end
         local key_indent = indent .. "    "
         local subtable_indent = indent .. string.rep(" ", max_key_length + 2 + 4)
         local FORMAT = "%s%" .. tostring(max_key_length) .. "s: %s"

         local COMBINED_PARTS = { }
         for i, key in ipairs(object_keys) do
            local encoded_val = encode_pretty_value(self, T[key], parents, subtable_indent, etc)
            table.insert(COMBINED_PARTS, string.format(FORMAT, key_indent, KEYS[i], encoded_val))
         end
         result_value = "{\n" .. table.concat(COMBINED_PARTS, ",\n") .. "\n" .. indent .. "}"
      end

      parents[T] = false
      return result_value
   end
end

function OBJDEF:encode(value, etc)
   if type(self) ~= 'table' or self.__index ~= OBJDEF then
      OBJDEF:onEncodeError("JSON:encode must be called in method format", etc)
   end

   local parents = {}
   return encode_value(self, value, parents, etc)
end

function OBJDEF:encode_pretty(value, etc)
   local parents = {}
   local subtable_indent = ""
   return encode_pretty_value(self, value, parents, subtable_indent, etc)
end

function OBJDEF.__tostring()
   return "JSON encode/decode package"
end

OBJDEF.__index = OBJDEF

function OBJDEF:new(args)
   local new = { }

   if args then
      for key, val in pairs(args) do
         new[key] = val
      end
   end

   return setmetatable(new, OBJDEF)
end

return OBJDEF:new()

--
-- Version history:
--
--   20111207.5    Added support for the 'etc' arguments, for better error reporting.
--
--   20110731.4    More feedback from David Kolf on how to make the tests for Nan/Infinity system independent.
--
--   20110730.3    Incorporated feedback from David Kolf at http://lua-users.org/wiki/JsonModules:
--
--                   * When encoding lua for JSON, Sparse numeric arrays are now handled by
--                     spitting out full arrays, such that
--                        JSON:encode({"one", "two", [10] = "ten"})
--                     returns
--                        ["one","two",null,null,null,null,null,null,null,"ten"]
--
--                     In 20100810.2 and earlier, only up to the first non-null value would have been retained.
--
--                   * When encoding lua for JSON, numeric value NaN gets spit out as null, and infinity as "1+e9999".
--                     Version 20100810.2 and earlier created invalid JSON in both cases.
--
--                   * Unicode surrogate pairs are now detected when decoding JSON.
--
--   20100810.2    added some checking to ensure that an invalid Unicode character couldn't leak in to the UTF-8 encoding
--
--   20100731.1    initial public release
--
end end)()end;
do require("package").preload["libs.middleclass"] = (function() local package;return function(...)-- <pack libs.middleclass> --
local middleclass = {
  _VERSION     = 'middleclass v3.0.0',
  _DESCRIPTION = 'Object Orientation for Lua',
  _LICENSE     = [[
    MIT LICENSE

    Copyright (c) 2011 Enrique Garca Cota

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be included
    in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
  ]]
  
  --Maurice here; I renamed initialize to init for my use. Just so you know.
}

local function _setClassDictionariesMetatables(aClass)
  local dict = aClass.__instanceDict
  dict.__index = dict

  local super = aClass.super
  if super then
    local superStatic = super.static
    setmetatable(dict, super.__instanceDict)
    setmetatable(aClass.static, { __index = function(_,k) return dict[k] or superStatic[k] end })
  else
    setmetatable(aClass.static, { __index = function(_,k) return dict[k] end })
  end
end

local function _setClassMetatable(aClass)
  setmetatable(aClass, {
    __tostring = function() return "class " .. aClass.name end,
    __index    = aClass.static,
    __newindex = aClass.__instanceDict,
    __call     = function(self, ...) return self:new(...) end
  })
end

local function _createClass(name, super)
  local aClass = { name = name, super = super, static = {}, __mixins = {}, __instanceDict={} }
  aClass.subclasses = setmetatable({}, {__mode = "k"})

  _setClassDictionariesMetatables(aClass)
  _setClassMetatable(aClass)

  return aClass
end

local function _createLookupMetamethod(aClass, name)
  return function(...)
    local method = aClass.super[name]
    assert( type(method)=='function', tostring(aClass) .. " doesn't implement metamethod '" .. name .. "'" )
    return method(...)
  end
end

local function _setClassMetamethods(aClass)
  for _,m in ipairs(aClass.__metamethods) do
    aClass[m]= _createLookupMetamethod(aClass, m)
  end
end

local function _setDefaultInitializeMethod(aClass, super)
  aClass.init = function(instance, ...)
    return super.init(instance, ...)
  end
end

local function _includeMixin(aClass, mixin)
  assert(type(mixin)=='table', "mixin must be a table")
  for name,method in pairs(mixin) do
    if name ~= "included" and name ~= "static" then aClass[name] = method end
  end
  if mixin.static then
    for name,method in pairs(mixin.static) do
      aClass.static[name] = method
    end
  end
  if type(mixin.included)=="function" then mixin:included(aClass) end
  aClass.__mixins[mixin] = true
end

local Object = _createClass("Object", nil)

Object.static.__metamethods = { '__add', '__call', '__concat', '__div', '__le', '__lt',
                                '__mod', '__mul', '__pow', '__sub', '__tostring', '__unm' }

function Object.static:allocate()
  assert(type(self) == 'table', "Make sure that you are using 'Class:allocate' instead of 'Class.allocate'")
  return setmetatable({ class = self }, self.__instanceDict)
end

function Object.static:new(...)
  local instance = self:allocate()
  instance:init(...)
  return instance
end

function Object.static:subclass(name)
  assert(type(self) == 'table', "Make sure that you are using 'Class:subclass' instead of 'Class.subclass'")
  assert(type(name) == "string", "You must provide a name(string) for your class")

  local subclass = _createClass(name, self)
  _setClassMetamethods(subclass)
  _setDefaultInitializeMethod(subclass, self)
  self.subclasses[subclass] = true
  self:subclassed(subclass)

  return subclass
end

function Object.static:subclassed(other) end

function Object.static:isSubclassOf(other)
  return type(other)                   == 'table' and
         type(self)                    == 'table' and
         type(self.super)              == 'table' and
         ( self.super == other or
           type(self.super.isSubclassOf) == 'function' and
           self.super:isSubclassOf(other)
         )
end

function Object.static:include( ... )
  assert(type(self) == 'table', "Make sure you that you are using 'Class:include' instead of 'Class.include'")
  for _,mixin in ipairs({...}) do _includeMixin(self, mixin) end
  return self
end

function Object.static:includes(mixin)
  return type(mixin)          == 'table' and
         type(self)           == 'table' and
         type(self.__mixins)  == 'table' and
         ( self.__mixins[mixin] or
           type(self.super)           == 'table' and
           type(self.super.includes)  == 'function' and
           self.super:includes(mixin)
         )
end

function Object:init() end

function Object:__tostring() return "instance of " .. tostring(self.class) end

function Object:isInstanceOf(aClass)
  return type(self)                == 'table' and
         type(self.class)          == 'table' and
         type(aClass)              == 'table' and
         ( aClass == self.class or
           type(aClass.isSubclassOf) == 'function' and
           self.class:isSubclassOf(aClass)
         )
end



function middleclass.class(name, super, ...)
  super = super or Object
  local theclass = super:subclass(name, ...)
  if debugclasses then
      theclass.__tostring = function(self) return self end
      theclass.__concat = function(self,other) return tostring(self)..tostring(other) end
  end
  --getmetatable(theclass).__tostring = function(t) return von.serialize(t) end
  return theclass
end

middleclass.Object = Object

setmetatable(middleclass, { __call = function(_, ...) return middleclass.class(...) end })

return middleclass
end end)()end;
do require("package").preload["libs.cupid"] = (function() local package;return function(...)-- <pack libs.cupid> --
-----------------------------------------------------
-- (C) Robert Blancakert 2012
-- Available under the same license as Love
-----------------------------------------------------


-----------------------------------------------------
-- Cupid Configuration
-----------------------------------------------------

local config = {

	always_use = true,

	enable_console = true,
	console_key = '`',
	console_override_print = true, --true
	console_height = 0.33,
	console_key_repeat = true,
	console_start_open = false,

	enable_remote = false, --true
	font = "whitrabt.ttf",

	enable_watcher = false,--true
	watcher_interval = 1.0,
	watcher_onchanged = "reload()",
	watcher_patterns = {"lua$"},
	enable_physics = false,
	physics_show = false,
	enable_temporal = true,

}

-----------------------------------------------------
-- Cupid Hooking 
-----------------------------------------------------

local cupid_error = function(...) error(...) end
local cupid_canvas
local cupid_preshot
local cupid_preshot_image
local cupid_screenshot
local cupid_screenshot_image
local main_args = {...}

local wraped_love = {}
local game_funcs = {}
local protected_funcs = {'update','draw','keyreleased','keypressed','textinput','load'}
local _love
local function protector(table, key, value)
	for k,v in pairs(protected_funcs) do
		if ( v == key ) then
			game_funcs[key] = value
			return
		end
	end
	rawset(_love, key, value)
end

local mods = {}
local modules = {}

local loaded = false

local g = nil

local function cupid_load_identity()
	local x,y,w,h = g.getScissor()
	g.setScissor(0,0,0,0)
	g.clear()
	if x ~= nil then
		g.setScissor(x,y,w,h)
	else
		g.setScissor()
	end
end

local function retaining(...)
	local values = {}
	g.push()
	for k,v in pairs({...}) do
		if type(v) == "function" then
			 v()
		elseif type(v) == "string" then
			values[v] = {g["get" .. v]()}
		end 
	end
	for k,v in pairs(values) do if #v > 0 then g["set" .. k](unpack(v)) end end
	g.pop()
end

local function cupid_load(args)
	local use = true

	if use then
		setmetatable(wraped_love, {__index = love, __newindex = protector})
		_love = love
		love = wraped_love
		for k,v in pairs(protected_funcs) do
			_love[v] = function(...)
				if g == nil then g = love.graphics end
				local result = {}
				local arg = {...}
				local paused = false
				for km,vm in pairs(modules) do
					if vm["paused"] and vm["paused"](vm,...) == true then paused = true end
				end
				for km,vm in pairs(modules) do
					if vm["pre-" .. v] and vm["pre-" .. v](vm,...) == false then return end
				end
				
				for km,vm in pairs(modules) do
						if vm["arg-" .. v] then arg = {vm["arg-" .. v](vm,unpack(arg))} end
				end

				if game_funcs[v] and not paused then
					result = {select(1,xpcall(
						function() return game_funcs[v](unpack(arg)) end, cupid_error
					))}
				end
				for km,vm in pairs(modules) do if vm["post-" .. v] then vm["post-" .. v](vm,...) end end
				return unpack(result)
			end
		end

		table.insert(modules, {
		--	["arg-update"] = function(self,dt) return dt / 8 end
		})


		local function load_modules(what)
			local mod = mods[what]()
			if ( mod.init ) then mod:init() end
			modules[what] = mod
		end

		if config.enable_console then
			load_modules("console")
		end

		if config.enable_watcher then
			load_modules("watcher")
		end

		if config.enable_remote then
			load_modules("remote")
		end

		if config.enable_physics then
			load_modules("physics")
		end

		if config.enable_temporal then
			load_modules("temporal")
		end

		load_modules("error")
	else
		love.load = nil
	end

end

-----------------------------------------------------
-- Commands
-----------------------------------------------------
local function cupid_print(str,color) print(str) end

local cupid_commands
cupid_commands = {
	env = {
		config = config,
		mode = function(...) g.setMode(...) end,
		quit = function(...) love.event.quit() end,
		dir = function(what, deep)
			if deep == nil then deep = true end
			what = what or cupid_commands.env
			local lst = {}
			while what ~= nil and type(what) == "table" do
				for k,v in pairs(what) do table.insert(lst,k) end
				local mt = getmetatable(what)
				if mt and deep then what = mt["__index"] else what = nil end
			end

			return "[" .. table.concat(lst, ", ") .. "]"
		end,
	},
	["command"] = function(self, cmd)
		local xcmd = cmd
		if not (
			xcmd:match("end") or xcmd:match("do") or 
			xcmd:match("do") or xcmd:match("function") 
			or xcmd:match("return") or xcmd:match("=") 
		) then
			xcmd = "return " .. xcmd
		end
		local func, why = loadstring(xcmd,"*")
		if not func then
			return false, why
		end
		local xselect = function(x, ...) return x, {...} end
		setfenv(func,self.env)
		local ok, result = xselect(pcall(func))
		if not ok then
			return false, result[1]
		end

		if type(result[1]) == "function" and not xcmd:match("[()=]") then
			ok, result = xselect(pcall(result[1]))
			if not ok then 
				return false, result[1]
			end
		end
		
		if ( #result > 0 ) then
			local strings = {}
			for k,v in pairs(result) do strings[k] = tostring(v) end
			return true, table.concat(strings, " , ")
		end

		return true, "nil"
	end,
	["add"] = function(self, name, cmd)
		rawset(self.env, name, cmd)
	end


}

setmetatable(cupid_commands.env, {__index = _G, __newindex = _G})


-----------------------------------------------------
-- Module Reloader
-----------------------------------------------------

local cupid_keep_package = {}
for k,v in pairs(package.loaded) do cupid_keep_package[k] = true end

local cupid_keep_global = {}
for k,v in pairs(_G) do cupid_keep_global[k] = true end

local function cupid_reload(keep_globals)

	-- Unload packages that got loaded
	for k,v in pairs(package.loaded) do 
		if not cupid_keep_package[k] then package.loaded[k] = nil end
	end

	if not keep_globals then
		setmetatable(_G, {})
		for k,v in pairs(_G) do 
			if not cupid_keep_global[k] then _G[k] = nil end
		end
	end

	if modules.error then modules.error.lasterror = nil end
	if love.graphics then love.graphics.reset() end
	local game, why
	if ( main_args[1] == "main" ) then
		ok, game = pcall(love.filesystem.load, 'game.lua')
	else
		ok, game = pcall(love.filesystem.load, 'main.lua')
	end
	
	if not ok then cupid_error(game) return false end

	xpcall(game, cupid_error)
	if love.load then love.load() end
	return true
end
cupid_commands:add("reload", function(...) return cupid_reload(...) end)

-----------------------------------------------------
-- Helpers
-----------------------------------------------------

local cupid_font_data;
local function cupid_font(size)
	local ok, font = pcall(g.newFont,config.font,size)
	if ok then 
		return font
	else
		return g.newFont(cupid_font_data, size)
	end
end

-----------------------------------------------------
-- Module Console
-----------------------------------------------------

mods.console = function() return {
	buffer = "",
	shown = config.console_start_open or false,
	lastkey = "",
	log = {},
	history = {},
	history_idx = 0,
	lines = 12,
	["init"] = function(self)
		if config.console_override_print then
			local _print = print
			print = function(...) 
				local strings = {}
				for k,v in pairs({...}) do strings[k] = tostring(v) end
				self:print(table.concat(strings, "\t"))
				_print(...)
			end
		end
		cupid_print = function(str, color) self:print(str, color) end
	end,
	["post-load"] = function(self)
	end,
	["post-draw"] = function(self)
		if not self.shown then return end
		if self.height ~= g.getHeight() * config.console_height then
			self.height = g.getHeight() * config.console_height
			self.lineheight = self.height / self.lines
			self.font = cupid_font(self.lineheight)
		end
		retaining("Color","Font", function()
			--cupid_load_identity()
			g.setColor(0,0,0,120)
			g.rectangle("fill", 0, 0, g.getWidth(), self.height)
			g.setColor(0,0,0,120)
			g.rectangle("line", 0, 0, g.getWidth(), self.height)
			if self.font then g.setFont(self.font) end
			local es = self.lineheight
			local xo = 5
			local idx = 1
			for k,v in ipairs(self.log) do
				g.setColor(0,0,0)
				local width, lines = g.getFont():getWrap(v[1], g.getWidth())
				idx = idx + lines

				g.printf(v[1], xo, self.height - idx*es, g.getWidth() - xo * 2, "left")
				g.setColor(unpack(v[2]))
				g.printf(v[1], xo-1, self.height - idx*es, g.getWidth() - xo * 2, "left")
			end
			g.setColor(0,0,0)
			g.print("> " .. self.buffer .. "_", xo, self.height - es)
			g.setColor(255,255,255)
			g.print("> " .. self.buffer .. "_", xo - 1, self.height - es - 1)
		end)
	end,
	["pre-keypressed"] = function(self, key, isrepeatOrUnicode)

		if not self.shown then return true end
		
		if key == "up" then
			if self.history_idx < #self.history then
				self.history_idx = self.history_idx + 1		
				self.buffer = self.history[self.history_idx]
			end
		elseif key == "down" then
			if self.history_idx > 0 then
				self.history_idx = self.history_idx - 1		
				self.buffer = self.history[self.history_idx] or ""
			end
		else

			-- Love 0.8 - Simulate text input
			if type(isrepeatOrUnicode) == "number" then
				self["pre-textinput"](self, string.char(isrepeatOrUnicode))
			end
		end

		return false
	end,
	["pre-keyreleased"] = function(self, key)
		if key == config.console_key then 
			self:toggle()
			return false
		elseif key == "return" then
			if ( #self.buffer > 0 ) then
				self:command(self.buffer)
				self.buffer = ""
			--else
				--self:toggle()
			end
		elseif key == "backspace" then
			self.buffer = self.buffer:sub(0, -2)
		elseif key == "escape" and self.shown then
			self:toggle()
			return false
		end
		if self.shown then return false end
	end,
	["pre-textinput"] = function(self, text)
		if not self.shown then return true end
		if text ~= config.console_key then
			self.buffer = self.buffer .. text
		end
		return false
	end,
	["command"] = function(self, cmd)
		self.history_idx = 0
		table.insert(self.history, 1, cmd)
		self:print("> " .. cmd, {200, 200, 200})
		local ok, result = cupid_commands:command(cmd)
		self:print(result, ok and {255, 255, 255} or {255, 0, 0})
	end,
	["toggle"] = function(self) 
		self.shown = not self.shown 
		if config.console_key_repeat and love.keyboard.hasKeyRepeat ~= nil then
			if self.shown then
				self.keyrepeat = love.keyboard.hasKeyRepeat()
				love.keyboard.setKeyRepeat(true)
			elseif self.keyrepeat then
				love.keyboard.setKeyRepeat(self.keyrepeat)
				self.keyrepeat = nil
			end
		end
	end,
	["print"] = function(self, what, color)
		table.insert(self.log, 1, {what, color or {255,255,255,255}})
		for i=self.lines+1,#self.log do self.log[i] = nil end
	end
} end


-----------------------------------------------------
-- Remote Commands over UDP
-----------------------------------------------------

-- This command is your friend!
-- watchmedo-2.7 shell-command --command='echo reload | nc -u localhost 10173' .

mods.remote = function()
	local socket = require("socket")
	if not socket then return nil end
	return {
	["init"] = function(self)
		self.socket = socket.udp() 
		self.socket:setsockname("127.0.0.1",10173)
		self.socket:settimeout(0)
	end,
	["post-update"] = function(self)
		local a, b = self.socket:receive(100)
		if a then
			print("Remote: " .. a)
			cupid_commands:command(a)
		end
	end
	}
end

-----------------------------------------------------
-- Module Error Handler
-----------------------------------------------------


mods.error = function() return {
	["init"] = function(self)
		cupid_error = function(...) self:error(...) end
	end,
	["error"] = function(self, msg) 
		local obj = {msg = msg, traceback = debug.traceback()}
		cupid_print(obj.msg, {255, 0, 0})
		obj.gamedata="Marin0SE " .. (marioversion or "UNKNOWN") .. ", LOVE " .. (love._version or "UNKNOWN") .. " running on " .. (love._os or "UNKNOWN") .. "\n"
		local info = {love.graphics.getRendererInfo()}
		obj.render="Graphics: "..info[1].." "..info[2].." ("..info[4]..", "..info[3]..")\n"
		if not self.always_ignore then self.lasterror = obj end
		if cupid_canvas==nil and cupid_preshot==nil then
			g.setBackgroundColor(255,255,255,0)
			cupid_canvas = g.newCanvas()
			cupid_preshot = g.newScreenshot()
			cupid_preshot_image = g.newImage(cupid_preshot)
			g.setCanvas(cupid_canvas)
		end
		local t={}
		for l in string.gmatch(obj.traceback, "(.-)\n") do
			if not string.match(l, "boot.lua") and not string.match(l, "cupid.lua") then
				l = string.gsub(l, "stack traceback:", "Trace:")
				table.insert(t, l)
			end
		end
		obj.traceback=table.concat(t,"\n")
		
		return msg
	end,
	["paused"] = function(self) return self.lasterror ~= nil end,
	["post-draw"] = function(self)
		if not self.lasterror then return end
		retaining("Color", "Font", function()
			--g.setBackgroundColor(255,255,255,255)
			g.draw(cupid_preshot_image)
			g.setBackgroundColor(255,255,255,0)
			--cupid_load_identity()
			local ox = g.getWidth() * 0.1;
			local oy = g.getWidth() * 0.1;
			if self.height ~= g.getHeight() * config.console_height then
				self.height = g.getHeight() * config.console_height
				self.font = cupid_font(self.lineheight)
			end
			local hh = g.getHeight() / 20
			g.setColor(0, 0, 0, 128)
			g.rectangle("fill", ox,oy, g.getWidth()-ox*2, g.getHeight()-ox*2)
			g.setColor(0, 0, 0, 255)
			g.rectangle("fill", ox,oy, g.getWidth()-ox*2, hh)
			g.setColor(0, 0, 0, 255)
			g.rectangle("line", ox,oy, g.getWidth()-ox*2, g.getHeight()-ox*2)
			g.setColor(255, 255, 255, 255)
			local msg = string.format("%s\n\n%s\n\n\n[C]ontinue, [A]lways, [R]eload, [E]xit, [U]pload Screenshot",
				self.lasterror.msg, self.lasterror.traceback)
			if self.font then g.setFont(self.font) end
			g.setColor(255, 255, 255, 255)
			g.print("[Lua Error]", ox*1.1+1, oy*1.1+1)
			g.setColor(0, 0, 0, 255)
			g.printf(msg, ox*1.1+1, hh + oy*1.1+1, g.getWidth() - ox * 2.2, "left")
			g.setColor(255, 255, 255, 255)
			g.printf(msg, ox*1.1, hh + oy*1.1, g.getWidth() - ox * 2.2, "left")
			g.setCanvas()
			if cupid_screenshot == nil then
				cupid_screenshot = cupid_canvas:getImageData()
				cupid_screenshot_image = g.newImage(cupid_screenshot)
			end
			g.draw(cupid_screenshot_image)
			--love.graphics.present()
		end)
	end,
	["post-keypressed"] = function(self, key, unicode) 
		if not self.lasterror then return end
		if key == "r" then 
			self.lasterror = nil
			cupid_reload() 
		elseif key == "c" then
			self.lasterror = nil 
		elseif key == "a" then
			self.lasterror = nil 
			self.always_ignore = true
		elseif key == "e" then
			love.event.push("quit")
		elseif key == "u" then
			screenshotUploadWrap("crash.png", cupid_screenshot)
		end
	end

} end

-----------------------------------------------------
-- Module Watcher
-----------------------------------------------------

mods.watcher = function() return {
	lastscan = nil,
	doupdate = nil,
	["init"] = function(self) 
	end,
	["post-update"] = function(self, dt)
		if self.doupdate then
			self.doupdate = self.doupdate - dt
			if self.doupdate < 0 then
				if config.watcher_onchanged then
					cupid_commands:command(config.watcher_onchanged)
				end
				self.doupdate = nil
			end
		end
		if self.lastscan ~= nil then
			local now = love.timer.getTime()
			if now - self.lastscan < config.watcher_interval then return end
			local changed = false
			local data = self:scan()
			if self.files == nil then
				self.files = data
			else
				local old = self.files
				for k,v in pairs(data) do
					if not old[k] or old[k] ~= v then
						print(k .. " changed!", old[k], v)
						changed = true
					end
				end
			end
			if changed then
				self.doupdate = 0.5
			end
			self.files = data
		else
			self.files = self:scan()
		end
		
		self.lastscan = love.timer.getTime()
	end,
	["scan"] = function(self)
		local out = {}
		local function scan(where)

			-- Support 0.8
			local getDirectoryItems = love.filesystem.getDirectoryItems or love.filesystem.enumerate
			local list = getDirectoryItems(where)
			for k,v in pairs(list) do
				local file = where .. v
				if not love.filesystem.isFile(file) then
					scan(file .. "/")
				else
					local match = true
					if config.watcher_patterns then
						match = false
						for k,v in pairs(config.watcher_patterns) do
							if file:match(v) then
								match = true
								break
							end
						end
					end
					if match then
						local modtime, err = love.filesystem.getLastModified(file)
						if modtime then out[v] = modtime else print(err, file) end
					end
				end
			end
		end
		scan("/")
		return out
	end


} end

-----------------------------------------------------
-- Module Physics
-----------------------------------------------------

mods.physics = function() return {
	colors = {},
	["init"] = function(self) 

	end,
	["pre-load"] = function(self)
		local physics = love.physics
		local wraped_physics = {}
		wraped_physics.newWorld = function(...)
			local out = {physics.newWorld(...)}
			self.world = out[1]
			return unpack(out)
		end
		setmetatable(wraped_physics, {__index=physics})
		rawset(wraped_love, "physics", wraped_physics)
	end,
	["post-draw"] = function(self)
		if not config.physics_show then return end
		retaining("Color", function()
			if self.world then
				local c = 0
				for bk,bv in pairs(self.world:getBodyList()) do
					g.push()
					g.translate(bv:getPosition())
					g.rotate(bv:getAngle())
					c = c + 1
					if not self.colors[c] then 						
						self.colors[c] = {math.random(50,255),math.random(50,255),math.random(50,255)}
					end
					g.setColor(unpack(self.colors[c]))
					local x, y = bv:getWorldCenter()
					g.rectangle("fill",-5,-5,10,10)
					for fk, fv in pairs(bv:getFixtureList()) do
						local s = fv:getShape()
						local st = s:getType()
						if ( st == "circle" ) then
							g.circle("line", 0, 0, s:getRadius())
							g.line(0,0, s:getRadius(), 0)
						elseif ( st == "polygon" ) then
							g.polygon("line", s:getPoints())
						end
					end
					g.pop()
				end
			end
		end)
	end

} end

-----------------------------------------------------
-- Module Physics
-----------------------------------------------------

mods.temporal  = function() return {
	["arg-update"] = function(self, dt, ...)
		local mul = 1
		if love.keyboard.isDown("]") then
			mul = 4
		elseif love.keyboard.isDown("[") then
			mul = 0.25
		end
		return dt * mul, unpack({...})
	end
} end

-----------------------------------------------------
-- All Done!  Have fun :)
-----------------------------------------------------
print('...')
if ( main_args[1] == "main" ) then
	local ok, game = pcall(love.filesystem.load,'game.lua')
	game(main_args)
	love.main = cupid_load
else
	cupid_load()
end
loaded = true


-----------------------------------------------------
-- White rabbit font.
-- MIT Licensed
-- http://www.squaregear.net/fonts/
-----------------------------------------------------
if love.filesystem then cupid_font_data = love.filesystem.newFileData([[
AAEAAAAKAIAAAwAgT1MvMn1yPZMAAACsAAAAVmNtYXAFDwXDAAABBAAAAcJnbHlmROhaegAAAsgA
ACuMaGVhZNJS8B0AAC5UAAAANmhoZWEKKgRPAAAujAAAACRobXR4KQR6YAAALrAAAADQbG9jYS05
Oc4AAC+AAAAAzG1heHAAiQE9AAAwTAAAACBuYW1l3GCuhQAAMGwAAAJfcG9zdAADAAAAADLMAAAA
JAABBLABkAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQAAAAAAAAAAAAcAAAAAAAAAAAAA
AABzZnR5AEAAIAB/BXj/OAAABXgAyAAAAP/AAAAAAAAAAAACAAEAAAAAABQAAwABAAABGgAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABACoAAAAGgAQAAMACgAiACYAJwArAC8AOQBC
AFoAXABgAHoAf///AAAAIAAjACcAKAAsADAAOgBDAFsAXQBhAHv//wAA/+oAAP/pAAD/6AAA/+8A
AP/L/+oAAAABABoAAAAcAAAAGgAAAB4AAAAsAAAAAAAqAAAACAAHAAoACwAEABUAAwAWAAUABgAi
ACQAIwAlACYAAgAJACcAFwAtAC4ALAAvADEAAAACAGQAAARMBXgAFgAgAAAzIiY1ETQ2MyEyFhUR
FAYiJjURIREUBhMhETQmIyEiBhXIKDy0eAGQeLQ8UDz9qDw8Alg8KP5wKDw8KAPoeLS0ePwYKDw8
KAH0/gwoPAMgASwoPDwoygABASwAAAK8AZAADwAAATMyFh0BFAYrASImPQE0NgGQyCg8PCjIKDw8
AZA8KMgoPDwoyCg8AAABASz/OAK8AZAAEAAAATMyFh0BFA8BBiMiJjURNDYBkMgoPB7IHigoPDwB
kDwoyCgeyB48KAGQKDwAAgEsAAACvASwAA8AHwAAATMyFh0BFAYrASImPQE0NhMzMhYdARQGKwEi
Jj0BNDYBkMgoPDwoyCg8PCjIKDw8KMgoPDwEsDwoyCg8PCjIKDz84DwoyCg8PCjIKDwGAAIBLP84
ArwEsAAPACAAAAEzMhYdARQGKwEiJj0BNDYTMzIWHQEUDwEGIyImNRE0NgGQyCg8PCjIKDw8KMgo
PB7IHigoPDwEsDwoyCg8PCjIKDz84DwoyCgeyB48KAGQKDwAAgEsAAACvAV4AA8AHwAAATMyFhUR
FAYrASImNRE0NhMzMhYdARQGKwEiJj0BNDYBkMgoPDwoyCg8PCjIKDw8KMgoPDwFeDwo/agoPDwo
AlgoPPwYPCjIKDw8KMgoPAYAAwBkAAAETAV4ABQAHgAoAAAzIiY1ETQ2MyEyFh0BFAcWHQEUBiMB
ITI2PQE0JiMhESEyNj0BNCYjIcgoPDwoAlh4tFpatHj+DAH0KDw8KP4MAfQoPDwo/gw8KASwKDy0
eMh4WkZ4yHi0AyA8KMgoPPwYPCjIKDwAAgEsA+gDhAV4AAsAFwAAATQ2MhYdARQGIiY1JTQ2MhYd
ARQGIiY1Arw8UDw8UDz+cDxQPDxQPAUUKDw8KMgoPDwoyCg8PCjIKDw8KAcAAQH0A+gCvAV4AAsA
AAE0NjIWHQEUBiImNQH0PFA8PFA8BRQoPDwoyCg8PCgBACMAZAAABEwFeAAIABEAGgAjACwANQA+
AEcAUABZAGIAawB0AH0AhgCPAJgAoQCqALMAvADFAM4A1wDgAOkA8gD7AQQBDQEWAR8BKAExAToA
ACEiJjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBiUiJjQ2MhYUBjMiJjQ2MhYUBjMi
JjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBiUiJjQ2MhYUBiciJjQ2MhYUBiciJjQ2MhYUBiciJjQ2
MhYUBiciJjQ2MhYUBhMiJjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBiUiJjQ2MhYU
BiciJjQ2MhYUBiciJjQ2MhYUBiciJjQ2MhYUBhMiJjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBiUi
JjQ2MhYUBiciJjQ2MhYUBiciJjQ2MhYUBhMiJjQ2MhYUBiciJjQ2MhYUBiciJjQ2MhYUBhMiJjQ2
MhYUBiciJjQ2MhYUBiciJjQ2MhYUBgEiJjQ2MhYUBgGQKDw8UDw8oCg8PFA8PKAoPDxQPDygKDw8
UDw8/LgoPDxQPDygKDw8UDw8oCg8PFA8PKAoPDxQPDygKDw8UDw8/LgoPDxQPDwoKDw8UDw8KCg8
PFA8PCgoPDxQPDwoKDw8UDw8oCg8PFA8PKAoPDxQPDygKDw8UDw8oCg8PFA8PP2AKDw8UDw8KCg8
PFA8PCgoPDxQPDwoKDw8UDw8oCg8PFA8PKAoPDxQPDygKDw8UDw8/kgoPDxQPDwoKDw8UDw8KCg8
PFA8PKAoPDxQPDwoKDw8UDw8KCg8PFA8PKAoPDxQPDwoKDw8UDw8KCg8PFA8PPy4KDw8UDw8PFA8
PFA8PFA8PFA8PFA8PFA8PFA8PFA8yDxQPDxQPDxQPDxQPDxQPDxQPDxQPDxQPDxQPDxQPMg8UDw8
UDzIPFA8PFA8yDxQPDxQPMg8UDw8UDzIPFA8PFA8/OA8UDw8UDw8UDw8UDw8UDw8UDw8UDw8UDzI
PFA8PFA8yDxQPDxQPMg8UDw8UDzIPFA8PFA8/ag8UDw8UDw8UDw8UDw8UDw8UDzIPFA8PFA8yDxQ
PDxQPMg8UDw8UDz+cDxQPDxQPMg8UDw8UDzIPFA8PFA8/nA8UDw8UDzIPFA8PFA8yDxQPDxQPPtQ
PFA8PFA8AAACAGQAAARMBXgAPQBBAAAhIiY1ESMRFAYjIiY1ESMiJjQ2OwE1IyImNDY7ARE0NjIW
FREzETQ2MhYVETMyFhQGKwEVMzIWFAYrAREUBgEVMzUDICg8yDwoKDxkKDw8KGRkKDw8KGQ8UDzI
PFA8ZCg8PChkZCg8PChkPP6syDwoASz+1Cg8PCgBLDxQPMg8UDwBLCg8PCj+1AEsKDw8KP7UPFA8
yDxQPP7UKDwDIMjIAAMAZAAABEwFeAAsADUAPQAAISImPQEhIiY0NjMhNSMiJjQ2OwE1NDYyFh0B
ITIWFAYjIRUzMhYUBisBFRQGARQWOwE1IyIGASMVMzI2NCYCWCg8/tQoPDwoASxkeLS0eGQ8UDwB
LCg8PCj+1GR4tLR4ZDz+rDwoZGQoPAH0ZGQoPDw8KGQ8UDzItPC0ZCg8PChkPFA8yLTwtGQoPAOE
KDzIPP6syDxQPCgAAwBkAAAETAV4AA8AHwA0AAAhIiY9ATQ2OwEyFh0BFAYjASImPQE0NjsBMhYd
ARQGIwMiJj0BNDcBNTQ2MhYdARQHARUUBgMgKDw8KMgoPDwo/OAoPDwoyCg8PCjIKDweAwI8UDwe
/P48PCjIKDw8KMgoPAPoPCjIKDw8KMgoPPwYPCjIKB4DBpwoPDwoyCge/QKkKDwAAwBkAAAETAV4
ACgAMgA6AAAhIi8BBwYrASImPQE0PwEnJj0BNDYyFh0BFA8BHwE3NjIWFA8BFxYUBgEXNzU0JiMi
BhUJAQcVFBY7AQPoKB6Gfh4oyHi0HoKCHrTwtB6GhoKCHlA8HoKCHjz9HGRkPCgoPAFo/vxkPCig
HoKCHrR4yCgegoIeKMh4tLR4yCgegoKCgh48UB5+hh5QPAOwZGScKDw8KPzgAQRonCg8ggABAfQA
AAOEBXgAFgAAISImNRE0NjMyFhQGIyIGFREUFjIWFAYDIHi0tHgoPDwoKDw8UDw8tHgDIHi0PFA8
PCj84Cg8PFA8KAABASwAAAK8BXgAFgAAISImNDYyNjURNCYjIiY0NjMyFhURFAYBkCg8PFA8PCgo
PDwoeLS0PFA8PCgDICg8PFA8tHj84Hi0AAABAGQBkARMBXgAKwAAASImND8BIyImNDY7AScmNDYy
FxsBNjIWFA8BMzIWFAYrARcWFAYjIicLAQYBkCg8Hnr8KDw8KPx6HjxQHoKCHlA8Hnr8KDw8KPx6
HjwoKB6Cgh4BkDxQHuY8UDzmHlA8Hv76AQYePFAe5jxQPOYeUDweAQb++h5AAAEAZADIBEwEsAAc
AAAlIiY1ESEiJjQ2MyERNDYyFhURITIWFAYjIREUBgJYKDz+1Cg8PCgBLDxQPAEsKDw8KP7UPMg8
KAEsPFA8ASwoPDwo/tQ8UDz+1Cg8AAEAZAJYBEwDIAALAAATIiY0NjMhMhYUBiPIKDw8KAMgKDw8
KAJYPFA8PFA8AAABAGQAAARMBXgAFAAAMyImPQE0NwE1NDYyFh0BFAcBFRQGyCg8HgMCPFA8Hvz+
PDwoyCgeAwacKDw8KMgoHv0CpCg8AAEAZAAABEwFeAAUAAAhIiY9AQEmPQE0NjIWHQEBFh0BFAYD
6Cg8/P4ePFA8AwIePDwopAL+HijIKDw8KJz8+h4oyCg8AAADAGQAAARMBXgADwAYACEAACEiJjUR
NDYzITIWFREUBiMBFBYzITI2NREJATQmIyEiBhUBkHi0tHgBkHi0tHj+DDwoAZAoPP2oAlg8KP5w
KDy0eAMgeLS0ePzgeLQBLCg8PCgCHP7oAhwoPDwoAAEBLAAAA4QFeAAaAAABIiY0PwE2MhYVETMy
FhQGIyEiJjQ2OwERBwYBkCg8HsgeUDxkKDw8KP5wKDw8KGQeHgPoPFAeyB48KPu0PFA8PFA8A2Ai
HjQAAQBkAAAETAV4ACQAABMiJjU0NjMhMhYdARQHASEyFhQGIyEiJjQ3ATU0JiMhIgYVFAbIKDy0
eAGQeLQe/YYCNCg8PCj84Cg8HgMCPCj+cCg8PAPoPCh4tLR4yCge/Yo8UDw8UB4DBpwoPDwoKDwm
AAEAZAAABEwFeAA7AAApASImNTQ2MhYVFBYzITI2PQE0JisBIiY0NjsBMjY9ATQmIyEiBhUUBiMi
JjU0NjMhMhYdARQHFh0BFAYDIP5weLQ8UDw8KAGQKDw8KMgoPDwoyCg8PCj+cCg8PCgoPLR4AZB4
tFpatLR4KDw8KCg8PCjIKDw8UDw8KMgoPDwoKDw8KHi0tHjIeFpGeMh4tDwAAQBkAAAETAV4ACEA
AAEhETQ2MhYVETMyFhQGKwERFAYjIiY1ESEiJjURNDYyFhUBLAGQPFA8ZCg8PChkPCgoPP4MKDw8
UDwCWAK8KDw8KP1EPFA8/tQoPDwoASw8KAJYKDw8KF4AAQBkAAAETAV4ACUAABMiJjURNDYzITIW
FAYjIREhMhYdARQGIyEiJjQ2MyEyNj0BNCYjyCg8PCgDICg8PCj9RAH0eLS0eP2oKDw8KAJYKDw8
KAJYPCgCWCg8PFA8/nC0eMh4tDxQPDwoyCg8qAACAGQAAARMBXgAGgAnAAAhIiY1ETQ2MyEyFhQG
IyEiBhURITIWHQEUBiMBERQWMyEyNj0BNCYjAZB4tLR4AZAoPDwo/nAoPAH0eLS0eP4MPCgBkCg8
PCi0eAMgeLQ8UDw8KP7UoIzIeLQCWP7UKDw8KMgoPDwAAQBkAAAETAV4ABUAADMiJjQ3AREhIiY0
NjMhMhYVERQHAQbIKDweAwL9RCg8PCgDICg8HvzgHjxQHgMGAQA8UDw8KP5wKB784B4yAAMAZAAA
BEwFeAAZACkAOQAAEzU0NyY9ATQ2MyEyFh0BFAcWHQEUBiMhIiYBMjY9ATQmIyEiBh0BFBYzATQm
IyEiBh0BFBYzITI2NWRaWrR4AZB4tFpatHj+cHi0ArwoPDwo/nAoPDwoAfQ8KP5wKDw8KAGQKDwB
LMh4WkZ4yHi0tHjIeFpGeMh4tLQCbDwoyCg8PCjIKDz+1Cg8PCjIKDw8KDwAAgBkAAAETAV4ABoA
JwAAATIWFREUBiMhIiY0NjMhMjY1ESEiJj0BNDYzARE0JiMhIgYdARQWMwMgeLS0eP2oKDw8KAJY
KDz+DHi0tHgB9Dwo/nAoPDwoBXi0ePzgeLQ8UDw8KAEsoIzIeLT9qAEsKDw8KMgoPHQAAQBkAAAD
hAV4ABEAAAkBFhQGIyInASY0NwE2MhYUBwFQAhYePCgoHv2oHh4CWB5QPB4CvP3uHlA8HgJYHlAe
AlgePFAeAAEBLAAABEwFeAARAAAJASY0NjIXARYUBwEGIyImNDcDYP3qHjxQHgJYHh79qB4oKDwe
ArwCEh5QPB79qB5QHv2oHjxQHgACAGQBkARMA+gACwAXAAATIiY0NjMhMhYUBiMBIiY0NjMhMhYU
BiPIKDw8KAMgKDw8KPzgKDw8KAMgKDw8KAMgPFA8PFA8/nA8UDw8UDwAAAIAZAAABEwFeAAIACcA
ACEiJjQ2MhYUBgMiJjQ3ATU0JiMhIgYVFAYiJjU0NjMhMhYdARQHAQYCWCg8PFA8PCgoPB4Bcjwo
/nAoPDxQPLR4AZB4tB7+cB48UDw8UDwBkDxQHgF2nCg8PCgoPDwoeLS0eMgoHv5wHigAAgBkAAAE
TAV4ACcAMAAAASImNDY7ATU0JiMhIgYVERQWMyEyFhQGIyEiJjURNDYzITIWFREUBgMiBhQWMjY0
JgMgeLS0eGQ8KP5wKDw8KAJYKDw8KP2oeLS0eAGQeLS0eCg8PFA8PAGQtPC0ZCg8PCj84Cg8PFA8
tHgDIHi0tHj+cHi0AZA8UDw8UDwoAAEB9AAAA4QFeAAVAAAhIyImNRE0NjsBMhYUBisBETMyFhQG
AyDIKDw8KMgoPDwoZGQoPDw8KASwKDw8UDz8GDxQPCgAAQEsAAACvAV4ABUAACEiJjQ2OwERIyIm
NDY7ATIWFREUBiMBkCg8PChkZCg8PCjIKDw8KDxQPAPoPFA8PCj7UCg8KAABAGQDIARMBXgAEgAA
EyImNDcBNjIXARYUBiMiJwkBBsgoPB4BkB5QHgGQHjwoKB7+tv62HgMgPFAeAZAeHv5wHlA8HgFO
/rIeAAEAZP84BEwAAAALAAAXIiY0NjMhMhYUBiPIKDw8KAMgKDw8KMg8UDw8UDwAAQH0A+gDhAV4
AAwAAAEmNDYyHwEWFAYjIicCEh48UB7IHjwoKB4Ezh5QPB7IHlA8HgABASwAAAOEBXgAKAAAISIm
NDYzMjY9ATQ3Jj0BNCYjIiY0NjMyFh0BFBY3MhYUBiMiBh0BFAYBkCg8PCgoPFpaPCgoPDwoeLRA
JCg8PCgoPLQ8UDw8KMh4Rlp4yCg8PFA8tHjIKEAEPFA8PCjIeLQAAQEsAAADhAV4ACgAACEiJj0B
NCYjIiY0NjMWNj0BNDYzMhYUBiMiBh0BFAcWHQEUFjMyFhQGAyB4tDwoKDw8KCRAtHgoPDwoKDxa
WjwoKDw8tHjIKDw8UDwEQCjIeLQ8UDw8KMh4WkZ4yCg8PFA8AAEB9AAAArwFeAAMAAAhIiY1ETQ2
MhYVERQGAlgoPDxQPDw8KASwKDw8KPtQKDw8AAEAZAMgBEwFeAAiAAATIiY1NDYzMhYVFBYzMjY1
NDYyFhUUBiMiJjU0JiMiBhUUBsgoPLR4eLQ8KCg8PFA8tHh4tDwoKDw8A+g8KHS4tHgoPDwoKDw8
KHi0tHgoPDwoKDwAEwBkAAAETAV4AAgAEQAaACMALAA1AD4ARwBQAFkAYgBrAHQAfQCGAI8AmACh
AKoAACEiJjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBjMiJjQ2MhYUBiUiJjQ2MhYUBiEiJjQ2MhYU
BiEiJjQ2MhYUBgEiJjQ2MhYUBiciJjQ2MhYUBgEiJjQ2MhYUBgEiJjQ2MhYUBgEiJjQ2MhYUBjMi
JjQ2MhYUBiUiJjQ2MhYUBhMiJjQ2MhYUBhMiJjQ2MhYUBiciJjQ2MhYUBiciJjQ2MhYUBgEiJjQ2
MhYUBgGQKDw8UDw8oCg8PFA8PKAoPDxQPDygKDw8UDw8/LgoPDxQPDwBaCg8PFA8PAFoKDw8UDw8
/LgoPDxQPDwoKDw8UDw8AvgoPDxQPDz9gCg8PFA8PAFoKDw8UDw8oCg8PFA8PP5IKDw8UDw8oCg8
PFA8PKAoPDxQPDwoKDw8UDw8KCg8PFA8PPy4KDw8UDw8PFA8PFA8PFA8PFA8PFA8PFA8PFA8PFA8
yDxQPDxQPDxQPDxQPDxQPDxQPAMgPFA8PFA8yDxQPDxQPPzgPFA8PFA8AyA8UDw8UDz9qDxQPDxQ
PDxQPDxQPMg8UDw8UDwBkDxQPDxQPP5wPFA8PFA8yDxQPDxQPMg8UDw8UDz7UDxQPDxQPDwAAQBk
AAAETAV4AA8AAAEyFhURFAYjISImNRE0NjMD6Cg8PCj84Cg8PCgFeDwo+1AoPDwoBLAoPAABAGQA
AARMBXgAKAAAISImNRE0NjMhMhYVFAYjIiY1NCYjISIGFREUFjMhMjY1NDYyFhUUBiMBkHi0tHgB
kHi0PCgoPDwo/nAoPDwoAZAoPDxQPLR4tHgDIHi0tHgoPDwoKDw8KPzgKDw8KCg8PCh4tAACAGQA
AARMBXgADwAZAAAzIiY1ETQ2MyEyFhURFAYjExE0JiMhESEyNsgoPDwoAlh4tLR4ZDwo/gwB9Cg8
PCgEsCg8tHj84Hi0ASwDICg8/Bg8AQABAGQAAARMBXgAHQAAASERITIWFAYjISImNRE0NjMhMhYU
BiMhESEyFhQGAyD+DAK8KDw8KPzgKDw8KAMgKDw8KP1EAfQoPDwCWP5wPFA8PCgEsCg8PFA8/nA8
UDwAAQBkAAAETAV4ABgAAAEhERQGIiY1ETQ2MyEyFhQGIyERITIWFAYDIP4MPFA8PCgDICg8PCj9
RAH0KDw8Alj+cIw8PCgEsCg8PFA8/nA8UDwoAAEAZAAABEwFeAAvAAAhIiY1ETQ2MyEyFhUUBiMi
JjU0JiMhIgYVERQWMyEyNjURIyImNDY7ATIWFREUBiMBkHi0tHgBkHi0PCgoPDwo/nAoPDwoAZAo
PGQoPDwoyCg8tHi0eAMgeLS0eCg8PCgoPDwo/OAoPDwoASw8UDw8KP5weLQBAAEAZAAABEwFeAAb
AAABERQGIiY1ESERFAYiJjURNDYyFhURIRE0NjIWBEw8UDz9qDxQPDxQPAJYPFA8BRT7UCg8PCgB
9P4MKDw8KASwKDw8KP4MAfQoPDxQAAEBLAAAA4QFeAAbAAAhIiY0NjsBESMiJjQ2MyEyFhQGKwER
MzIWFAYjAZAoPDwoZGQoPDwoAZAoPDwoZGQoPDwoPFA8A+g8UDw8UDz8GDxQPAABAGQAAARMBXgA
GQAAKQEiJjU0NjIWFRQWMyEyNjURNDYyFhURFAYDIP5weLQ8UDw8KAGQKDw8UDy0tHgoPDwoKDw8
KAPoKDw8KPwYeLQAAAEAZAAABEwFeAAbAAAJARYUBiInAQcRFAYiJjURNDYyFhURATYyFhQHAhgC
Fh48UB797mQ8UDw8UDwCdh5QPB4CvP3uHlA8HgIWZP6UKDw8KASwKDw8KP3UAnIePFAeAAEAZAAA
BEwFeAAQAAAlITIWFAYjISImNRE0NjIWFQEsArwoPDwo/OAoPDxQPMg8UDw8KASwKDw8KAABAGQA
AARMBXgAHQAAMyImNRE0NjIXCQE2MhYVERQGIiY1EQcGIi8BERQGyCg8PFAeAUoBSh5QPDxQPOYe
UB7mPDwoBLAoPB7+tgFKHjwo+1AoPDwoA8TqHh7m/EAoPAABAGQAAARMBXgAGgAAMyImNRE0NjIX
ARE0NjIWFREUBiImNREBERQGyCg8PFAeAnY8UDw8UDz9qDw8KASwKDwe/YoCMCg8PCj7UCg8PCgB
aAJY/EAoPAAAAgBkAAAETAV4AA8AHwAAISImNRE0NjMhMhYVERQGIxM0JiMhIgYVERQWMyEyNjUB
kHi0tHgBkHi0tHhkPCj+cCg8PCgBkCg8tHgDIHi0tHj84Hi0BEwoPDwo/OAoPDwoHAACAGQAAARM
BXgACQAcAAABITI2PQE0JiMhERQGIiY1ETQ2MyEyFh0BFAYjIQEsAfQoPDwo/gw8UDw8KAJYeLS0
eP4MAyA8KMgoPPu0KDw8KASwKDy0eMh4tAACAGQAAARMBXgAFQAvAAABNCYjISIGFREUFjsBNycm
NDYyHwE3FxQPARcWFAYiLwEHBisBIiY1ETQ2MyEyFhUDhDwo/nAoPDwooGSCHjxQHmaAyB6Ghh48
UB6Gfh4oyHi0tHgBkHi0BEwoPDwo/OAoPGSCHlA8HmaAYCgegoIeUDwegoIetHgDIHi0tHgAAgBk
AAAETAV4AAkAKAAAASEyNj0BNCYjIQEiJjURNCYjIREUBiImNRE0NjMhMhYdARQHFhURFAYBLAH0
KDw8KP4MArwoPDwo/gw8UDw8KAJYeLRaWjwDIDwoyCg8+1A8KAGQKDz+DCg8PCgEsCg8tHjIeFpG
eP5wKDwDAAEAZAAABEwFeAA4AAABIiY9ATQ2MyEyFhUUBiMiJjU0JiMhIgYdARQWMyEyFh0BFAYj
ISImNTQ2MhYVFBYzITI2PQE0JiMBkIygoIwBkHi0PCgoPDwo/nAoPDwoAZB4tLR4/nB4tDxQPDwo
AZAoPDwoAligjMh4tLR4KDw8KCg8PCjIKDy0eMiMoLR4KDw8KCg8PCjIKDwAAQBkAAAETAV4ABMA
ABMiJjQ2MyEyFhQGIyERFAYiJjURyCg8PCgDICg8PCj+1DxQPASwPFA8PFA8+7QoPDwoBEwAAQBk
AAAETAV4ABsAACkBIiY1ETQ2MhYVERQWMyEyNjURNDYyFhURFAYDIP5weLQ8UDw8KAGQKDw8UDy0
tHgD6Cg8PCj8GCg8PCgD6Cg8PCj8GHi0AAABAGQAAARMBXgAGQAAISInASY1ETQ2MhYVEQkBETQ2
MhYVERQHAQYCWCge/nAePFA8ASwBLDxQPB7+cB4eAZAeKAMgKDw8KP1A/tQBLALAKDw8KPzgKB7+
cB78AAEAZAAABEwFeAAqAAAhIicGIyImNRE0NjIWFREUFjMyNjURNDYyFhURFBYzMjY1ETQ2MhYV
ERQGAyB4WkZ4eLQ8UDw8KCg8PFA8PCgoPDxQPLRaWrR4A+goPDwo/BgoPDwoAZAoPDwo/nAoPDwo
A+goPDwo/Bh4tLQAAQBkAAAETAV4ACsAAAEVFAYiJj0BNDcJASY9ATQ2MhYdAQkBNTQ2MhYdARQH
CQEWHQEUBiImPQEBASw8UDweAUr+th48UDwBLAEsPFA8Hv6yAU4ePFA8/tQBBKAoPDwoyCgeAUoB
Sh4oyCg8PCig/tQBLKAoPDwoyCge/rb+th4oyCg8PCigASwAAQBkAAAETAV4ABwAAAkBJj0BNDYy
Fh0BCQE1NDYyFh0BFAcBERQGIiY1AfT+jh48UDwBLAEsPFA8Hv6OPFA8ApQBch4oyCg8PCig/tQB
LKAoPDwoyCge/pL9zCg8PCgAAQBkAAAETAV4AB0AABM0NwE1ISImNDYzITIWHQEUBwEVITIWFAYj
ISImNWQeAwL9RCg8PCgDICg8Hvz+ArwoPDwo/OAoPAEsKB4DBjg8UDw8KMgoHv0CQDxQPDwoABIA
ZP84BEwFeAAIABEAGgAjACwANQA+AEcAUABZAGIAawB0AH0AhgCPAJgAoQAAISImNDYyFhQGMyIm
NDYyFhQGMyImNDYyFhQGMyImNDYyFhQGJSImNDYyFhQGISImNDYyFhQGASImNDYyFhQGByImNDYy
FhQGAyImNDYyFhQGEyImNDYyFhQGAyImNDYyFhQGISImNDYyFhQGASImNDYyFhQGBSImNDYyFhQG
ASImNDYyFhQGEyImNDYyFhQGMyImNDYyFhQGASImNDYyFhQGAZAoPDxQPDygKDw8UDw8oCg8PFA8
PKAoPDxQPDz8uCg8PFA8PAL4KDw8UDw8/LgoPDxQPDwoKDw8UDw8KCg8PFA8PKAoPDxQPDwoKDw8
UDw8AWgoPDxQPDz+SCg8PFA8PAIwKDw8UDw8/kgoPDxQPDygKDw8UDw8oCg8PFA8PPy4KDw8UDw8
PFA8PFA8PFA8PFA8PFA8PFA8PFA8PFA8yDxQPDxQPDxQPDxQPAJYPFA8PFA8yDxQPDxQPAJYPFA8
PFA8/OA8UDw8UDz9qDxQPDxQPDxQPDxQPAPoPFA8PFA8yDxQPDxQPAJYPFA8PFA8/nA8UDw8UDw8
UDw8UDz84DxQPDxQPAACAGQAAARMA+gAGQAiAAAhIiY1NDYzITU0JiMhIiY0NjMhMhYVERQGIwMh
IgYVFBYzIQGQeLS0eAH0PCj+cCg8PCgBkHi0PChk/gwoPDwoAfS0eHi0ZCg8PFA8tHj9qCg8AZA8
KCg8AAIAZAAABEwFeAAJABwAAAEhESEyNjURNCYBIiY1ETQ2MhYVESEyFhURFAYjAyD+DAH0KDw8
/YAoPDxQPAH0eLS0eAMg/ag8KAGQKDz84DwoBLAoPDwo/tS0eP5weLQ8AAEAZAAABEwD6AAoAAAh
IiY1ETQ2MyEyFhUUBiMiJjU0JiMhIgYVERQWMyEyNjU0NjIWFRQGIwGQeLS0eAGQeLQ8KCg8PCj+
cCg8PCgBkCg8PFA8tHi0eAGQeLS0eCg8PCgoPDwo/nAoPDwoKDw8KHi0AAIAZAAABEwFeAAJABwA
AAEiBhURFBYzIRETISImNRE0NjMhETQ2MhYVERQGAZAoPDwoAfRk/ah4tLR4AfQ8UDw8AyA8KP5w
KDwCWPzgtHgBkHi0ASwoPDwo+1AoPAACAGQAAARMA+gAGgAkAAAhIiY1ETQ2MyEyFh0BFAYjIRUU
FjMhMhYUBiMBITU0JiMhIgYVAZB4tLR4AZB4tDwo/UQ8KAGQKDw8KP4MAlg8KP5wKDy0eAGQeLS0
eMgoPGQoPDxQPAJYZCg8PCg8AAEBLAAABEwFeAAjAAABIxEUBiImNREjIiY0NjsBNTQ2OwEyFhQG
KwEiBh0BMzIWFAYDIGQ8UDxkKDw8KGS0eMgoPDwoyCg8ZCg8PAMg/UQoPDwoArw8UDxkeLQ8UDw8
KGQ8UDxIAAIAZP84BEwD6AAaACQAACUiJj0BNDYzITIWFREUBiMhIiY0NjMhMjY9AhEhIgYdARQW
MwGQeLS0eAJYKDy0eP5wKDw8KAGQKDz+DCg8PCjItHjIeLQ8KPzgeLQ8UDw8KGTIAZA8KMgoPAAB
AGQAAARMBXgAGwAAEzQ2MhYVESEyFhURFAYiJjURNCYjIREUBiImNWQ8UDwB9Hi0PFA8PCj+DDxQ
PAUUKDw8KP7UtHj9qCg8PCgCWCg8/UQoPDwoAAIBLAAAA4QFeAAYACMAAAEjIiY0NjsBMhYVETMy
FhQGIyEiJjQ2OwETIiY1NDYyFhUUBgH0ZCg8PCjIKDxkKDw8KP5wKDw8KGRkKDw8UDw8AyA8UDw8
KP1EPFA8PFA8A+g8KCg8PCgoPAACAGT/OAOEBXgACAAnAAABIiY0NjIWFAYDIiY0NjsBMhYVERQG
KwEiJjU0NjIWFRQWOwEyNjURAyAoPDxQPDzwKDw8KMgoPLR4yHi0PFA8PCjIKDwEsDxQPDxQPP5w
PFA8PCj84Hi0tHgoPDwoKDw8KAK8AAEBLAAABEwFeAAcAAAhIicBBxUUBiImNRE0NjIWFREBNjIW
FAcJARYUBgPoKB7+tmQ8UDw8UDwBrh5QPB7+tgFKHjweAUpkoCg8PCgEsCg8PCj9DAGqHjxQHv66
/rIeUDwAAQEsAAADhAV4ABgAACEiJjQ2OwERIyImNDY7ATIWFREzMhYUBiMBkCg8PChkZCg8PCjI
KDxkKDw8KDxQPAPoPFA8PCj7tDxQPAABAGQAAARMA+gAKQAAAREUBiImNRE0NjsBMhc2MzIWFREU
BiImNRE0JiMiBhURFAYiJjURNCYjASw8UDw8KMh4WkZ4eLQ8UDw8KCg8PFA8PCgDIP1EKDw8KAMg
KDxaWrR4/agoPDwoAlgoPDwo/agoPDwoAlgoPAABAGQAAARMA+gAGAAAAREUBiImNRE0NjMhMhYV
ERQGIiY1ETQmIwEsPFA8PCgCWHi0PFA8PCgDIP1EKDw8KAMgKDy0eP2oKDw8KAJYKDw8AAIAZAAA
BEwD6AAPAB8AACEiJjURNDYzITIWFREUBiMTNCYjISIGFREUFjMhMjY1AZB4tLR4AZB4tLR4ZDwo
/nAoPDwoAZAoPLR4AZB4tLR4/nB4tAK8KDw8KP5wKDw8KCgAAgBk/zgETAPoABIAHAAAJSERFAYi
JjURNDYzITIWHQEUBiUhMjY9ATQmIyEDIP4MPFA8PCgCWHi0tP2UAfQoPDwo/gzI/tQoPDgsA+go
PLR4yHi0yDwoyCg8tAACAGT/OARMA+gAEgAcAAAlIiY9ATQ2MyEyFhURFAYiJjURNREhIgYdARQW
MwGQeLS0eAJYKDw8UDz+DCg8PCjItHjIeLQ8KPwYLDg8KAEsyAGQPCjIKDwAAQEsAAAETAPoABYA
AAERFAYiJjURNDYzITIWFRQGIiY1NCYjAfQ8UDw8KAGQeLQ8UDw8KAMg/UQoPDwoAyAoPLR4KDw8
KCg8KAABAGQAAARMA+gAJAAAASImNDYzITIWFAYjICMiBhQWMyEyFhQGIyEiJjQ2MyEyNjQmIwGQ
eLS0eAJYKDw8KP3QKCg8PCgBkHi0tHj9qCg8PCgCWCg8PCwBkLTwtDxQPDxQPLTwtDxQPDxQPAAB
ASwAAARMBXgAIwAAASImNDY7ARE0NjIWFREhMhYUBiMhERQWOwEyFhQGKwEiJjURAZAoPDwoZDxQ
PAEsKDw8KP7UPCjIKDw8KMh4tAMgPFA8ASwoPDwo/tQ8UDz+DCg8PFA8tHgB9DQAAQBkAAAETAPo
ABgAACURNDYyFhURFAYjISImNRE0NjIWFREUFjMDhDxQPDwo/ah4tDxQPDwoyAK8KDw8KPzgKDy0
eAJYKDw8KP2oKDwAAQBkAAAETAPoABkAACEiJwEmNRE0NjIWFREJARE0NjIWFREUBwEGAlgoHv5w
HjxQPAEsASw8UDwe/nAeHgGQHigBkCg8PCj+0P7UASwBMCg8PCj+cCge/nAeAAABAGQAAARMA+gA
KgAAISInBiMiJjURNDYyFhURFBYzMjY1ETQ2MhYVERQWMzI2NRE0NjIWFREUBgMgeFpGeHi0PFA8
PCgoPDxQPDwoKDw8UDy0Wlq0eAJYKDw8KP2oKDw8KAGQKDw8KP5wKDw8KAJYKDw8KP2oeLQAAAEA
ZAAABEwD6AAbAAAJAQYiJjQ3CQEmNDYyFwkBNjIWFAcJARYUBiInAlj+th5QPB4BRv66HjxQHgFK
AUoeUDwe/rIBTh48UB4BbP6yHjxQHgFKAUoeUDwe/roBRh48UB7+tv62HlA8HgABAGT/OARMA+gA
IwAAJSImNRE0NjIWFREUFjMhETQ2MhYVERQGIyEiJjQ2MyEyNj0BAZB4tDxQPDwoAfQ8UDy0eP5w
KDw8KAGQKDzItHgBkCg8PCj+cCg8AfQoPDwo/OB4tDxQPDwoZDwAAQBkAAAETAPoABcAADMiJjQ3
ASEiJjQ2MyEyFhQHASEyFhQGI8goPB4Ccv3UKDw8KAMgKDwe/YYCNCg8PCg8UB4CdjxQPDxQHv2K
PFA8AgABAAAAAAAA93U7il8PPPUAAAg0AAAAALNAIasAAAAAu1GEkgBk/zgETAV4AAAABwAAAAAA
AAAAAAEAAAV4/zgAAASwAGQAZARMAAAAAAAAAAAAAAAAAAAAAAADBLAAAAAAXRQEsABkASwBLAEs
ASwBLAAAAGQBLAH0AGQAZABkAGQAZAH0ASwAZABkAGQAZABkAGQBLABkAGQAZABkAGQAZABkAGQA
ZAEsAGQAZABkAfQBLABkAGQB9AEsASwB9ABkAGQAZABkAGQAZABkAGQAZAEsAGQAZABkAGQAZABk
AGQAZABkAGQAZABkAGQAZABkAGQAZABkAGQAZABkAGQAZAEsAGQAZAEsAGQBLAEsAGQAZABkAGQA
ZAEsAGQBLABkAGQAZABkAGQAZAAAAAAAAAAzAE4AawCaAMsA+wD7ATcBXgF1AzADiAPdBCgEgASk
BMgFCwU4BU8FcQWUBcsF9gYuBn0GsAbnByIHSAeaB9YH+QgcCEQIgQjICOoJDAkxCUcJYAmYCdAJ
6AoZCxILLgtnC5ELwAvpDCsMWAyBDKkM2Qz2DSYNUg2DDbAN9w41DoEOog7NDvsPOA99D60P3BDI
EPwRLBFlEZQRyxH+EjMSXhKTEs0S/hMjE18ThxO4E+YUEhQ3FG0UohTJFPcVNBVpFZ4VxgABAAAA
ZQE7ACMAAAAAAAEAAAAAAAAAAAAAAAAAAAABAAAAEADGAAEAAAAAAAAACQAAAAEAAAAAAAEAAwAJ
AAEAAAAAAAIABwAMAAEAAAAAAAMAAwATAAEAAAAAAAQAAwAWAAEAAAAAAAUADAAZAAEAAAAAAAYA
AwAlAAEAAAAAAAcACQAoAAMAAQQJAAAAbgAxAAMAAQQJAAEAGACfAAMAAQQJAAIADgC3AAMAAQQJ
AAMAMgDFAAMAAQQJAAQAGAD3AAMAAQQJAAUAGAEPAAMAAQQJAAYAFgEnAAMAAQQJAAcAUAE9Q29w
eXJpZ2h0TmV3UmVndWxhck5ld05ld1ZlcnNpb24gMS4wME5ld1RyYWRlbWFyawBDAG8AcAB5AHIA
aQBnAGgAdAAgAKkAIAAxADkAOQA5ACAAYgB5ACAATQBhAHQAdABoAGUAdwAgAFcAZQBsAGMAaAAu
ACAAQQBsAGwAIABSAGkAZwBoAHQAcwAgAFIAZQBzAGUAcgB2AGUAZAAuAFcAaABpAHQAZQAgAFIA
YQBiAGIAaQB0AFIAZQBnAHUAbABhAHIAVwBoAGkAdABlACAAUgBhAGIAYgBpAHQAOgBWAGUAcgBz
AGkAbwBuACAAMQAuADAAMABXAGgAaQB0AGUAIABSAGEAYgBiAGkAdABWAGUAcgBzAGkAbwBuACAA
MQAuADAAMABXAGgAaQB0AGUAUgBhAGIAYgBpAHQAVwBoAGkAdABlACAAUgBhAGIAYgBpAHQAmQAg
AFQAcgBhAGQAZQBtAGEAcgBrACAAbwBmACAATQBhAHQAdABoAGUAdwAgAFcAZQBsAGMAaAAAAAAA
AAAAAAAAAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=
]], "whiterabit.ttf", "base64") end
end end)()end;
do require("package").preload["libs.sha1"] = (function() local package;return function(...)-- <pack libs.sha1> --
--
-- SHA-1 secure hash computation, and HMAC-SHA1 signature computation,
-- in pure Lua (tested on Lua 5.1)
--
-- Latest version always at:  http://regex.info/blog/lua/sha1
--
-- Copyright 2009 Jeffrey Friedl
-- jfriedl@yahoo.com
-- http://regex.info/blog/
-- 
--
-- Version 1 [May 28, 2009]
--
--
-- Lua is a pathetic, horrid, turd of a language. Not only doesn't it have
-- bitwise integer operators like OR and AND, it doesn't even have integers
-- (and those, relatively speaking, are its good points). Yet, this
-- implements the SHA-1 digest hash in pure Lua. While coding it, I felt as
-- if I were chiseling NAND gates out of rough blocks of silicon. Those not
-- already familiar with this woeful language may, upon seeing this code,
-- throw up in their own mouth.
--
-- It's not super fast.... a 10k-byte message takes about 2 seconds on a
-- circa-2008 mid-level server, but it should be plenty adequate for short
-- messages, such as is often needed during authentication handshaking.
--
-- Algorithm: http://www.itl.nist.gov/fipspubs/fip180-1.htm
--
-- This file creates four entries in the global namespace:
--
--   local hash_as_hex   = sha1(message)            -- returns a hex string
--   local hash_as_data  = sha1_binary(message)     -- returns raw bytes
--
--   local hmac_as_hex   = hmac_sha1(key, message)        -- hex string
--   local hmac_as_data  = hmac_sha1_binary(key, message) -- raw bytes
--
-- Pass sha1() a string, and it returns a hash as a 40-character hex string.
-- For example, the call
--
--   local hash = sha1 "http://regex.info/blog/"
--
-- puts the 40-character string
--
--   "7f103bf600de51dfe91062300c14738b32725db5"
-- 
-- into the variable 'hash'
--
-- Pass sha1_hmac() a key and a message, and it returns the signature as a
-- 40-byte hex string.
--
--
-- The two "_binary" versions do the same, but return the 20-byte string of raw data
-- that the 40-byte hex strings represent.
--

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------


--
-- Return a W32 object for the number zero
--
local function ZERO()
   return {
      false, false, false, false,     false, false, false, false, 
      false, false, false, false,     false, false, false, false, 
      false, false, false, false,     false, false, false, false, 
      false, false, false, false,     false, false, false, false, 
   }
end

local hex_to_bits = {
   ["0"] = { false, false, false, false },
   ["1"] = { false, false, false, true  },
   ["2"] = { false, false, true,  false },
   ["3"] = { false, false, true,  true  },

   ["4"] = { false, true,  false, false },
   ["5"] = { false, true,  false, true  },
   ["6"] = { false, true,  true,  false },
   ["7"] = { false, true,  true,  true  },

   ["8"] = { true,  false, false, false },
   ["9"] = { true,  false, false, true  },
   ["A"] = { true,  false, true,  false },
   ["B"] = { true,  false, true,  true  },

   ["C"] = { true,  true,  false, false },
   ["D"] = { true,  true,  false, true  },
   ["E"] = { true,  true,  true,  false },
   ["F"] = { true,  true,  true,  true  },

   ["a"] = { true,  false, true,  false },
   ["b"] = { true,  false, true,  true  },
   ["c"] = { true,  true,  false, false },
   ["d"] = { true,  true,  false, true  },
   ["e"] = { true,  true,  true,  false },
   ["f"] = { true,  true,  true,  true  },
}

--
-- Given a string of 8 hex digits, return a W32 object representing that number
--
local function from_hex(hex)

   assert(type(hex) == 'string')
   assert(hex:match('^[0123456789abcdefABCDEF]+$'))
   assert(#hex == 8)

   local W32 = { }

   for letter in hex:gmatch('.') do
      local b = hex_to_bits[letter]
      assert(b)
      table.insert(W32, 1, b[1])
      table.insert(W32, 1, b[2])
      table.insert(W32, 1, b[3])
      table.insert(W32, 1, b[4])
   end

   return W32
end

local function COPY(old)
   local W32 = { }
   for k,v in pairs(old) do
      W32[k] = v
   end

   return W32
end

local function ADD(first, ...)

   local a = COPY(first)

   local C, b, sum

   for v = 1, select('#', ...) do
      b = select(v, ...)
      C = 0

      for i = 1, #a do
         sum = (a[i] and 1 or 0)
             + (b[i] and 1 or 0)
             + C

         if sum == 0 then
            a[i] = false
            C    = 0
         elseif sum == 1 then
            a[i] = true
            C    = 0
         elseif sum == 2 then
            a[i] = false
            C    = 1
         else
            a[i] = true
            C    = 1
         end
      end
      -- we drop any ending carry

   end

   return a
end

local function XOR(first, ...)

   local a = COPY(first)
   local b
   for v = 1, select('#', ...) do
      b = select(v, ...)
      for i = 1, #a do
         a[i] = a[i] ~= b[i]
      end
   end

   return a

end

local function AND(a, b)

   local c = ZERO()

   for i = 1, #a do
      -- only need to set true bits; other bits remain false
      if  a[i] and b[i] then
         c[i] = true
      end
   end

   return c
end

local function OR(a, b)

   local c = ZERO()

   for i = 1, #a do
      -- only need to set true bits; other bits remain false
      if  a[i] or b[i] then
         c[i] = true
      end
   end

   return c
end

local function OR3(a, b, c)

   local d = ZERO()

   for i = 1, #a do
      -- only need to set true bits; other bits remain false
      if a[i] or b[i] or c[i] then
         d[i] = true
      end
   end

   return d
end

local function NOT(a)

   local b = ZERO()

   for i = 1, #a do
      -- only need to set true bits; other bits remain false
      if not a[i] then
         b[i] = true
      end
   end

   return b
end

local function ROTATE(bits, a)

   local b = COPY(a)

   while bits > 0 do
      bits = bits - 1
      table.insert(b, 1, table.remove(b))
   end

   return b

end


local binary_to_hex = {
   ["0000"] = "0",
   ["0001"] = "1",
   ["0010"] = "2",
   ["0011"] = "3",
   ["0100"] = "4",
   ["0101"] = "5",
   ["0110"] = "6",
   ["0111"] = "7",
   ["1000"] = "8",
   ["1001"] = "9",
   ["1010"] = "a",
   ["1011"] = "b",
   ["1100"] = "c",
   ["1101"] = "d",
   ["1110"] = "e",
   ["1111"] = "f",
}

function asHEX(a)

   local hex = ""
   local i = 1
   while i < #a do
      local binary = (a[i + 3] and '1' or '0')
                     ..
                     (a[i + 2] and '1' or '0')
                     ..
                     (a[i + 1] and '1' or '0')
                     ..
                     (a[i + 0] and '1' or '0')

      hex = binary_to_hex[binary] .. hex

      i = i + 4
   end

   return hex

end

local x67452301 = from_hex("67452301")
local xEFCDAB89 = from_hex("EFCDAB89")
local x98BADCFE = from_hex("98BADCFE")
local x10325476 = from_hex("10325476")
local xC3D2E1F0 = from_hex("C3D2E1F0")

local x5A827999 = from_hex("5A827999")
local x6ED9EBA1 = from_hex("6ED9EBA1")
local x8F1BBCDC = from_hex("8F1BBCDC")
local xCA62C1D6 = from_hex("CA62C1D6")


function sha1(msg)

   assert(type(msg) == 'string')
   assert(#msg < 0x7FFFFFFF) -- have no idea what would happen if it were large

   local H0 = x67452301
   local H1 = xEFCDAB89
   local H2 = x98BADCFE
   local H3 = x10325476
   local H4 = xC3D2E1F0

   local msg_len_in_bits = #msg * 8

   local first_append = string.char(0x80) -- append a '1' bit plus seven '0' bits

   local non_zero_message_bytes = #msg +1 +8 -- the +1 is the appended bit 1, the +8 are for the final appended length
   local current_mod = non_zero_message_bytes % 64
   local second_append = ""
   if current_mod ~= 0 then
      second_append = string.rep(string.char(0), 64 - current_mod)
   end

   -- now to append the length as a 64-bit number.
   local B1, R1 = math.modf(msg_len_in_bits  / 0x01000000)
   local B2, R2 = math.modf( 0x01000000 * R1 / 0x00010000)
   local B3, R3 = math.modf( 0x00010000 * R2 / 0x00000100)
   local B4     =            0x00000100 * R3

   local L64 = string.char( 0) .. string.char( 0) .. string.char( 0) .. string.char( 0) -- high 32 bits
            .. string.char(B1) .. string.char(B2) .. string.char(B3) .. string.char(B4) --  low 32 bits



   msg = msg .. first_append .. second_append .. L64         

   assert(#msg % 64 == 0)

   --local fd = io.open("/tmp/msg", "wb")
   --fd:write(msg)
   --fd:close()

   local chunks = #msg / 64

   local W = { }
   local start, A, B, C, D, E, f, K, TEMP
   local chunk = 0

   while chunk < chunks do
      --
      -- break chunk up into W[0] through W[15]
      --
      start = chunk * 64 + 1
      chunk = chunk + 1

      for t = 0, 15 do
         W[t] = from_hex(string.format("%02x%02x%02x%02x", msg:byte(start, start + 3)))
         start = start + 4
      end

      --
      -- build W[16] through W[79]
      --
      for t = 16, 79 do
         -- For t = 16 to 79 let Wt = S1(Wt-3 XOR Wt-8 XOR Wt-14 XOR Wt-16). 
         W[t] = ROTATE(1, XOR(W[t-3], W[t-8], W[t-14], W[t-16]))
      end

      A = H0
      B = H1
      C = H2
      D = H3
      E = H4

      for t = 0, 79 do
         if t <= 19 then
            -- (B AND C) OR ((NOT B) AND D)
            f = OR(AND(B, C), AND(NOT(B), D))
            K = x5A827999
         elseif t <= 39 then
            -- B XOR C XOR D
            f = XOR(B, C, D)
            K = x6ED9EBA1
         elseif t <= 59 then
            -- (B AND C) OR (B AND D) OR (C AND D
            f = OR3(AND(B, C), AND(B, D), AND(C, D))
            K = x8F1BBCDC
         else
            -- B XOR C XOR D
            f = XOR(B, C, D)
            K = xCA62C1D6
         end

         -- TEMP = S5(A) + ft(B,C,D) + E + Wt + Kt; 
         TEMP = ADD(ROTATE(5, A), f, E, W[t], K)

         --E = D; D = C; C = S30(B); B = A; A = TEMP;
         E = D
         D = C
         C = ROTATE(30, B)
         B = A
         A = TEMP

         --printf("t = %2d: %s  %s  %s  %s  %s", t, A:HEX(), B:HEX(), C:HEX(), D:HEX(), E:HEX())
      end

      -- Let H0 = H0 + A, H1 = H1 + B, H2 = H2 + C, H3 = H3 + D, H4 = H4 + E. 
      H0 = ADD(H0, A)
      H1 = ADD(H1, B)
      H2 = ADD(H2, C)
      H3 = ADD(H3, D)
      H4 = ADD(H4, E)
   end

   return asHEX(H0) .. asHEX(H1) .. asHEX(H2) .. asHEX(H3) .. asHEX(H4)
end

local function hex_to_binary(hex)
   return hex:gsub('..', function(hexval)
                            return string.char(tonumber(hexval, 16))
                         end)
end

function sha1_binary(msg)
   return hex_to_binary(sha1(msg))
end

local xor_with_0x5c = {
   [string.char(  0)] = string.char( 92),   [string.char(  1)] = string.char( 93),
   [string.char(  2)] = string.char( 94),   [string.char(  3)] = string.char( 95),
   [string.char(  4)] = string.char( 88),   [string.char(  5)] = string.char( 89),
   [string.char(  6)] = string.char( 90),   [string.char(  7)] = string.char( 91),
   [string.char(  8)] = string.char( 84),   [string.char(  9)] = string.char( 85),
   [string.char( 10)] = string.char( 86),   [string.char( 11)] = string.char( 87),
   [string.char( 12)] = string.char( 80),   [string.char( 13)] = string.char( 81),
   [string.char( 14)] = string.char( 82),   [string.char( 15)] = string.char( 83),
   [string.char( 16)] = string.char( 76),   [string.char( 17)] = string.char( 77),
   [string.char( 18)] = string.char( 78),   [string.char( 19)] = string.char( 79),
   [string.char( 20)] = string.char( 72),   [string.char( 21)] = string.char( 73),
   [string.char( 22)] = string.char( 74),   [string.char( 23)] = string.char( 75),
   [string.char( 24)] = string.char( 68),   [string.char( 25)] = string.char( 69),
   [string.char( 26)] = string.char( 70),   [string.char( 27)] = string.char( 71),
   [string.char( 28)] = string.char( 64),   [string.char( 29)] = string.char( 65),
   [string.char( 30)] = string.char( 66),   [string.char( 31)] = string.char( 67),
   [string.char( 32)] = string.char(124),   [string.char( 33)] = string.char(125),
   [string.char( 34)] = string.char(126),   [string.char( 35)] = string.char(127),
   [string.char( 36)] = string.char(120),   [string.char( 37)] = string.char(121),
   [string.char( 38)] = string.char(122),   [string.char( 39)] = string.char(123),
   [string.char( 40)] = string.char(116),   [string.char( 41)] = string.char(117),
   [string.char( 42)] = string.char(118),   [string.char( 43)] = string.char(119),
   [string.char( 44)] = string.char(112),   [string.char( 45)] = string.char(113),
   [string.char( 46)] = string.char(114),   [string.char( 47)] = string.char(115),
   [string.char( 48)] = string.char(108),   [string.char( 49)] = string.char(109),
   [string.char( 50)] = string.char(110),   [string.char( 51)] = string.char(111),
   [string.char( 52)] = string.char(104),   [string.char( 53)] = string.char(105),
   [string.char( 54)] = string.char(106),   [string.char( 55)] = string.char(107),
   [string.char( 56)] = string.char(100),   [string.char( 57)] = string.char(101),
   [string.char( 58)] = string.char(102),   [string.char( 59)] = string.char(103),
   [string.char( 60)] = string.char( 96),   [string.char( 61)] = string.char( 97),
   [string.char( 62)] = string.char( 98),   [string.char( 63)] = string.char( 99),
   [string.char( 64)] = string.char( 28),   [string.char( 65)] = string.char( 29),
   [string.char( 66)] = string.char( 30),   [string.char( 67)] = string.char( 31),
   [string.char( 68)] = string.char( 24),   [string.char( 69)] = string.char( 25),
   [string.char( 70)] = string.char( 26),   [string.char( 71)] = string.char( 27),
   [string.char( 72)] = string.char( 20),   [string.char( 73)] = string.char( 21),
   [string.char( 74)] = string.char( 22),   [string.char( 75)] = string.char( 23),
   [string.char( 76)] = string.char( 16),   [string.char( 77)] = string.char( 17),
   [string.char( 78)] = string.char( 18),   [string.char( 79)] = string.char( 19),
   [string.char( 80)] = string.char( 12),   [string.char( 81)] = string.char( 13),
   [string.char( 82)] = string.char( 14),   [string.char( 83)] = string.char( 15),
   [string.char( 84)] = string.char(  8),   [string.char( 85)] = string.char(  9),
   [string.char( 86)] = string.char( 10),   [string.char( 87)] = string.char( 11),
   [string.char( 88)] = string.char(  4),   [string.char( 89)] = string.char(  5),
   [string.char( 90)] = string.char(  6),   [string.char( 91)] = string.char(  7),
   [string.char( 92)] = string.char(  0),   [string.char( 93)] = string.char(  1),
   [string.char( 94)] = string.char(  2),   [string.char( 95)] = string.char(  3),
   [string.char( 96)] = string.char( 60),   [string.char( 97)] = string.char( 61),
   [string.char( 98)] = string.char( 62),   [string.char( 99)] = string.char( 63),
   [string.char(100)] = string.char( 56),   [string.char(101)] = string.char( 57),
   [string.char(102)] = string.char( 58),   [string.char(103)] = string.char( 59),
   [string.char(104)] = string.char( 52),   [string.char(105)] = string.char( 53),
   [string.char(106)] = string.char( 54),   [string.char(107)] = string.char( 55),
   [string.char(108)] = string.char( 48),   [string.char(109)] = string.char( 49),
   [string.char(110)] = string.char( 50),   [string.char(111)] = string.char( 51),
   [string.char(112)] = string.char( 44),   [string.char(113)] = string.char( 45),
   [string.char(114)] = string.char( 46),   [string.char(115)] = string.char( 47),
   [string.char(116)] = string.char( 40),   [string.char(117)] = string.char( 41),
   [string.char(118)] = string.char( 42),   [string.char(119)] = string.char( 43),
   [string.char(120)] = string.char( 36),   [string.char(121)] = string.char( 37),
   [string.char(122)] = string.char( 38),   [string.char(123)] = string.char( 39),
   [string.char(124)] = string.char( 32),   [string.char(125)] = string.char( 33),
   [string.char(126)] = string.char( 34),   [string.char(127)] = string.char( 35),
   [string.char(128)] = string.char(220),   [string.char(129)] = string.char(221),
   [string.char(130)] = string.char(222),   [string.char(131)] = string.char(223),
   [string.char(132)] = string.char(216),   [string.char(133)] = string.char(217),
   [string.char(134)] = string.char(218),   [string.char(135)] = string.char(219),
   [string.char(136)] = string.char(212),   [string.char(137)] = string.char(213),
   [string.char(138)] = string.char(214),   [string.char(139)] = string.char(215),
   [string.char(140)] = string.char(208),   [string.char(141)] = string.char(209),
   [string.char(142)] = string.char(210),   [string.char(143)] = string.char(211),
   [string.char(144)] = string.char(204),   [string.char(145)] = string.char(205),
   [string.char(146)] = string.char(206),   [string.char(147)] = string.char(207),
   [string.char(148)] = string.char(200),   [string.char(149)] = string.char(201),
   [string.char(150)] = string.char(202),   [string.char(151)] = string.char(203),
   [string.char(152)] = string.char(196),   [string.char(153)] = string.char(197),
   [string.char(154)] = string.char(198),   [string.char(155)] = string.char(199),
   [string.char(156)] = string.char(192),   [string.char(157)] = string.char(193),
   [string.char(158)] = string.char(194),   [string.char(159)] = string.char(195),
   [string.char(160)] = string.char(252),   [string.char(161)] = string.char(253),
   [string.char(162)] = string.char(254),   [string.char(163)] = string.char(255),
   [string.char(164)] = string.char(248),   [string.char(165)] = string.char(249),
   [string.char(166)] = string.char(250),   [string.char(167)] = string.char(251),
   [string.char(168)] = string.char(244),   [string.char(169)] = string.char(245),
   [string.char(170)] = string.char(246),   [string.char(171)] = string.char(247),
   [string.char(172)] = string.char(240),   [string.char(173)] = string.char(241),
   [string.char(174)] = string.char(242),   [string.char(175)] = string.char(243),
   [string.char(176)] = string.char(236),   [string.char(177)] = string.char(237),
   [string.char(178)] = string.char(238),   [string.char(179)] = string.char(239),
   [string.char(180)] = string.char(232),   [string.char(181)] = string.char(233),
   [string.char(182)] = string.char(234),   [string.char(183)] = string.char(235),
   [string.char(184)] = string.char(228),   [string.char(185)] = string.char(229),
   [string.char(186)] = string.char(230),   [string.char(187)] = string.char(231),
   [string.char(188)] = string.char(224),   [string.char(189)] = string.char(225),
   [string.char(190)] = string.char(226),   [string.char(191)] = string.char(227),
   [string.char(192)] = string.char(156),   [string.char(193)] = string.char(157),
   [string.char(194)] = string.char(158),   [string.char(195)] = string.char(159),
   [string.char(196)] = string.char(152),   [string.char(197)] = string.char(153),
   [string.char(198)] = string.char(154),   [string.char(199)] = string.char(155),
   [string.char(200)] = string.char(148),   [string.char(201)] = string.char(149),
   [string.char(202)] = string.char(150),   [string.char(203)] = string.char(151),
   [string.char(204)] = string.char(144),   [string.char(205)] = string.char(145),
   [string.char(206)] = string.char(146),   [string.char(207)] = string.char(147),
   [string.char(208)] = string.char(140),   [string.char(209)] = string.char(141),
   [string.char(210)] = string.char(142),   [string.char(211)] = string.char(143),
   [string.char(212)] = string.char(136),   [string.char(213)] = string.char(137),
   [string.char(214)] = string.char(138),   [string.char(215)] = string.char(139),
   [string.char(216)] = string.char(132),   [string.char(217)] = string.char(133),
   [string.char(218)] = string.char(134),   [string.char(219)] = string.char(135),
   [string.char(220)] = string.char(128),   [string.char(221)] = string.char(129),
   [string.char(222)] = string.char(130),   [string.char(223)] = string.char(131),
   [string.char(224)] = string.char(188),   [string.char(225)] = string.char(189),
   [string.char(226)] = string.char(190),   [string.char(227)] = string.char(191),
   [string.char(228)] = string.char(184),   [string.char(229)] = string.char(185),
   [string.char(230)] = string.char(186),   [string.char(231)] = string.char(187),
   [string.char(232)] = string.char(180),   [string.char(233)] = string.char(181),
   [string.char(234)] = string.char(182),   [string.char(235)] = string.char(183),
   [string.char(236)] = string.char(176),   [string.char(237)] = string.char(177),
   [string.char(238)] = string.char(178),   [string.char(239)] = string.char(179),
   [string.char(240)] = string.char(172),   [string.char(241)] = string.char(173),
   [string.char(242)] = string.char(174),   [string.char(243)] = string.char(175),
   [string.char(244)] = string.char(168),   [string.char(245)] = string.char(169),
   [string.char(246)] = string.char(170),   [string.char(247)] = string.char(171),
   [string.char(248)] = string.char(164),   [string.char(249)] = string.char(165),
   [string.char(250)] = string.char(166),   [string.char(251)] = string.char(167),
   [string.char(252)] = string.char(160),   [string.char(253)] = string.char(161),
   [string.char(254)] = string.char(162),   [string.char(255)] = string.char(163),
}

local xor_with_0x36 = {
   [string.char(  0)] = string.char( 54),   [string.char(  1)] = string.char( 55),
   [string.char(  2)] = string.char( 52),   [string.char(  3)] = string.char( 53),
   [string.char(  4)] = string.char( 50),   [string.char(  5)] = string.char( 51),
   [string.char(  6)] = string.char( 48),   [string.char(  7)] = string.char( 49),
   [string.char(  8)] = string.char( 62),   [string.char(  9)] = string.char( 63),
   [string.char( 10)] = string.char( 60),   [string.char( 11)] = string.char( 61),
   [string.char( 12)] = string.char( 58),   [string.char( 13)] = string.char( 59),
   [string.char( 14)] = string.char( 56),   [string.char( 15)] = string.char( 57),
   [string.char( 16)] = string.char( 38),   [string.char( 17)] = string.char( 39),
   [string.char( 18)] = string.char( 36),   [string.char( 19)] = string.char( 37),
   [string.char( 20)] = string.char( 34),   [string.char( 21)] = string.char( 35),
   [string.char( 22)] = string.char( 32),   [string.char( 23)] = string.char( 33),
   [string.char( 24)] = string.char( 46),   [string.char( 25)] = string.char( 47),
   [string.char( 26)] = string.char( 44),   [string.char( 27)] = string.char( 45),
   [string.char( 28)] = string.char( 42),   [string.char( 29)] = string.char( 43),
   [string.char( 30)] = string.char( 40),   [string.char( 31)] = string.char( 41),
   [string.char( 32)] = string.char( 22),   [string.char( 33)] = string.char( 23),
   [string.char( 34)] = string.char( 20),   [string.char( 35)] = string.char( 21),
   [string.char( 36)] = string.char( 18),   [string.char( 37)] = string.char( 19),
   [string.char( 38)] = string.char( 16),   [string.char( 39)] = string.char( 17),
   [string.char( 40)] = string.char( 30),   [string.char( 41)] = string.char( 31),
   [string.char( 42)] = string.char( 28),   [string.char( 43)] = string.char( 29),
   [string.char( 44)] = string.char( 26),   [string.char( 45)] = string.char( 27),
   [string.char( 46)] = string.char( 24),   [string.char( 47)] = string.char( 25),
   [string.char( 48)] = string.char(  6),   [string.char( 49)] = string.char(  7),
   [string.char( 50)] = string.char(  4),   [string.char( 51)] = string.char(  5),
   [string.char( 52)] = string.char(  2),   [string.char( 53)] = string.char(  3),
   [string.char( 54)] = string.char(  0),   [string.char( 55)] = string.char(  1),
   [string.char( 56)] = string.char( 14),   [string.char( 57)] = string.char( 15),
   [string.char( 58)] = string.char( 12),   [string.char( 59)] = string.char( 13),
   [string.char( 60)] = string.char( 10),   [string.char( 61)] = string.char( 11),
   [string.char( 62)] = string.char(  8),   [string.char( 63)] = string.char(  9),
   [string.char( 64)] = string.char(118),   [string.char( 65)] = string.char(119),
   [string.char( 66)] = string.char(116),   [string.char( 67)] = string.char(117),
   [string.char( 68)] = string.char(114),   [string.char( 69)] = string.char(115),
   [string.char( 70)] = string.char(112),   [string.char( 71)] = string.char(113),
   [string.char( 72)] = string.char(126),   [string.char( 73)] = string.char(127),
   [string.char( 74)] = string.char(124),   [string.char( 75)] = string.char(125),
   [string.char( 76)] = string.char(122),   [string.char( 77)] = string.char(123),
   [string.char( 78)] = string.char(120),   [string.char( 79)] = string.char(121),
   [string.char( 80)] = string.char(102),   [string.char( 81)] = string.char(103),
   [string.char( 82)] = string.char(100),   [string.char( 83)] = string.char(101),
   [string.char( 84)] = string.char( 98),   [string.char( 85)] = string.char( 99),
   [string.char( 86)] = string.char( 96),   [string.char( 87)] = string.char( 97),
   [string.char( 88)] = string.char(110),   [string.char( 89)] = string.char(111),
   [string.char( 90)] = string.char(108),   [string.char( 91)] = string.char(109),
   [string.char( 92)] = string.char(106),   [string.char( 93)] = string.char(107),
   [string.char( 94)] = string.char(104),   [string.char( 95)] = string.char(105),
   [string.char( 96)] = string.char( 86),   [string.char( 97)] = string.char( 87),
   [string.char( 98)] = string.char( 84),   [string.char( 99)] = string.char( 85),
   [string.char(100)] = string.char( 82),   [string.char(101)] = string.char( 83),
   [string.char(102)] = string.char( 80),   [string.char(103)] = string.char( 81),
   [string.char(104)] = string.char( 94),   [string.char(105)] = string.char( 95),
   [string.char(106)] = string.char( 92),   [string.char(107)] = string.char( 93),
   [string.char(108)] = string.char( 90),   [string.char(109)] = string.char( 91),
   [string.char(110)] = string.char( 88),   [string.char(111)] = string.char( 89),
   [string.char(112)] = string.char( 70),   [string.char(113)] = string.char( 71),
   [string.char(114)] = string.char( 68),   [string.char(115)] = string.char( 69),
   [string.char(116)] = string.char( 66),   [string.char(117)] = string.char( 67),
   [string.char(118)] = string.char( 64),   [string.char(119)] = string.char( 65),
   [string.char(120)] = string.char( 78),   [string.char(121)] = string.char( 79),
   [string.char(122)] = string.char( 76),   [string.char(123)] = string.char( 77),
   [string.char(124)] = string.char( 74),   [string.char(125)] = string.char( 75),
   [string.char(126)] = string.char( 72),   [string.char(127)] = string.char( 73),
   [string.char(128)] = string.char(182),   [string.char(129)] = string.char(183),
   [string.char(130)] = string.char(180),   [string.char(131)] = string.char(181),
   [string.char(132)] = string.char(178),   [string.char(133)] = string.char(179),
   [string.char(134)] = string.char(176),   [string.char(135)] = string.char(177),
   [string.char(136)] = string.char(190),   [string.char(137)] = string.char(191),
   [string.char(138)] = string.char(188),   [string.char(139)] = string.char(189),
   [string.char(140)] = string.char(186),   [string.char(141)] = string.char(187),
   [string.char(142)] = string.char(184),   [string.char(143)] = string.char(185),
   [string.char(144)] = string.char(166),   [string.char(145)] = string.char(167),
   [string.char(146)] = string.char(164),   [string.char(147)] = string.char(165),
   [string.char(148)] = string.char(162),   [string.char(149)] = string.char(163),
   [string.char(150)] = string.char(160),   [string.char(151)] = string.char(161),
   [string.char(152)] = string.char(174),   [string.char(153)] = string.char(175),
   [string.char(154)] = string.char(172),   [string.char(155)] = string.char(173),
   [string.char(156)] = string.char(170),   [string.char(157)] = string.char(171),
   [string.char(158)] = string.char(168),   [string.char(159)] = string.char(169),
   [string.char(160)] = string.char(150),   [string.char(161)] = string.char(151),
   [string.char(162)] = string.char(148),   [string.char(163)] = string.char(149),
   [string.char(164)] = string.char(146),   [string.char(165)] = string.char(147),
   [string.char(166)] = string.char(144),   [string.char(167)] = string.char(145),
   [string.char(168)] = string.char(158),   [string.char(169)] = string.char(159),
   [string.char(170)] = string.char(156),   [string.char(171)] = string.char(157),
   [string.char(172)] = string.char(154),   [string.char(173)] = string.char(155),
   [string.char(174)] = string.char(152),   [string.char(175)] = string.char(153),
   [string.char(176)] = string.char(134),   [string.char(177)] = string.char(135),
   [string.char(178)] = string.char(132),   [string.char(179)] = string.char(133),
   [string.char(180)] = string.char(130),   [string.char(181)] = string.char(131),
   [string.char(182)] = string.char(128),   [string.char(183)] = string.char(129),
   [string.char(184)] = string.char(142),   [string.char(185)] = string.char(143),
   [string.char(186)] = string.char(140),   [string.char(187)] = string.char(141),
   [string.char(188)] = string.char(138),   [string.char(189)] = string.char(139),
   [string.char(190)] = string.char(136),   [string.char(191)] = string.char(137),
   [string.char(192)] = string.char(246),   [string.char(193)] = string.char(247),
   [string.char(194)] = string.char(244),   [string.char(195)] = string.char(245),
   [string.char(196)] = string.char(242),   [string.char(197)] = string.char(243),
   [string.char(198)] = string.char(240),   [string.char(199)] = string.char(241),
   [string.char(200)] = string.char(254),   [string.char(201)] = string.char(255),
   [string.char(202)] = string.char(252),   [string.char(203)] = string.char(253),
   [string.char(204)] = string.char(250),   [string.char(205)] = string.char(251),
   [string.char(206)] = string.char(248),   [string.char(207)] = string.char(249),
   [string.char(208)] = string.char(230),   [string.char(209)] = string.char(231),
   [string.char(210)] = string.char(228),   [string.char(211)] = string.char(229),
   [string.char(212)] = string.char(226),   [string.char(213)] = string.char(227),
   [string.char(214)] = string.char(224),   [string.char(215)] = string.char(225),
   [string.char(216)] = string.char(238),   [string.char(217)] = string.char(239),
   [string.char(218)] = string.char(236),   [string.char(219)] = string.char(237),
   [string.char(220)] = string.char(234),   [string.char(221)] = string.char(235),
   [string.char(222)] = string.char(232),   [string.char(223)] = string.char(233),
   [string.char(224)] = string.char(214),   [string.char(225)] = string.char(215),
   [string.char(226)] = string.char(212),   [string.char(227)] = string.char(213),
   [string.char(228)] = string.char(210),   [string.char(229)] = string.char(211),
   [string.char(230)] = string.char(208),   [string.char(231)] = string.char(209),
   [string.char(232)] = string.char(222),   [string.char(233)] = string.char(223),
   [string.char(234)] = string.char(220),   [string.char(235)] = string.char(221),
   [string.char(236)] = string.char(218),   [string.char(237)] = string.char(219),
   [string.char(238)] = string.char(216),   [string.char(239)] = string.char(217),
   [string.char(240)] = string.char(198),   [string.char(241)] = string.char(199),
   [string.char(242)] = string.char(196),   [string.char(243)] = string.char(197),
   [string.char(244)] = string.char(194),   [string.char(245)] = string.char(195),
   [string.char(246)] = string.char(192),   [string.char(247)] = string.char(193),
   [string.char(248)] = string.char(206),   [string.char(249)] = string.char(207),
   [string.char(250)] = string.char(204),   [string.char(251)] = string.char(205),
   [string.char(252)] = string.char(202),   [string.char(253)] = string.char(203),
   [string.char(254)] = string.char(200),   [string.char(255)] = string.char(201),
}


local blocksize = 64 -- 512 bits

function hmac_sha1(key, text)
   assert(type(key)  == 'string', "key passed to hmac_sha1 should be a string")
   assert(type(text) == 'string', "text passed to hmac_sha1 should be a string")

   if #key > blocksize then
      key = sha1_binary(key)
   end

   local key_xord_with_0x36 = key:gsub('.', xor_with_0x36) .. string.rep(string.char(0x36), blocksize - #key)
   local key_xord_with_0x5c = key:gsub('.', xor_with_0x5c) .. string.rep(string.char(0x5c), blocksize - #key)

   return sha1(key_xord_with_0x5c .. sha1_binary(key_xord_with_0x36 .. text))
end

function hmac_sha1_binary(key, text)
   return hex_to_binary(hmac_sha1(key, text))
end



--[[------------ VALIDATION TESTS -- uncomment to execute  ------------------------------------

print(1) assert(sha1 "http://regex.info/blog/"                                  == "7f103bf600de51dfe91062300c14738b32725db5", 1)
print(2) assert(sha1(string.rep("a", 10000))                                    == "a080cbda64850abb7b7f67ee875ba068074ff6fe", 2)
print(3) assert(sha1 "abc"                                                      == "a9993e364706816aba3e25717850c26c9cd0d89d", 3)
print(4) assert(sha1 "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" == "84983e441c3bd26ebaae4aa1f95129e5e54670f1", 4)
print(5) assert(sha1 "The quick brown fox jumps over the lazy dog"              == "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12", 5)
print(6) assert(sha1 "The quick brown fox jumps over the lazy cog"              == "de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3", 6)

-- a few randomly generated tests

print(7) assert("efb750130b6cc9adf4be219435e575442ec68b7c" == sha1(string.char(136,43,218,202,158,86,64,140,154,173,20,184,170,125,37,54,208,68,171,24,164,89,142,111,148,235,187,181,122):rep(76)), 7)
print(8) assert("432dff9d4023e13194170287103d0377ed182d96" == sha1(string.char(20,174):rep(407)), 8)
print(9) assert("ccba5c47946530726bb86034dbee1dbf0c203e99" == sha1(string.char(20,54,149,252,176,4,96,100,223):rep(753)), 9)
print(10) assert("4d6fea4f8576cd6648ae2d2ee4dc5df0a8309115" == sha1(string.char(118,171,221,33,54,209,223,152,35,67,88,50):rep(985)), 10)
print(11) assert("f560412aabf813d01f15fdc6650489584aabd266" == sha1(string.char(23,85,29,13,146,55,164,14,206,196,109,183,53,92,97,123,242,220,112,15,43,113,22,246,114,29,209,219,190):rep(177)), 11)
print(12) assert("b56795e12f3857b3ba1cbbcedb4d92dd9c419328" == sha1(string.char(21,216):rep(131)), 12)
print(13) assert("54f292ecb7561e8ce27984685b427234c9465095" == sha1(string.char(15,205,12,181,4,114,128,118,219):rep(818)), 13)
print(14) assert("fe265c1b5a848e5f3ada94a7e1bb98a8ce319835" == sha1(string.char(136,165,10,46,167,184,86,255,58,206,237,21,255,15,198,211,145,112,228,146,26,69,92,158,182,165,244,39,152):rep(605)), 14)
print(15) assert("96f186998825075d528646059edadb55fdd96659" == sha1(string.char(100,226,28,248,132,70,221,54,92,181,82,128,191,12,250,244):rep(94)), 15)
print(16) assert("e29c68e4d6ffd3998b2180015be9caee59dd8c8a" == sha1(string.char(247,14,15,163,0,53,50,113,84,121):rep(967)), 16)
print(17) assert("6d2332a82b3600cbc5d2417f944c38be9f1081ae" == sha1(string.char(93,98,119,201,41,27,89,144,25,141,117,26,111,132):rep(632)), 17)
print(18) assert("d84a91da8fb3aa7cd59b99f347113939406ef8eb" == sha1(string.char(28,252,0,4,150,164,91):rep(568)), 18)
print(19) assert("8edf1b92ad5a90ed762def9a873a799b4bda97f9" == sha1(string.char(166,67,113,111,161,253,169,195,158,97,96,150,49,219,103,16,186,184,37,109,228,111):rep(135)), 19)
print(20) assert("d5b2c7019f9ff2f75c38dc040c827ab9d1a42157" == sha1(string.char(38,252,110,224,168,60,2,133,8,153,200,0,199,104,191,62,28,168,73,48,199,217,83):rep(168)), 20)
print(21) assert("5aeb57041bfada3b72e3514f493d7b9f4ca96620" == sha1(string.char(57):rep(738)), 21)
print(22) assert("4548238c8c2124c6398427ed447ae8abbb8ead27" == sha1(string.char(221,131,171):rep(230)), 22)
print(23) assert("ed0960b87a790a24eb2890d8ea8b18043f1a87d5" == sha1(string.char(151,113,144,19,249,148,75,51,164,233,102,232,3,58,81,99,101,255,93,231,147,150,212,216,109,62):rep(110)), 23)
print(24) assert("d7ac6233298783af55901907bb99c13b2afbca99" == sha1(string.char(44,239,189,203,196,79,82,143,99,21,125,75,167,26,108,161,9,193,72):rep(919)), 24)
print(25) assert("43600b41a3c5267e625bbdfde95027429c330c60" == sha1(string.char(122,70,129,24,192,213,205,224,62,79,81,129,22,171):rep(578)), 25)
print(26) assert("5816df09a78e4594c1b02b170aa57333162def38" == sha1(string.char(76,103,48,150,115,161,86,42,247,82,197,213,155,108,215,18,119):rep(480)), 26)
print(27) assert("ef7903b1e811a086a9a5a5142242132e1367ae1d" == sha1(string.char(143,70):rep(65)), 27)
print(28) assert("6e16b2dac71e338a4bd26f182fdd5a2de3c30e6c" == sha1(string.char(130,114,144,219,245,72,205,44,149,68,150,169,243):rep(197)), 28)
print(29) assert("6cc772f978ca5ef257273f046030f84b170f90c9" == sha1(string.char(26,49,141,64,30,61,12):rep(362)), 29)
print(30) assert("54231fc19a04a64fc1aa3dce0882678b04062012" == sha1(string.char(76,252,160,253,253,167,27,179,237,15,219,46,141,255,23,53,184,190,233,125,211,11):rep(741)), 30)
print(31) assert("5511a993b808e572999e508c3ce27d5f12bb4730" == sha1(string.char(197,139,184,188,200,31,171,236,252,147,123,75,7,138,111,167,68,114,73,80,51,233,241,233,91):rep(528)), 31)
print(32) assert("64c4577d4763c95f47ac5d21a292836a34b8b124" == sha1(string.char(177,114,100,216,18,57,2,110,108,60,81,80,253,144,179,47,228,42,105,72,86,18,30,167):rep(901)), 32)
print(33) assert("bb0467117e3b630c2b3d9cdf063a7e6766a3eae1" == sha1(string.char(249,99,174,228,15,211,121,152,203,115,197,198,66,17,196,6,159,170,116):rep(800)), 33)
print(34) assert("1f9c66fca93bc33a071eef7d25cf0b492861e679" == sha1(string.char(205,64,237,65,171,0,176,17,104,6,101,29,128,200,214,24,32,91,115,71,26,11,226,69,141,83,249,129):rep(288)), 34)
print(35) assert("55d228d9bfd522105fe1e1f1b5b09a1e8ee9f782" == sha1(string.char(96,37,252,185,137,194,215,191,190,235,73,224,125,18,146,74,32,82,58,95,49,102,85,57,241,54,55):rep(352)), 35)
print(36) assert("58c3167e666bf3b4062315a84a72172688ad08b1" == sha1(string.char(65,91,96,147,212,18,32,144,138,187,70,26,105,42,71,13,229,137,185,10,86,124,171,204,104,42,2,172):rep(413)), 36)
print(37) assert("f97936ca990d1c11a9967fd12fc717dcd10b8e9e" == sha1(string.char(253,159,59,76,230,153,22,198,15,9,223,3,31):rep(518)), 37)
print(38) assert("5d15229ad10d2276d45c54b83fc0879579c2828e" == sha1(string.char(149,20,176,144,39,216,82,80,56,38,152,49,167,120,222,20,26,51,157,131,160,52,6):rep(895)), 38)
print(39) assert("3757d3e98d46205a6b129e09b0beefaa0e453e64" == sha1(string.char(120,131,113,78,7,19,59,120,210,220,73,118,36,240,64,46,149,3,120,223,80,232,255,212,250,76,109,108,133):rep(724)), 39)
print(40) assert("5e62539caa6c16752739f4f9fd33ca9032fff7e1" == sha1(string.char(216,240,166,165,2,203,2,189,137,219,231,229):rep(61)), 40)
print(41) assert("3ff1c031417e7e9a34ce21be6d26033f66cb72c9" == sha1(string.char(4,178,215,183,17,198,184,253,137,108,178,74,244,126,32):rep(942)), 41)
print(42) assert("8c20831fc3c652e5ce53b9612878e0478ab11ee6" == sha1(string.char(115,157,59,188,221,67,52,151,147,233,84,30,243,250,109,103,101,0,219,13,176,38,21):rep(767)), 42)
print(43) assert("09c7c977cb39893c096449770e1ed75eebb9e5a1" == sha1(string.char(184,131,17,61,201,164,19,25,36,141,173,74,134,132,104,23,104,136,121,232,12,203,115,111,54,114,251,223,61,126):rep(458)), 43)
print(44) assert("9534d690768bc85d2919a059b05561ec94547fc2" == sha1(string.char(49,93,136,112,92,42,117,28,31):rep(187)), 44)
print(45) assert("7dfca0671de92a62de78f63c0921ff087f2ba61d" == sha1(string.char(194,78,252,112,175,6,26,103,4,47,195,99,78,130,40,58,84,175,240,180,255,108,3,42,51,111,35,49,217,160):rep(72)), 45)
print(46) assert("62bf20c51473c6a0f23752e369cabd6c167c9415" == sha1(string.char(28,126,243,196,155,31,158,50):rep(166)), 46)
print(47) assert("2ece95e43aba523cdbf248d07c05f569ecd0bd12" == sha1(string.char(76,230,117,248,231,228):rep(294)), 47)
print(48) assert("722752e863386b737f29a08f23a0ec21c4313519" == sha1(string.char(61,102,1,118):rep(470)), 48)
print(49) assert("a638db01b5af10a828c6e5b73f4ca881974124a0" == sha1(string.char(130,8,4):rep(768)), 49)
print(50) assert("54c7f932548703cc75877195276bc2aa9643cf9b" == sha1(string.char(193,232,122,142,213,243,224,29,201,6,127,45,4,36,92,200,148,111,106,110,221,235,197,51,66,221,123,155,222,186):rep(290)), 50)
print(51) assert("ecfc29397445d85c0f6dd6dc50a1272accba0920" == sha1(string.char(221,76,21,148,12,109,232,113,230,110,96,82,36):rep(196)), 51)
print(52) assert("31d966d9540f77b49598fa22be4b599c3ba307aa" == sha1(string.char(148,237,212,223,44,133,153):rep(53)), 52)
print(53) assert("9f97c8ace98db9f61d173bf2b705404eb2e9e283" == sha1(string.char(190,233,29,208,161,231,248,214,210):rep(451)), 53)
print(54) assert("63449cfce29849d882d9552947ebf82920392aea" == sha1(string.char(216,12,113,137,33,99,200,140,6,222,170,2,115,50,138,134,211,244,176,250,42,95):rep(721)), 54)
print(55) assert("15dc62f4469fb9eae76cd86a84d576905c4bbfe7" == sha1(string.char(50,194,13,88,156,226,39,135,165,204):rep(417)), 55)
print(56) assert("abbc342bcfdb67944466e7086d284500e25aa103" == sha1(string.char(35,39,227,31,206,163,148,163,172,253,98,21,215,43,226,227,130,151,236,177,176,63,30,47,74):rep(960)), 56)
print(57) assert("77ae3a7d3948eaa2c60d6bc165ba2812122f0cce" == sha1(string.char(166,83,82,49,153,89,58,79,131,163,125,18,43,135,120,17,48,94,136):rep(599)), 57)
print(58) assert("d62e1c4395c8657ab1b1c776b924b29a8e009de1" == sha1(string.char(196,199,71,80,10,233,9,229,91,72,73,205,75,77,122,243,219,152):rep(964)), 58)
print(59) assert("15d98d5279651f4a2566eda6eec573812d050ff7" == sha1(string.char(78,70,7,229,21,78,164,158,114,232,100,102,92,18,133,160,56,177,160,49,168,149,13,39,249,214,54,41):rep(618)), 59)
print(60) assert("c3d9bc6535736f09fbb018427c994e58bbcb98f6" == sha1(string.char(129,208,110,40,135,3):rep(618)), 60)
print(61) assert("7dc6b3f309cbe9fa3b2947c2526870a39bf96dc4" == sha1(string.char(126,184,110,39,55,177,108,179,214,200,175,118,125,212,19,147,137,133,89,209,89,189,233,164,71,81,156,215,152):rep(908)), 61)
print(62) assert("b2d4ca3e787a1e475f6608136e89134ae279be57" == sha1(string.char(182,80,145,53,128,194,228,155,53):rep(475)), 62)
print(63) assert("fbe6b9c3a7442806c5b9491642c69f8e56fdd576" == sha1(string.char(9,208,72,179,222,245,140,143,123,111,236,241,40,36,49,68,61,16,169,124,104,42,136,82,172):rep(189)), 63)
print(64) assert("f87d96380201954801004f6b82af1953427dfdcb" == sha1(string.char(153,133,37,2,24,150,93,242,223,68,202,54,118,141,76,35,100,137,13):rep(307)), 64)
print(65) assert("a953e2d054dd77f75337dd9dfa58ec4d3978cfb4" == sha1(string.char(112,215,41,50,221,94):rep(155)), 65)
print(66) assert("e5c3047f9abfdd60f0c386b9a820f11d7028bc70" == sha1(string.char(247,177,124,213,47,175,139,203,81,21,85):rep(766)), 66)
print(67) assert("ee6fe88911a13abfc0006f8809f51b9de7f5920f" == sha1(string.char(81,84,151,242,186,133,39,245,175,79,66,170,246,216,0,88,100,190,137,2,146,58):rep(10)), 67)
print(68) assert("091db84d93bb68349eecf6bfa9378251ecd85500" == sha1(string.char(180,71,122,187):rep(129)), 68)
print(69) assert("d8041c7d65201cc5a77056a5c7eb94a524494754" == sha1(string.char(188,99,87,126,152,214,159,151,234,223,199,247,213,107,63,59,12,146,175,57,79,200,132,202):rep(81)), 69)
print(70) assert("cca1d77faf56f70c82fcb7bc2c0ac9daf553adff" == sha1(string.char(199,1,184,22,113,25,95,87,169,114,130,205,125,159,170,99):rep(865)), 70)
print(71) assert("c009245d9767d4f56464a7b3d6b8ad62eba5ddeb" == sha1(string.char(39,168,16,191,95,82,184,102,242,224,15,108):rep(175)), 71)
print(72) assert("8ce115679600324b58dc8745e38d9bea0a9fb4d6" == sha1(string.char(164,247,250,142,139,131,158,241,27,36,81,239,26,233,105,64,38,249,151,75,142,17,56,217,125,74,132,213,213):rep(426)), 72)
print(73) assert("75f1e55718fd7a3c27792634e70760c6a390d40f" == sha1(string.char(32,145,170,90,188,97,251,159,244,153,21,126,2,67,36,110,31,251,66):rep(659)), 73)
print(74) assert("615722261d6ec8cef4a4e7698200582958193f26" == sha1(string.char(51,24,1,69,81,157,34,185,26,159,231,119):rep(994)), 74)
print(75) assert("4f61d2c1b60d342c51bc47641e0993d42e89c0f9" == sha1(string.char(175,25,99,122,247,217,204,100,0,35,57,65,150,182,51,79,169,99,9,33,113,113,113):rep(211)), 75)
print(76) assert("7d9842e115fc2af17a90a6d85416dbadb663cef3" == sha1(string.char(136,42,39,219,103,95,119,125,205,72,174,15,210,213,23,75,120,56,104,31,63,255,253,100,61,55):rep(668)), 76)
print(77) assert("3eccab72b375de3ba95a9f0fa715ae13cae82c08" == sha1(string.char(190,254,173,227,195,41,49,122,135,57,100):rep(729)), 77)
print(78) assert("7dd68f741731211e0442ce7251e56950e0d05f96" == sha1(string.char(101,155,117,8,143,40,192,100,162,121,142,191,92):rep(250)), 78)
print(79) assert("5e98cdb7f6d7e4e2466f9be23ec20d9177c5ddff" == sha1(string.char(84,67,182,136,89):rep(551)), 79)
print(80) assert("dba1c76e22e2c391bde336c50319fbff2d66c3bb" == sha1(string.char(99,226,185,1,192):rep(702)), 80)
print(81) assert("4b160b8bfe24147b01a247bfdc7a5296b6354e38" == sha1(string.char(144,141,254,1,166,144,129,232,203,31,192,75,145,12):rep(724)), 81)
print(82) assert("27625ad9833144f6b818ef1cf54245dd4897d8aa" == sha1(string.char(31,187,82,156,224,133,116,251,180,165,246,8):rep(661)), 82)
print(83) assert("0ce5e059d22a7ba5e2af9f0c6551d010b08ba197" == sha1(string.char(228):rep(672)), 83)
print(84) assert("290982513a7f67a876c043d3c7819facb9082ea6" == sha1(string.char(150,44,52,144,68,76,207,114,106,153,99,39,219,81,73,140,71,4,228,220,55,244,210,225,221,32):rep(881)), 84)
print(85) assert("14cf924aafceea393a8eb5dd06616c1fe1ccd735" == sha1(string.char(140,194,247,253,117,121,184,216,249,84,41,12,199):rep(738)), 85)
print(86) assert("91e9cc620573db9a692bb0171c5c11b5946ad5c3" == sha1(string.char(48,77,182,152,26,145,231,116,179,95,21,248,120,55,73,66):rep(971)), 86)
print(87) assert("3eb85ec3db474d01acafcbc5ec6e942b3a04a382" == sha1(string.char(68,211):rep(184)), 87)
print(88) assert("f9bd0e886c74d730cb2457c484d30ce6a47f7afa" == sha1(string.char(168,73,19,144,110,93,7,216,40,111,212,192,33,9,136,28,210,175,140,47,125,243,206,157,151,252,26):rep(511)), 88)
print(89) assert("64461476eb8bba70e322e4b83db2beaee5b495d4" == sha1(string.char(33,141):rep(359)), 89)
print(90) assert("761e44ffa4df3b4e28ca22020dee1e0018107d21" == sha1(string.char(254,172,185,30,245,135,14,5,186,42,47,22):rep(715)), 90)
print(91) assert("41161168b99104087bae0f5287b10a15c805596f" == sha1(string.char(79):rep(625)), 91)
print(92) assert("7088f4d88146e6e7784172c2ad1f59ec39fa7768" == sha1(string.char(20,138,80,102,138,182,54,210,38,214,125,123,157,209,215,37):rep(315)), 92)
print(93) assert("2e498e938cb3126ac1291cee8c483a91479900c1" == sha1(string.char(140,197,97,112,205,97,134,190):rep(552)), 93)
print(94) assert("81a2491b727ef2b46fb84e4da2ced84d43587f4e" == sha1(string.char(109,44,17,199,17,107,170,54,113,153,212,161,174):rep(136)), 94)
print(95) assert("0e4f8a07072968fbc4fe32deccbb95f113b32df7" == sha1(string.char(181,247,203,166,34,61,180,48,46,77,98,251,72,210,217,242,135,133,38,12,177,163,249,31,1,162):rep(282)), 95)
print(96) assert("8d15dddd48575a1a0330976b57e2104629afe559" == sha1(string.char(15,60,105,249,158,45,14,208,202,232,255,181,234,217):rep(769)), 96)
print(97) assert("98a9dd7b57418937cbd42f758baac4754d5a4a4b" == sha1(string.char(115,121,91,76,175,110,149,190,56,178,191,157,101,220,190,251,62,41,190,37):rep(879)), 97)
print(98) assert("578487979de082f69e657d165df5031f1fa84030" == sha1(string.char(189,240,198,207,102,142,241,154):rep(684)), 98)
print(99) assert("3e6667b40afb6bcc052654dd64a653ad4b4f9689" == sha1(string.char(85,82,55,80,43,17,57,20,157,10,148,85,154,58,254,254,221,132,53,105,43,234,251,110,111):rep(712)), 99)



--
-- now tests for the HMAC-SHA1 computation
--

assert("31285f3fa3c6a086d030cf0f06b07e7a96b5cbd0" == hmac_sha1("63xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",   "data"), 100)
assert("2d183212abc09247e21282d366eeb14d0bc41fb4" == hmac_sha1("64xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",  "data"), 101)
assert("ff825333e64e696fc13d82c19071fa46dc94a066" == hmac_sha1("65xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx", "data"),  102)


print(103) assert("ecc8b5d3abb5182d3d570a6f060fef2ee6c11a44" == hmac_sha1(string.char(220,58,17,206,77,234,240,187,69,25,179,182,186,38,57,83,120,107,198,148,234,246,46,96,83,28,231,89,3,169,42,62,125,235,137), string.char(1,225,98,83,100,71,237,241,239,170,244,215,3,254,14,24,216,66,69,30,124,126,96,177,241,20,44,3,92,111,243,169,100,119,198,167,146,242,30,124,7,22,251,52,235,95,211,145,56,204,236,37,107,139,17,184,65,207,245,101,241,12,50,149,19,118,208,133,198,33,80,94,87,133,146,202,27,89,201,218,171,206,21,191,43,77,127,30,187,194,166,39,191,208,42,167,77,202,186,225,4,86,218,237,157,117,175,106,63,166,132,136,153,243,187)), 103)

print(104) assert("bd1577a9417d804ee2969636fa9dde838beb967d" == hmac_sha1(string.char(216,76,38,50,235,99,92,110,245,5,134,195,113,7), string.char(144,3,250,84,145,227,206,87,188,42,169,182,106,31,207,205,33,76,52,158,255,49,129,169,9,145,203,225,90,228,163,33,49,99,29,135,60,112,152,5,200,121,35,77,56,116,68,109,190,136,184,248,144,172,47,107,30,16,105,232,146,137,24,81,245,94,28,76,27,82,105,146,252,219,119,164,21,14,74,192,209,208,156,56,172,124,89,218,51,108,44,174,193,161,228,147,219,129,172,210,248,239,22,11,62,128,1,50,98,233,141,224,102,152,44,68,66,46,210,114,138,113,121,90,7,70,125,191,192,222,225,200,217,48,22,10,132,29,236,71,108,140,102,96,51,142,51,220,4)), 104)

print(105) assert("e8ddf90f0c117ee61b33db4df49d7fc31beca7f7" == hmac_sha1(string.char(189,213,184,86,24,160,198,82,138,223,71,149,249,70,183,47,0,106,27,39,85,102,57,190,237,182,2,10,21,253,252,3,68,73,154,75,79,247,28,132,229,50,2,197,204,213,170,213,255,83,100,213,60,67,202,61,137,125,16,215,254,157,106,5), string.char(78,103,249,15,43,214,87,62,52,57,135,84,44,92,142,209,120,139,76,216,33,223,203,96,218,12,6,126,241,195,47,203,196,22,113,138,228,44,122,37,215,166,184,195,91,97,175,153,115,243,37,225,82,250,54,240,20,237,149,183,5,43,142,113,214,130,100,149,83,232,70,106,152,110,25,74,46,60,159,239,193,173,235,146,173,142,110,71,1,97,54,217,52,228,250,42,223,53,105,24,87,98,117,245,101,189,147,238,48,111,68,52,169,78,151,38,21,249)), 105)

print(106) assert("e33c987c31bb45b842868d49e7636bd840a1ffd3" == hmac_sha1(string.char(154,60,91,199,157,45,32,99,248,5,163,234,114,223,234,48,238,82,43,242,52,176,243,5,135,26,141,49,105,120,220,135,192,96,219,152,126,74,58,110,200,56,108,1,68,175,82,235,149,191,67,72,195,46,35,131,237,188,177,223,145,122,26,234,136,93,34,96,71,214,55,27,13,116,235,109,58,83,175,226,59,13,218,93,5,132,43,235), string.char(182,10,154)), 106)

print(107) assert("f6039d217c16afadfcfae7c5e3d1859801a0fe22" == hmac_sha1(string.char(73,120,173,165,190,159,174,100,255,56,217,98,249,11,166,25,66,95,96,99,70,73,223,132,231,147,220,151,79,102,111,98), string.char(134,93,229,103)), 107)

print(108) assert("f6056b19cf6b070e62a0917a46f4b3aefcf6262d" == hmac_sha1(string.char(49,40,62,214,208,180,147,74,162,196,193,9,118,47,100,9,235,94,3,122,226,163,145,175,233,148,251,88,49,216,208,110,13,97,255,189,120,252,223,241,55,210,77,4), string.char(92,185,37,240,36,97,21,132,188,80,103,36,162,245,63,104,19,106,242,44,96,28,197,26,46,168,73,46,76,105,30,167,101,64,67,119,65,140,177,226,223,108,206,60,59,0,182,125,42,200,101,159,109,6,62,85,67,66,88,137,92,234,61,19,22,177,144,127,129,129,195,230,180,149,128,148,45,18,94,163,196,55,70,184,251,3,200,162,16,210,188,61,186,218,173,227,212,8,125,20,138,82,68,170,24,158,90,98,228,166,246,96,74,24,217,93,91,102,246,221,121,115,157,243,45,158,45,90,186,11,127,179,59,72,37,71,148,123,62,150,114,167,248,197,18,251,92,164,158,83,129,58,127,162,181,92,85,121,13,118,250,221,220,150,231,5,230,28,213,25,251,17,71,68,234,173,10,206,111,72,123,205,49,73,62,209,173,46,94,91,151,122)), 108)

print(109) assert("15ddfa1baa0a3723d8aff00aeefa27b5b02ede95" == hmac_sha1(string.char(91,117,129,150,117,169,221,182,193,130,126,206,129,177,184,171,174,224,91,234,60,197,243,158,59,0,122,240,145,106,192,179,96,84,46,239,170,123,120,51,142,101,45,34), string.char(27,71,38,183,232,93,23,174,151,181,121,91,142,138,180,125,75,243,160,220,225,205,205,72,13,162,104,218,47,162,77,23,16,154,31,156,122,67,227,25,190,102,200,57,116,190,131,8,208,76,174,53,204,88,227,239,71,67,208,32,57,72,165,121,80,139,80,29,90,32,229,208,115,169,238,189,206,82,180,68,157,124,119,1,75,27,122,246,197,178,90,225,138,244,73,12,226,104,191,70,53,210,245,250,239,238,3,229,196,22,28,199,122,158,9,33,109,182,109,87,25,159,159,146,217,77,37,25,173,211,38,173,70,252,18,193,7,167,160,135,63,190,149,14,221,143,173,152,184,143,157,245,137,219,74,239,185,40,14,0,29,87,169,84,67,75,255,252,201,131,75,108,43,129,210,193,108,139,60,228,29,36,150,15,86)), 109)

print(110) assert("d7cba04970a79f5d04c772fbe74bcc0951ff9c67" == hmac_sha1(string.char(159,179,206,236,86,25,53,102,163,243,239,139,134,14,243), string.char(106,160,249,31,114,205,9,66,139,182,209,218,31,151,57,132,182,85,218,220,103,15,210,218,101,244,240,227,12,184,127,137,40,127,232,195,234,182,0,214,125,122,141,207,61,244,143,202,159,229,100,76,165,44,226,137,100,61,1,107,132,142,144,158,223,249,151,78,186,194,189,83,45,66,178,41,23,172,195,137,170,216,208,27,149,112,68,188,0)), 110)

print(111) assert("84625a20dc9ada78ec9de910d37734a299f01c5d" == hmac_sha1(string.char(85,239,250,237,210,126,142,84,119,107,100,163,15,179,132,206,112,85,119,101,44,163,240,10,14,69,169,158,170,190,95,66,129,69,218,229), string.char(210,103,131,185,91,224,115,108,129,11,50,16,90,98,64,124,157,177,50,21,30,201,244,101,136,104,149,102,34,166,25,62,1,79,216,4,221,113,168,169,5,151,172,22,166,28,130,137,251,164,220,189,253,45,149,80,247,84,130,208,69,49,120,8,90,154,100,191,121,81,230,207,23,189,7,164,112,123,158,192,224,255,218,200,70,238,211,161,35,251,150,125,24,10,131,220,57,178,196,38,231,196,206,94,118,32,56,197,136,148,145,247,188,64,56,53,195,140,92,202,22,122,229,105,115,14,42,27,107,223,105)), 111)

print(112) assert("c463318ac1878cd770ec93b2710b706296316894" == hmac_sha1(string.char(162,21,153,195,254,135,203,75,152,144,200,187,226,4,248,93,161,180,219,181,99,130,122,28,179,140,152,9,21,115,34,140,162,45,88,4,33,238,179,125,58,23,108,194,158,48,191,40,3,50,81,247,114,241,0,88,147,93,57,178,73,187,11,195,254,171,106,167,245,190,117,160,1,219,200,249,107,233,58,19,122), string.char(246,179,198,163,52,106,45,38,131,22,142,185,149,121,79,211,0,16,102,52,46,176,83,7,32,42,103,184,234,107,180,128,128,130,21,27,236)), 112)

print(113) assert("e2d37df980593b3e52aadb0d99d61114fb2c1182" == hmac_sha1(string.char(43,84,125,158,182,211,26,238,222,247,6,171,184,54,70,44,169,4,74,34,98,71,118,189,138,53,8,164,117,22,76,171,57,255,122,230,110,122,228,22,252,123,174,218,222,77,80,150,159,43,236,137,234,48,122,138,100,137,112), string.char(249,234,226,86,109,2,157,76,229,42,178,223,196,247,42,194,17,17,117,3,45,6,80,202,22,105,44,242,84,25,21,189,5,216,35,200,220,192,110,81,215,145,109,179,48,44,40,35,216,240,48,240,33,210,79,35,64,189,81,15,135,228,83,14,254,32,211,229,158,79,188,230,84,106,78,126,226,106,203,59,67,134,186,52,21,48,2,142,231,116,241,167,177,175,74,188,232,234,56,41,181,118,232,190,184,76,64,109,167,178,123,118,3,50,46,254,253,83,156,116,220,247,69,27,160,167,210,205,79,60,28,253,17,219,32,44,217,223,77,153,229,55,113,75,234,154,247,13,133,49,220,200,241,111,136,205,14,78,222,55,181,250,160,143,224,37,63,227,155,12,39,173,209,45,171,93,93,70,36,129,111,173,183,112,31,231,22,146,129,171,75,128,45)), 113)

print(114) assert("666f9c282cf544c9c28006713a7461c7efbbdbda" == hmac_sha1(string.char(71,33,203,83,173,199,175,245,206,13,237,187,54,61,85,15,153,125,168,223,231,56,46,250,173,192,247,189,45,166,225,223,109,254,15,79,144,188,71,201,70,25,218,205,13,184,204,219,221,82,133,189,144,179,242,125,211,108,100,1,132,110,231,87,107,91,169,101,241,105,30), string.char(98,122,51,157,136,38,149,9,82,27,218,155,76,61,254,154,43,172,59,105,123,45,97,146,191,58,50,153,139,40,37,116)), 114)

print(115) assert("6904a4ce463002b03923c71cdac6c38f57315b63" == hmac_sha1(string.char(15,40,41,76,105,201,153,223,174,12,100,114,234,95,204,95,84,31,26,28,69,85,48,111,40,173,162,6,198,36,252,179,244,9,112,213,64,87,58,186,4,147,229,211,161,30,226,159,75,38,91,89,224,245,156,110,229,50,210), string.char(213,155,72,86,75,185,138,211,199,57,75,9,1,141,184,89,82,180,105,17,193,63,161,202,25,60,16,201,72,179,74,129,73,172,84,39,140,33,25,122,136,143,116,100,100,234,246,108,135,180,85,12,85,151,176,154,172,147,249,242,180,207,126,126,235,203,55,8,251,29,135,134,166,152,80,76,242,15,69,225,199,221,133,118,194,227,9,185,190,125,120,116,182,15,241,209,113,253,241,58,145,106,136,25,60,47,174,209,251,54,159,98,103,88,245,61,108,91,12,245,119,191,232,36)), 115)

print(116) assert("c57c742c772f92cce60cf3a1ddc263b8df0950f3" == hmac_sha1(string.char(193,178,151,175,44,234,140,18,10,183,92,17,232,95,94,198,229,188,188,131,247,236,215,129,243,171,223,83,42,173,88,157,29,46,221,57,80,179,139,80), string.char(214,95,30,179,51,95,183,198,185,9,76,215,255,122,91,103,133,117,42,33,0,145,60,129,129,237,203,59,141,214,108,79,247,244,187,250,157,177,245,72,191,63,176,211)), 116)

print(117) assert("092336f7f1767874098a54d5f27092fbb92b7c94" == hmac_sha1(string.char(208,10,217,108,72,232,56,67,6,179,160,172,29,67,115,171,118,82,124,118,61,111,21,132,209,92,212,166,181,129,43,55,198,96,169,112,86,212,68,214,81,239,122,216,104,73,114,209,60,182,248,118,74,100,26,1,176,3,166,188), string.char(42,4,235,56,198,119,175,244,93,77)), 117)

print(118) assert("c1d58ad2b611c4d9d59e339da7952bdae4a70737" == hmac_sha1(string.char(100,129,37,207,188,116,232,140,204,90,90,93,124,132,140,81,102,156,67,254,228,192,150,161,10,62,143,218,237,111,151,98,78,168,188,87,170,190,35,228,169,228,143,252,213,85,11,124,92,91,18,27,122,141,98,6,77,106,205,209,2,185,249), string.char(58,190,56,255,176,80,220,228,0,251,108,108,220,197,51,131,164,162,60,181,21,54,122,174,31,13,4,84,198,203,105,11,64,230,1,30,218,208,252,219,44,147,2,108,227,66,49,71,21,95,248,93,193,180,165,240,224,226,13,9,208,186,12,118,243,28,113,49,122,192,212,164,43,41,151,183,187,126,115,85,174,40,125,9,54,193,164,95,21,77,200,226,50,115,187,122,34,141,255,224,239,12,132,191,48,102,205,248,128,164,116,48,39,191,98,53,169,230,249,215,231,152,45,27,226,10,143,15,209,157,208,181,15,210,195,5,29,48,29,125,62,59,191,216,170,179,226,110,40,46,32,130,235,48,234,233,17)), 118)

print(119) assert("3de84c915278a7d5e7d5629ec88193fb5bbadd15" == hmac_sha1(string.char(89,175,111,33,154,12,173,230,28,117), string.char(188,233,41,180,142,157,96,76,105,212,92,202,155,167,179,28,12,156,64,73,32,253,253,166,9,240,7,0,248,43,101,135,226,231,173,221,180,43,160,217,6,38,183,186,214,217,137,83,148,148,40,141,217,98,209,12,167,102,95,166,136,231,232,84,59,112,148,201,166,104,135,124,189,85,160,183,143,122,200,190,144,205,25,254,180,188,108,225,171,131,240,185,86,243,192,173,130,50,150,57,242,180,132,193,11,110,247,121,25,24,110,199,156,121,233,149,79,103,15,173,184,143,45,125,164,242,125,10,183,189,189,135,121,59,148,106,77,9,16,123,176,100,142,246,156,180,202,87,43,102,113,123)), 119)

print(120) assert("e8cc5a50f80e7d52edd7ae4ec037414b70798598" == hmac_sha1(string.char(139,243,17,238,11,156,138,122,212,86,201,213,100,167,65,199,92,182,255,36,221,82,192,213,199,162,69,42,222,95,65,170,146,48,39,185,147,18,140,122,168,141), string.char(141,216,25,29,235,207,123,188,85,53,131,180,125,226,97,244,250,138,64,39,30,250,146,101,219,171,213,158,164,172,137,22,136,86,46,77,95,213,66,198,15,24,164,148,29,166,169,195,196,111,122,147,247,215,148,9,129,40,133,178,69,242,171,235,181,83,241,208,237,17,37,30,188,152,47,214,69,229,114,225,75,172,163,184,38,158,230,177,187,124,33,240,238,148,197,235,237,98,33,237,59,205,147,128,108,254,95,5,6,49,10,224,78,139,164,235,220,78,224,15,213,136,198,217,114,156,130,247,167,64,36,10,183,221,193,220,195,80,125,143,248,228,254,6,221,137,170,211,66)), 120)

print(121) assert("80d9a0bc9600e6a0130681158a1787ef6b9c91d6" == hmac_sha1(string.char(152,28,190,131,179,120,137,63,214,85,213,89,116,246,171,92,0,47,44,102,120,206,185,116,71,106,195), string.char(250,9,181,163,46,88,166,238,164,40,207,236,152,104,201,42,14,255,125,57,173,176,230,171,63,6,254,130,140,201,45,152,164,216,171,27,172,105,19,103,128,33,255,93,64,155,55,210,140,2,94,168,168,164,5,218,249,227,221,133,72,112,97,243,140,149,193,80)), 121)

print(122) assert("cb4182de586a30d606a057c948fe33733145790a" == hmac_sha1(string.char(193,229,65,81,159,93,162,173,74,64,195,41,80,189,104,238,119,67,255,63,209,247,146,247,210,208,86,14,102,153,246,175,242,209,42,4,243,138,217,58,206,147,19,163,152,239,154,78,5,1,175,97,251,24,185,10,67,107,174,145,178,121,36,238,108,85,214,162,78,195,107,135,114,76,180,37,99,103,78,232,29,244,11,60,236,112,18,241,39,164,107,18), string.char(222,85,11,36,12,191,252,103,180,161,84,168,21,125,50,76,4,148,195,230,210,114,35,116,225,176,16,64,44,20,17,224,227,243,175,251,204,177,41,223,76,216,228,221,54,226,150,209,145,175,142,137,140,25,196,99,252,175,125,15,39,76,47,127,188,51,88,227,194,171,249,141,12,249,225,199,241,112,153,26,107,204,191,23,241,46,223,143,9,9,46,64,197,209,23,18,208,139,148,45,146,94,80,86,49,12,122,218,14,210,133,164,39,227,102,60,129,6,43)), 122)

print(123) assert("864e291ec69124c3a43976bae4ba1788f181f027" == hmac_sha1(string.char(231,211,73,154,64,125,224,253,200,234,208,210,83,9), string.char(33,248,155,139,159,173,90,40,200,95,96,12,81,103,8,139,211,189,87,75,8,6,36,103,116,204,137,181,81,233,97,171,47,27,143,164,63,3,223,107,80,232,182,154,7,255,190,171,209,115,219,6,34,109,1,254,214,73,2)), 123)

print(124) assert("bee434914e65818f81bd07e4e0bbb58328be3ca1" == hmac_sha1(string.char(222,123,148,175,157,117,104,212,169,13,252,113,231,104,37,8,147,119,92,27,100,132,250,105,63,13,195,90,251,122,185,97,159,68,36,7,75,163,179,3,6,170,164,152,86,30,49,239,201,245,43,220,78,62,154,206,95,24,149,138,138,15,24,68,58,255,99,88,143,192,12), string.char(97,76,73,171,140,99,57,217,56,73,182,189,58,19,177,104,85,85,45,31,170,132,53,51,155,143,70,169,189,5,41,231,34,132,235,228,114,58,100,105,146,27,67,89,32,34,78,133,155,222,88,26,83,198,128,183,19,243,27,186,192,77,184,54,142,57,24)), 124)

print(125) assert("0268f79ef55c3651a66a64a21f47495c5beeb212" == hmac_sha1(string.char(181,166,229,31,47,25,64,129,95,242,221,96,73,42,243,170,15,33,14,198,78,194,235,139,177,112,191,190,52,224,93,95,107,125,245,17,170,161,53,148,19,180,83,154,45,98,76,170,51,178,114,71,34,242,184,75,1,130,199,40,197,88,203,86,169,109,206,67,86,175,201,135,101,76,130,144,248,80,212,14,119,186), string.char(53,208,22,216,93,88,59,64,135,112,49,253,34,11,210,160,117,40,219,36,226,45,207,163,134,133,199,101)), 125)

print(126) assert("bcb2473c745d7dee1ec17207d1d804d401828035" == hmac_sha1(string.char(143,117,182,35), string.char(110,95,240,139,124,96,238,255,165,146,205,18,155,244,252,176,24,19,253,39,33,248,90,95,34,115,70,63,195,91,124,144,243,91,110,80,173,47,46,231,73,228,207,37,183,28,42,144,66,248,178,255,129,52,55,232,1,33,193,185,184,237,8)), 126)

print(127) assert("402ed75be595f59519e3dd52323817a65e9ff95b" == hmac_sha1(string.char(247,77,247,124,27,156,148,227,12,21,17,94,56,14,118,47,140,239,200,249,216,139,7,172,16,211,237,94,62,201,227,42,250,8,179,21,39,85,186,145,147,106,127,67,111,250,163,89,152,115,166,254,8,246,141,238,43,45,194,131,191,202), string.char(138,227,90,40,221,37,181,54,26,20,24,125,19,101,12,120,111,20,104,10,225,140,64,218,8,33,179,95,215,142,203,127,243,231,166,76,234,159,59,160,132,56,215,143,103,75,155,158,56,126,71,252,229,54,34,240,30,133,110,67,146,213,116,73,14,160,186,169,155,196,84,132,171,200,171,56,92,38,136,90,57,155,145,67,190,198,235,112,242,120,150,191,216,41,21,36,205,42,68,145,226,246,178,70,60,157,254,206,70,84,189,36,197,48,208,249,144,223,6,72,17,253,236,106,205,245,30,1,80,121,165,103,12,202,115,227,192,64,42,223,113,200,195,156,120,202,110,131,130,39,64,217,108,23,133,140,56,144,167,77,45,236,145,161,150,229,85,231,203,159,203,85,125,221,226)), 127)

print(128) assert("20231b6abcdd7e5d5e22f83706652acf1ae5255e" == hmac_sha1(string.char(132,122,252,170,107,28,195,210,121,194,245,252,42,64,42,103,220,18,61,68,19,78,182,234,93,130,175,20,4,199,66,91,247,247,87,107,89,205,68,125,19,254,59,47,228,134,200,145,148,78,52,236,51,255,152,231,47,168,213,124,228,34,48), string.char(61,232,69,199,207,49,72,159,37,230,105,207,63,141,245,127,142,77,168,111,126,92,145,26,202,215,116,19,125,81,203,11,86,36,19,218,90,255,4,10,21,185,151,111,188,125,123,2,137,151,171,178,195,199,106,55,42,42,20,164,35,177,237,41,207,24,102,218,213,223,204,186,212,30,59,121,52,34,84,76,142,179,75,6,84,8,72,210,72,177,45,103,218,70,165,69,36,152,50,228,147,192,61,104,209,76,155,147,169,162,151,178,72,109,241,41,76,0,60,251,107,99,92,37,95,215,172,154,172,93,254,65,176,43,99,242,151,78,48,58,35,49,23,174,115,224,227,106,49,30,9)), 128)

print(129) assert("b5a24d7aadc1e8fb71f914e1fa581085a8114b27" == hmac_sha1(string.char(233,21,254,12,70,129,236,10,187,36,119,197,152,242,131,11,10,243,169,217,128,247,196,111,183,109,146,155,92,91,71,83,0,136,109,1,130,143,0,8,6,22,160,153,190,164,199,56,152,229), string.char(152,112,218,132,38,125,94,106,64,9,137,105)), 129)

print(130) assert("7fd9169b441711bef04ea08ed87b1cd8f245aeb2" == hmac_sha1(string.char(108,226,105,159), string.char(103,218,254,85,50,58,111,74,108,60,174,27,113,65,100,217,97,208,125,38,170,151,72,125,82,114,185,58,4,143,39,223,250,168,66,182,37,216,130,111,103,157,59,0,245,222,8,65,240)), 130)

print(131) assert("98038102f8476b28dd11b535b6c1b93eb8089360" == hmac_sha1(string.char(77,121,52,138,71,149,161,87,106,75,232,247,8,148,175,24,23,60,151,104,176,208,148,227,226,191,73,123,164,36,177,235,101,190,128,202,139,116,201,125,61,41,204,187,48,107,63,231,12,137,11,228,93,136,178,243,90), string.char(90,6,232,110,12,66,45,86,141,121,2,6,177,135,64,208,45,178,129,37,253,246,74,48,71,211,243,121,31,209,138,147,185,141,65,185,245,9,137,134,148,123,181,128,204,74,222,150,239,169,179,36,236,104,147,255,251,204,5,191,198,185,153,195,26,112,179,170,232,101,238,143,143)), 131)

print(132) assert("ba43c9b8e98b4b7176a1bb63fcbed5b004dc4fcd" == hmac_sha1(string.char(133,107,178,183,204,2,203,106,242,180,87,58,134), string.char(211,208,255,34,198,99,119,185,171,52,118,94,65,241,45,24,40,6,2,203,126,216,21,51,245,154,92,198,201,220,190,135,182,137,113,68,250,94,126,233,140,94,118,244,244,98,252,97,217,204,239,218,178,240,65,150,246,217,231,142,157,33,113,135,135,214,137,103,211,213,48,132,171,43,96,51,241,45,42,237,53,247,134,102,163,214,96,147,131,74,180,19,7,12,174,60,37,60,78,85,92,186,121,27,234,128,132,64,47,106,127,218,52,30,59,230,85,240,164,54,168,232,131,110,145,125,255,238,145,237,134,196,197,138,105,74,34,134,29,249,222,119,194,104,230)), 132)

print(133) assert("0c1ad0332f0c6c1f61e6cc86f0a343065635ecb3" == hmac_sha1(string.char(230,111,251,74,216,102,12,134,90,44,121,175,56,221,225,235,180,246,56,12,236,119,119,109,97,59,224,121,27,37,72,219,138,193,50,219,193,152,1,229,224,197,233,76,188,62,120,17,63,158,186,198,87,135,34,60,164,139,3,200,20,188,203,110,212,137,91,70,35,255,146,213,216,71,73,143,55,219,54,142,105,83,175,193,32,226,150,51,59), string.char(185,250,11,8,121,214,91,27,1,50,67,204,219,252,212,198,117,234,57,127,214,12,220,104,44,177,225,238,103,138,144,162,28,69,143,108,192,4,160,63,175,185,123,46,151,221,127,145,55,32,85,245,251,178,125,223,107,192,206,207,232,231,190,44,221,173,1,59,12,178,112,22,253,222,14,40,18,141,128,144,196,6,112,206,183,144,215,156,159,79,132,152,170,22,68,106,137,248,12,242,231,98,96,144,148,20,212,30,242,109,36,112,50,51,57,212,181,191,80,73,215,119,244,209,57,108,147,182,67,204,154,48,216,116)), 133)

print(134) assert("466442888b6989fd380f918d0476a16ae26279cf" == hmac_sha1(string.char(250,60,248,215,154,159,2,121), string.char(236,249,8,10,180,146,36,144,83,196,49,166,17,81,51,72,28)), 134)

print(135) assert("f9febfeda402b930ec1b95c1325788305cb9fde8" == hmac_sha1(string.char(124,195,165,216,158,253,119,86,162,36,185,72,162,141,160,225,183,25,54,123,73,61,40,165,101,154,157,200,113,14,117,144,185,64,236,219,3,87,90,49), string.char(73,1,223,35,5,159,39,85,95,170,227,61,14,227,142,222,255,253,152,123,104,35,229,6,195,106,30,59,5,36,2,173,71,161,217,189,47,193,3,216,34,10,25,30,212,255,141,94,25,72,52,58,50,56,180,99,173,155)), 135)

print(136) assert("53fe70b7e825d017ef0bdecbacdda4e8a76cbc6f" == hmac_sha1(string.char(144,144,130,150,207,183,143,100,188,177,90,5,4,95,116,105,252,118,187,251,35,113,251,86,36,234,176,165,55,165,158,4,182,85,62,255,18,146,128,67,221,183,78,71,158,184,140,14,84,44,36,79,244,158,37,1,122,43,103,228,217,253,72,113,228,121,160,29,87,5,158,64,38,253,179,122,187,157,106,99,161,79,97,176,119,86,101,40,142,241,217,85), string.char(12,89,157,112,207,206,171,254,87,106,42,113,70,72,222,239,88,94,14,41,14,175,206,56,219,244,230,40,33,154,107,249,45,70,55,104,151,193,246,133,99,59,244,179,8,145,225,100,146,142,128,74,40,155,99,93,204,253,249,222,64,99,156,121,142,49,166,62,171,223,135,55,212,183,144,218,56,12,211,99,254,58,249,219,197,189,173,141,60,196,241,157,67,151,251,172,49,105,200,88,224,175,9,79,65,40,5,255,222,14,152,149,228,83,154,207,104,132,106,96,40,229,182,120,100,207,223,81,171,141,1,171)), 136)

print(137) assert("81b1df7265954a8aee4e119800169660ff9e75c8" == hmac_sha1(string.char(232,167,4,53,90,111,79,91,163,125,230,202,52,242,160,135,66,211,246,17,131,109,109,235,91), string.char(111,177,251,180,63,13,33,205,231,130,203,167,177,156,87,70,33,148,229,163,158,224,123,37,18,204,185,89,235,2,30,252,229,202,170,157,175,157,208,254,135,190,34,14,42,211,154,243,31,100,71,53,169,76,36)), 137)

print(138) assert("caf986508402b3feb70c5b44d902f4a9428a44d2" == hmac_sha1(string.char(127,2,162,53,6,172,189,169,176,254,107,46,57,207,23,25,182,72,34,228,164,113,12,179,149,45,169,19,3,204,202,10,126,153,130,41,143,200,198,47,215,15,58,124,225,60,171,98,8,211,72,235,211,187,172,37,119,96,55,243,98,198,225,191,79,207,94,215,255,21,101,128,153,233,88,101,57,195,70,194), string.char(97,24,129,203,10,176,242,39,165,95,51,30,187,106,207,160,18,154,16,130,178,80,206,128,148,56,213,55,46,85,76,100,50,131,41,167,130,12,81,161,158,55,181,12,12,38,89,193,136,220,81,114,191,157,20,221,171,245)), 138)

print(139) assert("83bd91a9e8072010f3b54d215c56ada0cd810bb6" == hmac_sha1(string.char(215,33,57,193,51,126,38,114,7,29,93,101,78,152,222,121,42,0,236,169,48,137,202,48,90,249,235,46,44,126,78,251,15,84,200,235,43,108,8,196,210,57,152,86,254), string.char(153,35,68,230,52,95,243,220,32,101,148,76,80,168,187,172,170,254,10,70,31,117,40,131,61,155,200,189,25,198,120,41,181,53,14,175,64,89,126,94,242,61,52,1,188,255,121,254,74,88,19,10,126,225,89,31,21,104,199,82,149,60,110,194,123,236,13,38,7,213,176,182,202,211,178,185,99,8,173,220,168,166,108,208,71,152,174,5,134,167,220,47,74,177,231,90,114,208,168,47,112,74,58,73,94,224,101,64,128,255,186,179,119,159,117,110,2,188,38,73,230,39,50,73,162,22,117,185,182,168,70,252,11,242,243,165,32,104,220,211)), 139)

print(140) assert("c123d92ee67689922dfb3b68a45584e7e5dc5dc3" == hmac_sha1(string.char(167,32,181,181,249,210), string.char(249,7,96,196,48,157,109,129,192,227,82,84,196,167,224,145,61,177,60,74,217,117,199,147,147,54,198,138,5,51,135,112,29,184,49,16,0,240,172,21,214,114,146,57,2,154,205,60,113,32,113,255,165,5,178,15,159)), 140)

print(141) assert("454d9ba00ac4e0e90a2866ba2abefba40dac9aab" == hmac_sha1(string.char(116,2,170,84,236,37), string.char(219,144,86,39,237,166,110,90,213,70)), 141)

print(142) assert("e919cce3908786205511fee0283e1eb41c0c45a1" == hmac_sha1(string.char(180,76,140,201,56,232,48,183,173,36,111,94,208,153,234,255,52,18,121,118,117,77,92,74,241,103,193,164,169,1,60,46,101,73,61,221,26,253,209,124,99,154,177,218,59,238,159,191,0,65,117,78,15,12,92,35,254,40,11,112,112,91,49,248,198,229,161,247,130,170,76,146,8,220,134,96,155,68,50,168,186,135,188,186,36), string.char(26,47,201,201,197,232,196,239,204,197,162,14,53,254,88,75,43,254,11,20,52,61,136,206,162,29,223,55,125,50,200,239,135,51,154,54,78,191,188,0,137,191,149,162,191,103,0,168,52,178,147,251,253,86,98,17,15,202,231,0,122,10,131,25,15,129,48,190,60,205,185,114,193,122,19,47,52,142,124,107,45,174,221,196,18,32,79,12,129,84,40)), 142)

print(143) assert("fa770f6b76984edb0f7fa514a19d3c7ef9c82c51" == hmac_sha1(string.char(70,55,200,82,238,241,84,180,129,122,103,199,170,177), string.char(88,236,14,60,249,2,197,242,76,152,248,241,158,232,113,242,209,93,232,113,147,210,80,180,44,124,186,150,172,177,138,131,117,151,174,231,93,248,244,200,191,169,159,206,232,246,2,121,106,183,107,79,210,73,145,244,254,248,85,217,156,221,238,120,224,176,31,56,246,26,3,186,189,86,41,17,34,8,208,58,46,130,226,139,209,194,3,34,55,213,154,12,250,229,201,122,89,47,177,229,80,165,183,77,178,139,3,241,165,196,239,93,98,101,99,210,99,5,135,132,151,197,4,154,87,130,145,175,243,238,132,0,146,14,6,205,227,78,150,59,191,223,74,145,57,82,30,223,90,205,248,47,195,220,215,167,112,216,20,130,26,88,170,101,26,14,216,62,169,217,1,135,193,147,218)), 143)

print(144) assert("d3418e6e6d0a96f8ea7c511273423651a63590c8" == hmac_sha1(string.char(61,175,211,89,77,91,143,76,18,30,252,16,181,45,211,37,207,204,174,174,60,208,36,85,23,106,141,215,62,8,158,98,209,49,96,143,129,99,11,159,79,116,98,244,51,237,227,250,73,196,36,216,181,157,159,87,248,108,29,22,181,175,72,92,160,127,46,204,202,175,61,108,172,50,225,48,84,167,116,67,183), string.char(174,62,218,81,85,89,4,35,26)), 144)

print(145) assert("f2fbe13b442bff3c09dcdaeaf375cb2f5214f821" == hmac_sha1(string.char(188,80,129,208,85,53,8,122,92,99,56,251,59,108,97,145,1,97,157,181,156,243,30,204,227,88,205,151), string.char(137,30,19,71,50,239,11,212,91,234,79,248,244,118,108,245,251,78,53,136,249,55,210,231,109,207,153,83,10,63,98,225,79,113,124,64,100,16,195,9,136,28,50,215,93,93,153,25,97,77,4,13,46,34,164,59,33,206,62,125,8,79,219,42,155,39,241,96,18)), 145)

print(146) assert("aeacb03e8284a01b93e51e483df58a9492035668" == hmac_sha1(string.char(62,67,97,44,112,68,107,91,105,4,183,154,9,14,164,180,87,140,195,231,62,49,250,154,193,186,219,18,100,156,176,124,223,164,68,64,105,214,144,200,65), string.char(221,20,36,192,59,234,90,174,232,184,75,15,92,229,59,191,36,51,4,190,226,35,237,189,21,100,135,138,171,202,163,227,176,231,72,185,43,197,134,157,44,86,26,42,230,251,2,124,220,245,242,116,77,35,197,154,237,73,117,131,126,242,167,242,8,72,163,171,60,29,77,152,142,69,25,234,195,2,159,49,178,63,48,56,131,143,165,22,142,116,109,11,57,71,101,99,84,204,56,233,173,65,180,228,211,10,197,204,26,70,198,81,217,83,130,70,79,54,93,96,116,32,21,219,193,70,55,84,161,89,47,206,13,167,46,104,205,218)), 146)

print(147) assert("e163c334e08bd3fa537c1ea309ce99cfbcd97930" == hmac_sha1(string.char(238,187,29,13,100,125,10,129,46,251,49,62,207,74,243,25,25,73,196,100,114,64,141,173,143,144,70,13,162,227,33,255,83,58,254,138,23,146,90,86,17,33,152,227,15,100,200,147,81,114,166,234,47,60,70,190,208,28,16,44,71,150,101,197,182,57,143,79,29,135,45,211,194,62,234,28,244,74,56,104,187,94,146,174,190,198,55,143,134,60,186,144,190,100,102,0,171,151), string.char(177,90,20,162,64,145,130,87,137,70,153,237,51,138,248,29,166,134,168,68,133,121,161,26,228,137,145,116,243,224,201,229,61,107,250,198,214,208,72,169,248,155,247,54,163,167,71,248,69,106,105,139,224,138,85,94,31,143,4,215,83,239,21,198,28,1,120,83,91,92,58,150,110,77,111,166,222,236,170,129,2,121,86,66,42,129,146,232,46,248,136,175,130,118,126,205,184,136,6,35,180,174,194,59,89,243,199,38,97,48,80,98,45,111)), 147)

print(148) assert("6a82b3a54ed409f612a934caf96e6c4799286f19" == hmac_sha1(string.char(11,59,108,100,113,56,239,211,2,138,219,101,50,50,111,31,171,212,228,55,89,196,44,158,77,252,212,134,106,7,250,223,219,46,231,87,9,62,213,104,169,49,1,75,3,10,50,238,5,150,47,14,47,45,171,183,40,245,194,249,228,216,85), string.char(97,131,91,189,9,52,88,203,250,245,46,96,7,95,176,61,57,192,91,231,193,32,41,169,96,101,39,240,29,143,24,56,57,177,70,135,225,90,42,192,134,103,239,175,243,246,76,137,14,237,82,215,7,76,246,219,132,50,175,25,164,4,216,65,102,0,114,216,159,80,58,32,4,100,22,35,71,140,49,16,216,182,91,80,181,129,151,55,130,7,77,84,211,111,45,51,192,123,213,192,11,81,138,60,225,21,37,182,180,223,170,163,110,9,47,214,200,249,164,98,215)), 148)

print(149) assert("79caa9946fcf0ccdd882bc409abe77d3470d28f7" == hmac_sha1(string.char(202,142,21,201,45,72,11,211,67,134,42,192,96,255,210,211,252,6,101,131,25,195,101,76,250,161,148,242,30,129,241,85,68,173,236,140,120,80,71,62,55,4,33,104,52,160,143,118,252,72), string.char(100,188,93,165,75,34,224,223,6,130,52,160,83,157,253,27,200,125,117,249,41,203,19,242,4,188,209,213,211,20,162,252,215,238,221,30,219,252,246,110,117,77,89,204,221,246,69,62,160,186,37,144,43,151,39,133,254,134,24,223)), 149)

print(150) assert("bd1e60a3df42e2687746766d7d67d57e262f3c9b" == hmac_sha1(string.char(57,212,172,224,206,230,13,50,80,54,19,87,147,166,245,67,118,37,101,214,207,60,66,29,197,236,146,140,192,15,36,155,108,121,215,211,210,118,22,20,56,245,42,153,150,32,224,201,171,2,238,41,70,140,73,60,215,243,86,20,169,152,220,104,95,215,187), string.char(245,123,43,109,29,108,197,27,55,167,255,177,226,205,111,126,146,75,93,70,180,90,139,218,243,232,221,247,129,77,115,101,144,42,13,249,223,127,200,213,140,113,23,10,149,107,244,86,41,133,147,26,167,85,189,76,176,12,190,52,90,54,78,29,97,204,161,224,59,243,128,64,133,95,192,19,137,220,96,228,97,161,51,21,157,172,127,76,53,38,83,126,178,26,203,206,165,241,101,130,79,122,75,29,205,240,1,68,222,48,101,7,29,6,82,240,133,112)), 150)

print(151) assert("fe249fa66eb1e6228e1e5166d7862d119ffa0dcf" == hmac_sha1(string.char(152,13,170,129,7,65,32,194,85,196,85,12,170,227,139,215,70,137,246,105,100,111,252,221,54,174,90,169,59,11,198,33,110,94,246,195,174,13,212,47,18,94,17,67,68,56,251,213,92,67,243,114,181,166,24,182,238,146,48,196,11,238,91,213,46,184,187,199,15,221,193,36,73,244,30,222,175,132,165,177,162,54,215,130,171,58,26,144,218,62,172,120,188,20,182,242,47,178,120,175), string.char(129,126,32,58,251,104,186,25,18,204,5,240,65,194,32,205,194,18,151,173,185,249,237,55,145,8,41,18,171,28,59,234,62,163,32,173,197,176,206,224,95,176,218,168,183,82,53,172,205,6,223,190,189,16,3,34,212,201,54,152,89,231,194,95,8,238,133,56,139,157,115,35,74,58,21,162,111,36,105,135,151,30,207,33,198,186,122,221,98,36,196,251,27)), 151)

print(152) assert("88aef9bb450b75bf96e8b5fd7831ed0d16d7fe7a" == hmac_sha1(string.char(162,225,9,204,87,95,132,152,211,133,93,120,105,156,131,55,245,224,33,115,182,10,28,49,80,175,241,67,66,52,21,55,174,108,66,100,77,20), string.char(55,61,250,187,157,98,212,245,5,54,170,60,235,228,197,182,230,24,195,215,202,55,56,153,9,94,164,107,67,93,143,1,235,195,133,201,103,57,130,177,71,73,169,80,21,251,130,247,21,61,228,39,166,173,211,203,149,55,11,224,70,52,248,118,112,219,39,188,147,5,203,101,158,134,53,250,103,73,154,249,71,181,53,171,227,26,79,200,145,178,24,80,102,26,90,101,70,143,233,17,150,181,170)), 152)

print(153) assert("a057dd823478540bbe9a6fcdf2d4dcfcac663545" == hmac_sha1(string.char(83,17,204,150,211,96,88,52,225,90,61,59,28,127,135), string.char(49,226,129,162,111,75,221,186,24,219,219,178,226,132,19,126,192,69,124,114,214,31,7,127,194,134,202,147,45,176,215,141,41,94,69,38,199,231,185,223,10,104,108,50,237,20,76,194,33,43,117,117,176,3,117,117,55,68,112,207,74,72,163)), 153)

print(154) assert("b11757ccfafc8feadc4e9402c820f4903f20032b" == hmac_sha1(string.char(34,11,53,219), string.char(225,194,251,106,223,229,212,105,164,172,25,25,224,199,225,172,197,42,167,1,227,165,17,247,75,250,10,208,99,124,254,158,103,74,89,60,78,141,201,44,253,87,248,239,74,86,75,64,249,189,21,170,249,18,139,21,130,226,66,200,231,35,227,147,95,213,133,35,47,236,52,64,122,115,80,170,27,50,182,151,180,106,120,85,103,255,143,27,233,43,217,152,70,82,8,229,103,42,153,38,130,184,108,160,199,69,38,184)), 154)

print(155) assert("bfd0994350b2e1e0d6a1faed059f67f1dd8b361f" == hmac_sha1(string.char(221,156,128,63,215,109,55,123,41,27,110,127,209,144,178,143,120,12,226,47,56,212,131,228,3,40,186,208,233,135,33,206,92,214,153,77,12,220,72,240,176,53,22,37,130,58,180,4,111,124,135,31,192,71,117,87,11,41,231,101,37,164,112,3,55,141,250,131,191,117,90,159,224,244,9,251,154), string.char(35,88,113,69,231,5,150,40,123,13,197,27,49,72,161,1,212,222,252,74,197,170,137,72,231,245,117,236,29,12,36,59,225,103,44,119,136,34,241,17,142,239,46,152,129,163,107,17,165,112,187,15,122,217,67,13,215,157,212,26,103,226,237,161,213,3,152,88,247,236,130,133,84,200,132,191,166,8,96,247,4,142,14,81,179,64,88,202,156,242,181,95,162,19,97,223,51,76,176,218,22,116,24,238,204,128,241,236,204,2,56,86,77,211,4,52,221,82,94,76,9,21,182,112,199,161,29,39,183,120,13,0,124,136,95,182,241,3,73,167,51,237,152,149,84,147,41,42,241,174,12,30,226,245,139,230,127,34,205,41,166,228,242,105,251,4,150,29,106,42,27,239,89,249,230,246,242,149,4,60,240,93,13,166,102,239,81,216,137,196)), 155)

print(156) assert("15c4527be05987a9b5c33b920be4a4402f7cf941" == hmac_sha1(string.char(132,158,227,135,167,32,19,192,144,48,232,68,79,78,135,122,136,140,97,67,34,91,225,48,126,67,77,115,154,189,13,45,8,234,59,233,245,77,34,76,95,78,3,250,179,224,20,25,6,202,214,115,165,230,85,115,250,236,135,34,32,158,196,45,207,61,71,51,93,27,187,232,175,233,147,68,231,110,12,198,233,165,24,209,206,25,16,252,127,72), string.char(210,162,121,23,181,21,75,54,110,47,15,166,133,206,100,217,57,133,228,32,112,208,186,28,140,8,207,74,185,17,128,29,181,172,20,156,64,192,112,8,207,131,53,10,182,147,224,71,218,94,71,86,215,2,133,46,160,27,51,189,38,130,224,120,185,144,253,117,193,24,154,229,247,132,62,103,65,163,106,172,22,5,2,32,129,38,213,118,110,125,156,14,48,240,170,225,158,89,92,190,254,231,51,220,8,174,188,233,226,106,224,99,218,82,64,219,206,75,166,111,25,7,87,248,145,251,109,106,243,241,89,200,85,184,155,183,249,61,70,87,115,182,81,80,155,24,245,123,184,102,214,255,122,83,61,214,88,235,169,28,147,196,247,97,28,82,193,72,71,96,243,176,35,189,236,44,184,52,151,249,186,189,150,184,142,238,88,113,120,68,234,50,136,104,80,145,179,57,6,186)), 156)

print(157) assert("b9f87f5f23583bdd21b1ea18e7e647513b7b0596" == hmac_sha1(string.char(216,79,247,98,215,219,128,232,135,111,179,168,80,76,36,250,224,157,229,209,238,186,212,188,200,52,208,200,210,79,182,186,22,22,37,34,86,107,89,238,168,90,53,30,151,191,89,163,253,24,204,152,118,1,158,25,168,2,123,91,111,39,101,239,247,37,200,51,215,31,146,211,163,136,208), string.char(153,134,211,81,255,219,50,91,67,48,102,63,244,170,129,66,3,151,110,167,142,150,153,95,89,90,23,87,12,85,42,209,197,36,41,189,199,136,196,159,125,53,253,192,135,234,94,34,87,79,143,213,237,149,212,170,231,181,22,72,81,233,151,243,134,71,160,155,121,32,233,251,187,179,139,48,254,206,172,165,202,105,222,31,223,95,203,87,114,52,218,59,187,41,43,135,200,108,102,201,85,199,8,176,249,44,96,104,160,85,149,177,25,88,55,231,85,120,227,6,180,24)), 157)

print(158) assert("0b586895674ab11d3b395c07ddb01151a6e562f5" == hmac_sha1(string.char(26,110,222,147,168,18,74,206,186,238,154,250,229,207,138,175,126,82,236,148,74,180,27,168,159,89,211,34,39,115,227,239,22,199,252,96,100,16,193,117,111,102,75,70,2,114,214,196,29,26,43,189,183,0,194,217,204), string.char(90,15,17,198,223,30,20,138,203,132,6,170,107,40,167,58,194,212,244,49,174,60,209,164,26,87,174,177,41,166,95,173,40,61,47,136,147,239,125,167,146,180,97,167,33,185,5,110,128,36,61,52,140,20,189,16,216,83,164,46,74,16,251,250,72,50,47,5,86,60,56,77,101,64,11,120,124,194,212,199,136,87,157,160,90,172,101,222,235,23,111,11,36,11,68,20,43,251,65,212,206,150,0,50,146,170,183,93,89,142,161,50,110,237,95,191,22,184,62,194,81)), 158)

print(159) assert("38b25a1d9d927ba5e6b294d2aa69c0ab8ab0a0c5" == hmac_sha1(string.char(93,218,103,160,235,71,107,150,18,170,193,9,63,245,77,150,71,242,137,52,243,12,207,183,222,252,20,215,210,194,241,79), string.char(87,97,35,201,134,196,180)), 159)

print(160) assert("a72ce76565c2876e78f86ce9e137a9881328fddc" == hmac_sha1(string.char(48,215,222,182,164,136,31,53,160,28,61,171,220,159,243,154,169,101,191,193,99,28,140,59,60,215,77,170,51,136,50,145,159,135,237,149,83,154,219,223,29,200,85,193,173,201,66,142,100,21,89,144,111,5,24,229,228,154,160,32,210,71,19,63,244,230,61,185,221,158,151,51), string.char(196,237,178,172,24,232,144,251,253,31,8,63,69,58,202,88,120,219,39,34,223,173,196,164,135,93,188,69,126,58,153,37,72,219,50,152,76,235,244,223,205,60,74,12,109,203,134,239,40,181,207,99,118,149,179,84,14,53,189,201,55,110,67,81,116,140,31,247,163,135,53,254,82,230,55,162,255,230,149,144,217,62,164,59,124,59,78,177,115,47,26,169,228,18,167,232,89,161,56,105,127,111,230,93,230,181,222,212,254,85,32,117,140,80,246,117,21,140,221,198,11,196,112,69,122,125,156)), 160)

print(161) assert("cd324faf8204be01296bea85a22d991533fd353e" == hmac_sha1(string.char(25,136,140,2,222,149,164,20,148,15,90,33,106,111,10,252,67,120,57,49,251,171,99,173,114,16,102,240,206,188,231,174,51,124,38,1,217,142,4,15,78,4,5,128,207,82), string.char(84,0,42,233,157,150,105,1,216,32,170,11,100,98,103,220,137,102,32,185,55,211,207,179,252,190,248,117,253,189,196,71,112,32,4,198,87,5,133,125,238,107,210,227,149,206,12,124,31,59,213,66,105,100,240,237,149,232,174,140,127,9,65,204,162,243,100,120,6,229,71,56,140,128,228,102,121,14,43,166,252,230,172,93,96,25,214,174,151,2,50,64,152,164,132,115,109,176,25,144,171,252,231,72)), 161)

print(162) assert("fb6e40ddbf3df49d4b44ccecf9e9bc74567df49e" == hmac_sha1(string.char(31,41,38,118,207,197,83,231,45,187,105,1,246,6,34,16,214,148,97,64,139,27,73,129,71,129,183,182,228,12,74,242,94,43,121,163,188,242,92,43,154,103,20,208,89,213,63,46,81,60,69,217,238,237,97,18), string.char(126,99,64,121,143,219,76,227,119,32,135,246,48,55,214,38,179,255,33,43,32,140,228,44,218,40,187,117,172,131,225,222,72,61,213,132,167,121,190,167,66,213,199,59,212,61,69,242,46,169,89,191,74,0,228,208,46,112,7,81,88,203,95,180,179,75,116,222,115,239,1,132,178,73,139,252,77,1,151,222,108,84,196,161,79,220,80,44,223,44,131,252,58,28,201,3,77,211,33,208,237,47,251,79,134,223,48,8,0,236,139,11,232,186,188,134,249,29,208,154,137,169,218,228,203,254,106,88,35,252,155,111,119,14,147,161,19,60,145,157,120,236,108,122,218,168,105,59,10,44,99,208,86)), 162)

print(163) assert("373f21bf8fe4e855f882cc976ebed31717f4c791" == hmac_sha1(string.char(198,41,45,129,159,48,37,183,170,144,24,223,108,176,68,60,197,245,254,165,24,152,14,25,243,46,6,25,142,99,64,10,145,229,74,232,162,201,72,215,116,26,179,127,107,45,193,232,96,170,168,153,79,47), string.char(79,250,224,177,254,56,111,120,135,79,55,200,199,71,65,132,222,7,106,170,26,179,235,237,47,172,88,28,244,88,137,177,92,178,147,129,147,85,88,157,30,207,235,246,132,98,232,18,201,57,151,90,174,148,126,22,38,118,133,49,83,156,56,195,10,95,180,250,215,220,251,5,131,243,70,2,162,239,197,153,196,28,181,167,26,14,247,86,244,69,190,100,255,158,217,222,58,116,126,245,240,139,255,213,7,28,222,99,12,127,57,2,212,33,136,220,203,251,87,205,213,160,146,162,73,55,112,203,60,243,139,167,45,91,68,62,204,245,206,221,52,253,5,193,69,19,190,131,64,250,12,127,77,212,53,83,102,212,11,215,253,143,111,201)), 163)

print(164) assert("df709285c8a1917aaa6d570bd1d4225ca916b110" == hmac_sha1(string.char(193,124,34,185,160,71,134,56,178,152,165,219,223,89,174,116,11,237), string.char(47,110,24,9,42,187,179,71,114,43,155,129,158,24,130,32,208,3,46,63,16,1,192,210,72,220,200,89,120,80,82,65,199,119,167,86,57,33,105,118,215,60,18,155,17,154,63,59,189,153,236,78,219,89,4,116,208,122,56,65,253,220,57,147,162,242,193,86,45,145,151,61,30,138,105,139,99,89)), 164)

print(165) assert("66be81c24c87feeecfd805872c6cde41cb1dd732" == hmac_sha1(string.char(128,186,31,231,128,48,206,237,59), string.char(56,228,42,58,98,45,202,132,30,78,80,52,36,128,7,55,209,148,181,52,185,220,137,85,111,128,220,109,55,70,185,242,253,155,165,193,240,63,144,253,240,147,18,161,7,46,40,148,201,0,127,1,33,145,180,247,90,206,178,96,62,137,130,99,248,248,227,135,213,21,230,40,88,162,106,240,218,93,226,108,9,121,173,70,255,106,137,222,135,206,104,153,171,1,52,156,166,27,98,7,74,180,206,11,193,129,77,194,86,224,175,79,77,95,134,62,58,252,180,100,191,53,28,59,121,123,146,107,121,249,168,51,204,170,141,26,84,126,38,77,203,11,58,123,155,167,60,176,151,7,39,75,217,254,32,110,79,123,188,133,158,178,132,198,169,23,5,104,124,44,206,191,239,139,152,110,207,42)), 165)

print(166) assert("2d1dd80c3f0fc323ca46ebd0f73c628caa03f88b" == hmac_sha1(string.char(142,87,50,47,146,180,251,164,35,75,53,50,101,115,90,97,66,12), string.char(174,244,41,143,173,27,117,79,53,73,0,189,83,91,13,71,117,85,96,32,199,168,244,72,218,249,207,107,244,1,113,203,160,156,89,244,132,5,4,220,254,112,77,156,158,105,180,98,40,99,198,236,134,209,13,237,93,220,177,70,97,76,178,106,60,60,92,248)), 166)

print(167) assert("444ef9725523ad1aac3d1c20f4954cdf1550d706" == hmac_sha1(string.char(242,169,63,243,133,158,118,205,250,154,66,127,178,170,214,241,96,22,173,138,6,189,90,45,108,70,236,108,93,58,54,204,85,241,194,55,55,184), string.char(30,52,200,164,245,80,75)), 167)

print(168) assert("2170bcfb79e4ab2164287a30ee26535681e34505" == hmac_sha1(string.char(121,111,11,221,34,216,169,179,73,247,222,122,96,168,61,168,201,230,139,158,110,154,74,83,118,254,237,255,99,212,46,218,83,69,185,10,249,78,46,76,206,206,137,133,118,57,241,114,228,54,51,68,71,224,188,188,0,119,173,94,120,1,25,13,237,4,181,170,222,92,106,28,9,111,128,137,228,2,110,4,137,171,219,70), string.char(108,95,232,156,70,235,149,211,52,84,86,25,251,127,119,231,109,144,54,177,96,118,213,3,8,119,95,192,187,221,115,83,67,39,207,82,215,85,156,198,179,246,177,202,115,103,79,97,222,133,113,201,27,92,185,48,227,223,142,96,143,181,175,238,115,112,29,30,126,59,109,252,136,153,28,112,50,138,155,249,223,114,93,107,122,114,163,226,53,219,44,15,172,233,76,98,175,107,246,181,249,112,230,173,152,211,183,120,227,165,187,10,240,94)), 168)

print(169) assert("2bcd1eb6df83aed8bcdfbb36474651f466b1fb22" == hmac_sha1(string.char(178,135,218,237,192,188,60,157,46,65,76,100,66,248,152,23,200,194,67,107,95,127,67,111,149,64,60,158,199,115,159,64,45,192,212,179,46,13,171,104,139,49,185,254,235,183,65,52,140,30,89), string.char(106,32,155,133,229,130,33,200,31,51,242)), 169)

print(170) assert("505910401632c487cd9482ecd6ad16928f21d6f4" == hmac_sha1(string.char(170,34,244,62,31,230,158,102,235,63,93,33,111,253,232,211,132,160,120,156,107), string.char(43,16,194,149,208,76,252,14,73,11,1,172,79,41,132,217,125,96,221,110,199,248,129,122,45,63,77,145,21,98,40,149,154,9,127,27,168,224,204,167,203,74,218,196,236,230,47,29,122,138,65,239,123,120,29,68,236,137,130,95,114,230,185,146,32,69,201,48,251,233,103,61,132,167,245,42,68,249,145,166,137,204,186)), 170)

print(171) assert("6d5f9ae7e8a51f2e615ae3aa8525a41b0bf77282" == hmac_sha1(string.char(166,8,119,187,177,166,23,183,147,37,177,162,102,16,93,204,247,119,248,179,23,89,48,145,188,37,197,176,238,218,173,6,216,229,224,108,58,78,40,199,9,241,191,154,88,124,237,142,228,7,235,102,142,123,4,124,38,46,170,229,116,243,104,106,26,163,94,2,118,71,173,171,104), string.char(41,12,123,197,199,117,129,177,132,149,175,83,168,79,76,58,236,204,99,121,155,207,228,89,236,154,103,137,183,221,208,93,22,222,28,237,140,21,25,149,188,111,6,85,251,31,73,79,239,246,66,46,215,157,184,5,207,4)), 171)

print(172) assert("8c20120cd131e07d9fa46467602d57c9017ca22d" == hmac_sha1(string.char(12,24,169,75,70,190,156,115,112,233,245,216,85,248,62,24,91,179,204,185,0,129,209,137,116,97,242,183,35,151,91,170,41,4,81,12,120,47,78,145,193,50,237,224,62,203,171,169,6,141,126,75,29,40), string.char(47,165,0,107,170,77,37,219,45,135,102,68,144,218,213,74,35,58,246,179,171,3,148,55,216,32,29,102,83,58,29,11,166,75,243,60,21,9,202,179,236,129,212,62,217,203,6,193,18,176,156,198,86,140,135,222,109,48,195,112,167,218,92,76,71,40,128,221,235,43,81,109,198,51,77,122,183,111,173,195,8,249,40,159,212,136,180,215,171,70,60,108,26,185,11,222,67,47,142,179,158,131,135,153,168,251,199,21,44,7,164,68,212,209,54,75,18,200,117,213,16,175,152,29,146,154,151,236,143,173,86,70,224,138,71,33,33,151,122,205,128,223,166,51,149,125,178,225,234,164,180)), 172)

print(173) assert("1ef2a94a2e620a164e07590f006c5a46b722fe7e" == hmac_sha1(string.char(78,109,133,245,198,165,112,63,135,53,124,251,110,183,41,34,153,68,22,253,66,201,9,41,15,99,105,14,252,172,212,39,100,14,128,16,64,47,104,37,33,27,203,120,163,182,52,37,27,224,212,40,134,81,70,29,155,101,246,141,238,41,253,124,222,216,49,49,85,46,51,51,122,39,221,156,104,7,14,52,71,93,31,219), string.char(191,94,78,159,209,12,118,97,214,190,238,108,175,252,192,244,8,104,145,30,236,242,45,49,215,185,251,73,46,101,156,221,136,245,45,240,138,174,187,151,0,122,113,154,195,94,245,186,218,211,203,189,37,251,21,33,225,66,168,152,102,200,245,101,102,217,193,215,194,214,48,131,153,140,75,100,237,240,32,89,113,17,125,177,189,188,212,101,211,212,102,57,251,213,216,14,86,204,198,147,122,97,203,127,100,107,126,107,116,34,220,122,154,130,135,199,9,243,9,194,214)), 173)

print(174) assert("ad924bedf84061c998029fb2f168877f0b3939bb" == hmac_sha1(string.char(174,37,249,22,190,230,152,74,215,14,1,180,201,164,238,160,59,157,213,35,36,43,116,160,158,144,131,30,213,232,29,183,205,87,35,85,252,120,126,5,54,113,176), string.char(25,233,197,224,170,150,207,83,58,255,63,236,20,13,179,143,48,248,212,16,220,143,14,123,207,59,28,124,19)), 174)

print(175) assert("75a6cfbedde0f1b196209a282b25f5f8b9fef3d1" == hmac_sha1(string.char(131,192,35,70,146,214,224,190,220,240,195,81,129,33,207,253,47,230,111,169,187,136,52,244,217,178,143,140,225,154,105,95,112,201,136,90,221,255,44,31,48,178,90,178,218,122,228,165,90,189,107,45,217,249,89,213,136,139,91,187,202,204,26,250,112), string.char(41,13,202,37,1,104,116,166,245,50,221,59,115,68,187,115,80,93,202,147,10,96,209,213,76,103,143,237,217,21,124,152,82,54,147,207,164,43,89,83,118,67,43,179,79,64,127,252,9,26,125,101,80,192,111,224,104,243,45,67,54,251,238,146,154,212,193,181,138,168,231,171,203,62,93,97,46,55,109,253,214,79,60,62,126,183,235,63,121,46,99,3,223,174,223,2,208,78,7,15,161,56,160,59,205,122,138,77,47,250,107,136,65,199,98,86,131,217,96,226,11,166,185,131,231,76,28,83,140,7,146,87,158,20,102,224,86,5,232,96,34,129,172,236,146,1,139,63,252,1,48,196,242,41,145,97,254,174,88,107,169,70,158,165,246,160,4,16,212,109,236)), 175)

print(176) assert("c6f51cc53b0a341dafa4607ee834cffaa8c7c2a2" == hmac_sha1(string.char(85,193,15,80,156,124,171,95,40,75,229,181,147,237,153,83,232,67,210,131,57,69,7,226,226,195,164,46,185,83,120,177,67,77,119,201,9,123,117,111,148,176,12,145,14,80,225,95,71,136,179,94,136,6,78,230,149,135,176,131,19,125,185,48,200,244,111,8,28,170,82,121,242,200,208,145,73,59,234,19,87,61,79,137,245,148,212,94,96,253,227,60,162,170,49,102), string.char(200,235,229,185,225,227,209,209,199,11,112,58,19,202,246,237,94,60,90,176,145,87,191,138,171,88,242,239,21,146,3,92,255,188,99,146,74,134,252,19,201,111,239,76,249,231,71,109,230,240,192,234,253,52,58,173,153,24,131,161,97,222,0,203,177,179,186,160,46,206,73,176,154,39,248,22,66,164,232,120,188,5,73,245,68,8,40,157,155,93,50,207)), 176)

print(177) assert("a07ef6f8799ef46062ffea5a43bb3edd30c1fdde" == hmac_sha1(string.char(81,90,37,124,211,22,19,34,50,56,90,45,17,230,233,38,76,24,250), string.char(142,185,46,191,103,207,110,48,71,10,217,115,193,52,131,87,106,39,9,80,216,15,235,169,30,143,3,7,188,78,34,136,18,200,181,140,22,253,141,59,235,25,59,204,147,80,162,108,237,101,167,249,7,168,24,123,215,220,198,38,133,253,72,168,10,139,84,22,195,36,241,128,70,132,28,242,56,40,159,113,184,187,89,38,198,255,176,88,112,125,68,12,57,207,3,251,72,198,135,48,118,244,199,192,205,164,181,243,40,33,195,204,9,78,108,253,114,211,173,121,245,104,13,116,143,160,241,139,210,162,78,62,69,232,40,248,254,177,6,148,177,168,51,253,177,84,152,29,107,91,186,68,118,30,125,62,196,24,14,87,158,83,39,240,192,79,78,61,133,109,106,98,120,232,144,18,49,96,17,202,208,189,152,171,219,19,41,132,179,219,83,220,201,36,191)), 177)

print(178) assert("63585793821f635534879a8576194f385f4a551a" == hmac_sha1(string.char(78,213,189,105,102,116,246,215), string.char(162,53,102,158,78,125,120,189,186,214,237,16,219,220,44,24,30,62,32,177,104,217,225,27,92,128,95,202,50,177,239,152,151,161,31,152,93,108,29,125,23,63,55,243,160,169,99,102,15,188,196,129,217,239,132,180,177,251,132,173,62,172,21,139,16,137,231,6,243,185,218,60,60,156,166,153,99,149,144,192,151,249,141,165,222,254,4,111,58,46,106,78,160,215,49,128,252,4,114,236,132,108,114,189,143,45,42,84,134,81,47,140,247,146,247,179,63,14,92,136,120,139)), 178)

print(179) assert("95bb1229d26df63839ba4846a41505d48ff98290" == hmac_sha1(string.char(121,190,21,20,39,101,53,249,44,132,19,132,4,114,199,22,32,143,38,33,184,181,66,55,183,240,31,204,225,230,125,186,87,25,90,229,11,55,239,62,101,67,238,1,104,178,191,144,148,105,6,26,127,154,135,247,248,171,41,44,57,83,186,220,42,40,68,153,189,221), string.char(99,150,114,100,37,53,229,202,20,171,246,91,188,188,46,232,70,26,151,35,223,28,97,132,9,242,55,238,98,75,108,91,226,48,236,209,133,92,68,194,241,199,188,86,59,255,230,128,252,193,94,113,134,27,32,50,191,176,159,185,89,209,255,192,9,214,252,63,147,8,92,162,114,72,50,101,136,180,95,39,55,143,137,118,40,14,104,3,149,153,230,135,98,93,72,180,72,86,185,80,107,69,68,20,73)), 179)

print(180) assert("9e7c9a258a32e6b3667549cef7a61f307f49b4b9" == hmac_sha1(string.char(105,200,69,23,156,169,151,107,30,139,196,145,128,108,52,7,181,248,255,83,176,169,152,51,158,236,49,191,65,208,155,204,105,179,148,226,142,194,63,253,217,184,69,11,135,185,203,150,146,57,129,80,87,84,231,168,63,186,149,85,128,236,135,217,246,255,121,70,251,68,139,215,199,143,87,13,196,20,50,92,55,116,34,141,117,89,228,94,63,142,250,182,58,91,68,214), string.char(38,52,86,63,109,91,84,11,33,250,194,192,178,94,37,17,65,111,173,17,37,54,163,168,142,91,191,197,161,229,44,163,163,125,81,204,167,185,244,119,75,28,211,87,159)), 180)

print(181) assert("7fb01c88e7e519265c18e714efd38bc66f831071" == hmac_sha1(string.char(138,214,212,108,83,152,165,123), string.char(148,223,186,162,237,166,230,68,59,78,220,164,231,42,46,211,239,38,39,150,174,50,58,4,0,135,87,123,123,5,33,252,197,6,53,83,27,178,189,228,166,252,91,141,67,44,68,106,222,17,46,84,214,252,110,181,216,132,14,246,209,57,183,155,238,64,215,121,8,169,157,175,182,191,169,94,116,105,91,49,203,30,155,202,39,140,146,6,115,162,112,130,175,86,143,128,126,249,148,185,39,174,63,83,19,76,164,34,228,97,198,250,65,3,168,158,61,130,167,166,144,185,146,184,160,39,189,11,243,125,255,60,217,46)), 181)

print(182) assert("15ab3da2a97592c5f2e22586b4c8a8653411e756" == hmac_sha1(string.char(6,242,91,101,37,118,105,53,170,56,114,144,117,49,53,203,169,216,9,232,9,170,204,129,82,41,210,45,86,176,139,80,152,168,1,154,32,111,89,165,143,205,21,236,105,62,231,106,232,205,7,189,245,52,145,100,78,140,200,183,209,232,196,88,109,175,70,153,150,231,252,7,189,119,97,176,216,201,186,245,24,128,33,57,113,188,184,0,146,248,69,255,77,144,101), string.char(186,246,72,178,189,127,22,42,22,217,81,156,253,142,152,86,42,41,164,77,150,11,208,155,154,185,18,81,156,185,140,224,215,98,1,97,33,194,137,206,144,219,207,210,52,203,198,1,109,182,65,138,122,227,168,207,213,110,206,102,12,181,198,195,133,218,23,187,117,190,56,140,154,239,105,62,96,148,126,187,47,24,139,194,18,211,225,252,195,49,102,138,165,160,90,153,100,140,105,154,242,59,133,226,19,68,125,59,83,140,48,240,226,129,151,79,130,59,96,111,27,73,198)), 182)

print(183) assert("7b06792805f4e8062ee9dfbbaffccd787c6f98e1" == hmac_sha1(string.char(83,132,152,16,245,136,91,241,37,158,80,92,65,223,79,3,189,213,89,253,159,93,194,52,218), string.char(212,242,37,98,229,190,238,23,210,197,147,253,82,105,146,168,198,253,2,160,165,188,165,221,179,112,136,72,149,79,138,70,101,95,210,73,157,14,211,92,27,230,177,84,170,183,15,40,0,92,222,252,166,48,1,139,40,16,186,178,231,109,100,125,253,125,123,94,115,94,150,157,186,230,115,163,194,164,30,131,162,90,28,61,44,248,137,8,246,173,31,177,236,39,8,10,192,148,211,36,215,57)), 183)

print(184) assert("a28fe22ba0845ae3d57273febbbf1d13e8fde928" == hmac_sha1(string.char(149), string.char(11,139,249,120,214,252,67,75)), 184)

print(185) assert("87a9daa85402f6c4b02f1e9fd6edd7e5d178bb88" == hmac_sha1(string.char(114,92,75,169,228,153,182,206,125,139,162,232,77,38,72,129,132,81,11,153,91,92,152,253,10,79,138,142,17,191,161,194,147,213,43,214,39,32,146,46,132,40,77,192,82,54,55,239,50,47), string.char(114,8,110,153,77,155,178,113,203,30,21,41,136,111,176,255,74,214,117,12,189,194,198,37,73,152,196,108,207,188,187,31,227,237,17,1,66,200,73,83,31,61,161,61,31,149,1,152,140,202,163,175,140,136,51,59,121,28,125,192,238,96,192,65,33,177,136,135,173,13,52,101,42,55,189,201,157,244,104,235,148,114,84,154,10,99,153,41,208,213,41,83,193,129,216,46,4,226,81,184,1,249,70,93,183,173,9,29,57,75,209,67,227,49,253,132,129,13,157,55,66,191,136,67,95,108,155,116,17,125,151,217,242,204,110,143,189,201,118)), 185)

print(186) assert("6300b2f6236b83de0c84ff1816d246231a5d3b79" == hmac_sha1(string.char(215,10,19,7,73,236,63,23,34,49,11,240,186,195,32,171,67,85,7,95,190,237,77,216,115,36,230,204,139,95,229,37,201,115,81,96,217,205,49,22,169,32,90,2,90,93,137,247,83,229,39,88,235,175,191,246,80,40,228,114,188,115,14,252,35,40,130,240,20,25,202,80,184,27,227,175,149,64,110,223,25,64,57,189,153,176,143,30,76,2,68), string.char(13,245,250,139,223,128,3,6,189,59,12,139,38,153,215,76,250,198,91,117,242,118,34,26,133,244,143,5,56,182,213,167,144,71,250,40,202,81,22,14,72,201,143,10,177,4,166,75,160,156,100,5,147,138,104,98,9,125,81,202,44,120,241,221,181,0,169,155,96,1,4,205,145,105,150,122,135,231,42,165,179,83,39,122,159,193,139,28,4,201,178,41,168,11,177,61,39,14,196,60,29,131,201,91,46,35,128,63,167,48,132,134,105,224,246,244,81,144,209,123,222,190,167,138,76,194,42,152,23,125,52,156,18,217,101,207,239,63,235,3,3,49,147,172,158,97,179,86,233,85,155,245,206,205,165,195,180,223,20,62,197,143,149,126,152)), 186)

print(187) assert("35fe4e0cf2417a783d5bdbc17bbc0ab77d2699e7" == hmac_sha1(string.char(15,157,117,128,204,42,12,183,229,129,132,234,228,150,235,100,100,77,160,26,154,230,246,138,150,120,252,20,188,138,171,189,208,62,201,58,158,152,167,165,98,249,52,143,7,26,109,227,144,81,213,157,31,155,26,12,206,103,193,29,142,126,205,123,83,111,179,166,31,32,183,183,100,54,51,205,180,186,160,220,176,233,42,94,62,241,88,74,31,24,22,115,179,124,136,206,78,83), string.char(248,157,191,249,76,86,187,243,10,116,1,227,141,21,104,154,167,72,30,245,6,57,40,170,253,15,4,192,237,237,142,141,196,243,231,245,121,219,150,237,212,118,78,25,201,249,174,21,76,98,187,155,82,243,218,142,239,101,235,240,134,70,212,205,136,165,170,71,121,137,44,8,110,14,167,162,233,92,51,191,178,227,85,134,168,222,121,62,35,127,57,92,80,142,91,112,9,248,129,127,236,2,190,165,125,236,188,117,158,241,181,134,54,133,16,64,100,156,59,83,249,105,235,187,160,186,158,173,52,25,129,20,156,209,102,170,209,10,3,233,12,228,205,138,16,140,108,74,75,65,238,155,251,129,73,236,118,93,202,217,46,180,165,27,84,120,61,186,173,148,131,161,187,30,175,21,249,12,245,145,89,93,61,151,254,29,247,51,198,238,111,52,30,254)), 187)

print(188) assert("83c2a380e55ecbc6190b9817bb291a00c36de5e8" == hmac_sha1(string.char(61,128,92,30,94,101,187,67,197,177,98,100,191,221,190,196,86,62,8,238,225,3,93,127,28,126,217,206,56,192,90,9,74,34,43,228,190,162,57,99,170,238,230,196,99,213,31,6,184,11,79,82,100,68,255,40,63), string.char(78,173,248,128,215,226,77,57,233,135,163,11,241,74,59,78,169,219,125,37,182,56,139,89,32,52,80,165,233,52,179,54,216,45,205,209,173,33,12,148,231,66,126,155,191,91,155,174,23,15,14,28,77,186,139,113,48,141,153,177,252,194,23,61,181,189,66,151,45,11,119,74,236,107,206,244,41,117,161,182,233,138,57,196,90,118,28,99,186,150,54,180,105,230,2,41,246,19,80,211,173,102,72,78,82,253,5,183,248,101,173,204,2,145,105,4,160,44,110,211,63,45,46,78)), 188)

print(189) assert("bd59d0dcf812107a613a2d892322f532c16ec210" == hmac_sha1(string.char(161,183,101,160,169,208,82,58,88,198,190,85,53,240,56,6,20,136,86,18,216,63,190), string.char(39,227,142,194,37,34,121,168,239,99,70,39,179,128,26,113,47,95,70,129,255,219,63,233,44,33,19,127,22,24,208,50,19,141,185,19,54,82,147,138,44,69)), 189)

print(190) assert("6aa92cb64b2e390fbf04dc7edfe3af068109ffba" == hmac_sha1(string.char(202,230,55,100,136,80,156,240,98,73,97,72,191,195,185,105,150,97,148,33,167,140,212,100,247,154,5,152,117,24,128,221,150,49,143,86,12,211,161,75,177,75,145,46,112,143,37,181,84,50,230,81), string.char(131,200,0,161,117,217,5,10,64,79,178,147,64,248,35,147,135,103,157,181,194,123,76,13,150,118,204,63,32,203,155,222,227,148,31,28,218,83,245,17,208,200,104,78,85,31,114,194,67,159,184,167,42,199,241,6,182,195,3,79,22,236,124)), 190)

print(191) assert("a42cf08fa6d8ad6ae00251aeed0357dca80645c7" == hmac_sha1(string.char(170,52,245,172,122,225,164,248,23,35,54,243,118,35,165,16,6), string.char(245,115,59,162,179,146,39,213,64,240,80,108,190,127,116,16,154,211,33,171,150,46,77,213,99,88,160,101,236,202,70,26,61,83,79,110,127,74,97,34,18,243,140,34,244,249,225,88,132,102,7,99,220,140,46,111,96,48,93,44,47,186,86,246,244,127,236,150,35,69,111,238,54,24,71,157,254,21,2,194,69,47,190,87,72,235,60,243,40,153,111,55,220,25,91,17,156,195,57,207,107,145,6,82,104,232,209)), 191)

print(192) assert("8dd62dcf68ef2d193005921161341839b8cac487" == hmac_sha1(string.char(136,5,195,241,18,208,11,46,252,182,96,183,164,87,248,13), string.char(78,49,162,9,47,79,26,139,66,194,248,90,171,207,167,43,201,223,102,192,49,145,83,42,1,52,250,116,216,133,224,224,17,143,41,153,65,214,231,109,160,5,31,85,17,186,199,226,214,92,21,194,148,98,68,209,50,74,26,150,97,59,223,8,131,173,145,6,31,126,248,86,226,2,94,15,3,202,239,99,177,237,61,99,14,253,26,246,0,151,2,7,159,40,249,166)), 192)

print(193) assert("eff66e7a69ae7d2a90b2d80c64ce7c41fe560a19" == hmac_sha1(string.char(123,54,89,205,103,116,21,97,164,41,23,224,151,195,22,196,90,52,253,92), string.char(141,12,168,171,49,30,165,57,107,214,157,224,36,163,182,184,103,186,133,22,2,215,52,220,95,205,231,180,221,139,67,184,21,46,172,95,183,220,31,27,227,122,183,196,114,206,132,162,51,164,84,212,172,63,218,236,127,215,218,77,119,105,14,19,164,53,149,11,13,1,29,246,69,200,208,239,154,60,245,31,172,82,158,165,197,250,151,83,12,156,215,201,66,45,238,228,77,125,157,35,235,162,78,220,132,14,137,168,238,127,10,24,41,132,181,43,95,73,33,32,129,149,145,55,80,156,171,73,90,183,166,182,163,154,31,104,14,56,59,102,72,210,121,191,251,239,1,5,76,116,158,89,40,69,220,107,23,168,106,93,92,95,21,91,118,118,71,29,64,142,84,15,153,193,47,214,30,117,236,217)), 193)

print(194) assert("0f1adc518afcca2ed7ad0adaaedd544835ddb76e" == hmac_sha1(string.char(142,36,199,16,52,54,62,146,153,25,162,85,251,247), string.char(110,70,53,237,120,53,50,196,24,82,199,210,156,178,110,124,7,24,229,89,39,1,10,96,74,211,36,79,166,4,33,238,64,220,239,129,48,232,244,172,142,79,154,73,36,107,182,208,191,25,201,19,233,23,60,236,180,76,116,53,232,181,101,62,160,252,213,171,166,113,193,73,75,13,209,63,76,92,95,176,119,0,125,174,42,138,77,23,212,81,180,10,193,118,244,242,163,246,206,150,162,92,20,208,51,71,254,197,11,222,203,153,208,251,243,193,124,141,215,171,55,244,230,78,158,32,223,138,156,43,98,39,191,108,111,6,117,130,195,100,221,233,17,98,180,49,132,139,171,20,180,7,206,35,54,17,48,253,130,185,249,2,52,17,207,73,24,33)), 194)

print(195) assert("5e87f8d9a653312fd7b070a33a5d9e67b28b9a84" == hmac_sha1(string.char(255,237,33,255,4,170,95,90,88,77,217,10,94,118,134,20,33,208,17,136,77,18,169,205,112,36,203,231,67,47,186,91,7,17,29), string.char(97,211,98,53,135,238,42,101,144,12,75,185,119,223,114,81,201,94,21,118,16,152,74,215,56,61,131,151,83,96,83,59,49,199,255,207,153,90,231,39,181,4,59,9,2,150,207,124,209,120,37,236,195,66,189,209,137,9,165,78,172,142,209,243,237,145,204,210,222,153,52,127,39,174,133,17,186,219,87,142,209,212,223,60,249,57,244,251,44,254,73,238,52,99,94,237,189,185,237,1,101,166,220,170,103,209)), 195)

print(196) assert("837c7cc92e0d2c725b1d1d2f02ef787be37896fa" == hmac_sha1(string.char(150,241,64,89,79,72,88,157,113,139,190,43,211,214,202,52,124,91,111,198,47,161,120,17,120,157,112,248,245,154,254,25,233,96,216), string.char(214,251,73,193,181,158,253,28,23,48,186,168,162,26,124,103,22,195,165,63,189,196,162,229,69,1,208,85,249,24,73,101,243,149,68,236,124,147,108,67,37,75,202,143,57,124,71,176,27,216,208,183,164,173,219,170,79,10,198,1,232,35,9,19,70,131,211,60,37,94,146,98,92,31,150,95,89,189,46,38,156,118,171,137,86,87,32,173,77,14,135,233,233,114,162,136,57,113,73,115,134,87,184)), 196)

print(197) assert("64534553f76e55b890101380ad9149d3cacb5b76" == hmac_sha1(string.char(231,24,192,54,17,14,98,122,119,170,71,54,206,207,223,109,164,181,124,186,122,111,122,34,157,24,237,130,207,206,117,76,183,162,174,124,60,60,77,114,139,170,194,143,232,74,160,141,161,171,51,178,162,159,234,208,55), string.char(141,184,241,185,112,45,53,192,72,152,139,145,146,149,145,151,12,140,111,79,158,172,212,175,75,225,127,4,252,104,5,94,105,24,141,183,79,208,240,227,63,126,213,4,13,109,216,244,237,24,196,52,212,245,147,109,18,63,69,107,122,245,101,67,212,232,92,25,135,67,127,247,187,143,224,198,105,38,147,12,238,6,57,53,105,246,0,127,222,69,163,44,11,245,82,220,32,108,33,70,93,177,89,75,192,214,104,236,84,28,221,209,27,12,80,239,111,249,57,39,236,193,17,69,66,180,63,193,242,248,72,22,225,56,198,235,111,102,33,171,159,124,220,143,108,10,71,186,219,213,28,209,145,188,36,70,59,9,235,154,57,12,211,146,6,87,83)), 197)

print(198) assert("b7efbbc21ac1a746e22368e814ef5921056331ac" == hmac_sha1(string.char(137,153,151,252,88,36,165,92,194,50,19,117), string.char(155,113,35,47,22,52,144,77,130,20,178,133,75,207,168,146,132,209,160,7,123,190,117,196,147,212,142,25,182,222,56,249,192,228,6,224,250,221,89,7,176,27,37,49,215,192,74,132,127,101,32,23,34,131,23,74,37,226,208,205,162,242,102)), 198)

print(199) assert("950ad3222f4917f868d09feab237a909fb6d50b7" == hmac_sha1(string.char(78,46,85,132,231,4,243,255,22,45,240,155,151,119,94,213,50,111,10,83,40,204,49,52,17,69,132,44,213,83,54,251,211,159,123,55,17,58,162,170,210,3,35,237,165,181,217,27,7,249,158,22,158,207,77,121,37,63,37,39,204,68,99,158,78,175,73,183,47,99,134,65,74,234,154,33,14,117,126,98,167,242,106,112,145,82), string.char(144,133,184,16,9,8,227,98,190,60,141,255,87,69,63,214,12,67,14,206,32,120,59,232,176,82,32,194,115,52,148,143,126,86,82,101,167,249,17,169,9,105,228)), 199)

---]]-----------------------------------------------------------------------------------------
--END
end end)()end;
do require("package").preload["libs.neubind"] = (function() local package;return function(...)-- <pack libs.neubind> --
--[[
	Here's the foundation for a bind system that works with LOVE 0.9.1 
	It requires the following features:
		* An input from any device sends a signal, which is traditionally a bind.
		* One input to many signals.
		* Comboing signals to produce a new signal.
		* Mouse virtualization to input pairs.
		* Convert digital signals 
]]

--[[@NOTES:
	when interfacing with this, mapping controller IDs to names:
	save the controller name and its current ID,
	try to find a controller with stored name -- fallback on existing ID if found
]]

local enum_itypes = {
	"key",
	"mouseaxis",
	"mousebtn",
	--mousegesture ???
	"joyaxis",
	"joybtn",
	"joyhat",
}

--[[
	a complete set of examples of valid itypes
	
	key = {
		itype = "key",
		const = "x", --https://www.love2d.org/wiki/KeyConstant
	},
	joyaxis = {
		itype = "joyaxis",
		joystick = 1, --the id of the joystick to use
		axis = 1, --the axis id of the joystick to probe
	}
]]

local example_keymap = {
	config = {
		-- are we using any joysticks?
		useJoysticks = false,
	},
	
	controls = {
		-- standard name = {table of properties}
		-- OR
		-- standard name = {{key1}, {key2}}
		--[[
			itype		=	input_enum
		]]
		playerDebug = {
			itype = "key",
			const = "x",
		},
	}
}

neubind = class("neubind")

function neubind:init(inputtable)
	if love.joystick then
		-- go through all connected joysticks and get their signatures
		self.joysigs = {}
		self.joys = love.joystick.getJoysticks()
		for i, joystick in ipairs(self.joys) do
			self.joysigs[i] = {
				axis_init = {joystick:getAxes()},
				
				num_axes = joystick:getAxisCount(),
				num_buttons = joystick:getButtonCount(),
				num_hats = joystick:getHatCount(),
				
				guid = joystick:getGUID(),
				name = joystick:getName(),
				id = {joystick:getID()},
				
				can_vibrate = joystick:isVibrationSupported(),
				is_gamepad = joystick:isGamepad(),
			}
		end
	end
	
	self.promptTimer = 0
	self.isPrompting = false
	
	self.controlTable = inputtable or {} --the table of controls to monitor
	
	-- condense any non-table items into tables
	for k,v in pairs(self.controlTable) do
		if not v[1] then
			self.controlTable[k] = {v}
		end
	end
	
	self.controls = {}	--this is for checking the exact value of a control
	self.tapped = {}	--like above, but only active for a frame after being pressed
	self.released = {}	--like above, but only active for a frame after being released
end

-- add a control if it didn't already exist
function neubind:addControl(controlname, controlsets)
	if not self.controlTable[controlname] then
		if not controlsets[1] then
			self.controlTable[controlname] = {controlsets}
		else
			self.controlTable[controlname] = controlsets
		end
		return true
	else
		return false
	end
end

-- emulate a keypress, mostly for netplay foolery
function neubind:remotePressed(control)
	
end

function neubind:remoteReleased(control)
	
end

function neubind:update(dt)
	--print("neu update")
	-- iterate through controls and think
	
	--improvement ideas: snapshot every control state at the beginning and then backreference them
	
	for control, sets in pairs(self.controlTable) do
		local active = false
		
		for i,stub in pairs(sets) do
			if stub.itype == "key" and love.keyboard then
				active = self:check_key(stub.const)
			else
				assert(false, "CRITICAL: Tried to process input of unknown type: "..stub.itype.."!")
			end
			
			if not active then
				-- not active, cry
				break
			end
		end
		
		self.controls[control] = active
		
		if active then
			self.released[control] = false
			if self.tapped[control]==false then 
				self.tapped[control]=true
				if self.controlPressed then
					self:controlPressed(control)
				end
			elseif self.tapped[control]==true then
				self.tapped[control]=nil
			end
		else
			self.tapped[control] = false
			if self.released[control]==false then
				self.released[control]=true 
				if self.controlReleased then
					self:controlReleased(control)
				end
			elseif self.released[control]==true then
				self.released[control]=nil
			end
		end
	end
end

function neubind:check_key(const)
	return love.keyboard.isDown(const)
end


-- callback stub
function neubind:controlPressed(control)
	print("im pressed and gay", control)
end

-- callback stub
function neubind:controlReleased(control)
	print("im released and gay", control)
end

-- tell the system to catch the next signal
function neubind:promptStart(duration)
	self.promptTimer = duration or -1
	self.isPrompting = true
end

-- tell the system to stop trying to catch signals
function neubind:promptStop()
	self.promptTimer = 0
	self.isPrompting = false
end

-- callback to send a signal when something is captured via prompt
function neubind:promptCallback(controlname, controlid)
	--@controlname == string that describes a control
	--@controlid == the id of the control
end
end end)()end;
do require("package").preload["libs.lube.tcp"] = (function() local package;return function(...)-- <pack libs.lube.tcp> --
local socket = require "socket"

--- CLIENT ---

local tcpClient = {}
tcpClient._implemented = true

function tcpClient:createSocket()
	self.socket = socket.tcp()
	self.socket:settimeout(0)
end

function tcpClient:_connect()
	self.socket:settimeout(5)
	local success, err = self.socket:connect(self.host, self.port)
	self.socket:settimeout(0)
	return success, err
end

function tcpClient:_disconnect()
	self.socket:shutdown()
end

function tcpClient:_send(data)
	return self.socket:send(data)
end

function tcpClient:_receive()
	local packet = ""
	local data, _, partial = self.socket:receive(8192)
	while data do
		packet = packet .. data
		data, _, partial = self.socket:receive(8192)
	end
	if not data and partial then
		packet = packet .. partial
	end
	if packet ~= "" then
		return packet
	end
	return nil, "No messages"
end

function tcpClient:setoption(option, value)
	if option == "broadcast" then
		self.socket:setoption("broadcast", not not value)
	end
end


--- SERVER ---

local tcpServer = {}
tcpServer._implemented = true

function tcpServer:createSocket()
	self._socks = {}
	self.socket = socket.tcp()
	self.socket:settimeout(0)
	self.socket:setoption("reuseaddr", true)
end

function tcpServer:_listen()
	self.socket:bind("*", self.port)
	self.socket:listen(5)
end

function tcpServer:send(data, clientid)
	-- This time, the clientip is the client socket.
	if clientid then
		clientid:send(data)
	else
		for sock, _ in pairs(self.clients) do
			sock:send(data)
		end
	end
end

function tcpServer:receive()
	for sock, _ in pairs(self.clients) do
		local packet = ""
		local data, _, partial = sock:receive(8192)
		while data do
			packet = packet .. data
			data, _, partial = sock:receive(8192)
		end
		if not data and partial then
			packet = packet .. partial
		end
		if packet ~= "" then
			return packet, sock
		end
	end
	for i, sock in pairs(self._socks) do
		local data = sock:receive()
		if data then
			local hs, conn = data:match("^(.+)([%+%-])\n?$")
			if hs == self.handshake and conn ==  "+" then
				self._socks[i] = nil
				return data, sock
			end
		end
	end
	return nil, "No messages."
end

function tcpServer:accept()
	local sock = self.socket:accept()
	while sock do
		sock:settimeout(0)
		self._socks[#self._socks+1] = sock
		sock = self.socket:accept()
	end
end

return {tcpClient, tcpServer}
end end)()end;
do require("package").preload["libs.lube.udp"] = (function() local package;return function(...)-- <pack libs.lube.udp> --
local socket = require "socket"

--- CLIENT ---

local udpClient = {}
udpClient._implemented = true

function udpClient:createSocket()
	self.socket = socket.udp()
	self.socket:settimeout(0)
end

function udpClient:_connect()
	-- We're connectionless,
	-- guaranteed success!
	return true
end

function udpClient:_disconnect()
	-- Well, that's easy.
end

function udpClient:_send(data)
	return self.socket:sendto(data, self.host, self.port)
end

function udpClient:_receive()
	local data, ip, port = self.socket:receivefrom()
	if ip == self.host and port == self.port then
		return data
	end
	return false, "Unknown remote sent data."
end

function udpClient:setOption(option, value)
	if option == "broadcast" then
		self.socket:setoption("broadcast", not not value)
	end
end


--- SERVER ---

local udpServer = {}
udpServer._implemented = true

function udpServer:createSocket()
	self.socket = socket.udp()
	self.socket:settimeout(0)
end

function udpServer:_listen()
	self.socket:setsockname("*", self.port)
end

function udpServer:send(data, clientid)
	-- We conviently use ip:port as clientid.
	if clientid then
		local ip, port = clientid:match("^(.-):(%d+)$")
		self.socket:sendto(data, ip, tonumber(port))
	else
		for clientid, _ in pairs(self.clients) do
			local ip, port = clientid:match("^(.-):(%d+)$")
			self.socket:sendto(data, ip, tonumber(port))
		end
	end
end

function udpServer:receive()
	local data, ip, port = self.socket:receivefrom()
	if data then
		local id = ip .. ":" .. port
		return data, id
	end
	return nil, "No message."
end

function udpServer:accept()
end


return {udpClient, udpServer}
end end)()end;
do require("package").preload["libs.lube.core"] = (function() local package;return function(...)-- <pack libs.lube.core> --
--- CLIENT ---

local client = {}
-- A generic client class
-- Implementations are required to implement the following functions:
--  * createSocket() --> Put a socket object in self.socket
--  * success, err = _connect() --> Connect the socket to self.host and self.port
--  * _disconnect() --> Disconnect the socket
--  * success, err = _send(data) --> Send data to the server
--  * message, err = _receive() --> Receive a message from the server
--  * setOption(option, value) --> Set a socket option, options being one of the following:
--      - "broadcast" --> Allow broadcast packets.
-- And they also have to set _implemented to evaluate to true.
--
-- Note that all implementations should have a 0 timeout, except for connecting.

function client:init()
	assert(self._implemented, "Can't use a generic client object directly, please provide an implementation.")
	-- 'Initialize' our variables
	self.host = nil
	self.port = nil
	self.connected = false
	self.socket = nil
	self.callbacks = {
		recv = nil
	}
	self.handshake = nil
	self.ping = nil
end

function client:setPing(enabled, time, msg)
	-- If ping is enabled, create a self.ping
	-- and set the time and the message in it,
	-- but most importantly, keep the time.
	-- If disabled, set self.ping to nil.
	if enabled then
		self.ping = {
			time = time,
			msg = msg,
			timer = time
		}
	else
		self.ping = nil
	end
end

function client:connect(host, port, dns)
	-- Verify our inputs.
	if not host or not port then
		return false, "Invalid arguments"
	end
	-- Resolve dns if needed (dns is true by default).
	if dns ~= false then
		local ip = socket.dns.toip(host)
		if not ip then
			return false, "DNS lookup failed for " .. host
		end
		host = ip
	end
	-- Set it up for our new connection.
	self:createSocket()
	self.host = host
	self.port = port
	-- Ask our implementation to actually connect.
	local success, err = self:_connect()
	if not success then
		self.host = nil
		self.port = nil
		return false, err
	end
	self.connected = true
	-- Send our handshake if we have one.
	if self.handshake then
		self:send(self.handshake .. "+\n")
	end
	return true
end

function client:disconnect()
	if self.connected then
		self:send(self.handshake .. "-\n")
		self:_disconnect()
		self.host = nil
		self.port = nil
	end
end

function client:send(data)
	-- Check if we're connected and pass it on.
	if not self.connected then
		return false, "Not connected"
	end
	return self:_send(data)
end

function client:receive()
	-- Check if we're connected and pass it on.
	if not self.connected then
		return false, "Not connected"
	end
	return self:_receive()
end

function client:update(dt)
	if not self.connected then return end
	assert(dt, "Update needs a dt!")
	-- First, let's handle ping messages.
	if self.ping then
		self.ping.timer = self.ping.timer + dt
		if self.ping.timer > self.ping.time then
			self:_send(self.ping.msg)
			self.ping.timer = 0
		end
	end
	-- If a recv callback is set, let's grab
	-- all incoming messages. If not, leave
	-- them in the queue.
	if self.callbacks.recv then
		local data, err = self:_receive()
		while data do
			self.callbacks.recv(data)
			data, err = self:_receive()
		end
	end
end


--- SERVER ---

local server = {}
-- A generic server class
-- Implementations are required to implement the following functions:
--  * createSocket() --> Put a socket object in self.socket.
--  * _listen() --> Listen on self.port. (All interfaces.)
--  * send(data, clientid) --> Send data to clientid, or everyone if clientid is nil.
--  * data, clientid = receive() --> Receive data.
--  * accept() --> Accept all waiting clients.
-- And they also have to set _implemented to evaluate to true.
-- Note that all functions should have a 0 timeout.

function server:init()
	assert(self._implemented, "Can't use a generic server object directly, please provide an implementation.")
	-- 'Initialize' our variables
	-- Some more initialization.
	self.clients = {}
	self.handshake = nil
	self.callbacks = {
		recv = nil,
		connect = nil,
		disconnect = nil,
	}
	self.ping = nil
	self.port = nil
end

function server:setPing(enabled, time, msg)
	-- Set self.ping if enabled with time and msg,
	-- otherwise set it to nil.
	if enabled then
		self.ping = {
			time = time,
			msg = msg
		}
	else
		self.ping = nil
	end
end

function server:listen(port)
	-- Create a socket, set the port and listen.
	self:createSocket()
	self.port = port
	self:_listen()
end

function server:update(dt)
	assert(dt, "Update needs a dt!")
	-- Accept all waiting clients.
	self:accept()
	-- Start handling messages.
	local data, clientid = self:receive()
	while data do
		local hs, conn = data:match("^(.+)([%+%-])\n?$")
		if hs == self.handshake and conn == "+" then
			-- If we already knew the client, ignore.
			if not self.clients[clientid] then
				self.clients[clientid] = {ping = -dt}
				if self.callbacks.connect then
					self.callbacks.connect(clientid)
				end
			end
		elseif hs == self.handshake and conn == "-" then
			-- Ignore unknown clients (perhaps they timed out before?).
			if self.clients[clientid] then
				self.clients[clientid] = nil
				if self.callbacks.disconnect then
					self.callbacks.disconnect(clientid)
				end
			end
		elseif not self.ping or data ~= self.ping.msg then
			-- Filter out ping messages and call the recv callback.
			if self.callbacks.recv then
				self.callbacks.recv(data, clientid)
			end
		end
		-- Mark as 'ping receive', -dt because dt is added after.
		-- (Which means a net result of 0.)
		if self.clients[clientid] then
			self.clients[clientid].ping = -dt
		end
		data, clientid = self:receive()
	end
	if self.ping then
		-- If we ping then up all the counters.
		-- If it exceeds the limit we set, disconnect the client.
		for i, v in pairs(self.clients) do
			v.ping = v.ping + dt
			if v.ping > self.ping.time then
				self.clients[i] = nil
				if self.callbacks.disconnect then
					self.callbacks.disconnect(i)
				end
			end
		end
	end
end

return {client, server}
end end)()end;
do require("package").preload["libs.lube.init"] = (function() local package;return function(...)-- <pack libs.lube.init> --
-- Get our base modulename, to require the submodules
local modulename = ...
modulename = modulename:match("^(.+)%.init$") or modulename

local function subrequire(sub)
	return unpack(require(modulename .. "." .. sub))
end

-- Common Class fallback
local fallback = {}
function fallback.class(_, table, parent)
	parent = parent or {}

	local mt = {}
	function mt:__index(name)
		return table[name] or parent[name]
	end
	function mt:__call(...)
		local instance = setmetatable({}, mt)
		instance:init(...)
		return instance
	end

	return setmetatable({}, mt)
end

-- Use the fallback only if not other class
-- commons implemenation is defined
local common = fallback
if _G.common and _G.common.class then
	common = _G.common
end

lube = {}

-- All the submodules!
local client, server = subrequire "core"
lube.Client = common.class("lube.Client", client)
lube.Server = common.class("lube.Server", server)

local udpClient, udpServer = subrequire "udp"
lube.udpClient = common.class("lube.udpClient", udpClient, lube.Client)
lube.udpServer = common.class("lube.udpServer", udpServer, lube.Server)

local tcpClient, tcpServer = subrequire "tcp"
lube.tcpClient = common.class("lube.tcpClient", tcpClient, lube.Client)
lube.tcpServer = common.class("lube.tcpServer", tcpServer, lube.Server)

-- If enet is found, load that, too
if pcall(require, "enet") then
	local enetClient, enetServer = subrequire "enet"
	lube.enetClient = common.class("lube.enetClient", enetClient, lube.Client)
	lube.enetServer = common.class("lube.enetServer", enetServer, lube.Server)
end

return lube
end end)()end;
do require("package").preload["libs.lube.enet"] = (function() local package;return function(...)-- <pack libs.lube.enet> --
local enet = require "enet"

--- CLIENT ---

local enetClient = {}
enetClient._implemented = true

function enetClient:createSocket()
	self.socket = enet.host_create()
	self.flag = "reliable"
end

function enetClient:_connect()
	self.socket:connect(self.host .. ":" .. self.port)
	local t = self.socket:service(5000)
	local success, err = t and t.type == "connect"
	if not success then
		err = "Could not connect"
	else
		self.peer = t.peer
	end
	return success, err
end

function enetClient:_disconnect()
	self.socket:disconnect()
	return self.socket:flush()
end

function enetClient:_send(data)
	return self.peer:send(data, 0, self.flag)
end

function enetClient:_receive()
	return (self.peer:receive())
end

function enetClient:setoption(option, value)
	if option == "enetFlag" then
		self.flag = value
	end
end

function enetClient:update(dt)
	if not self.connected then return end
	if self.ping then
		if self.ping.time ~= self.ping.oldtime then
			self.ping.oldtime = self.ping.time
			self.peer:ping_interval(self.ping.time*1000)
		end
	end

	while true do
		local event = self.socket:service()
		if not event then break end

		if event.type == "receive" then
			if self.callbacks.recv then
				self.callbacks.recv(event.data)
			end
		end
	end
end


--- SERVER ---

local enetServer = {}
enetServer._implemented = true

function enetServer:createSocket()
	self.connected = {}
end

function enetServer:_listen()
	self.socket = enet.host_create("*:" .. self.port)
end

function enetServer:send(data, clientid)
	if clientid then
		return self.socket:get_peer(clientid):send(data)
	else
		return self.socket:broadcast(data)
	end
end

function enetServer:receive()
	return (self.peer:receive())
end

function enetServer:accept()
end

function enetServer:update(dt)
	if self.ping then
		if self.ping.time ~= self.ping.oldtime then
			self.ping.oldtime = self.ping.time
			for i = 1, self.socket:peer_count() do
				self.socket:get_peer(i):timeout(5, 0, self.ping.time*1000)
			end
		end
	end

	while true do
		local event = self.socket:service()
		if not event then break end

		if event.type == "receive" then
			local hs, conn = event.data:match("^(.+)([%+%-])\n?$")
			local id = event.peer:index()
			if hs == self.handshake and conn == "+" then
				if self.callbacks.connect then
					self.connected[id] = true
					self.callbacks.connect(id)
				end
			elseif hs == self.handshake and conn == "-" then
				if self.callbacks.disconnect then
					self.connected[id] = false
					self.callbacks.disconnect(id)
				end
			else
				if self.callbacks.recv then
					self.callbacks.recv(event.data, id)
				end
			end
		elseif event.type == "disconnect" then
			local id = event.peer:index()
			if self.connected[id] and self.callbacks.disconnect then
				self.callbacks.disconnect(id)
			end
			self.connected[id] = false
		elseif event.type == "connect" and self.ping then
			event.peer:timeout(5, 0, self.ping.time*1000)
		end
	end
end

return {enetClient, enetServer}
end end)()end;
do require("package").preload["libs.TEsound"] = (function() local package;return function(...)-- <pack libs.TEsound> --
--- TEsound v1.3, a simplified sound system for Love 2D
-- @author Ensayia (Ensayia@gmail.com) & Taehl (SelfMadeSpirit@gmail.com)
TEsound = {}				-- Namespace
TEsound.channels = {}		-- This holds the currently playing sound channels
TEsound.volumeLevels = {}	-- Volume levels that multiply the volumes of sounds with those tags
TEsound.pitchLevels = {}	-- Pitch levels that multiply the pitches of sounds with those tags


-- Functions for playing sounds

--- Play a sound, or a random sound from a list. (with optional tag(s), volume, pitch, and on-finished function)
-- @param sound A filepath to the sound file (example: "sounds/jump.ogg"), or a list of filepaths. If a list is used, a random sound from that list will be played. Passing a string is shorthand for passing a table with only one item.
-- @param tags One or more tags that can be used to identify a sound (Example, single: "music". Example, multiple: {"sfx", "gun", "player"}). Multiple sounds may share tags, or tags may be unique. If omitted, no tags are assigned. Passing a string is shorthand for passing a table with only one item.
-- @param volume A number between 0 and 1 which specifies how loud a sound is. If the sound has a tag which a volume has been specified for, it will multiply this number (ie., if you use the tag "sfx" and volume 0.5, and "sfx" has been tagVolume-ed to 0.6, then the sound will be played at 0.3 volume).
-- @param pitch A number which specifies the speed/pitch the sound will be played it. If the sound has a tag which a pitch has been specified for, it will multiply this number.
-- @param func A function which will be called when the sound is finished playing (it's passed one parameter - a list with the sound's volume and pitch). If omitted, no function will be used.
function TEsound.play(sound, tags, volume, pitch, func)
	if type(sound) == "table" then
		assert(#sound > 0, "The list of sounds must have at least one sound.")
		sound = sound[math.random(#sound)]
	end
	if not (type(sound) == "string" or (type(sound) == "userdata" and sound:type() == "SoundData")) then
		error("You must specify a sound - a filepath as a string, a SoundData, or a table of them. Not a Source!")
	end
	
	table.insert(TEsound.channels, { love.audio.newSource(sound), func, {volume or 1, pitch or 1}, tags=(type(tags) == "table" and tags or {tags}) })
	local s = TEsound.channels[#TEsound.channels]
	s[1]:play()
	s[1]:setVolume( (volume or 1) * TEsound.findVolume(tags) * (TEsound.volumeLevels.all or 1) )
	s[1]:setPitch( (pitch or 1) * TEsound.findPitch(tags) * (TEsound.pitchLevels.all or 1) )
	return #TEsound.channels
end

--- Play a repeating sound, or random sounds from a list. (with optional tag(s), volume, and pitch)
-- @param sound See TEsound.play
-- @param tags See TEsound.play
-- @param n The number of times the sound will be looped. If omitted, the sound will loop until TEsound.stop is used.
-- @param volume See TEsound.play
-- @param pitch See TEsound.play
function TEsound.playLooping(sound, tags, n, volume, pitch)
	return TEsound.play( sound, tags, volume, pitch,
		(not n or n > 1) and function(d) TEsound.playLooping(sound, tags, (n and n-1), d[1], d[2]) end
	)
end


-- Functions for modifying sounds that are playing (passing these a tag instead of a string is generally preferable)

--- Sets the volume of channel or tag and its loops (if any).
-- Volume/pitch changes take effect immediately and last until changed again. Sound "tags" are recommended for changing multiple sounds together, so you can independently adjust the volume of all sound effects, music, etc. Just don't forget to tag your sounds! If a sound has multiple tags with set volumes, the first one (in the order of its tag list) will be used.
-- Example: TEsound.volume("music", .5))	-- set music to half volume
-- @param channel Determines which channel (number) or tag (string) will be affected. Since sound channels aren't static, it's advisable to use tags. The special sound tag "all" will always affect all sounds.
-- @param volume See TEsound.play. If omitted, effectively resets volume to 1.
function TEsound.volume(channel, volume)
	if type(channel) == "number" then
		local c = TEsound.channels[channel] volume = volume or c[3][1] c[3][1] = volume
		c[1]:setVolume( volume * TEsound.findVolume(c.tags) * (TEsound.volumeLevels.all or 1) )
	elseif type(channel) == "string" then TEsound.volumeLevels[channel]=volume for k,v in pairs(TEsound.findTag(channel)) do TEsound.volume(v, volume) end
	end
end

--- Sets the pitch of channel or tag and its loops (if any).
-- @param channel See TEsound.volume
-- @param pitch See TEsound.play. If omitted, effectively resets pitch to 1.
function TEsound.pitch(channel, pitch)
	if type(channel) == "number" then
		local c = TEsound.channels[channel] pitch = pitch or c[3][2] c[3][2] = pitch
		c[1]:setPitch( pitch * TEsound.findPitch(c.tags) * (TEsound.pitchLevels.all or 1) )
	elseif type(channel) == "string" then TEsound.pitchLevels[channel]=pitch for k,v in pairs(TEsound.findTag(channel)) do TEsound.pitch(v, pitch) end
	end
end

--- Pauses a channel or tag. Use TEsound.resume to unpause.
-- @param channel See TEsound.volume
function TEsound.pause(channel)
	if type(channel) == "number" then TEsound.channels[channel][1]:pause()
	elseif type(channel) == "string" then for k,v in pairs(TEsound.findTag(channel)) do TEsound.pause(v) end
	end
end

--- Resumes a channel or tag from a pause.
-- @param channel See TEsound.volume
function TEsound.resume(channel)
	if type(channel) == "number" then TEsound.channels[channel][1]:resume()
	elseif type(channel) == "string" then for k,v in pairs(TEsound.findTag(channel)) do TEsound.resume(v) end
	end
end

-- Stops a sound channel or tag either immediately or when finished and prevents it from looping.
-- @param channel See TEsound.volume
-- @param finish If true, the sound will be allowed to finish playing instead of stopping immediately.
function TEsound.stop(channel, finish)
	if type(channel) == "number" then local c = TEsound.channels[channel] c[2] = nil if not finish then c[1]:stop() end
	elseif type(channel) == "string" then for k,v in pairs(TEsound.findTag(channel)) do TEsound.stop(v, finish) end
	end
end


-- Utility functions

--- Cleans up finished sounds, freeing memory (highly recommended to go in love.update()). If not called, memory and channels won't be freed, and sounds won't loop.
function TEsound.cleanup()
	for k,v in ipairs(TEsound.channels) do
		if v[1]:isStopped() then
			if v[2] then v[2](v[3]) end		-- allow sounds to use custom functions (primarily for looping, but be creative!)
			table.remove(TEsound.channels, k)
		end
	end
end


-- Internal functions

-- Returns a list of all sound channels with a given tag.
-- @param tag The channels of all sounds with this tag will be returned.
-- @return A list of sound channel numbers.
function TEsound.findTag(tag)
	local t = {}
	for channel,sound in ipairs(TEsound.channels) do
		if sound.tags then for k,v in ipairs(sound.tags) do
			if tag == "all" or v == tag then table.insert(t, channel) end
		end end
	end
	return t
end

--- Returns a volume level for a given tag or tags, or 1 if the tag(s)'s volume hasn't been set. If a list of tags is given, it will return the level of the first tag with a set volume.
-- @param tag Chooses the tag to check the volume of.
-- @return volume, a number between 0 and 1 (if nil, defaults to 1).
function TEsound.findVolume(tag)
	if type(tag) == "string" then return TEsound.volumeLevels[tag] or 1
	elseif type(tag) == "table" then for k,v in ipairs(tag) do if TEsound.volumeLevels[v] then return TEsound.volumeLevels[v] end end
	end
	return 1
end

--- Returns a pitch level for a given tag or tags, or 1 if the tag(s)'s pitch hasn't been set.
-- @param tag See TEsound.findVolume
-- @return pitch, a number between 0 and 1 (if nil, defaults to 1).
function TEsound.findPitch(tag)
	if type(tag) == "string" then return TEsound.pitchLevels[tag] or 1
	elseif type(tag) == "table" then for k,v in ipairs(tag) do if TEsound.pitchLevels[v] then return TEsound.pitchLevels[v] end end
	end
	return 1
end

-- Returns a list of all sound channels within a set of tags.
function TEsound.findAllTags(tags)
	local t = TEsound.channels
	local b = false
	for k,v in ipairs(tags) do
		for channel,sound in ipairs(t) do
			b = false
			if sound.tags and not (#sound.tags < #tags) then for k0,v0 in ipairs(sound.tags) do
				if v0==v then b=true end
			end end
			if not b then table.remove(t,channel) end
		end
	end
	return t
end

-- Recursively turns up a set of sound channels with a set of tags.
function TEsound.findAllTagsRecurse(tags,sounds)
	if type(tags)=='string' then return TEsound.findTag(tag) end
	local sounds = sounds or nil
	local a = sounds==nil
	if a and #tags==1 then return TEsound.findTag(tag[1]) end
	local b = false
	local tag = table.remove(tags, 1)
	for channel,sound in ipairs(sounds or TEsound.channels) do
		if sounds==nil then sounds={} end
		b = false
		if not (a and (#sound.tags < #tags+1)) then for i,v in ipairs(sound.tags) do if v==tag then b=true end end end
		if not a and not b then	table.remove(sounds, channel) elseif a and b then table.insert(sounds, sound) end
	end
	if #tags==0 then return sounds else	return TEsound.findAllTagsRecurse0(tags, sounds) end
end
end end)()end;
do require("package").preload["libs.lume"] = (function() local package;return function(...)-- <pack libs.lume> --
--
-- lume
--
-- Copyright (c) 2014, rxi
--
-- This library is free software; you can redistribute it and/or modify it
-- under the terms of the MIT license. See LICENSE for details.
--

local lume = { _version = "1.4.1" }

local pairs, ipairs = pairs, ipairs
local type, assert, unpack = type, assert, unpack or table.unpack
local tostring, tonumber = tostring, tonumber
local math_floor = math.floor
local math_ceil = math.ceil
local math_random = math.random
local math_cos = math.cos
local math_atan2 = math.atan2
local math_sqrt = math.sqrt
local math_abs = math.abs
local math_pi = math.pi

local patternescape = function(str)
  return str:gsub("[%(%)%.%%%+%-%*%?%[%]%^%$]", "%%%1")
end

local absindex = function(len, i)
  return i < 0 and (len + i + 1) or i
end

local iscallable = function(x)
  if type(x) == "function" then return true end
  local mt = getmetatable(x)
  return mt and mt.__call ~= nil
end



function lume.clamp(x, min, max)
  return x < min and min or (x > max and max or x)
end


function lume.round(x, increment)
  if increment then return lume.round(x / increment) * increment end
  return x > 0 and math_floor(x + .5) or math_ceil(x - .5)
end


function lume.sign(x)
  return x < 0 and -1 or 1
end


function lume.lerp(a, b, amount)
  return a + (b - a) * lume.clamp(amount, 0, 1)
end


function lume.smooth(a, b, amount)
  local t = lume.clamp(amount, 0, 1)
  local m = t * t * (3 - 2 * t)
  return a + (b - a) * m
end


function lume.pingpong(x)
  return 1 - math_abs(1 - x % 2)
end


function lume.distance(x1, y1, x2, y2, squared)
  local dx = x1 - x2
  local dy = y1 - y2
  local s = dx * dx + dy * dy
  return squared and s or math_sqrt(s)
end


function lume.angle(x1, y1, x2, y2)
  return math_atan2(y2 - y1, x2 - x1)
end


function lume.random(a, b)
  if not a then a, b = 0, 1 end
  if not b then b = 0 end
  return a + math_random() * (b - a)
end


function lume.randomchoice(t)
  return t[math_random(#t)]
end


function lume.weightedchoice(t)
  local sum = 0
  for k, v in pairs(t) do
    assert(v >= 0, "weight value less than zero")
    sum = sum + v
  end
  assert(sum ~= 0, "all weights are zero")
  local rnd = lume.random(sum)
  for k, v in pairs(t) do
    if rnd < v then return k end
    rnd = rnd - v
  end
end


function lume.shuffle(t)
  for i = 1, #t do
    local r = math_random(#t)
    t[i], t[r] = t[r], t[i]
  end
  return t
end


function lume.array(...)
  local t = {}
  for x in ... do t[#t + 1] = x end
  return t
end


function lume.each(t, fn, ...)
  if type(fn) == "string" then
    for _, v in pairs(t) do v[fn](v, ...) end
  else
    for _, v in pairs(t) do fn(v, ...) end
  end
  return t
end


function lume.map(t, fn)
  local rtn = {}
  for k, v in pairs(t) do rtn[k] = fn(v) end
  return rtn
end


function lume.all(t, fn)
  fn = fn or function(x) return x end
  for k, v in pairs(t) do
    if not fn(v) then return false end
  end
  return true
end


function lume.any(t, fn)
  fn = fn or function(x) return x end
  for k, v in pairs(t) do
    if fn(v) then return true end
  end
  return false
end


function lume.reduce(t, fn, first)
  local acc = first or t[1]
  assert(acc, "reduce of an empty array with no first value")
  for i = first and 1 or 2, #t do acc = fn(acc, t[i]) end
  return acc
end


function lume.set(t, retainkeys)
  local rtn = {}
  for k, v in pairs(lume.invert(t)) do
    rtn[retainkeys and v or (#rtn + 1)] = k
  end
  return rtn
end


function lume.filter(t, fn, retainkeys)
  local rtn = {}
  for k, v in pairs(t) do
    if fn(v) then rtn[retainkeys and k or (#rtn + 1)] = v end
  end
  return rtn
end


function lume.merge(t, t2, retainkeys)
  for k, v in pairs(t2) do
    t[retainkeys and k or (#t + 1)] = v
  end
  return t
end


function lume.find(t, value)
  for k, v in pairs(t) do
    if v == value then return k end
  end
  return nil
end


function lume.match(t, fn)
  for k, v in pairs(t) do
    if fn(v) then return v, k end
  end
  return nil
end


function lume.count(t, fn)
  local count = 0
  if fn then
    for k, v in pairs(t) do
      if fn(v) then count = count + 1 end
    end
  else
    for k in pairs(t) do count = count + 1 end
  end
  return count
end


function lume.slice(t, i, j)
  i = i and absindex(#t, i) or 1
  j = j and absindex(#t, j) or #t
  local rtn = {}
  for x = i < 1 and 1 or i, j > #t and #t or j do
    rtn[#rtn + 1] = t[x]
  end
  return rtn
end


function lume.invert(t)
  local rtn = {}
  for k, v in pairs(t) do rtn[v] = k end
  return rtn
end


function lume.clone(t)
  local rtn = {}
  for k, v in pairs(t) do rtn[k] = v end
  return rtn
end


function lume.fn(fn, ...)
  assert(iscallable(fn), "expected a function as the first argument")
  local args = {...}
  return function(...)
    local a = lume.merge(lume.clone(args), {...})
    return fn(unpack(a))
  end
end


function lume.once(fn, ...)
  local fn = lume.fn(fn, ...)
  local done = false
  return function(...)
    if done then return end
    done = true
    return fn(...)
  end
end


local memoize_fnkey = {}
local memoize_nil = {}

function lume.memoize(fn)
  local cache = {}
  return function(...)
    local c = cache
    for i = 1, select("#", ...) do
      local a = select(i, ...) or memoize_nil
      c[a] = c[a] or {}
      c = c[a]
    end
    c[memoize_fnkey] = c[memoize_fnkey] or {fn(...)}
    return unpack(c[memoize_fnkey])
  end
end


function lume.combine(...)
  local funcs = {}
  for i = 1, select("#", ...) do
    local fn = select(i, ...)
    if fn ~= nil then
      assert(iscallable(fn), "expected a function or nil")
      funcs[#funcs + 1] = fn
    end
  end
  return function(...)
    for _, f in ipairs(funcs) do f(...) end
  end
end


function lume.time(fn, ...)
  local start = os.clock()
  local rtn = {fn(...)}
  return (os.clock() - start), unpack(rtn)
end


local lambda_cache = {}

function lume.lambda(str)
  if not lambda_cache[str] then
    local args, body = str:match([[^([%w,_ ]-)%->(.-)$]])
    assert(args and body, "bad string lambda")
    local s = "return function(" .. args .. ")\nreturn " .. body .. "\nend"
    lambda_cache[str] = lume.dostring(s)
  end
  return lambda_cache[str]
end


function lume.serialize(x)
  local f = { string = function(v) return string.format("%q", v) end,
              number = tostring, boolean = tostring }
  f.table = function(t)
    local rtn = {}
    for k, v in pairs(t) do
      rtn[#rtn + 1] = "[" .. f[type(k)](k) .. "]=" .. f[type(v)](v) .. ","
    end
    return "{" .. table.concat(rtn) .. "}"
  end
  local err = function(t,k) error("unsupported serialize type: " .. k) end
  setmetatable(f, { __index = err })
  return f[type(x)](x)
end


function lume.deserialize(str)
  return lume.dostring("return " .. str)
end


function lume.split(str, sep)
  if not sep then
    return lume.array(str:gmatch("([%S]+)"))
  else
    assert(sep ~= "", "empty separator")
    local psep = patternescape(sep)
    return lume.array((str..sep):gmatch("(.-)("..psep..")"))
  end
end


function lume.trim(str, chars)
  if not chars then return str:match("^[%s]*(.-)[%s]*$") end
  chars = patternescape(chars)
  return str:match("^[" .. chars .. "]*(.-)[" .. chars .. "]*$")
end


function lume.format(str, vars)
  if not vars then return str end
  local f = function(x)
    return tostring(vars[x] or vars[tonumber(x)] or "{" .. x .. "}")
  end
  return (str:gsub("{(.-)}", f))
end


function lume.trace(...)
  local info = debug.getinfo(2, "Sl")
  local t = { "[" .. info.short_src .. ":" .. info.currentline .. "]" }
  for i = 1, select("#", ...) do
    local x = select(i, ...)
    x = (type(x) == "number") and lume.round(x, .01) or (x or "nil")
    t[#t + 1] = tostring(x)
  end
  print(table.concat(t, " "))
end


function lume.dostring(str)
  return assert((loadstring or load)(str))()
end


function lume.uuid()
  local fn = function(x)
    local r = math_random(16) - 1
    r = (x == "x") and (r + 1) or (r % 4) + 9
    return ("0123456789abcdef"):sub(r, r)
  end
  return (("xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx"):gsub("[xy]", fn))
end


function lume.hotswap(modname)
  local oldglobal = lume.clone(_G)
  local updated = {}
  local function update(old, new)
    if updated[old] then return end
    updated[old] = true
    local oldmt, newmt = getmetatable(old), getmetatable(new)
    if oldmt and newmt then update(oldmt, newmt) end
    for k, v in pairs(new) do
      if type(v) == "table" then update(old[k], v) else old[k] = v end
    end
  end
  local err = nil
  local function onerror(e)
    for k, v in pairs(_G) do _G[k] = oldglobal[k] end
    err = lume.trim(e)
  end
  local ok, oldmod = pcall(require, modname)
  oldmod = ok and oldmod or nil
  xpcall(function()
    package.loaded[modname] = nil
    local newmod = require(modname)
    if type(oldmod) == "table" then update(oldmod, newmod) end
    for k, v in pairs(oldglobal) do
      if v ~= _G[k] and type(v) == "table" then
        update(v, _G[k])
        _G[k] = v
      end
    end
  end, onerror)
  package.loaded[modname] = oldmod
  if err then return nil, err end
  return oldmod
end


function lume.rgba(color)
  local a = math_floor((color / 16777216) % 256)
  local r = math_floor((color /    65536) % 256)
  local g = math_floor((color /      256) % 256)
  local b = math_floor((color) % 256)
  return r, g, b, a
end


local chain_mt = {}
chain_mt.__index = lume.map(lume.filter(lume, iscallable, true),
  function(fn)
    return function(self, ...)
      self._value = fn(self._value, ...)
      return self
    end
  end)
chain_mt.__index.result = function(x) return x._value end

function lume.chain(value)
  return setmetatable({ _value = value }, chain_mt)
end


return lume
end end)()end;
do require("package").preload["libs.monocle"] = (function() local package;return function(...)-- <pack libs.monocle> --
Monocle = {}
function Monocle.new(initial)
	Monocle.active = initial.isActive or false
	Monocle.names = {}
	Monocle.listeners = {}
	Monocle.results = {}

	Monocle.printqueue = {}

	Monocle.commands = {}
	Monocle.cmdresults = {}

	Monocle.text = ''
	Monocle.textCursorPosition = 0

	Monocle.printer = initial.customPrinter or false
	Monocle.printColor = initial.customColor or {64,64,64,128}

	Monocle.debugToggle = initial.debugToggle or '`'

	Monocle.watchedFiles = initial.filesToWatch or {}
	Monocle.watchedFileTimes = {}
	for i, v in ipairs(Monocle.watchedFiles) do
		assert(love.filesystem.getLastModified(v),v .. ' must not exist or is in the wrong directory. Oh no! D:')
		Monocle.watchedFileTimes[i] = love.filesystem.getLastModified(v)
	end

	--Monocle.print('Monocle Initialized.')
end

function Monocle.textinput(text)
	if Monocle.active and text ~= Monocle.debugToggle then
		--Monocle.text = Monocle.text .. text
	elseif text == Monocle.debugToggle then
		Monocle.active = not Monocle.active
	end
end

function Monocle.keypressed(key)
	if Monocle.active then
		-- If entering a command:
		if key == "return" then
			-- parses string

			Monocle.results[Monocle.text] = loadstring('return ' .. Monocle.text)()

			-- Clear Monocle.text.
			Monocle.text = ''

		elseif key == 'backspace' then
			Monocle.text = string.sub(Monocle.text,1,string.len(Monocle.text)-1)
		end
	end
end

function Monocle.print(text,justtext)
	if Monocle.printer and not justtext then
		print("[Monocle]: " .. text)
	elseif justtext then
		return "[Monocle]: " .. text
	end
end


function Monocle.update()
	for key,obj in ipairs(Monocle.listeners) do
		if type(obj) == 'function' then
			Monocle.results[key] = obj() or 'Error!'
		elseif type(obj) == 'table' then
			Monocle.results[key] = 'food'
		end
	end

	for i, v in ipairs(Monocle.watchedFiles) do
		if Monocle.watchedFileTimes[i] ~= love.filesystem.getLastModified(v) then
			print('reloading')
			Monocle.watchedFileTimes[i] = love.filesystem.getLastModified(v)
			love.filesystem.load('main.lua')()
		end
	end
end
function Monocle.watch(name,obj)
	if type(obj) == 'function' then
		Monocle.print('Watching ' .. name)
		table.insert(Monocle.listeners,obj)
		table.insert(Monocle.names,name)
	else
		Monocle.print('Object to watch is not a string')
		error('Object to watch is not a string')
	end
end
--[[ Out of date
function Monocle.unwatch(name)
	Monocle.listeners[name] = nil
	Monocle.results = {}
end
--]]
function Monocle.draw()
	if Monocle.active then
		local oldcolor = {love.graphics.getColor()}
		love.graphics.setColor(Monocle.printColor)
		--love.graphics.print("> " .. Monocle.text .. "|", 0, 0)
		local draw_y = 0
		for name,result in pairs(Monocle.results) do
			if type(result) == 'number' or type(result) == 'string' then
				love.graphics.print(Monocle.names[name] .. " : " .. result, 0, (draw_y + 1) * 15)
			elseif type(result) == 'table' then
				love.graphics.print(Monocle.names[name] .. " : Table:", 0, (draw_y + 1) * 15)
				draw_y = draw_y + 1
				for i,v in pairs(result) do
					love.graphics.print("      " .. i .. " : " .. v, 0, (draw_y + 1) * 15)
					draw_y = draw_y + 1
				end
			end
			draw_y = draw_y + 1
		end	-- For name,result
		love.graphics.setColor(oldcolor)
	end -- Monocle.active
end

--[[local function error_printer(msg, layer)
	print((debug.traceback("Error: " .. tostring(msg), 1+(layer or 1)):gsub("\n[^\n]+$", "")))
end

function love.errhand(msg)
	msg = tostring(msg)

	error_printer(msg, 2)

	if not love.window or not love.graphics or not love.event then
		return
	end

	if not love.graphics.isCreated() or not love.window.isCreated() then
		if not pcall(love.window.setMode, 800, 600) then
			return
		end
	end

	-- Reset state.
	if love.mouse then
		love.mouse.setVisible(true)
		love.mouse.setGrabbed(false)
	end
	if love.joystick then
		for i,v in ipairs(love.joystick.getJoysticks()) do
			v:setVibration() -- Stop all joystick vibrations.
		end
	end
	if love.audio then love.audio.stop() end
	love.graphics.reset()
	love.graphics.setBackgroundColor(89, 157, 220)
	local font = love.graphics.setNewFont(14)

	love.graphics.setColor(255, 255, 255, 255)

	local trace = debug.traceback()

	love.graphics.clear()
	love.graphics.origin()

	local err = {}
	local mon = {}
	for i, v in pairs(Monocle.results) do
		table.insert(mon, Monocle.names[i] .. ": " .. v)
	end
	table.insert(err, "[Monocle] An error has occurred! You can either close this and reload the game, or edit your code and come back to this window. The game should automatically reload it's main.lua file when it detects changes in your files (the files specified by 'filesToWatch' in your Monocle.new() parameters\n")
	table.insert(err, "Error\n")
	table.insert(err, msg.."\n\n")

	for l in string.gmatch(trace, "(.-)\n") do
		if not string.match(l, "boot.lua") then
			l = string.gsub(l, "stack traceback:", "Traceback\n")
			table.insert(err, l)
		end
	end


	local p = table.concat(err, "\n")

	p = string.gsub(p, "\t", "")
	p = string.gsub(p, "%[string \"(.-)\"%]", "%1")

	local function draw()
		love.graphics.clear()
		love.graphics.printf(p, 150, 70, love.graphics.getWidth()-150)
		love.graphics.printf(table.concat(mon,'\n'), 0, 15, 150)
		love.graphics.present()
	end

	while true do
		love.event.pump()

		for e, a, b, c in love.event.poll() do
			if e == "quit" then
				return
			end
			if e == "keypressed" and a == "escape" then
				return
			end
		end

		draw()

		if love.timer then
			love.timer.sleep(0.1)
			for i, v in ipairs(Monocle.watchedFiles) do
				if Monocle.watchedFileTimes[i] ~= love.filesystem.getLastModified(v) then
					print('reloading')
					Monocle.watchedFileTimes[i] = love.filesystem.getLastModified(v)
					love.filesystem.load('main.lua')()
					love.run()
					love.graphics.setBackgroundColor(89, 157, 220)
					love.graphics.setColor(255,255,255)
				end
			end
		end
	end

end]]




return Monocle

end end)()end;
do require("package").preload["server"] = (function() local package;return function(...)-- <pack server> --
--[[ NORMALIZATION:
	clientid == the id of the client according to lube
	playerid == the id of a player in the server_peerlist
]]

server_sendhistory = {}
server_recvhistory = {}

function server_load()
	local socket = require "socket"
	-- begin
	local port = 27020
	server = lube.udpServer()
	server:setPing(true, 0.1, "pingu")
	server.callbacks.recv = server_recv
	server.callbacks.connect = server_connect
	server.callbacks.disconnect = server_disconnect
	print("[LUBE|server] starting...")
	server:listen(tonumber(port))
	game.isServer = true
	print("[LUBE|server] listening on port " .. port)

	server_startedgame = false
	server_coordsupdatetimer = 0
	server_angletimer = 0
	server_peerlist = {}

	server_startgametimer = 0
	clientisnetworkhost = true

	server_inflivesvalue = infinitelives
	server_sharingportalsvalue = playersaresharingportals
	server_infinitetime = infinitetime
	server_mappack = mappack

	server_globalmappacklist = mappackname

	lobby_maxplayers = 10
end
local resyncconfig = false
local resynctimer = -5
local server_pingtimer = 0
local timeouttables = {}
server_coordsupdatedelta = .05
server_clientidlookup = {}

function server_send(cmd, pl, targets)
	local digest = Tserial.pack({cmd=cmd,pl=pl})
	if type(targets)=="number" then
		targets={targets}
	elseif targets==nil then
		targets={}
		for i=1,#server_peerlist do
			table.insert(targets, i)
		end
	end
	--print("DEBUG: "..cmd.." & "..von.serialize(pl).." & "..von.serialize(players))
	for k,v in pairs(targets) do
		if server_sendhistory[server_peerlist[v].clientid]==nil then
			server_sendhistory[server_peerlist[v].clientid]={}
		end
		if server_sendhistory[server_peerlist[v].clientid][cmd]~=digest or bypassdupecheck then
			server_sendhistory[server_peerlist[v].clientid][cmd] = digest
			if v~=1 --[[networkclientnumber]] then
				--if chan~="synccoords" and chan~="otherpointingangle" then
				--[[print("DEBUG: k "..tostring(k))
				print("DEBUG: v "..tostring(v))
				print("DEBUG: cmd "..cmd)
				print("DEBUG: server_peerlist "..von.serialize(server_peerlist))]]
				if server_peerlist[v]==nil then print("INVISIBLE PEER?!") end
				--[[print("DEBUG: server_peerlist[v] "..von.serialize(server_peerlist[v]))
				print("DEBUG: server_peerlist[v].nick "..server_peerlist[v].nick)
				print("DEBUG: server_peerlist[v].clientid "..server_peerlist[v].clientid)]]
				--print("[LUBE|server] Sending command '"..cmd.."' to "..server_peerlist[v].nick.."("..server_peerlist[v].clientid.."|"..v..")")
				--end
				server:send(digest, server_peerlist[v].clientid)
			else
				print("[LUBE|server] Running broadcasted command '"..cmd.."' on self.")
				if _G["client_callback_" .. cmd] then
					_G["client_callback_" .. cmd](pl)
				end
			end
		--else
			--print("SERVER-WARNING-SENDDUPE")
		end
	end
end

function server_connect(clientid)
  print("[LUBE|server] Client " .. clientid .. " connected!")
end

function server_disconnect(clientid)
  print("[LUBE|server] Client " .. clientid .. " disconnected!")
end
function server_getpidfromcid(clientid)
	return server_clientidlookup[clientid]
end
function server_recv(rdata, clientid)
	local data = Tserial.unpack(rdata, true)
	data.pl.clientid = clientid
	data.pl.playerid = server_getpidfromcid(clientid)
	if data.pl.playerid == nil then
		print("WARNING: playerid in inbound message '"..data.cmd.."' was nil.")
	end
	if server_recvhistory[clientid]==nil then
		server_recvhistory[clientid]={}
	end
	if server_recvhistory[clientid][data.cmd]~=rdata or bypassdupecheck then
		server_recvhistory[clientid][data.cmd] = rdata
		print("[LUBE|server] Running client->server command '"..data.cmd.."' from client("..tostring(clientid).."|"..tostring(data.pl.playerid)..")!")
		print("SERVER-DEBUG: "..Tserial.pack(data.pl,true))
		assert(_G["server_callback_"..data.cmd]~=nil, "Received invalid client->server command '"..data.cmd.."'!")
		_G["server_callback_" .. data.cmd](data.pl)
	--else
		--print("SERVER-WARNING-RECVDUPE")
	end
end

function server_update(dt)
	server:update(dt)
	--[[if not server_startedgame then
		server_pingtimer = server_pingtimer + dt
		if server_pingtimer > 2 then
			for k, v in pairs(server_peerlist) do
				server_send("pingupdate", {id=k,ping=v.mostrecentping})
			end

			server_pingtimer = server_pingtimer - 2
			for x = 2, #server_peerlist do
				server_sendto("pingcheck", nil, server_peerlist[x].ip, server_peerlist[x].port)
				server_peerlist[x].countingping = true
				server_peerlist[x].personalpingtimer = 0
			end
		end
	end]]

	--[[for x = 2, #server_peerlist do
		if server_peerlist[x].countingping then
			server_peerlist[x].personalpingtimer = server_peerlist[x].personalpingtimer + dt
		end
	end]]

	--[[if server_resyncmaxplayers then
		server_resyncmaxplayers = false
		for x = 2, #server_peerlist do
			server_sendto("changemax", {lobby_maxplayers}, server_peerlist[x].ip, server_peerlist[x].port)
		end
	end]]
	
	server_coordsupdatetimer = server_coordsupdatetimer + dt
	if server_coordsupdatetimer > server_coordsupdatedelta and server_startedgame and objects then
		server_coordsupdatetimer = server_coordsupdatetimer - server_coordsupdatedelta
		for k, v in pairs(server_peerlist) do
			local tosend={}
			for i=1,#server_peerlist do
				table.insert(tosend, i)
			end
			tosend[k]=nil
			server_send("synccoords", {
				target=k,
				x=objects["player"][k].x,
				y=objects["player"][k].y,
				speedx=objects["player"][k].speedx,
				speedy=objects["player"][k].speedy,
				pointingangle=objects["player"][k].pointingangle, 
				--@DEV: ^ This is here until I write an easier way to manage timers.
				--dt=dt,
			}, tosend)
		end
	end

	--[[if server_angletimer > .1 and server_startedgame and objects then
		server_angletimer = server_angletimer - .1
		for i, v in pairs(server_peerlist) do
			for j, k in pairs(server_peerlist) do
				if i ~= j and k.pointingangle and j ~= 1 then
					server_sendto("otherpointingangle", {id=j,pointingangle=k.pointingangle}, v.ip, v.port)
				elseif j == 1 and i ~= j then
					server_sendto("otherpointingangle", {id=j,pointingangle=objects["player"][1].pointingangle}, v.ip, v.port)
				end
			end
		end
	end]]
	
	if server_startedgame then
		for x = 1, #timeouttables do
			if timeouttables[x] > 20 then
				server_clientquit(nil, x)
			end
		end
	end
end

function server_update2(dt)
	if true then
		if chan == "changemappack" then
			server_mappack = data.mappack
			for x = 2, #server_peerlist do
				server_sendto("changemappack", {mappack=server_mappack}, server_peerlist[x].ip, server_peerlist[x].port)
			end
		end

		local clientnumber = tonumber(data.clientid)
		if not server_peerlist[clientnumber] and not server_startedgame and clientnumber and ip and port then
			--If there's no clientnumber then resend the data
			for i, v in pairs(server_peerlist) do
				server_sendto("clientnumber", {id=i}, v.ip, v.port)
			end
		elseif not server_peerlist[clientnumber] and server_startedgame and clientnumber then
			if clientnumber > #server_peerlist then
				clientnumber = #server_peerlist
			end
		end

		_G["server_" .. chan](clientnumber, data)
		
		if not server_startedgame then
			chan, data, ip, port = server_receivefrom()
		else
			if clientnumber and server_peerlist[clientnumber] then
				timeouttables[clientnumber] = 0 
			end
			chan, data = server_receive()
		end
	end

	if resynctimer >= 0 then
		resynctimer = resynctimer + dt
		if resynctimer > .4 then
			resynctimer = -5
			resyncconfig = true
		end
	end

	--[[if resyncconfig then
		local hasdata = true
		for i, v in pairs(server_peerlist) do
			if not v.hattable or not v.colortable or not v.portalcolors then
				hasdata = false
				break
			end
		end
		if hasdata then
			print("synced config")
			server_syncconfig()
			resyncconfig = false
		end
	end]]


	--[[for i, v in pairs(server_peerlist) do
		for j, k in pairs(server_peerlist) do
			if i~= j and i~= "qcode is best" and j ~= "qcode is best" then
				if v.immediatelysyncangle then
					server_udp:sendto("otherpointingangle;" .. i .. ";" .. v.pointingangle, k.ip, k.port)
				end
			end
		end
	end]]


	


	--socket.sleep(0.01)
end


function server_start()
	print("server_start")
	if server_startedgame then
		for x = 1, #server_peerlist do
			timeouttables[x] = timeouttables[x] + dt
		end
	end
	
	if lobby_currentmappackallowed --[[and #server_peerlist > 1]] then --debug
		server_send("startgame", {numplayers=#server_peerlist})
		server_startedgame = true

		for x = 1, #server_peerlist do
			timeouttables[x] = 0
		end
	end
end

function server_shutserver()
	for x = 2, #server_peerlist do
		server_udp:sendto("quit", server_peerlist[x].ip, server_peerlist[x].port)
	end

	--udp:close()
	clientisnetworkhost = false
	--server_udp:close()
	onlinemp = false
end

-- GREAT BIG LIST OF CALLBACKS
function server_callback_connect(pl)
	if #server_peerlist < lobby_maxplayers then
		--Send swarm of information to a client that connects
		--@TODO: We need to *not* have this prebuilt entities table.
		table.insert(server_peerlist, {clientid=pl.clientid, nick=pl.nick, mappacks=pl.mappacks})
		local respondto = #server_peerlist
		server_clientidlookup[pl.clientid]=respondto
		server_sendhistory[pl.clientid] = {}
		server_recvhistory[pl.clientid] = {}
		local connecttable = {
			yourpid = respondto,
			mappacks = mappacklist,
			inflives = server_inflivesvalue,
			sharingportals = server_sharingportalsvalue,
			infinitetime = server_infinitetime,
			checkboxes = {}
		}
		if server_peerlist[1].checkboxvalues then
			print("yep", #server_peerlist[1].checkboxvalues)
			for k, v in pairs(server_peerlist[1].checkboxvalues) do
				connecttable.checkboxes[k]=v
			end
		end
		--@DEV: don't let this get in the way for now
		--resyncconfig = true
		server_send("connected", connecttable, respondto)
		hook.Call("ServerClientConnected", respondto, pl.clientid)
		return
	else
		server_send("rejected", {reason="lobby full"}, pl.clientid)
	end
end
function server_callback_coordsupdate(pl)
	local sendto={}
	for i=1,#server_peerlist do
		table.insert(sendto, i)
	end
	sendto[pl.playerid]=nil
	pl.target = pl.playerid
	--@TODO: Make the above available in the form of "everyonebut(pls)"
	server_send("synccoords", pl, sendto)
end
function server_callback_controlupdate(pl)
	local sendto={}
	for i=1,#server_peerlist do
		table.insert(sendto, i)
	end
	sendto[pl.playerid]=nil
	pl.target = pl.playerid
	--print("ZDEBUG: "..von.serialize(pl))
	--@TODO: Make the above available in the form of "everyonebut(pls)"
	server_send("synccontrol", pl, sendto)
end
end end)()end;
do require("package").preload["intro"] = (function() local package;return function(...)-- <pack intro> --
function intro_load()
	gamestate = "intro"
	
	introduration = 2.5
	blackafterintro = 0.3
	introfadetime = 0.5
	introprogress = 0
	
	allowskip = false
end

function intro_update(dt)
	allowskip = true
	if introprogress < introduration+blackafterintro then
		introprogress = introprogress + dt
		if introprogress > introduration+blackafterintro then
			introprogress = introduration+blackafterintro
		end
		
		if introprogress > 0.5 and playedwilhelm == nil then
			playsound("stab") --allowed global
			
			playedwilhelm = true
		end
		
		if introprogress == introduration + blackafterintro then
			menu_load()
			shaders:set(1, shaderlist[currentshaderi1])
			shaders:set(2, shaderlist[currentshaderi2])
		end
	end
end

function intro_draw()	
	local logoscale = scale
	if logoscale <= 1 then
		logoscale = 0.5
	else
		logoscale = 1
	end
	
	if introprogress >= 0 and introprogress < introduration then
		local a = 255
		if introprogress < introfadetime then
			a = introprogress/introfadetime * 255
		elseif introprogress >= introduration-introfadetime then
			a = (1-(introprogress-(introduration-introfadetime))/introfadetime) * 255
		end
		
		love.graphics.setColor(255, 255, 255, a)
		
		if introprogress > introfadetime+0.3 and introprogress < introduration - introfadetime then
			local y = (introprogress-0.2-introfadetime) / (introduration-2*introfadetime) * 206 * 5
			love.graphics.draw(logo, love.graphics.getWidth()/2, love.graphics.getHeight()/2, 0, logoscale, logoscale, 142, 150)
			love.graphics.setScissor(0, love.graphics.getHeight()/2+150*logoscale - y, love.graphics.getWidth(), y)
			love.graphics.draw(logoblood, love.graphics.getWidth()/2, love.graphics.getHeight()/2, 0, logoscale, logoscale, 142, 150)
			love.graphics.setScissor()
			
		elseif introprogress >= introduration - introfadetime then
			love.graphics.draw(logoblood, love.graphics.getWidth()/2, love.graphics.getHeight()/2, 0, logoscale, logoscale, 142, 150)
		else
			love.graphics.draw(logo, love.graphics.getWidth()/2, love.graphics.getHeight()/2, 0, logoscale, logoscale, 142, 150)
		end
		
		local a2 = math.max(0, (1-(introprogress-.5)/0.3)*255)
		love.graphics.setColor(150, 150, 150, a2)
		properprint("loading mari0 se..", love.graphics.getWidth()/2-string.len("loading mari0 se..")*4*scale, love.graphics.getHeight()/2-170*logoscale-7*scale)
		love.graphics.setColor(50, 50, 50, a2)
		properprint(loadingtext, love.graphics.getWidth()/2-string.len(loadingtext)*4*scale, love.graphics.getHeight()/2+165*logoscale)
	end
end

function intro_skip()
	if not allowskip then
		return
	end
	soundlist["stab"].source:stop()
	menu_load()
	shaders:set(1, shaderlist[currentshaderi1])
	shaders:set(2, shaderlist[currentshaderi2])
end
end end)()end;
do require("package").preload["regiondrag"] = (function() local package;return function(...)-- <pack regiondrag> --
regiondrag = class("regiondrag")

regiondragboxwidth = 3

function regiondrag:init(x, y, width, height)
	self.x = x-1
	self.y = y-1
	self.width = width or 1
	self.height = height or 1
	
	self.grabbed = 0
end

function regiondrag:update(dt)
	if self.grabbed ~= 0 then
		local mx, my = mouse.getPosition()
		local oldx, oldy, oldwidth, oldheight, oldgrabbed = self.x, self.y, self.width, self.height, self.grabbed
		local tx, ty = getMouseTile(mx-.5*16*scale, my)
		
		--X
		
		if self.grabbed == 1 or self.grabbed == 3 then
			if tx < self.x then
				self.width = self.x-tx+self.width
				self.x = tx
			elseif tx > self.x then
				if tx > self.x+self.width then
					self.grabbed = self.grabbed + 1
					self.x = self.x+self.width
					self.width = tx-self.x
				else
					self.width = self.x-tx+self.width
					self.x = tx
				end
			end
		
		elseif self.grabbed == 2 or self.grabbed == 4 then
			if tx > self.x+self.width then
				self.width = tx-self.x
			elseif tx < self.x+self.width then
				if tx <= self.x then
					self.grabbed = self.grabbed - 1
					self.width = self.x-tx
					self.x = tx
				else
					self.width = tx-self.x
				end
			end
		end
		
		--Y
		
		if self.grabbed == 1 or self.grabbed == 2 then
			if ty < self.y then
				self.height = self.y-ty+self.height
				self.y = ty
			elseif ty > self.y then
				if ty > self.y+self.height then
					self.grabbed = self.grabbed + 2
					self.y = self.y+self.height
					self.height = ty-self.y
				else
					self.height = self.y-ty+self.height
					self.y = ty
				end
			end
		
		elseif self.grabbed == 3 or self.grabbed == 4 then
			if ty > self.y+self.height then
				self.height = ty-self.y
			elseif ty < self.y+self.height then
				if ty <= self.y then
					self.grabbed = self.grabbed - 2
					self.height = self.y-ty
					self.y = ty
				else
					self.height = ty-self.y
				end
			end
		end
		
		if self.grabbed == 5 then
			self.x, self.y = self.movestartx+round((mx-self.movex)/16/scale), self.movestarty+round((my-self.movey)/16/scale)
		end
		
		if self.width == 0 or self.height == 0 then
			self.x, self.y, self.width, self.height, self.grabbed = oldx, oldy, oldwidth, oldheight, oldgrabbed
		end
	end
end

function regiondrag:draw()
	local high = 0
	if self:inhighlight(mouse.getX(), mouse.getY(), 5) and self.grabbed == 0 then
		high = 5
	end
	for i = 1, 4 do
		if self:inhighlight(mouse.getX(), mouse.getY(), i) then
			high = i
			break
		end
	end
	
	if high == 5 or self.grabbed == 5 then
		love.graphics.setColor(255, 255, 255, 100)
	else
		love.graphics.setColor(255, 127, 39, 100)
	end
	love.graphics.rectangle("fill", (self.x-xscroll)*16*scale, (self.y-yscroll-.5)*16*scale, self.width*16*scale, self.height*16*scale)
	
	--edges
	
	for i = 1, 4 do
		local x, y
		
		if i == self.grabbed or (self.grabbed == 0 and high == i) then
			love.graphics.setColor(255, 255, 255, 200)
		else
			love.graphics.setColor(222, 97, 29, 200)
		end
		
		if i == 1 then
			x = (self.x-xscroll)*16*scale
			y = (self.y-yscroll-.5)*16*scale
		elseif i == 2 then
			x = (self.x-xscroll+self.width)*16*scale
			y = (self.y-yscroll-.5)*16*scale
		elseif i == 3 then
			x = (self.x-xscroll)*16*scale
			y = (self.y-yscroll-.5+self.height)*16*scale
		elseif i == 4 then
			x = (self.x-xscroll+self.width)*16*scale
			y = (self.y-yscroll-.5+self.height)*16*scale
		end
		
		love.graphics.rectangle("fill", x-regiondragboxwidth*scale, y-regiondragboxwidth*scale, regiondragboxwidth*2*scale, regiondragboxwidth*2*scale)	
	end
end

function regiondrag:checkGrab(x, y)
	for i = 1, 5 do
		if self:inhighlight(mouse.getX(), mouse.getY(), i) then
			self.grabbed = i
			break
		end
	end
	
	if self.grabbed == 5 then
		self.movex = x
		self.movey = y
		self.movestartx = self.x
		self.movestarty = self.y
	elseif self.grabbed == 0 then
		return true
	end
end

function regiondrag:releaseGrab()
	self.grabbed = 0
end

function regiondrag:inhighlight(x, y, i)
	if i == 1 then
		vx = (self.x-xscroll)*16*scale
		vy = (self.y-yscroll-.5)*16*scale
	elseif i == 2 then
		vx = (self.x-xscroll+self.width)*16*scale
		vy = (self.y-yscroll-.5)*16*scale
	elseif i == 3 then
		vx = (self.x-xscroll)*16*scale
		vy = (self.y-yscroll-.5+self.height)*16*scale
	elseif i == 4 then
		vx = (self.x-xscroll+self.width)*16*scale
		vy = (self.y-yscroll-.5+self.height)*16*scale
	elseif i == 5 then
		return x >= (self.x-xscroll)*16*scale and x < (self.x-xscroll+self.width)*16*scale and y >= (self.y-yscroll-.5)*16*scale and y < (self.y-yscroll-.5+self.height)*16*scale
	end
	
	return x >= vx-regiondragboxwidth*scale and x < vx+regiondragboxwidth*scale and y >= vy-regiondragboxwidth*scale and y < vy+regiondragboxwidth*scale
end
end end)()end;
do require("package").preload["anim"] = (function() local package;return function(...)-- <pack anim> --
anim = class("anim")
--[[
	anim (for lack of the availability of "animation") is for player animations
	
	this is so that the code for handling an animation like mario growing doesn't
	leave the player in a particular weird state that hinges on physical properties
	
	
]]

function anim:init(actor, sequence_name)
	
	self.actor = actor
	-- a reference to the player object we are responsible for managing
	
	self.sequence_name = sequence_name
	-- the name of a sequence to invoke on a player
	
	self.timer = 0
	-- how far along in the animation we are
	self.duration = 0
	-- the total duration of the animation
end


end end)()end;
do require("package").preload["fire"] = (function() local package;return function(...)-- <pack fire> --
fire = class("fire")

function fire:init(x, y)
	--PHYSICS STUFF
	if objects["bowser"][1] then --make bowser fire this
		self.y = objects["bowser"][1].y+0.25
		self.x = objects["bowser"][1].x-0.750
		 
		--get goal Y
		self.targety = objects["bowser"][1].starty-math.random(3)+2/16
	else
		self.y = y-1+1/16
		self.targety = self.y
		self.x = x+6/16
	end
	
	self.speedy = 0
	self.speedx = -firespeed
	
	self.width = 24/16
	self.height = 8/16
	self.active = true
	self.moves = false
	self.autodelete = true
	self.gravity = 0
	self.category = 17
	
	self.mask = {	true,
					true, false, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true}
	
	--IMAGE STUFF
	self.drawable = true
	self.graphic = fireimg
	self.quad = firequad[1]
	self.offsetX = 0
	self.offsetY = 8
	self.quadcenterX = 0
	self.quadcenterY = 0
	
	self.rotation = 0 --for portals
	self.timer = 0
	self.quadi = 1
	
	playsound("fire", self.x, self.y, self.speedx, self.speedy)
end

function fire:update(dt)
	--animate
	self.timer = self.timer + dt
	while self.timer > fireanimationdelay do
		if self.quadi == 2 then
			self.quadi = 1
		else
			self.quadi = 2
		end
		
		self.quad = firequad[self.quadi]
		self.timer = self.timer - fireanimationdelay
	end
	
	self.x = self.x + self.speedx*dt
	
	if self.y > self.targety then
		self.y = self.y - fireverspeed*dt
		if self.y < self.targety then
			self.y = self.targety
		end
	elseif self.y < self.targety then
		self.y = self.y + fireverspeed*dt
		if self.y > self.targety then
			self.y = self.targety
		end
	end
end

function fire:leftcollide(a, b)
	return false
end

function fire:rightcollide(a, b)
	return false
end

function fire:floorcollide(a, b)
	return false
end

function fire:ceilcollide(a, b)
	return false
end
end end)()end;
do require("package").preload["itemanimation"] = (function() local package;return function(...)-- <pack itemanimation> --
itemanimation = class("itemanimation")

function itemanimation:init(x, y, i)
	self.x = x
	self.y = y
	self.i = i
	self.timer = 0
	
	self.v = enemiesdata[self.i]
end

function itemanimation:update(dt)
	self.timer = self.timer + dt
	if self.timer >= mushroomtime then
		table.insert(objects["enemy"], enemy:new(self.x, self.y-1, self.i, map[self.x][self.y]))
		return true
	end
end

function itemanimation:draw()
	local yoffset = self.timer/mushroomtime*1
	love.graphics.setScissor((self.x-xscroll-6)*16*scale, (self.y-yscroll-6.5)*16*scale, 176*scale, 80*scale)
	love.graphics.draw(self.v.graphic, self.v.quad, math.floor(((self.x-xscroll-.5-self.v.width/2+(self.v.spawnoffsetx or 0))*16+self.v.offsetX)*scale), math.floor(((self.y-yscroll-yoffset-self.v.height+(self.v.spawnoffsety or 0))*16-self.v.offsetY)*scale), 0, scale, scale, self.v.quadcenterX, self.v.quadcenterY)
	love.graphics.setScissor()
end
end end)()end;
do require("package").preload["notice"] = (function() local package;return function(...)-- <pack notice> --
notice = {}
notice.red = {255, 127, 127}
notice.white = {255, 255, 255}
notice.notices = {}
notice.duration = 5 --seconds
notice.fadetime = 0.5

function notice.new(text, color, duration)
	local duration = duration or notice.duration
	local text = text or ""
	local color = color or notice.white
	table.insert(notice.notices, {text=text:lower(), color=color, life=duration, duration=duration})
end 

function notice.update(dt)
	for i = #notice.notices, 1, -1 do
		local v = notice.notices[i]
		
		v.life = v.life - dt
		
		if v.life <= 0 then
			table.remove(notice.notices, i)
		end
	end
end

function notice.draw()
	local y = 0
	for i = #notice.notices, 1, -1 do
		local v = notice.notices[i]
		
		--get width by finding longest line
		local split = v.text:split("|")
		local longest = #split[1]
		for i = 2, #split do
			if #split[i] > longest then
				longest = #split[i]
			end
		end
		
		local height = #split*10+3
		
		local actualy = notice.gety(y, v.life, height, v.duration)
		
		local targetrect = {width*16 - longest*8-5, actualy, longest*8+5, height}
		local scissor = {(width*16 - longest*8-5)*scale, y*scale, (longest*8+5)*scale, (actualy-y+height)*scale}
		--This freezes the menu for some reason
		--Spent a goddamn hour debugging this
		--FML
		--love.graphics.setScissor(unpack(scissor))
		
		love.graphics.setColor(0, 0, 0, 200)
		love.graphics.rectangle("fill", targetrect[1]*scale, targetrect[2]*scale, targetrect[3]*scale, targetrect[4]*scale)
		
		love.graphics.setColor(255, 255, 255, 255)
		drawrectangle(targetrect[1]+1, targetrect[2]+1, targetrect[3]-2, targetrect[4]-2)
		
		love.graphics.setColor(v.color)
		properprint(v.text, (targetrect[1]+2)*scale, (actualy+3)*scale)
		y = actualy+height
		--love.graphics.setScissor()
	end
	
	love.graphics.setColor(255, 255, 255)
end

function notice.gety(y, life, height, duration)
	if life > duration-notice.fadetime then
		return y - height*((life-(duration-notice.fadetime))/notice.fadetime)^2
	elseif life < notice.fadetime then
		return y - height*((notice.fadetime-life)/notice.fadetime)^2
	else
		return y
	end
end
end end)()end;
do require("package").preload["screenboundary"] = (function() local package;return function(...)-- <pack screenboundary> --
screenboundary = class("screenboundary")

function screenboundary:init(x)
	self.x = x
	self.y = -1000	
	self.width = 0
	self.height = 1000+mapheight
	self.moves = false
	self.active = true
	self.category = 10
	self.mask = {true}
end 
end end)()end;
do require("package").preload["imgurupload"] = (function() local package;return function(...)-- <pack imgurupload> --
-- WHOO BOY THANK THE LORDY FOR SSL FROM http://love2d.org/forums/viewtopic.php?f=5&t=76728
require("libs.ssl")
require("libs.https")
local https = require("ssl.https")
local ltn12 = require("ltn12")

local CLIENT_ID = "4ce94df6f78813c" --dedicated to uploading images of crashes/misbehaviors in this game

function upload_imagedata(oname, imagedata)
	local outname = oname or "temp.png"
	imagedata:encode(outname)
	local idata, isize = love.filesystem.read(outname)
	local t = {}
	local reqbody = idata
	https.request({
		url = "https://api.imgur.com/3/image",
		sink = ltn12.sink.table(t),
		source = ltn12.source.string(reqbody),
		method = "POST",
		headers = {
			["Authorization"] = "Client-ID "..CLIENT_ID,
			["content-length"] = string.len(reqbody),
			["content-type"] = "multipart/form-data",
		},
	})
	return JSON:decode(table.concat(t))
end
end end)()end;
do require("package").preload["animationsystem"] = (function() local package;return function(...)-- <pack animationsystem> --
function animationsystem_load()
	animationtriggerfuncs = {}
	animations = {}
	
	local dir = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/animations")
	
	for i = 1, #dir do
		if string.sub(dir[i], -4) == "json" then
			table.insert(animations, animation:new("mappacks/" .. mappack .. "/animations/" .. dir[i], dir[i]))
		end
	end 
end

function animationsystem_update(dt)
	if not editormode then
		for i, v in pairs(animations) do
			v:update(dt)
		end
	end
end

function animationsystem_draw()
	if not editormode then
		for i, v in pairs(animations) do
			v:draw()
		end
	end
end
end end)()end;
do require("package").preload["customhats"] = (function() local package;return function(...)-- <pack customhats> --
--Not the hatloader mod.

function loadhat(path)
	local s = love.filesystem.read(path)
	if not s then
		return
	end
	 
	local s1 = s:split("|")
	
	if #s1 ~= 8 then
		return
	end
	
	if not love.filesystem.exists("hats/" .. s1[7] .. ".png") or not love.filesystem.exists("hats/" .. s1[8] .. ".png") then
		return
	end
	
	table.insert(hat, {x = s1[1], y = s1[2], height = s1[3], graphic = love.graphics.newImage("hats/" .. s1[7] .. ".png")})
	table.insert(bighat, {x = s1[4], y = s1[5], height = s1[6], graphic = love.graphics.newImage("hats/" .. s1[8] .. ".png")})
	
	hatcount = hatcount + 1
end

local files = love.filesystem.getDirectoryItems("hats")

for i, v in pairs(files) do
	if string.sub(v, -3, -1) == "txt" then
		loadhat("hats/" .. v)
	end
end
end end)()end;
do require("package").preload["levelscreen"] = (function() local package;return function(...)-- <pack levelscreen> --
function levelscreen_load(reason, i)
	--check if lives left
  help_tipi = math.random(1,#help_tips)
	livesleft = true
	--[[for i = 1, players do
		if mariolivecount == false or objects["player"][i].lives > 0 then
			livesleft = true
		end
	end]]
	
	if reason == "sublevel" then
		gamestate = "sublevelscreen"
		blacktime = sublevelscreentime
		sublevelscreen_level = i
	elseif reason == "vine" then
		gamestate = "sublevelscreen"
		blacktime = sublevelscreentime
		sublevelscreen_level = i
	elseif livesleft then
		gamestate = "levelscreen"
		blacktime = levelscreentime
		if reason == "next" then --next level
			checkpointsub = false
			checkpointx = {}
			checkpointy = {}
			respawnsublevel = 0
			
			--check if next level doesn't exist
			if not love.filesystem.exists("mappacks/" .. mappack .. "/" .. marioworld .. "-" .. mariolevel .. ".txt") then
				gamestate = "mappackfinished"
				blacktime = gameovertime
				music:play("princessmusic.ogg")
			end
		end
	else
		gamestate = "gameover"
		blacktime = gameovertime
		playsound("gameover") --no players loaded at this point, allowed global
	end
	
	if editormode then
		blacktime = 0
	end
	
	if reason ~= "initial" then
		updatesizes()
	end
	
	if marioworld == 1 or mariolevel == 1 then
		blacktime = blacktime * 1.5
	end
	
	coinframe = 1
	redcoinframe = 1
	
	love.graphics.setBackgroundColor(0, 0, 0)
	levelscreentimer = 0
	
	--reached worlds
	local updated = false
	if not reachedworlds[mappack] then
		reachedworlds[mappack] = {}
	end
	
	if marioworld ~= "M" and not reachedworlds[mappack][marioworld] then
		reachedworlds[mappack][marioworld] = true
		updated = true
	end
	
	if updated then
		saveconfig()
	end
	
	--Load the level
	
	if gamestate == "levelscreen" then
		if respawnsublevel ~= 0 then
			loadlevel(marioworld .. "-" .. mariolevel .. "_" .. respawnsublevel)
		else
			loadlevel(marioworld .. "-" .. mariolevel)
		end
	elseif gamestate == "sublevelscreen" then
		loadlevel(sublevelscreen_level)
	end
	
	if skiplevelscreen and gamestate ~= "gameover" and gamestate ~= "mappackfinished" then
		startlevel(gamestate == "levelscreen")
	end
end

function levelscreen_update(dt)
	levelscreentimer = levelscreentimer + dt
	if levelscreentimer > blacktime then
		if gamestate == "levelscreen" or gamestate == "sublevelscreen" then
			startlevel(gamestate == "levelscreen")
		else
			menu_load()
		end
		
		return
	end
end

function levelscreen_draw()
	--black background
	love.graphics.setColor(0, 0, 0)
	love.graphics.rectangle("fill", 0, 0, width*16*scale, height*16*scale)
	love.graphics.setColor(255, 255, 255)

	if levelscreenback then
		love.graphics.draw(levelscreenback, 0, 0, 0, scale, scale)
	end
	
	if levelscreentimer < blacktime - blacktimesub and levelscreentimer > blacktimesub then
		if gamestate == "levelscreen" then
			properprint("world " .. marioworld .. "-" .. mariolevel, (width/2*16)*scale-40*scale, 72*scale - (players-1)*6*scale)
			
			if not arcade and not mkstation then
				for i = 1, players do
					local x = width/2*16-29
					local y = 97 + (i-1)*20 - (players-1)*8
							
					local v = characters[mariocharacter[i]]
					local angle = 3
					if v.nopointing then
						angle = 1
					end
					
					local pid = i
					if pid > 4 then
						pid = 5
					end
					
					
					
					drawplayer(nil, x+6, y+11, scale,     v.smalloffsetX, v.smalloffsetY, 0, v.smallquadcenterX, v.smallquadcenterY, "idle", false, false, mariohats[i], v.animations, v.idle[angle], 0, false, false, mariocolors[i], 1, portalcolor[i][1], portalcolor[i][2], nil, nil, nil, nil, nil, nil, characters[mariocharacter[i]])
					
					love.graphics.setColor(255, 255, 255, 255)
					if mariolivecount == false then
						properprint("*  inf", (width/2*16)*scale-8*scale, y*scale+7*scale)
					else
						properprint("*  " .. objects["player"][i].lives, (width/2*16)*scale-8*scale, y*scale+7*scale)
					end
				end
			end
			
			
			if mappack == "smb" then
				local  s = help_tips[help_tipi]
				properprint(s, (width/2*16)*scale-string.len(s)*4*scale, 200*scale)
			end
			
			if mappack == "portal" and marioworld == 1 and mariolevel == 1 then
				local s = "you can remove your portals with "
				--[[for i = 1, #controls[1]["reload"] do
					s = s .. controls[1]["reload"][i]
					if i ~= #controls[1]["reload"] then
						s = s .. "-"
					end
				end]]
				s = s .. "hard work and dedication"
				properprint(s, (width/2*16)*scale-string.len(s)*4*scale, 190*scale)
				
				local s = "you can grab cubes and push buttons with "
				--[[for i = 1, #controls[1]["use"] do
					s = s .. controls[1]["use"][i]
					if i ~= #controls[1]["use"] then
						s = s .. "-"
					end
				end]]
				s = s .. "your hands"
				properprint(s, (width/2*16)*scale-string.len(s)*4*scale, 200*scale)
			end
			
		elseif gamestate == "mappackfinished" then
			properprint("congratulations!", (width/2*16)*scale-64*scale, 120*scale)
			properprint("you have finished this mappack!", (width/2*16)*scale-128*scale, 140*scale)
		else
			local s = "game over"
			properprint(s, (width/2*16)*scale-40*scale, 120*scale)
		end
		
		love.graphics.translate(0, -yoffset*scale)
		if yoffset < 0 then
			love.graphics.translate(0, yoffset*scale)
		end
		
		drawui(true)
	end
end
end end)()end;
do require("package").preload["bighatconfigs"] = (function() local package;return function(...)-- <pack bighatconfigs> --
bighat = {}

table.insert(bighat, {x = 0, y = 0, height = 4, graphic = love.graphics.newImage("standardbighats/standard.png")})

table.insert(bighat, {x = -2, y = -3, height = 5, graphic = love.graphics.newImage("standardbighats/tyrolean.png")})

table.insert(bighat, {x = -2, y = -2, height = 5, graphic = love.graphics.newImage("standardbighats/towering1.png")})

table.insert(bighat, {x = -2, y = -8, height = 9, graphic = love.graphics.newImage("standardbighats/towering2.png")})

table.insert(bighat, {x = -3, y = -1, height = 2, graphic = love.graphics.newImage("standardbighats/towering3.png")})

table.insert(bighat, {x = -1, y = -7, height = 10, graphic = love.graphics.newImage("standardbighats/drseuss.png")})

table.insert(bighat, {x = -3, y = -8, height = 8, graphic = love.graphics.newImage("standardbighats/bird.png")})

table.insert(bighat, {x = -3, y = -2, height = 3, graphic = love.graphics.newImage("standardbighats/banana.png")})

table.insert(bighat, {x = 1, y = -3, height = 3, graphic = love.graphics.newImage("standardbighats/beanie.png")})

table.insert(bighat, {x = -1, y = -5, height = 8, graphic = love.graphics.newImage("standardbighats/toilet.png")})

table.insert(bighat, {x = -1, y = -4, height = 5, graphic = love.graphics.newImage("standardbighats/indian.png")})

table.insert(bighat, {x = -1, y = -2, height = 4, graphic = love.graphics.newImage("standardbighats/officerhat.png")})

table.insert(bighat, {x = -2, y = -3, height = 7, graphic = love.graphics.newImage("standardbighats/crown.png")})

table.insert(bighat, {x = -2, y = -7, height = 10, graphic = love.graphics.newImage("standardbighats/tophat.png")})

table.insert(bighat, {x = -2, y = 1, height = 3, graphic = love.graphics.newImage("standardbighats/batter.png")})

table.insert(bighat, {x = -2, y = 0, height = 3, graphic = love.graphics.newImage("standardbighats/bonk.png")})

table.insert(bighat, {x = 0, y = 0, height = 4, graphic = love.graphics.newImage("standardbighats/bakerboy.png")})

table.insert(bighat, {x = -3, y = 0, height = 3, graphic = love.graphics.newImage("standardbighats/troublemaker.png")})

table.insert(bighat, {x = 0, y = 0, height = 4, graphic = love.graphics.newImage("standardbighats/whoopee.png")})

table.insert(bighat, {x = -1, y = -1, height = 4, graphic = love.graphics.newImage("standardbighats/milkman.png")})

table.insert(bighat, {x = -2, y = 1, height = 3, graphic = love.graphics.newImage("standardbighats/bombingrun.png")})

table.insert(bighat, {x = -4, y = 3, height = 0, graphic = love.graphics.newImage("standardbighats/bonkboy.png")})

table.insert(bighat, {x = -2, y = -1, height = 4, graphic = love.graphics.newImage("standardbighats/flippedtrilby.png")})

table.insert(bighat, {x = 0, y = -1, height = 3, graphic = love.graphics.newImage("standardbighats/superfan.png")})

table.insert(bighat, {x = -1, y = -2, height = 4, graphic = love.graphics.newImage("standardbighats/familiarfez.png")})

table.insert(bighat, {x = -3, y = -1, height = 4, graphic = love.graphics.newImage("standardbighats/santahat.png")})

table.insert(bighat, {x = -1, y = 0, height = 3, graphic = love.graphics.newImage("standardbighats/sailor.png")})

table.insert(bighat, {x = -3, y = 0, height = 5, graphic = love.graphics.newImage("standardbighats/koopa.png")})

table.insert(bighat, {x = -2, y = -5, height = 5, graphic = love.graphics.newImage("standardbighats/blooper.png")})

table.insert(bighat, {x = -1, y = 1, height = 3, graphic = love.graphics.newImage("standardbighats/shyguy.png")})

table.insert(bighat, {x = -1, y = 3, height = 4, graphic = love.graphics.newImage("standardbighats/goodnewseverybody.png")})

table.insert(bighat, {x = -3, y = -1, height = 5, graphic = love.graphics.newImage("standardbighats/jetset.png")})

table.insert(bighat, {x = -1, y = 0, height = 3, graphic = love.graphics.newImage("standardbighats/jotaro.png")})

table.insert(bighat, {x = -1, y = -3, height = 4, graphic = love.graphics.newImage("standardbighats/dio.png")})

table.insert(bighat, {x = -1, y = -2, height = 14, graphic = love.graphics.newImage("standardbighats/flabber.png")})

table.insert(bighat, {x = -1, y = -2, height = 14, graphic = love.graphics.newImage("standardbighats/he.png")})

table.insert(bighat, {x = -1, y = -2, height = 14, graphic = love.graphics.newImage("standardbighats/mario3coon.png")})

table.insert(bighat, {x = -4, y = -5, height = 14, graphic = love.graphics.newImage("standardbighats/hothead.png")})

table.insert(bighat, {x = -5, y = -5, height = 14, graphic = love.graphics.newImage("standardbighats/praisethesun.png")})

table.insert(bighat, {x = -4, y = -6, height = 14, graphic = love.graphics.newImage("standardbighats/flycap.png")})

table.insert(bighat, {x = -3, y = -1, height = 14, graphic = love.graphics.newImage("standardbighats/konamim.png")})

table.insert(bighat, {x = -7, y = -12, height = 14, graphic = love.graphics.newImage("standardbighats/bighead.png")})
end end)()end;
do require("package").preload["editor"] = (function() local package;return function(...)-- <pack editor> --
-- unused for now
editor_undohistory = {}
--indexed by operation stack, largest number is most recent
--[[element example:
	{
	op="tile",
	data={
		before=map[x][y],
		after=map[x][y],
	},
	}
]]
testbed = {}

require "editortool"
local editortoollist = love.filesystem.getDirectoryItems("tools")
local editortools = {}

for k,v in pairs(editortoollist) do
	editortoollist[k] = v:sub(0,-5)
	require("tools."..editortoollist[k])
	editortools[editortoollist[k]] = _G[editortoollist[k]]:new()
	editortools[editortoollist[k]].name = editortoollist[k]
end

function changeTool(toolname, ...)
	local arg={...}
	print("changeTool for "..toolname.." called with:")
	table.print(arg)
	previouseditortool = activeeditortool
	previouseditortool.active = false
	activeeditortool = editortools[toolname]
	activeeditortool:change(unpack(arg))
	activeeditortool.active = true
end

function previousTool()
	local temp = activeeditortool
	activeeditortool = previouseditortool
	previouseditortool = temp
	previouseditortool.active = false
	activeeditortool.active = true
	-- Will this even work? Who knows.
end

function editor_load()
	print("Editor loaded!")
	editorstate = "main"
	activeeditortool = editortools["notool"]
	changeTool("paintdraw")
	editorignorerelease = false --this is an ugly hack until we figure out how to wrangle our inputs
	editorignoretap = false
	currentanimation = 1
	tilecount1 = 168
	tilecount2 = 74
	
	tooltipa = 0
	
	tilesoffset = 0
	
	minimapscroll = 0
	minimapx = 3
	minimapy = 30
	minimapheight = 15
	
	currenttile = 1
	
	rightclicka = 0
	
	minimapscrollspeed = 30
	minimapdragging = false
	
	allowdrag = true
	
	--get current description and shit
	local mappackname = ""
	local mappackauthor = ""
	local mappackdescription = ""
	if love.filesystem.exists("mappacks/" .. mappack .. "/settings.txt") then
		local data = love.filesystem.read("mappacks/" .. mappack .. "/settings.txt")
		local split1 = data:split("\n")
		for i = 1, #split1 do
			local split2 = split1[i]:split("=")
			if split2[1] == "name" then
				mappackname = split2[2]:lower()
			elseif split2[1] == "author" then
				mappackauthor = split2[2]:lower()
			elseif split2[1] == "description" then
				mappackdescription = split2[2]:lower()
			end
		end
	end
	
	guielements["tabmain"] = guielement:new("button", 1, 1, "main", maintab, 3)
	guielements["tabmain"].fillcolor = {63, 63, 63}
	guielements["tabtiles"] = guielement:new("button", 43, 1, "tiles", tilestab, 3)
	guielements["tabtiles"].fillcolor = {63, 63, 63}
	guielements["tabtools"] = guielement:new("button", 93, 1, "tools", toolstab, 3)
	guielements["tabtools"].fillcolor = {63, 63, 63}
	guielements["tabmaps"] = guielement:new("button", 143, 1, "maps", mapstab, 3)
	guielements["tabmaps"].fillcolor = {63, 63, 63}
	guielements["tabanimations"] = guielement:new("button", 185, 1, "animations", animationstab, 3)
	guielements["tabanimations"].fillcolor = {63, 63, 63}
	
	--MAIN
	--left side
	guielements["colorsliderr"] = guielement:new("scrollbar", 17, 75, 101, 11, 11, background[1]/255, "hor")
	guielements["colorsliderr"].backgroundcolor = {255, 0, 0}
	guielements["colorsliderg"] = guielement:new("scrollbar", 17, 87, 101, 11, 11, background[2]/255, "hor")
	guielements["colorsliderg"].backgroundcolor = {0, 255, 0}
	guielements["colorsliderb"] = guielement:new("scrollbar", 17, 99, 101, 11, 11, background[3]/255, "hor")
	guielements["colorsliderb"].backgroundcolor = {0, 0, 255}
	
	for i = 1, #backgroundcolor do
		guielements["defaultcolor" .. i] = guielement:new("button", 125+(math.mod(i-1, 3))*12, 63+(math.ceil(i/3))*12, "", defaultbackground, 0, {i}, 1, 8)
		guielements["defaultcolor" .. i].fillcolor = backgroundcolor[i]
	end
	
	local args = {unpack(musiclist)}
	local musici = 1
	for i = 1, #args do
		if args[i] == musicname then
			musici = i
		end
		args[i] = string.lower(string.sub(args[i], 1, -5))
	end
	
	guielements["musicdropdown"] = guielement:new("dropdown", 17, 125, 11, changemusic, musici, unpack(args))
	guielements["spritesetdropdown"] = guielement:new("dropdown", 17, 150, 11, changespriteset, spriteset, "overworld", "underground", "castle", "underwater")
	guielements["timelimitdecrease"] = guielement:new("button", 17, 175, "{", decreasetimelimit, 0, nil, nil, nil, true)
	guielements["timelimitincrease"] = guielement:new("button", 31 + string.len(mariotimelimit)*8, 175, "}", increasetimelimit, 0, nil, nil, nil, true)
	
	local i = 1
	if portalsavailable[1] and not portalsavailable[2] then
		i = 2
	elseif not portalsavailable[1] and portalsavailable[2] then
		i = 3
	elseif not portalsavailable[1] and not portalsavailable[2] then
		i = 4
	end
	guielements["portalgundropdown"] = guielement:new("dropdown", 87, 187, 6, changeportalgun, i, "both", "blue", "orange", "none")
	
	--right side
	guielements["autoscrollcheckbox"] = guielement:new("checkbox", 290, 20, toggleautoscroll, autoscroll, "follow mario")
	
	guielements["intermissioncheckbox"] = guielement:new("checkbox", 200, 66, toggleintermission, intermission, "intermission")
	guielements["warpzonecheckbox"] = guielement:new("checkbox", 200, 81, togglewarpzone, haswarpzone, "warpzone text")
	guielements["underwatercheckbox"] = guielement:new("checkbox", 200, 96, toggleunderwater, underwater, "underwater")
	guielements["bonusstagecheckbox"] = guielement:new("checkbox", 200, 111, togglebonusstage, bonusstage, "bonus stage")
	guielements["custombackgroundcheckbox"] = guielement:new("checkbox", 200, 126, togglecustombackground, custombackground, "background:")
	guielements["customforegroundcheckbox"] = guielement:new("checkbox", 200, 156, togglecustomforeground, customforeground, "foreground:")
	
	--bottom
	guielements["savebutton"] = guielement:new("button", 10, 200, "save", savelevel, 2)
	guielements["menubutton"] = guielement:new("button", 54, 200, "menu", menu_load, 2)
	guielements["newlevellabel"] = guielement:new("text", 98, 204, "new:", {128,128,128})
	guielements["newsublevelbutton"] = guielement:new("button", 128, 200, "sub", new_level, 2, {true})
	guielements["newlevelbutton"] = guielement:new("button", 162, 200, "level", new_level, 2)
	guielements["testbutton"] = guielement:new("button", 252, 200, "test", test_level, 2)
	guielements["widthbutton"] = guielement:new("button", 296, 200, "size", openchangewidth, 2)
	
	guielements["savebutton"].bordercolor = {255, 0, 0}
	guielements["savebutton"].bordercolorhigh = {255, 127, 127}
	
	--maybe I should use webkit next time
	--hahahahhahahaha no
	
	--mapsize stuff
	guielements["maptopup"] = guielement:new("button", 0, 0, "_dir4", changenewmapsize, nil, {"top", "up"}, nil, 8, 0.02)
	guielements["maptopdown"] = guielement:new("button", 0, 0, "_dir6", changenewmapsize, nil, {"top", "down"}, nil, 8, 0.02)
	guielements["mapleftleft"] = guielement:new("button", 0, 0, "_dir3", changenewmapsize, nil, {"left", "left"}, nil, 8, 0.02)
	guielements["mapleftright"] = guielement:new("button", 0, 0, "_dir5", changenewmapsize, nil, {"left", "right"}, nil, 8, 0.02)
	guielements["maprightleft"] = guielement:new("button", 0, 0, "_dir3", changenewmapsize, nil, {"right", "left"}, nil, 8, 0.02)
	guielements["maprightright"] = guielement:new("button", 0, 0, "_dir5", changenewmapsize, nil, {"right", "right"}, nil, 8, 0.02)
	guielements["mapbottomup"] = guielement:new("button", 0, 0, "_dir4", changenewmapsize, nil, {"bottom", "up"}, nil, 8, 0.02)
	guielements["mapbottomdown"] = guielement:new("button", 0, 0, "_dir6", changenewmapsize, nil, {"bottom", "down"}, nil, 8, 0.02)
	
	guielements["mapwidthapply"] = guielement:new("button", 0, 0, "apply", mapwidthapply, 3)
	guielements["mapwidthcancel"] = guielement:new("button", 0, 0, "cancel", mapwidthcancel, 3)
	
	local args = {unpack(custombackgrounds)}
	table.insert(args, 1, "default")
	
	local i = 1
	for j = 1, #custombackgrounds do
		if custombackground == custombackgrounds[j] then
			i = j+1
		end
	end
	
	guielements["backgrounddropdown"] = guielement:new("dropdown", 298, 125, 10, changebackground, i, unpack(args))
	
	args = {unpack(custombackgrounds)}
	table.insert(args, 1, "none")
	
	i = 1
	for j = 1, #custombackgrounds do
		if customforeground == custombackgrounds[j] then
			i = j+1
		end
	end
	
	guielements["foregrounddropdown"] = guielement:new("dropdown", 298, 155, 10, changeforeground, i, unpack(args))
	
	guielements["scrollfactorscrollbar"] = guielement:new("scrollbar", 298, 140, 93, 35, 11, reversescrollfactor(), "hor")
	guielements["fscrollfactorscrollbar"] = guielement:new("scrollbar", 298, 170, 93, 35, 11, reversefscrollfactor(), "hor")
	
	args = {unpack(levelscreens)}
	table.insert(args, 1, "none")
	
	i = 1
	for j = 1, #levelscreens do
		if levelscreenbackname == levelscreens[j] then
			i = j+1
		end
	end
	
	guielements["levelscreendropdown"] = guielement:new("dropdown", 298, 185, 10, changelevelscreen, i, unpack(args))
	
	--TOOLS
	livesanchorx = 340
	guielements["selectionbutton"] = guielement:new("button", 5, 22, "select", selectionbutton, 2, false)
	-- 4, 383)
	--"selection tool|click and drag to select entities|rightclick to configure all at once|hit del to delete."
	guielements["selectionbutton"].bordercolor = {0, 255, 0}
	guielements["selectionbutton"].bordercolorhigh = {220, 255, 220}
	
	guielements["lightdrawbutton"] = guielement:new("button", 5, 22+18, "ant line", lightdrawbutton, 2, false)
	-- 2, 383)
	-- "power line draw|click and drag to draw power lines"
	guielements["lightdrawbutton"].bordercolor = {0, 0, 255}
	guielements["lightdrawbutton"].bordercolorhigh = {127, 127, 255}
	
	guielements["liveslabel"] = guielement:new("text", livesanchorx-48, 205-18, "lives:")
	guielements["livesdecrease"] = guielement:new("button", livesanchorx, 203-18, "{", livesdecrease, 0)
	
	local increasex = 0
	local whattowrite = "???"
	if mariolivecount == 0 then
		mariolivecount = false
		whattowrite = "inf"
		increasex = livesanchorx + 14 + 24
	elseif mariolivecount > 999 then
		whattowrite = "why"
		increasex = livesanchorx + 14 + 24
	else
		whattowrite = mariolivecount
	end
	increasex = livesanchorx + 14 + string.len(whattowrite)*8
	guielements["livesnum"] = guielement:new("text", livesanchorx+12, 205-18, whattowrite)
	guielements["livesincrease"] = guielement:new("button", increasex, 203-18, "}", livesincrease, 0)
	
	guielements["edittitle"] = guielement:new("input", 5, 205-20, 17, nil, mappackname, 17)
	guielements["editauthorlabel"] = guielement:new("text", 5, 205+4, "by:", {128, 128, 128})
	guielements["editauthor"] = guielement:new("input", 5+32, 205, 13, nil, mappackauthor, 13)
	guielements["editdescription"] = guielement:new("input", 150, 203-18, 17, nil, mappackdescription, 51, 3)
	guielements["savesettings"] = guielement:new("button", 294, 203, "save info", savesettings, 2)
	guielements["savesettings"].bordercolor = {255, 0, 0}
	guielements["savesettings"].bordercolorhigh = {255, 127, 127}
	
	--MAPS
	
	--animationS
	testbed.animations = nodetree:new(animations, animationlist)
	testbed.maps = maptree:new()
	testbed.tiles = tiletree:new()
	
	if editorloadopen then
		editoropen()
		editorloadopen = false
	else
		editorstate = "main"
		editentities = false
		editorclose()
	end
end

function editor_start()
	editormode = true
	players = 1
	playertype = "portalgun"
	playertypei = 1
	for k,v in pairs(cheats_active) do
		cheats_active[k] = false
	end
	game_load()
end

function editor_update(dt)
	----------
	--EDITOR--
	----------
	if rightclickm then
		rightclickm:update(dt)
		if rightclicka < 1 then
			rightclicka = math.min(1, rightclicka + dt/linktoolfadeouttimefast)
		end
	elseif not rightclickactive then
		if rightclicka > 0 then
			rightclicka = math.max(0, rightclicka - dt/linktoolfadeouttimefast)
		end
	end
	
	if changemapwidthmenu then
		return
	end
	
	for k,v in pairs(testbed) do
		if v.active then
			v:update(dt)
		end
	end
end

function switch_tileset(tileset)
	if testbed.tiles then
		testbed.tiles:selectview(table.find(testbed.tiles.buildfrom, tileset))
	end
end

function editor_draw()	
	love.graphics.setColor(255, 255, 255)
	
	local mousex, mousey = mouse.getPosition()
	
	--EDITOR
	if editormenuopen == false then
		if activeeditortool then
			activeeditortool:draw()
		end
		
		-- draw all entities that have outputs
		if rightclickactive then
			local cox, coy = getMouseTile(mousex, mousey+8*scale)
			
			local table1 = {}
			for i, v in pairs(outputsi) do
				table.insert(table1, v)
			end
			
			for x = math.floor(xscroll), math.floor(xscroll)+width+1 do
				for y = math.floor(yscroll), math.floor(yscroll)+height+1 do
					for i, v in pairs(table1) do
						if inmap(x, y) and #map[x][y] > 1 and map[x][y][2] == v then							
							local r = map[x][y]
							local drawline = false
							
							if cox == x and coy == y and table.contains(outputsi, map[x][y][2]) then
								love.graphics.setColor(255, 255, 150, 255)
							elseif table.contains(outputsi, map[x][y][2]) then
								love.graphics.setColor(255, 255, 150, 150)
							end
							love.graphics.rectangle("fill", math.floor((x-xscroll-1)*16*scale), ((y-1-yscroll)*16-8)*scale, 16*scale, 16*scale)
						end
					end
				end
			end
		end
		
		-- draw all the links, ever
		
		-- WARNING: This branch of code is so unperformant it can slay the framerate.
		-- I'm talking 450fps down to 200fps, yowza.
		if drawalllinks then
			local added = 0
			for x = 1, mapwidth do
				for y = 1, mapheight do
					local tx, ty = x, y
					local x1, y1
					local x2, y2
					
					x1, y1 = math.floor((tx-xscroll-.5)*16*scale), math.floor((ty-yscroll-1)*16*scale)
					
					local drawtable = {}
					
					for i = 1, #map[tx][ty] do
						if map[tx][ty][i] == "link" then
							x2, y2 = math.floor((map[tx][ty][i+2]-xscroll-.5)*16*scale), math.floor((map[tx][ty][i+3]-yscroll-1)*16*scale)
							
							local t = map[tx][ty][i+1]
							added = added + 0.2
							local color = getrainbowcolor(0.7)
							table.insert(drawtable, {x1, y1, x2, y2, t, color})
						end
					end
					
					table.sort(drawtable, function(a,b) return math.abs(a[3]-a[1])>math.abs(b[3]-b[1]) end)
					
					for i = 1, #drawtable do
						local x1, y1, x2, y2, t, c = unpack(drawtable[i])
						local r, g, b = unpack(c)
						love.graphics.setColor(r, g, b, math.max(0, (1-rightclicka)*255))
						
						if math.mod(i, 2) == 0 then
							drawlinkline2(x1, y1, x2, y2)
						else
							drawlinkline(x1, y1, x2, y2)
						end
						properprintbackground(t, math.floor(x2-string.len(t)*4*scale), y2+10*scale, true, {r, g, b, math.max(0, (1-rightclicka)*255)})
					end
				end
			end
		end
		
		
		if (rightclickactive or rightclickm) and editorstate ~= "lightdraw" or rightclicka > 0 then
			local tx, ty
			local x1, y1
			local x2, y2
			
			if rightclickm then
				tx = rightclickm.tx
				ty = rightclickm.ty
				x1, y1 = math.floor((tx-xscroll-.5)*16*scale), math.floor((ty-yscroll-1)*16*scale)
			-- i have no idea what this does, but it WILL break things
			else
				tx = rightclickoldX
				ty = rightclickoldY
				x1, y1 = math.floor((tx-xscroll-.5)*16*scale), math.floor((ty-yscroll-1)*16*scale)
			end
			
			local drawtable = {}
			
			--faithplate paths
			if entitylist[map[tx][ty][2]].t == "faithplate" then
				local yoffset = -8/16
				local x = tx
				local y = ty-1
				local pointstable = {{x=x, y=y+yoffset}}
				
				local speedx, speedy
				
				if rightclickm then
					speedx = rightclickm.t[2].value
					speedy = -rightclickm.t[4].value
				else
					speedx = tonumber(map[tx][ty][3])
					speedy = -tonumber(map[tx][ty][4])
				end
				
				local step = 1/60
				
				repeat
					x, y = x+speedx*step, y+speedy*step
					speedy = speedy + yacceleration*step
					table.insert(pointstable, {x=x, y=y+yoffset})
				until y > yscroll+height+.5
				
				love.graphics.setColor(62, 213, 244, 150*rightclicka)
				for i = 1, #pointstable-1 do
					local v = pointstable[i]
					local w = pointstable[i+1]
					love.graphics.line((v.x-xscroll)*16*scale, (v.y-yscroll-.5)*16*scale, (w.x-xscroll)*16*scale, (w.y-yscroll-.5)*16*scale)
				end
			end 
		end
		if rightclickm then
			rightclickm:draw()
		end
	else
		if changemapwidthmenu then
			local w = width*16-52
			local h = height*16-52
			
			local s = math.min(w/newmapwidth, h/newmapheight)
			
			w = newmapwidth*s
			h = newmapheight*s
			
			local mapx, mapy = (width*16 - w)/2, (height*16 - h)/2
			
			love.graphics.setColor(0, 0, 0, 200)
			love.graphics.rectangle("fill", (mapx-2)*scale, (mapy-2)*scale, (w+4)*scale, (h+4)*scale)
			
			
			--minimap
			for x = 1, mapwidth do
				for y = 1, mapheight do
					if x > -newmapoffsetx and x <= newmapwidth-newmapoffsetx and y > -newmapoffsety and y <= newmapheight-newmapoffsety then
						local id = map[x][y][1]
						if id ~= nil and rgblist[id] and id ~= 0 and tilequads[id]:getproperty("invisible", x, y) == false then
							love.graphics.setColor(unpack(rgblist[id]))
							love.graphics.rectangle("fill", (mapx+(x-1+newmapoffsetx)*s)*scale, (mapy+(y-1+newmapoffsety)*s)*scale, s*scale, s*scale)
						end
					end
				end
			end
			
			love.graphics.setColor(255, 0, 0, 255)
			drawrectangle(mapx-1, mapy-1, w+2, h+2)
			
			love.graphics.setColor(255, 255, 255)
			properprintbackground("old width: " .. mapwidth, 26*scale, (mapy-21)*scale, true)
			properprintbackground("old height: " .. mapheight, 26*scale, (mapy-11)*scale, true)
			
			properprintbackground("new width: " .. newmapwidth, 26*scale, (mapy+h+4)*scale, true)
			properprintbackground("new height: " .. newmapheight, 26*scale, (mapy+h+14)*scale, true)
			
			--button positioning
			guielements["maptopup"].x, guielements["maptopup"].y = width*8-5, mapy-24
			guielements["maptopdown"].x, guielements["maptopdown"].y = width*8-5, mapy-13
			
			guielements["mapbottomup"].x, guielements["mapbottomup"].y = width*8-5, mapy+h+2
			guielements["mapbottomdown"].x, guielements["mapbottomdown"].y = width*8-5, mapy+h+13
			
			guielements["mapleftleft"].x, guielements["mapleftleft"].y = mapx-24, height*8-5
			guielements["mapleftright"].x, guielements["mapleftright"].y = mapx-13, height*8-5
			
			guielements["maprightleft"].x, guielements["maprightleft"].y = mapx+w+2, height*8-5
			guielements["maprightright"].x, guielements["maprightright"].y = mapx+w+13, height*8-5
			
			guielements["mapwidthapply"].x, guielements["mapwidthapply"].y = width*8+10, mapy+h+4
			guielements["mapwidthcancel"].x, guielements["mapwidthcancel"].y = width*8+65, mapy+h+4
		else
			love.graphics.setColor(0, 0, 0, 230)
			
			if minimapdragging == false then
				love.graphics.rectangle("fill", 1*scale, 18*scale, 398*scale, 205*scale)		
			else
				love.graphics.rectangle("fill", 1*scale, 18*scale, 398*scale, (18+minimapheight*2)*scale)
			end
			
			--GUI not priority
			for i, v in pairs(guielements) do
				if not v.priority and v.active then
					v:draw()
				end
			end

			--GUI priority
			for i, v in pairs(guielements) do
				if v.priority and v.active then
					v:draw()
				end
			end
			
			if editorstate == "tiles" then
				if testbed.tiles and testbed.tiles.active then
					testbed.tiles:draw()
				end
			elseif editorstate == "main" then		
				--MINIMAP
				love.graphics.setColor(255, 255, 255)
				properprint("minimap", 3*scale, 21*scale)
				love.graphics.rectangle("fill", minimapx*scale, minimapy*scale, 394*scale, minimapheight*2*scale+4*scale)
				love.graphics.setColor(unpack(background))
				love.graphics.rectangle("fill", (minimapx+2)*scale, (minimapy+2)*scale, 390*scale, minimapheight*2*scale)
				
				local lmap = map
				
				love.graphics.setScissor((minimapx+2)*scale, (minimapy+2)*scale, 390*scale, minimapheight*2*scale)
				
				for x = 1, mapwidth do --blocks
					for y = math.floor(yscroll)+1, math.min(mapheight, math.ceil(yscroll)+16) do
						if x-minimapscroll > 0 and x-minimapscroll < 196 then
							local id = lmap[x][y][1]
							if id ~= nil and id ~= 0 and tilequads[id]:getproperty("invisible", x, y) == false then
								if rgblist[id] then
									love.graphics.setColor(unpack(rgblist[id]))
									love.graphics.rectangle("fill", (minimapx+x*2-minimapscroll*2)*scale, (minimapy+(y+1)*2-(math.floor(yscroll)+1)*2-math.mod(yscroll, 1)*2)*scale, 2*scale, 2*scale)
								end
							end
						end
					end
				end
				
				love.graphics.setScissor()
				
				love.graphics.setColor(255, 0, 0)
				drawrectangle(xscroll*2+minimapx-minimapscroll*2, minimapy, (width+2)*2, minimapheight*2+4)
				drawrectangle(xscroll*2+minimapx-minimapscroll*2+1, minimapy+1, (width+1)*2, minimapheight*2+2)
				love.graphics.setColor(255, 255, 255)
				
				if minimapdragging == false then
					properprint("portalgun:", 8*scale, 189*scale)
					properprint(mariotimelimit, 29*scale, 177*scale)
					properprint("timelimit", 8*scale, 166*scale)
					properprint("spriteset", 8*scale, 141*scale)
					properprint("music", 8*scale, 116*scale)
					properprint("background color", 8*scale, 66*scale)
					
					if custombackground then
						love.graphics.setColor(255, 255, 255, 255)
					else
						love.graphics.setColor(150, 150, 150, 255)
					end
					properprint("scrollfactor", 199*scale, 142*scale)
					
					if customforeground then
						love.graphics.setColor(255, 255, 255, 255)
					else
						love.graphics.setColor(150, 150, 150, 255)
					end
					properprint("scrollfactor", 199*scale, 172*scale)
					
					love.graphics.setColor(255, 255, 255, 255)
					properprint("levelscreen:", 198*scale, 187*scale)
				end
			elseif editorstate == "maps" then
				if testbed.maps and testbed.maps.active then
					testbed.maps:draw()
				end
			elseif editorstate == "tools" then
				--nothing here, we turned all the stray text into labels
			elseif editorstate == "animations" then
				if testbed.animations and testbed.animations.active then
					testbed.animations:draw()
				end
			end
		end
	end
	
	if minimapdragging then
		for i, v in pairs({"tabmain", "tabtiles", "tabtools", "tabmaps", "tabanimations", "autoscrollcheckbox"}) do
			guielements[v]:draw()
		end
	end
end

function maintab()
	if _G["from" .. editorstate .. "tab"] then
		_G["from" .. editorstate .. "tab"]()
	end

	editorstate = "main"
	for i, v in pairs(guielements) do
		v.active = false
	end
	
	guielements["tabmain"].fillcolor = {0, 0, 0}
	guielements["tabtiles"].fillcolor = {63, 63, 63}
	guielements["tabtools"].fillcolor = {63, 63, 63}
	guielements["tabmaps"].fillcolor = {63, 63, 63}
	guielements["tabanimations"].fillcolor = {63, 63, 63}
	guielements["tabmain"].active = true
	guielements["tabtiles"].active = true
	guielements["tabtools"].active = true
	guielements["tabmaps"].active = true
	guielements["tabanimations"].active = true
	
	guielements["colorsliderr"].active = true
	guielements["colorsliderg"].active = true
	guielements["colorsliderb"].active = true
	for i = 1, #backgroundcolor do
		guielements["defaultcolor" .. i].active = true
	end
	
	guielements["autoscrollcheckbox"].active = true
	guielements["musicdropdown"].active = true
	guielements["spritesetdropdown"].active = true
	guielements["timelimitdecrease"].active = true
	guielements["timelimitincrease"].active = true
	guielements["portalgundropdown"].active = true
	guielements["savebutton"].active = true
	guielements["menubutton"].active = true
	guielements["newlevellabel"].active = true
	guielements["newsublevelbutton"].active = true
	guielements["newlevelbutton"].active = true
	guielements["testbutton"].active = true
	guielements["widthbutton"].active = true
	guielements["intermissioncheckbox"].active = true
	guielements["warpzonecheckbox"].active = true
	guielements["underwatercheckbox"].active = true
	guielements["bonusstagecheckbox"].active = true
	guielements["custombackgroundcheckbox"].active = true
	guielements["customforegroundcheckbox"].active = true
	guielements["scrollfactorscrollbar"].active = true
	guielements["fscrollfactorscrollbar"].active = true
	guielements["backgrounddropdown"].active = true
	guielements["foregrounddropdown"].active = true
	guielements["levelscreendropdown"].active = true
end

function tilestab()
	if _G["from" .. editorstate .. "tab"] then
		_G["from" .. editorstate .. "tab"]()
	end

	editorstate = "tiles"
	for i, v in pairs(guielements) do
		v.active = false
	end
	
	guielements["tabmain"].fillcolor = {63, 63, 63}
	guielements["tabtiles"].fillcolor = {0, 0, 0}
	guielements["tabtools"].fillcolor = {63, 63, 63}
	guielements["tabmaps"].fillcolor = {63, 63, 63}
	guielements["tabanimations"].fillcolor = {63, 63, 63}
	guielements["tabmain"].active = true
	guielements["tabtiles"].active = true
	guielements["tabtools"].active = true
	guielements["tabmaps"].active = true
	guielements["tabanimations"].active = true
	
	testbed.tiles:activate()
end

function toolstab()
	if _G["from" .. editorstate .. "tab"] then
		_G["from" .. editorstate .. "tab"]()
	end

	editorstate = "tools"
	for i, v in pairs(guielements) do
		v.active = false
	end
	
	guielements["tabmain"].fillcolor = {63, 63, 63}
	guielements["tabtiles"].fillcolor = {63, 63, 63}
	guielements["tabtools"].fillcolor = {0, 0, 0}
	guielements["tabmaps"].fillcolor = {63, 63, 63}
	guielements["tabanimations"].fillcolor = {63, 63, 63}
	guielements["tabmain"].active = true
	guielements["tabtiles"].active = true
	guielements["tabtools"].active = true
	guielements["tabmaps"].active = true
	guielements["tabanimations"].active = true
	
	-- hoo boy
	guielements["selectionbutton"].active = true
	guielements["lightdrawbutton"].active = true
	guielements["edittitle"].active = true
	guielements["editauthorlabel"].active = true
	guielements["editauthor"].active = true
	guielements["editdescription"].active = true
	guielements["savesettings"].active = true
	
	guielements["livesdecrease"].active = true
	guielements["liveslabel"].active = true
	guielements["livesnum"].active = true
	guielements["livesincrease"].active = true
end

function mapstab()
	if _G["from" .. editorstate .. "tab"] then
		_G["from" .. editorstate .. "tab"]()
	end

	editorstate = "maps"
	for i, v in pairs(guielements) do
		v.active = false
	end
	
	guielements["tabmain"].fillcolor = {63, 63, 63}
	guielements["tabtiles"].fillcolor = {63, 63, 63}
	guielements["tabtools"].fillcolor = {63, 63, 63}
	guielements["tabmaps"].fillcolor = {0, 0, 0}
	guielements["tabanimations"].fillcolor = {63, 63, 63}
	guielements["tabmain"].active = true
	guielements["tabtiles"].active = true
	guielements["tabtools"].active = true
	guielements["tabmaps"].active = true
	guielements["tabanimations"].active = true
	
	testbed.maps:activate()
end

function animationstab()
	if _G["from" .. editorstate .. "tab"] then
		_G["from" .. editorstate .. "tab"]()
	end
	
	editorstate = "animations"
	
	for i, v in pairs(guielements) do
		v.active = false
	end
	
	guielements["tabmain"].fillcolor = {63, 63, 63}
	guielements["tabtiles"].fillcolor = {63, 63, 63}
	guielements["tabtools"].fillcolor = {63, 63, 63}
	guielements["tabmaps"].fillcolor = {63, 63, 63}
	guielements["tabanimations"].fillcolor = {0, 0, 0}
	guielements["tabmain"].active = true
	guielements["tabtiles"].active = true
	guielements["tabtools"].active = true
	guielements["tabmaps"].active = true
	guielements["tabanimations"].active = true
	
	--@NODETREE
	testbed.animations:activate()
end

function fromanimationstab()
	testbed.animations:deactivate()
	testbed.animations:save()
end

function frommapstab()
	testbed.maps:deactivate()
end

function fromtoolstab()
	guielements["tabmain"].active = false
	guielements["tabtiles"].active = false
	guielements["tabtools"].active = false
	guielements["tabmaps"].active = false
	guielements["tabanimations"].active = false
	
	-- hoo boy
	guielements["selectionbutton"].active = false
	guielements["lightdrawbutton"].active = false
	guielements["edittitle"].active = false
	guielements["editauthorlabel"].active = false
	guielements["editauthor"].active = false
	guielements["editdescription"].active = false
	guielements["savesettings"].active = false
	
	guielements["livesdecrease"].active = false
	guielements["liveslabel"].active = false
	guielements["livesnum"].active = false
	guielements["livesincrease"].active = false
end

function fromtilestab()
	guielements["tabmain"].active = false
	guielements["tabtiles"].active = false
	guielements["tabtools"].active = false
	guielements["tabmaps"].active = false
	guielements["tabanimations"].active = false
	
	testbed.tiles:deactivate()
end

function frommaintab()
	guielements["tabmain"].active = false
	guielements["tabtiles"].active = false
	guielements["tabtools"].active = false
	guielements["tabmaps"].active = false
	guielements["tabanimations"].active = false
	
	guielements["colorsliderr"].active = false
	guielements["colorsliderg"].active = false
	guielements["colorsliderb"].active = false
	for i = 1, #backgroundcolor do
		guielements["defaultcolor" .. i].active = false
	end
	
	guielements["autoscrollcheckbox"].active = false
	guielements["musicdropdown"].active = false
	guielements["spritesetdropdown"].active = false
	guielements["timelimitdecrease"].active = false
	guielements["timelimitincrease"].active = false
	guielements["portalgundropdown"].active = false
	guielements["savebutton"].active = false
	guielements["menubutton"].active = false
	guielements["newlevellabel"].active = false
	guielements["newsublevelbutton"].active = false
	guielements["newlevelbutton"].active = false
	guielements["testbutton"].active = false
	guielements["widthbutton"].active = false
	guielements["intermissioncheckbox"].active = false
	guielements["warpzonecheckbox"].active = false
	guielements["underwatercheckbox"].active = false
	guielements["bonusstagecheckbox"].active = false
	guielements["custombackgroundcheckbox"].active = false
	guielements["customforegroundcheckbox"].active = false
	guielements["scrollfactorscrollbar"].active = false
	guielements["fscrollfactorscrollbar"].active = false
	guielements["backgrounddropdown"].active = false
	guielements["foregrounddropdown"].active = false
	guielements["levelscreendropdown"].active = false
end

function openchangewidth()
	for i, v in pairs(guielements) do
		v.active = false
	end
	
	guielements["maptopup"].active = true
	guielements["maptopdown"].active = true
	guielements["mapbottomup"].active = true
	guielements["mapbottomdown"].active = true
	guielements["mapleftleft"].active = true
	guielements["mapleftright"].active = true
	guielements["maprightleft"].active = true
	guielements["maprightright"].active = true
	guielements["mapwidthapply"].active = true
	guielements["mapwidthcancel"].active = true

	changemapwidthmenu = true
	newmapwidth = mapwidth
	newmapheight = mapheight
	newmapoffsetx = 0
	newmapoffsety = 0
end

function mapwidthapply()
	changemapwidthmenu = false
	objects["tile"] = {}
	
	local newmap = {}
	local newcoinmap = {}
	for x = 1, newmapwidth do
		newmap[x] = {}
		newcoinmap[x] = {}
		for y = 1, newmapheight do
			local oldx, oldy = x-newmapoffsetx, y-newmapoffsety
			if inmap(oldx, oldy) then
				newmap[x][y] = map[oldx][oldy]
				newcoinmap[x][y] = coinmap[oldx][oldy]
			else
				newmap[x][y] = {1, gels={}, portaloverride={}}
			end
			
			if tilequads[newmap[x][y][1]]:getproperty("collision", x, y) then
				objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1, 1, 1, true)
			end
		end
	end
	
	objects["player"][1].x = objects["player"][1].x + newmapoffsetx
	objects["player"][1].y = objects["player"][1].y + newmapoffsety
	
	xscroll = xscroll + newmapoffsetx
	yscroll = yscroll + newmapoffsety
	
	if xscroll < 0 then
		xscroll = 0
	end
	
	if xscroll > mapwidth-width then
		xscroll = math.max(0, mapwidth-width)
		hitrightside()
	end
	
	map = newmap
	coinmap = newcoinmap
	mapwidth = newmapwidth
	mapheight = newmapheight
	
	--Update animatedtimers
	animatedtimers = {}
	for x = 1, mapwidth do
		if not animatedtimers[x] then
			animatedtimers[x] = {}
		end
	end
	
	--move all them links!
	for x = 1, mapwidth do
		for y = 1, mapheight do
			for i, v in pairs(map[x][y]) do
				if v == "link" then
					map[x][y][i+2] = map[x][y][i+2] + newmapoffsetx
					map[x][y][i+3] = map[x][y][i+3] + newmapoffsety
				end
			end
		end
	end
	
	objects["screenboundary"]["right"].x = mapwidth
	generatespritebatch()
	
	editorclose()
	
	--maintab()
end

function mapwidthcancel()
	changemapwidthmenu = false
	editorclose()
	--maintab()
end

function changenewmapsize(side, dir)
	if side == "top" then
		if dir == "up" then
			newmapheight = newmapheight + 1
			newmapoffsety = newmapoffsety + 1
		else
			if newmapheight > 15 then
				newmapheight = newmapheight - 1
				newmapoffsety = newmapoffsety - 1
			end
		end
	elseif side == "bottom" then
		if dir == "up" then
			if newmapheight > 15 then
				newmapheight = newmapheight - 1
			end
		else
			newmapheight = newmapheight + 1
		end
	elseif side == "left" then
		if dir == "left" then
			newmapwidth = newmapwidth + 1
			newmapoffsetx = newmapoffsetx + 1
		else
			if newmapwidth > 1 then
				newmapwidth = newmapwidth - 1
				newmapoffsetx = newmapoffsetx - 1
			end
		end
	elseif side == "right" then
		if dir == "left" then
			if newmapwidth > 1 then
				newmapwidth = newmapwidth - 1
			end
		else
			newmapwidth = newmapwidth + 1
		end
	end
end


function placetile(x, y, t, ent)
	local editentities = ent or editentities
	local currenttile = t or currenttile
	local cox, coy = getMouseTile(x, y+8*scale)
	
	if inmap(cox, coy) == false then
		return
	end
	
	if editentities == false then
		coinmap[cox][coy] = tilequads[currenttile]:getproperty("coin")
		
		if tilequads[currenttile]:getproperty("collision") == true and tilequads[map[cox][coy][1]]:getproperty("collision") == false then
			objects["tile"][cox .. "-" .. coy] = tile:new(cox-1, coy-1, 1, 1, true)
		elseif tilequads[currenttile]:getproperty("collision") == false and tilequads[map[cox][coy][1]]:getproperty("collision") == true then
			objects["tile"][cox .. "-" .. coy] = nil
		end
		if map[cox][coy][1] ~= currenttile then
			map[cox][coy][1] = currenttile
			map[cox][coy]["gels"] = {}
			generatespritebatch()
		end
		
		if currenttile == 136 then
			placetile(x+16*scale, y, 137)
			placetile(x, y+16*scale, 138)
			placetile(x+16*scale, y+16*scale, 139)
		end
		
	else
		local t = map[cox][coy]
		if editenemies == false and entitylist[currenttile].t == "remove" then --removing tile
			for i = 2, #map[cox][coy] do
				map[cox][coy][i] = nil
			end
		else
			for i = 3, #map[cox][coy] do
				map[cox][coy][i] = nil
			end
			
			map[cox][coy][2] = currenttile
			
			if editenemies == false then
				if rightclickmenues[entitylist[currenttile].t] then
					for i = 1, #rightclickmenues[entitylist[currenttile].t] do
						local v = rightclickmenues[entitylist[currenttile].t][i]
						if table.contains(rightclickelementslist, v.t) then
							if v.default then
								table.insert(map[cox][coy], v.default)
							else
								table.insert(map[cox][coy], "nil")
							end
						end
					end
				end
			else --Enemy rightclick menu?
				--no
			end
		end
	end
end

function editorclose()
	editormenuopen = false
	for i, v in pairs(guielements) do
		v.active = false
	end
	if editorstate == "main" then
		frommaintab()
	elseif editorstate == "tiles" then
		fromtilestab()
	elseif editorstate == "tools" then
		fromtoolstab()
	elseif editorstate == "maps" then
		frommapstab()
	elseif editorstate == "animations" then
		fromanimationstab()
	end
end

function editoropen()
	for i = 1, players do
		objects["player"][i]:removeportals()
	end
	if editorstate == "lightdraw" or editorstate == "selection" then
		editorstate = "tools"
	end
	closerightclickmenu()
	finishregion()
	editormenuopen = true
	
	if mariolivecount == false or mariolivecount > 999 then
		guielements["livesincrease"].x = livesanchorx + 14 + 24
	else
		guielements["livesincrease"].x = livesanchorx + 14 + string.len(mariolivecount)*8
	end
	guirepeattimer = 0
	--getmaps()
	
	selectionx, selectiony, selectionwidth, selectionheight = nil, nil, nil, nil
	
	if editorstate == "main" then
		maintab()
	elseif editorstate == "tiles" then
		tilestab()
	elseif editorstate == "tools" then
		toolstab()
	elseif editorstate == "maps" then
		mapstab()
	elseif editorstate == "animations" then
		animationstab()
	end
end

function editor_controlupdate(dt)
	local x, y = getMousePos()
	local button = "honk" --for the sake of Just Getting It To Work For Now(tm)
	
	-- one-press shortcuts
	if controls.tap.editorTabMain then
		editoropen()
		maintab()
	elseif controls.tap.editorTabTiles then
		tilestab()
		editoropen()
	elseif controls.tap.editorTabTools then
		editoropen()
		toolstab()
	elseif controls.tap.editorTabMaps then
		editoropen()
		mapstab()
	elseif controls.tap.editorTabAnimations then
		editoropen()
		animationstab()
	end
	
	if controls.tap.editorQuickToggle then
		if editormenuopen then
			editorclose()
		else
			editoropen()
		end
	end
	
	if controls.tap.editorNextLevel then
		mapnumberclick(marioworld, mariolevel+1, mariosublevel, true)
	elseif controls.tap.editorPreviousLevel then
		mapnumberclick(marioworld, mariolevel-1, mariosublevel, true)
	end
	
	if controls.editorShortcutModifier then
		if controls.tap.editorCameraFollowToggle then
			toggleautoscroll()
		end
		
		if controls.tap.editorErase then
			currenttile = 1
			editenemies = false
			editentities = not editentities
		end
		
		if controls.tap.editorQuickSave then
			savemap(currentmap)
		end
		
		if controls.tap.editorTestLevelToggle then
			if testlevel then
				editorloadopen = false
				checkpointsub = false
				marioworld = testlevelworld
				mariolevel = testlevellevel
				testlevel = false
				editormode = true
				
				if mariosublevel > 0 then
					loadlevel(marioworld .. "-" .. mariolevel .. "_" .. mariosublevel)
				else
					loadlevel(marioworld .. "-" .. mariolevel)
				end
				startlevel()
				--editor_load()
			else
				test_level()
			end
		end
		
		if controls.tap.editorTilesAll then
			switch_tileset("all")
			editoropen()
			tilestab()
		elseif controls.tap.editorTilesSMB then
			switch_tileset("smb")
			editoropen()
			tilestab()
		elseif controls.tap.editorTilesPortal then
			switch_tileset("portal")
			editoropen()
			tilestab()
		elseif controls.tap.editorTilesCustom then
			switch_tileset("custom")
			editoropen()
			tilestab()
		elseif controls.tap.editorTilesAnimated then
			switch_tileset("animated")
			editoropen()
			tilestab()
		elseif controls.tap.editorTilesEntities then
			switch_tileset("entities")
			editoropen()
			tilestab()
		elseif controls.tap.editorTilesEnemies then
			switch_tileset("enemies")
			editoropen()
			tilestab()
		end
	end
	
	
	
	-- constants and paints
	if controls.editorPaint and not testlevel and not editormenuopen then
		if editorstate == "main" and editormenuopen then
			local mousex, mousey = mouse.getPosition()
			if mousey >= minimapy*scale and mousey < (minimapy+minimapheight*2+4)*scale then
				if mousex >= minimapx*scale and mousex < (minimapx+394)*scale then
					--HORIZONTAL
					if mousex < (minimapx+width)*scale then
						if minimapscroll > 0 then
							minimapscroll = minimapscroll - minimapscrollspeed*dt
							if minimapscroll < 0 then
								minimapscroll = 0
							end
						end
					elseif mousex >= (minimapx+394-width)*scale then
						if minimapscroll < mapwidth-width-170 then
							minimapscroll = minimapscroll + minimapscrollspeed*dt
							if minimapscroll > mapwidth-width-170 then
								minimapscroll = mapwidth-width-170
							end
						end
					end
					
					--VERTICAL
					if mousey < (minimapy+5)*scale then
						if yscroll > 0 then
							yscroll = yscroll - minimapscrollspeed*dt
							if yscroll < 0 then
								yscroll = 0
							end
						end
					elseif mousey >= (minimapy+minimapheight*2+4-5)*scale then
						if yscroll < mapheight-height then
							yscroll = yscroll + minimapscrollspeed*dt
							if yscroll > mapheight-height-1 then
								yscroll = mapheight-height-1
							end
						end
					end
				
					xscroll = (mousex/scale-3-width) / 2 + minimapscroll
					
					if xscroll < minimapscroll then
						xscroll = minimapscroll
					end
					if xscroll > 170 + minimapscroll then
						xscroll = 170 + minimapscroll
					end
					if xscroll > mapwidth-width then
						xscroll = mapwidth-width
					end

					--SPRITEBATCH UPDATE
					if math.floor(xscroll) ~= spritebatchX[1] then
						generatespritebatch()
						spritebatchX[1] = math.floor(xscroll)
					elseif math.floor(yscroll) ~= spritebatchY[1] then
						generatespritebatch()
						spritebatchY[1] = math.floor(yscroll)
					end
				end
			end
			
			updatescrollfactor()
			updatefscrollfactor()
			updatebackground()
		end
	end
	
	-- scroll, bias: up & left
	if controls.editorScrollLeft and not editormenuopen then
		autoscroll = false
		guielements["autoscrollcheckbox"].var = autoscroll
		xscroll = xscroll - 30*gdt
		if xscroll < 0 then
			xscroll = 0
		end
		generatespritebatch()
	elseif controls.editorScrollRight and not editormenuopen then
		autoscroll = false
		guielements["autoscrollcheckbox"].var = autoscroll
		xscroll = xscroll + 30*gdt
		if xscroll > mapwidth-width then
			xscroll = mapwidth-width
		end
		generatespritebatch()
	end
	if controls.editorScrollUp and not editormenuopen then
		autoscroll = false
		guielements["autoscrollcheckbox"].var = autoscroll
		yscroll = yscroll - 30*gdt
		if yscroll < 0 then
			yscroll = 0
		end
		generatespritebatch()
	elseif controls.editorScrollDown and not editormenuopen then
		autoscroll = false
		guielements["autoscrollcheckbox"].var = autoscroll
		yscroll = yscroll + 30*gdt
		if yscroll > mapheight-height-1 then
			yscroll = mapheight-height-1
		end
		generatespritebatch()
	end
	
	-- taps and releases
	if controls.tap.editorSelect and not testlevel then
		if editormenuopen == false then
			-- ode for the "with-preview" minimap drag
			--[[elseif editorstate == "main" then
				if y >= minimapy*scale and y < (minimapy+34)*scale then
					if x >= minimapx*scale and x < (minimapx+394)*scale then
						minimapdragging = true
						toggleautoscroll(false)
					end
				end
			end]]
		else
			if editorstate == "tiles" then
				if testbed.tiles then
					testbed.tiles:control_update(dt)
				end
			end
		end
	elseif controls.release.editorSelect and not testlevel then
		--guirepeattimer = 0
		--minimapdragging = false
		--allowdrag = true
	end
	
	if controls.tap.editorContext and not testlevel then
		if editormenuopen then
			if editorstate == "main" then
				-- this code transportates the player to the cursor position
				--@TODO: Make this player-specific and use a different keyboard shortcut
				if y >= (minimapy+2)*scale and y < (minimapy+32)*scale then
					if x >= (minimapx+2)*scale and x < (minimapx+392)*scale then
						local x = math.floor((x-minimapx*scale+math.floor(minimapscroll*scale*2))/scale/2)
						local y = math.floor((y-minimapy*scale)/scale/2+math.floor(yscroll))
						
						if objects["player"][1] then
							objects["player"][1].x = x-1+2/16
							objects["player"][1].y = y-1+2/16
						end
					end
				end
			end
		else
			local tileX, tileY = getMouseTile(x, y+8*scale)
			if inmap(tileX, tileY) == false then
				return
			end
			local r = map[tileX][tileY]
			if #r > 1 then
				local tile = r[2]
				if entitylist[tile] and rightclickmenues[entitylist[tile].t] then
					print("ANGRY AT THE WORLD!")
					local tileX, tileY = getMouseTile(x, y+8*scale)
					rightclickm = rightclickmenu:new(x/scale, y/scale, rightclickmenues[entitylist[r[2]].t], tileX, tileY)
					rightclickactive = false
					changeTool("notool")
					rightclickoldX, rightclickoldY = tileX, tileY
				end
			end
		end
	end
	
	-- change tile used, bias: previous
	if controls.tap.editorPrevBlock then
		-- this shouldn't work for now, I'm sorry
		if not editormenuopen then
			if editentities then
				if editenemies then
					--get which current tile
					local curr = 1
					while enemies[curr] ~= currenttile and curr < #enemies do
						curr = curr + 1
					end
					
					if curr+1 > #enemies then
						curr = 0
					end
					
					currenttile = enemies[curr+1]
				end
			elseif animatedtilelist then
				if currenttile <= 10000+animatedtilecount then
					currenttile = currenttile + 1
					if currenttile == 10001+animatedtilecount then
						currenttile = 10001
					end
				end
			else
				if currenttile <= smbtilecount+portaltilecount+customtilecount then
					currenttile = currenttile + 1
					if currenttile > smbtilecount+portaltilecount+customtilecount then
						currenttile = 1
					end
				end
			end
		end
	elseif controls.tap.editorNextBlock then
		-- same as above
		if not editormenuopen then
			if editentities then
				if editenemies then
					--get which current tile
					local curr = 1
					while enemies[curr] ~= currenttile and curr > 0 do
						curr = curr + 1
					end
					
					if curr-1 == 0 then
						curr = #enemies+1
					end
					
					currenttile = enemies[curr-1]
				end
			elseif animatedtilelist then
				if currenttile > 10000 then
					currenttile = currenttile - 1
					if currenttile == 10000 then
						currenttile = 10000+animatedtilecount
					end
				end
			else
				if currenttile > 0 then
					currenttile = currenttile - 1
					if currenttile == 0 then
						currenttile = smbtilecount+portaltilecount+customtilecount
					end
				end
			end
		end
	end
	
	if controls.tap.editorDropper then
		changeTool("dropper")
		activeeditortool:update(dt)
	end
	

	if controls.tap.editorDelete and activeeditortool and activeeditortool.name=="selection" then
		activeeditortool:clear()
	end
	
	if controls.tap.menuBack and not testlevel then
		if rightclickm then
			closerightclickmenu()
		elseif changemapwidthmenu then
			mapwidthcancel()
		else
			--@TODO: add a flag here so that doubletapping closes the program
			if editormenuopen then
				editorclose()
			elseif not editormenuopen and not testlevel then
				editoropen()
			end
		end
	end
	
	if activeeditortool then
		activeeditortool:update(dt)
	end
end

function toggleautoscroll(var)
	if var ~= nil then
		autoscroll = var
	else
		autoscroll = not autoscroll
	end
	guielements["autoscrollcheckbox"].var = autoscroll
end

function toggleintermission(var)
	if var ~= nil then
		intermission = var
	else
		intermission = not intermission
	end
	guielements["intermissioncheckbox"].var = intermission
end

function togglewarpzone(var)
	if var ~= nil then
		haswarpzone = var
	else
		haswarpzone = not haswarpzone
	end
	guielements["warpzonecheckbox"].var = haswarpzone
end

function toggleunderwater(var)
	if var ~= nil then
		underwater = var
	else
		underwater = not underwater
	end
	guielements["underwatercheckbox"].var = underwater
end

function togglebonusstage(var)
	if var ~= nil then
		bonusstage = var
	else
		bonusstage = not bonusstage
	end
	guielements["bonusstagecheckbox"].var = bonusstage
end

function togglecustombackground(var)
	if custombackground then
		custombackground = false
	else
		custombackground = custombackgrounds[guielements["backgrounddropdown"].var-1]
		if custombackground == nil then
			custombackground = true
		end
	end
	
	guielements["custombackgroundcheckbox"].var = custombackground ~= false
end

function togglecustomforeground(var)
	if customforeground then
		customforeground = false
	else
		customforeground = custombackgrounds[guielements["foregrounddropdown"].var-1]
		if customforeground == nil then
			customforeground = true
		end
	end
	
	guielements["customforegroundcheckbox"].var = customforeground ~= false
end

function changebackground(var)
	guielements["backgrounddropdown"].var = var
	if custombackground then
		custombackground = custombackgrounds[guielements["backgrounddropdown"].var-1]
		if custombackground == nil then
			custombackground = true
		end
	end	
end

function changeforeground(var)
	guielements["foregrounddropdown"].var = var
	if customforeground then
		customforeground = custombackgrounds[var-1]
		if customforeground == nil then
			customforeground = true
		end
	end	
end

function changelevelscreen(var)
	guielements["levelscreendropdown"].var = var
	levelscreenbackname = levelscreens[var-1]
end

function changeportalgun(var)
	if var == 1 then
		portalsavailable = {true, true}
	elseif var == 2 then
		portalsavailable = {true, false}
	elseif var == 3 then
		portalsavailable = {false, true}
	elseif var == 4 then
		portalsavailable = {false, false}
	end
	guielements["portalgundropdown"].var = var
end

function changemusic(var)
	stopmusic()
	musicname = musiclist[var]
	
	if var == 1 then
		musicname = nil
	end
	
	playmusic()
	guielements["musicdropdown"].var = var
end

function changespriteset(var)
	spriteset = var
	guielements["spritesetdropdown"].var = var
end

function decreasetimelimit()
	mariotimelimit = mariotimelimit - 10
	if mariotimelimit < 0 then
		mariotimelimit = 0
	end
	mariotime = mariotimelimit
	guielements["timelimitincrease"].x = 31 + string.len(mariotimelimit)*8
end

function increasetimelimit()
	mariotimelimit = mariotimelimit + 10
	mariotime = mariotimelimit
	guielements["timelimitincrease"].x = 31 + string.len(mariotimelimit)*8
end

function new_level(sub)
	if marioworld >= 8 and mariolevel >= 8 then
		if (sub and mariosublevel >= 5) or not sub then
			notice.add("level limit")
			return false
		end
	end
	
	if sub then
		mariosublevel = mariosublevel + 1
		if mariosublevel > 5 then
			mariosublevel = 0
			mariolevel = mariolevel + 1
		end
	else
		mariolevel = mariolevel + 1
	end
	
	if mariolevel > 4 then
		mariolevel = 1
		marioworld = marioworld + 1
	end
	
	savelevel()
end

function test_level()
	savelevel()
	editorclose()
	editormode = false
	testlevel = true
	testlevelworld = marioworld
	testlevellevel = mariolevel
	autoscroll = true
	if mariosublevel ~= 0 then
		loadlevel(currentmap)
	else
		loadlevel(currentmap)
	end
	startlevel()
end

function lightdrawbutton()
	editorstate = "lightdraw"
	editorignoretap = true
	editorignorerelease = true
	lightdrawX = nil
	lightdrawY = nil
	editorclose()
end

function savesettings()
	local s = ""
	s = s .. "name=" .. guielements["edittitle"].value .. "\n"
	s = s .. "author=" .. guielements["editauthor"].value .. "\n"
	s = s .. "description=" .. guielements["editdescription"].value .. "\n"
	if mariolivecount == false then
		s = s .. "lives=0\n"
	else
		s = s .. "lives=" .. mariolivecount .. "\n"
	end
	
	love.filesystem.createDirectory( "mappacks" )
	love.filesystem.createDirectory( "mappacks/" .. mappack )
	
	love.filesystem.write("mappacks/" .. mappack .. "/settings.txt", s)
end

function livesdecrease()
	if mariolivecount == false then
		return
	end
	
	mariolivecount = mariolivecount - 1
	
	local whattowrite = "???"
	if mariolivecount == 0 then
		mariolivecount = false
		whattowrite = "inf"
	elseif mariolivecount > 999 then
		whattowrite = "why"
	else
		whattowrite = mariolivecount
	end
	
	guielements["livesincrease"].x = livesanchorx + 14 + string.len(whattowrite)*8
	guielements["livesnum"].value = whattowrite
end

function livesincrease()
	if mariolivecount == false then
		mariolivecount = 1
	else
		mariolivecount = mariolivecount + 1
	end
	
	local whattowrite = "???"
	if mariolivecount > 999 then
		whattowrite = "why"
	else
		whattowrite = mariolivecount
	end
	
	guielements["livesnum"].value = whattowrite
	guielements["livesincrease"].x = livesanchorx + 14 + string.len(whattowrite)*8
end

function defaultbackground(i)
	background = {unpack(backgroundcolor[i])}
	love.graphics.setBackgroundColor(unpack(background))
	
	guielements["colorsliderr"].internvalue = background[1]/255
	guielements["colorsliderg"].internvalue = background[2]/255
	guielements["colorsliderb"].internvalue = background[3]/255
end

function updatebackground()
	background[1] = guielements["colorsliderr"].internvalue*255
	background[2] = guielements["colorsliderg"].internvalue*255
	background[3] = guielements["colorsliderb"].internvalue*255
	love.graphics.setBackgroundColor(unpack(background))
end

function updatescrollfactor()
	scrollfactor = round((guielements["scrollfactorscrollbar"].value*3)^2, 2)
end

function updatefscrollfactor()
	fscrollfactor = round((guielements["fscrollfactorscrollbar"].value*3)^2, 2)
end

function reversescrollfactor()
	return math.sqrt(scrollfactor)/3
end

function reversefscrollfactor()
	return math.sqrt(fscrollfactor)/3
end

function formatscrollnumber(i)
	if i < 0 then
		i = round(i, 1)
	else
		i = round(i, 2)
	end
	
	if string.len(i) == 1 then
		i = i .. ".00"
	elseif string.len(i) == 3 and math.abs(i) < 10 then
		i = i .. "0"
	end
	
	if string.sub(i, 4, 4) == "." then
		return string.sub(i, 1, 3)
	else
		return string.sub(i, 1, 4)
	end
end

function closerightclickmenu()
	if rightclickm then
		local edittable = {{x=rightclickm.tx, y=rightclickm.ty}}
		
		if selectionwidth then
			local selectionlist = selectiongettiles(selectionx, selectiony, selectionwidth, selectionheight)
			
			for i = 1, #selectionlist do
				local v = selectionlist[i]
				-- |@WARNING:| This code is probably broken because I removed the groundlighttable and made it an "r" value.
				if (map[v.x][v.y][2] == map[rightclickm.tx][rightclickm.ty][2] or (table.contains("groundlight", entitylist[map[rightclickm.tx][rightclickm.ty][2]].t) and table.contains("groundlight", entitylist[map[v.x][v.y][2]].t))) and (v.x ~= rightclickm.tx or v.y ~= rightclickm.ty) then
					table.insert(edittable, {x=v.x, y=v.y})
				end
			end
		end
		
		for i = 1, #edittable do
			local x, y = edittable[i].x, edittable[i].y
			
			--remove all values until link or region
			while map[x][y][3] and map[x][y][3] ~= "link" and tostring(map[x][y][3]):split(":")[1] ~= "region" do
				table.remove(map[x][y], 3)
			end
			
			--add values to link
			for i = #rightclickm.variables, 1, -1 do
				local v = rightclickm.variables[i]
				local value
				
				if v.t == "scrollbar" then
					value = rightclickm.t[i].value
				elseif v.t == "checkbox" then
					value = tostring(rightclickm.t[i].var)
				elseif v.t == "directionbuttons" then
					value = v.value
				elseif v.t == "submenu" then
					if rightclickm.t[i].actualvalue then
						value = rightclickm.t[i].entries[rightclickm.t[i].value]
					else
						value = rightclickm.t[i].value
					end
				elseif v.t == "input" then
					value = rightclickm.t[i].value
				end
				
				if value then
					table.insert(map[x][y], 3, value)
				end
			end
		end
		
		rightclickm = nil
	end
end

function startlinking(x, y, t)
	changeTool("linker", x, y, t, true)
	closerightclickmenu()
	
	
	--[[editorignoretap = true
	rightclickactive = true
	linktoolX = x
	linktoolY = y
	linktoolt = t
	rightclicka = 1]]
	
end

function startregion(x, y, t)
	changeTool("region", x, y, t, true)
	closerightclickmenu()
end

function finishregion()
	--dummy code, honk honk
end

function removelink(x, y, t)
	local edittable = {{x=x, y=y}}
	
	if selectionwidth then
		local selectionlist = selectiongettiles(selectionx, selectiony, selectionwidth, selectionheight)
		
		for i = 1, #selectionlist do
			local v = selectionlist[i]
			-- |@WARNING:| This code is probably broken because I removed the groundlighttable and made it an "r" value.
			if (map[v.x][v.y][2] == map[x][y][2] or (entitylist[map[v.x][v.y][2]] and table.contains("groundlight", entitylist[map[v.x][v.y][2]].t) and table.contains("groundlight", entitylist[map[x][y][2]].t))) and (v.x ~= x or v.y ~= y) then
				table.insert(edittable, {x=v.x, y=v.y})
			end
		end
	end
	
	for j = 1, #edittable do
		local cx, cy = edittable[j].x, edittable[j].y
		
		local r = map[cx][cy]
		local i = 1
		
		while (r[i] ~= "link" or tostring(r[i+1]) ~= tostring(t)) and i < #r do
			i = i + 1
		end
		
		if i < #r then --found a match
			table.remove(map[cx][cy], i)
			table.remove(map[cx][cy], i)
			table.remove(map[cx][cy], i)
			table.remove(map[cx][cy], i)
		end
	end
end

function selectionbutton()
	changeTool("selection")
	editorclose()
end

function selectionstart()
	local mousex, mousey = mouse.getPosition()
	selectionx = mousex
	selectiony = mousey
	
	selectiondragging = true
end

function selectionend()
	local mousex, mousey = mouse.getPosition()
	selectionwidth = mousex - selectionx
	selectionheight = mousey - selectiony
	
	if selectionwidth < 0 then
		selectionx = selectionx + selectionwidth
		selectionwidth = -selectionwidth
	end
	if selectionheight < 0 then
		selectiony = selectiony + selectionheight
		selectionheight = -selectionheight
	end
	
	selectiondragging = false
end

function selectiongettiles(x, y, width, height)
	x, y = round(x), round(y)
	width, height = round(width), round(height)

	local out = {}
	
	local xstart, ystart = getMouseTile(x, y+7*scale)
	local xend, yend = getMouseTile(x+width, y+height+7*scale)
	
	for cox = xstart, xend do
		for coy = ystart, yend do
			if inmap(cox, coy) and map[cox][coy][2] then
				table.insert(out, {x=cox, y=coy})
			end
		end
	end
	
	return out
end

function paintLight()
	local mousex, mousey = mouse.getPosition()
	local currentx, currenty = getMouseTile(mousex, mousey+8*scale)
	if lightdrawX and (currentx ~= lightdrawX or currenty ~= lightdrawY) then
		local xdir = 0
		if currentx > lightdrawX then
			xdir = 1
		elseif currentx < lightdrawX then
			xdir = -1
		end
		
		local ydir = 0
		if currenty > lightdrawY then
			ydir = 1
		elseif currenty < lightdrawY then
			ydir = -1
		end
		
		--fill in the gaps
		local x, y = lightdrawX, lightdrawY
		while x ~= currentx or y ~= currenty do
			if x ~= currentx then
				if x < currentx then
					x = x + 1
				else
					x = x - 1
				end
			else
				if y < currenty then
					y = y + 1
				else
					y = y - 1
				end
			end
			table.insert(lightdrawtable, {x=x,y=y})
		
			if #lightdrawtable >= 3 then
				local prevx, prevy = lightdrawtable[#lightdrawtable-2].x, lightdrawtable[#lightdrawtable-2].y
				local currx, curry = lightdrawtable[#lightdrawtable-1].x, lightdrawtable[#lightdrawtable-1].y
				local nextx, nexty = lightdrawtable[#lightdrawtable].x, lightdrawtable[#lightdrawtable].y
				
				local prev = "up"
				if prevx < currx then
					prev = "left"
				elseif prevx > currx then
					prev = "right"
				elseif prevy > curry then
					prev = "down"
				end
				
				local next = "up"
				if nextx < currx then
					next = "left"
				elseif nextx > currx then
					next = "right"
				elseif nexty > curry then
					next = "down"
				end
				
				local tile
				if (prev == "up" and next == "down") or (prev == "down" and next == "up") then
					tile = 43
				elseif (prev == "left" and next == "right") or (prev == "right" and next == "left") then
					tile = 44
				elseif (prev == "up" and next == "right") or (prev == "right" and next == "up") then
					tile = 45
				elseif (prev == "right" and next == "down") or (prev == "down" and next == "right") then
					tile = 46
				elseif (prev == "down" and next == "left") or (prev == "left" and next == "down") then
					tile = 47
				elseif (prev == "left" and next == "up") or (prev == "up" and next == "left") then
					tile = 48
				end
				
				placetile((currx-xscroll-.5)*16*scale, (curry-yscroll-1)*16*scale, tile, true)
			end
		end
		
		lightdrawX = currentx
		lightdrawY = currenty
	end
end

function drawlinkline2(x1, y1, x2, y2)
	love.graphics.rectangle("fill", x1-math.ceil(scale/2), y1, scale, y2-y1)
	love.graphics.rectangle("fill", x2, y2-math.ceil(scale/2), x1-x2, scale)
end

function drawlinkline(x1, y1, x2, y2)
	love.graphics.rectangle("fill", x1, y1-math.ceil(scale/2), x2-x1, scale)
	love.graphics.rectangle("fill", x2-math.ceil(scale/2), y1, scale, y2-y1)
end
end end)()end;
do require("package").preload["animatedquad"] = (function() local package;return function(...)-- <pack animatedquad> --
animatedquad = class("animatedquad")

function animatedquad:init(imgpath, s, number)
	self.number = number
	self.image = love.graphics.newImage(imgpath)
	self.imagedata = love.image.newImageData(imgpath)
	self.quadlist = {} 
	for x = 1, math.floor(self.image:getWidth()/17) do
		table.insert(self.quadlist, love.graphics.newQuad((x-1)*17, 0, 16, 16, self.image:getWidth(), self.image:getHeight()))
	end
	self.quadi = 1
	self.properties = {}
	for x = 1, #self.quadlist do
		self.properties[x] = getquadprops(self.imagedata, x, 1)
	end
	self.props = self.properties[self.quadi]
	self.delays = {}
	self.timer = 0
	self.spikes = {}
	
	self.delays = s:split(",")
	
	if self.delays[1] == "triggered" then
		self.triggered = true
		table.remove(self.delays, 1)
	end
	
	for i = 1, #self.delays do
		self.delays[i] = tonumber(self.delays[i])
	end
	
	local delaycount = #self.delays
	for j = #self.delays+1, #self.quadlist do
		self.delays[j] = self.delays[math.mod(j-1, delaycount)+1]
	end
	
end

function animatedquad:updateproperties()
	local oldcol = self.collision
	local oldportalable = self.portalable
	
	self.props = self.properties[self.quadi]
	
	if oldcol ~= self.props.collision then
		for x = 1, mapwidth do
			for y = 1, mapheight do
				if map[x][y][1] == self.number then
					if self.props.collision then
						objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
					else
						objects["tile"][x .. "-" .. y] = nil
						checkportalremove(x, y)
					end
				end
			end
		end
	end
	
	if oldportalable ~= self.props.portalable then
		for x = 1, mapwidth do
			for y = 1, mapheight do
				if map[x][y][1] == self.number then
					if oldportalable ~= self.portalable then
						if not self.props.portalable then
							checkportalremove(x, y)
						end
					end
				end
			end
		end
	end
end

function animatedquad:update(dt)
	self.timer = self.timer + dt
	while self.timer > self.delays[self.quadi] do
		self.timer = self.timer - self.delays[self.quadi]
		self.quadi = self.quadi + 1
		if self.quadi > #self.quadlist then
			self.quadi = 1
		end
		if objects and not self.triggered then
			self:updateproperties()
		end
	end
end

function animatedquad:quad(x, y)
	if self.triggered and x and y and animatedtimers[x][y] then
		return self.quadlist[animatedtimers[x][y]:geti()]
	else
		return self.quadlist[self.quadi]
	end
end

function animatedquad:getproperty(s, x, y)
	if self.triggered and x and y and animatedtimers[x][y] then
		return self.properties[animatedtimers[x][y]:geti()][s]
	else
		return self.props[s]
	end
end
end end)()end;
do require("package").preload["world"] = (function() local package;return function(...)-- <pack world> --
world = class("world")
--[[
	world is meant to contain the global gamestate info that does not belong to players
	the idea is that world is supposed to be an interface for all the global functions and data
	that are getting used everywhere
	
	additionally, map info is available through this, but it is important to note that 
	we want to be able to extend this functionality such that multiple maps can be loaded
	simultaneously, but they would belong to the same world so the timer and such would be
	shared
	
	since world is a class there can be multiple worlds and by utilizing this we would have
	multiple sets of worlds loaded simultaneously
	
	modifying this file to teach bungalo something
]]


function world:init()
	self.map = { --x
			{ --y
				{ --z
					{}, --element at 1,1,1
				},
			},
		}
	
	-- PHYSICS AND THE LIKE
	self.friction = 14
	--[[significant friction values:
		14 = base friction for motionless players
		20 = friction the box 
		100 = "superfriction" for when player's run speed is above maxrunspeed
	]]
	self.friction_air_multiplier = 0
	--[[significant air friction values:
		0 = basically nothing cares about air
	]]
	self.gravity = 80 --this is aliased as "yacceleration" in the code, so be aware
	--[[significant gravity values:
		30 = player's gravity while jumping
		
	]]
	
	
	-- GAME FLAGS
	self.timelimit = 300
	self.time = self.timelimit
	
	self.lowtime = 99 --when the time gets to this, play the jingle
	self.timescale = 2.5 --for use with converting magic nintendo units into real people time
	
	self.backgroundcolor = {0,0,0}
	
	-- OTHER THINGS THAT WE MANAGE
	self.players = objects["player"] --for now we reference the global players because that's all we know
end



-- SPECIAL HELPER FUNCTIONS TO TRACK THE WORLD'S INHABITANTS
function world:isFantastic()
	return true
end

-- FILTERS
local filters = {}
filters.by_property = function(ply, property)
	return ply[property]
end
filters.genocide = function(ply, reason)
	return ply:die(reason)
end

-- FILTER WRAPPERS
function world:anyPlayersWithProperty(property)
	return filter.runAny(self.players, filters.by_property, property)
end

function world:killAllPlayers(reason)
	return filter.runAll(self.players, filters.genocide, reason)
end

function world:anyPlayersActiveAndAlive()
	return filter.multiAny("All",
		{self.players, filters.by_property, "controlsenabled"}, 
		{self.players, filters.by_property, "dead"}
	)
end
end end)()end;
do require("package").preload["physics"] = (function() local package;return function(...)-- <pack physics> --
--[[
	PHYSICS LIBRARY THING
	WRITTEN BY Maurice Gugan FOR MARI0
	DON'T STEAL MY SHIT
	Licensed under WTFPL
]]--

--MASK REFERENCE LIST
---1: *ALWAYS NOT COLLIDE*

---2: WORLD
---3: MARIO
---4: GOOMBA
---5: KOOPA
---6: MUSHROOM/ONEUP/FLOWER/STAR

---7: GEL DISPENSER
---8: GEL
---9: BOX
--10: SCREENBOUNDARIES
--11: BULLETBILL

--12: PORTALWALLS
--13: FIREBALLS
--14: HAMMERS
--15: PLATFORMS/SEESAWS
--16: BOWSER

--17: FIRE
--18: VINE
--19: SPRING
--20: HAMMERBROS
--21: LAKITO

--22: BUTTON --Not used anymore
--23: CASTLEFIRE
--24: CHEEP
--25: DOOR
--26: FAITHPLATE

--27: FLYINGFISH
--28: LIGHTBRIDGE
--29: PLANT
--30: SQUID
--31: UPFIRE

function prerotatecall(a, b)
	local prerotatecalls = {"goomba", "koopa", "hammerbros", "lakito", "cheep", "flyingfish", "squid"}
	if table.contains(prerotatecalls, a) then
		return true
	end
	
	return false
end

function physicsupdate(dt)
	local lobjects = objects
	
	for j, w in pairs(lobjects) do
		if j ~= "tile" then
			for i, v in pairs(w) do
				if v.moves and v.active then
					--GRAVITY
					v.speedy = v.speedy + (v.gravity or yacceleration)*dt*0.5
					
					if v.speedy > maxyspeed then
						v.speedy = maxyspeed
					end
					
					--Standard conversion!
					if v.gravitydirection and v.gravitydirection ~= math.pi/2 then
						v.speedx, v.speedy = convertfromstandard(v, v.speedx, v.speedy)
					end
					
					--PORTALS LOL
					local passed = false
					if v.portalable ~= false then
						if not checkportalVER(v, v.x+v.speedx*dt) then
							if checkportalHOR(v, v.y+v.speedy*dt) then
								passed = true
							end
						else
							passed = true
						end
						
						if passed and j == "player" then
							playsound("portalenter", w.x, w.y, w.speedx, w.speedy)
							--@WARNING: This might not work in multiplayer, but it might as well.
						end
					end
					
					--COLLISIONS ROFL
					local horcollision = false
					local vercollision = false
					
					
					
					
					
					
					--VS OTHER OBJECTS PRE TILE GROUP
					for h, u in pairs(lobjects) do
						if h ~= "tile" then
							local pass = true
							for k, l in pairs(latetable) do
								if h == l then
									pass = false
									break
								end
							end
							
							if pass then
								--print("getting physical with", j, "and", h)
								local hor, ver = handlegroup(i, h, u, v, j, dt, passed)
								if hor then
									horcollision = true
								end
								if ver then
									vercollision = true
								end
								
								--Check for emancipation grill
								checkforemances(dt, v)
							end
						end
					end
					
					--VS TILES (Because I only wanna check close ones)
					local xstart = math.floor(v.x+v.speedx*dt-2/16)+1
					local ystart = math.floor(v.y+v.speedy*dt-2/16)+1
					
					local xfrom = xstart
					local xto = xstart+math.ceil(v.width)
					local dir = 1
					
					if v.speedx < 0 then
						xfrom, xto = xto, xfrom
						dir = -1
					end
					
					for x = xfrom, xto, dir do
						for y = ystart, ystart+math.ceil(v.height) do
							--check if invisible block
							if inmap(x, y) and (not tilequads[map[x][y][1]]:getproperty("invisible", x, y) or j == "player") then
								local t = lobjects["tile"][x .. "-" .. y]
								if t then
									--    Same object          Active        Not masked
									if (i ~= g or j ~= h) and t.active and v.mask[t.category] ~= true then
										local collision1, collision2 = checkcollision(v, t, "tile", x .. "-" .. y, j, i, dt, passed)
										if collision1 then
											horcollision = true
										elseif collision2 then
											vercollision = true
										end
									end
								end
							end
						end
					end
					
					--VS: LATE OBJECTS
					for g, h in pairs(latetable) do
						local u = objects[h]
						local hor, ver = handlegroup(i, h, u, v, j, dt, passed)
						if hor then
							horcollision = true
						end
						if ver then
							vercollision = true
						end
						
						--Check for emancipation grill
						checkforemances(dt, v)
					end
					
					--Move the object
					if vercollision == false then
						v.y = v.y + v.speedy*dt
					end
					
					if horcollision == false then
						v.x = v.x + v.speedx*dt
					end
					
					if v.gravitydirection and v.gravitydirection ~= math.pi/2 then
						v.speedx, v.speedy = converttostandard(v, v.speedx, v.speedy)
					end
					
					if vercollision == false then
						if v.previouslyonground and v.startfall and not v.jumping then
							v.previouslyonground = false
							if v.speedy >= 0 then
								v:startfall(i)
							end
						end
					elseif not v.previouslyonground and v.startfall then
						v.previouslyonground = true
					end
					
					--check if object is inside portal
					if v.portalable ~= false then
						inportal(v)
					end
					
					--GRAVITY
					v.speedy = v.speedy + (v.gravity or yacceleration)*dt*0.5
				end
			end
		end
	end
end

function checkforemances(dt, v)
	if v.emancipatecheck then
		for h, u in pairs(objects["emancipationgrill"]) do
			if u.power then
				if u.dir == "hor" then
					if inrange(v.x+6/16, u.startx-1, u.endx, true) and inrange(u.coy-14/16, v.y, v.y+v.speedy*dt, true) then
						if v.emancipate then v:emancipate(h) end
					end
				else
					--[[@NOTE:
						we patched this to be overzealous because shoved objects
						have no speed therefore the range check immediately fails
						and any other solution is asymetrical (only works from the left)
						
						a better solution would have some math.abs()s and math.min()s
					]]
					if inrange(v.y+6/16, u.starty-1, u.endy, true) and inrange(u.cox-14/16, v.x-14/16, v.x+v.speedx*dt+14/16, true) then
						if v.emancipate then v:emancipate(h) end
					end
				end
			end
		end
	end
end

function handlegroup(i, h, u, v, j, dt, passed)
	local horcollision = false
	local vercollision = false
	for g, t in pairs(u) do
		--    Same object?          Active                 Not masked
		if (i ~= g or j ~= h) and t.active and (v.mask == nil or v.mask[t.category] ~= true) and (t.mask == nil or t.mask[v.category] ~= true) then
			local collision1, collision2 = checkcollision(v, t, h, g, j, i, dt, passed)
			if collision1 then
				horcollision = true
			elseif collision2 then
				vercollision = true
			end
		end
	end
	
	return horcollision, vercollision
end

function checkcollision(v, t, h, g, j, i, dt, passed) --v: b1table | t: b2table | h: b2type | g: b2id | j: b1type | i: b1id
	local hadhorcollision = false
	local hadvercollision = false
	
	if h ~= "tile" or (not tilequads[map[t.cox][t.coy][1]]:getproperty("slantupleft", t.cox, t.coy) and not tilequads[map[t.cox][t.coy][1]]:getproperty("slantupright", t.cox, t.coy)) then
		if math.abs(v.x+v.speedx*dt-t.x) < math.max(v.width, t.width)+1 and
		math.abs(v.y+v.speedy*dt-t.y) < math.max(v.height, t.height)+1 then
			--check if it's a passive collision (Object is colliding anyway)
			if not passed and aabb(v.x, v.y, v.width, v.height, t.x, t.y, t.width, t.height) then --passive collision! (oh noes!)
				if passivecollision(v, t, h, g, j, i, dt) then
					hadvercollision = true
				end
				
			elseif aabb(v.x + v.speedx*dt, v.y + v.speedy*dt, v.width, v.height, t.x, t.y, t.width, t.height) then
				if aabb(v.x + v.speedx*dt, v.y, v.width, v.height, t.x, t.y, t.width, t.height) then --Collision is horizontal!
					if horcollision(v, t, h, g, j, i, dt) then
						hadhorcollision = true
					end
					
				elseif aabb(v.x, v.y+v.speedy*dt, v.width, v.height, t.x, t.y, t.width, t.height) then --Collision is vertical!
					if vercollision(v, t, h, g, j, i, dt) then
						hadvercollision = true
					end
					
				else 
					--We're fucked, it's a diagonal collision! run!
					--Okay actually let's take this slow okay. Let's just see if we're moving faster horizontally than vertically, aight?
					local grav = yacceleration
					if self and self.gravity then
						grav = self.gravity
					end
					if math.abs(v.speedy-grav*dt) < math.abs(v.speedx) then
						--vertical collision it is.
						if vercollision(v, t, h, g, j, i, dt) then
							hadvercollision = true
						end
					else 
						--okay so we're moving mainly vertically, so let's just pretend it was a horizontal collision? aight cool.
						if horcollision(v, t, h, g, j, i, dt) then
							hadhorcollision = true
						end
					end
				end
			end
		end
	else
		if math.abs(v.x-t.x) < math.max(v.width, t.width)+1 and math.abs(v.y-t.y) < math.max(v.height, t.height)+1 then
			--check if it's a passive collision (Object is colliding anyway)
			local slant = "ul"
			if tilequads[map[t.cox][t.coy][1]]:getproperty("slantupright", t.cox, t.coy) then
				slant = "ur"
			end
			if not passed and aabt(v.x, v.y, v.width, v.height, t.x, t.y, t.width, t.height, slant) then --passive collision! (oh noes!)
				if trianglepassivecollision(v, t, h, g, j, i, dt) then
					hadvercollision = true
				end
			elseif aabt(v.x + v.speedx*dt, v.y + v.speedy*dt, v.width, v.height, t.x, t.y, t.width, t.height, slant) then
				if trianglevercollision(v, t, h, g, j, i, dt) then
					hadvercollision = true
				end
			end	
		end
	end
	
	return hadhorcollision, hadvercollision
end

function trianglevercollision(v, t, h, g, j, i, dt)
	if v.floorcollide then
		if v:floorcollide(j, v, g, i) ~= false then
			if v.speedy then
				v.speedy = 0
			end
			if t.slant == "ur" then
				v.y = t.y-v.height + math.max(0, math.min(1, (v.x+v.speedx*dt)-(t.x)))
			elseif t.slant == "ul" then
				v.y = t.y-v.height + math.max(0, math.min(1, (t.x+t.width)-((v.x+v.speedx*dt)+v.width)))
			end
			return true
		end
	else
		if v.speedy then
			v.speedy = 0
		end
		if t.slant == "ur" then
			v.y = t.y-v.height+(t.x-v.x)+2/16
		elseif t.slant == "ul" then
			v.y = t.y-v.height + math.max(0, math.min(1, (t.x+t.width)-((v.x+v.speedx*dt)+v.width)))
		end
		return true
	end
end

function trianglepassivecollision(v, t, h, g, j, i, dt)
	trianglevercollision(v, t, h, g, j, i, dt)
end

function passivecollision(v, t, h, g, j, i, dt)
	if v.passivecollide then
		v:passivecollide(h, t, i, g)
		if t.passivecollide then
			t:passivecollide(j, v, i, g)
		end
	else
		if v.floorcollide then
			if v:floorcollide(h, t, i, g) ~= false then
				if v.speedy > 0 then
					v.speedy = 0
				end
				v.y = t.y - v.height
				return true
			end
		else
			if v.speedy > 0 then
				v.speedy = 0
			end
			v.y = t.y - v.height
			return true
		end
	end
	
	return false
end

function horcollision(v, t, h, g, j, i, dt)
	if v.speedx < 0 then
		--move object RIGHT (because it was moving left)
		
		if collisionexists("right", t) then
			if callcollision("right", t, j, v, g, i) ~= false then
				if t.speedx and t.speedx > 0 then
					t.speedx = 0
				end
			end
		else
			if t.speedx and t.speedx > 0 then
				t.speedx = 0
			end
		end
		if collisionexists("left", v) then
			if callcollision("left", v, h, t, i, g) ~= false then
				if v.speedx < 0 then
					v.speedx = 0
				end
				v.x = t.x + t.width
				return true
			end
		else
			if v.speedx < 0 then
				v.speedx = 0
			end
			v.x = t.x + t.width
			return true
		end
	else
		--move object LEFT (because it was moving right)
		
		if collisionexists("left", t) then
			if callcollision("left", t, j, v, g, i) ~= false then
				if t.speedx and t.speedx < 0 then
					t.speedx = 0
				end
			end
		else
			if t.speedx and t.speedx < 0 then
				t.speedx = 0
			end
		end
		
		if collisionexists("right", v) then
			if callcollision("right", v, h, t, i, g) ~= false then
				if v.speedx > 0 then
					v.speedx = 0
				end
				v.x = t.x - v.width
				return true
			end
		else
			if v.speedx > 0 then
				v.speedx = 0
			end
			v.x = t.x - v.width
			return true
		end
	end
	
	return false
end

function vercollision(v, t, h, g, j, i, dt)
	if v.speedy < 0 then
		--move object DOWN (because it was moving up)
		if collisionexists("floor", t) then
			if callcollision("floor", t, j, v, g, i) ~= false then
				if t.speedy and t.speedy > 0 then
					t.speedy = 0
				end
			end
		else
			if t.speedy and t.speedy > 0 then
				t.speedy = 0
			end
		end
		
		if collisionexists("ceil", v) then
			if callcollision("ceil", v, h, t, i, g) ~= false then
				if v.speedy < 0 then
					v.speedy = 0
				end
				v.y = t.y  + t.height
				return true
			end
		else
			if v.speedy < 0 then
				v.speedy = 0
			end
			v.y = t.y  + t.height
			return true
		end
	else					
		if collisionexists("ceil", t) then
			if callcollision("ceil", t, j, v, g, i) ~= false then
				if t.speedy and t.speedy < 0 then
					t.speedy = 0
				end
			end
		else	
			if t.speedy and t.speedy < 0 then
				t.speedy = 0
			end
		end
		if collisionexists("floor", v) then
			if callcollision("floor", v, h, t, i, g) ~= false then
				if v.speedy > 0 then
					v.speedy = 0
				end
				v.y = t.y - v.height
				return true
			end
		else
			if v.speedy > 0 then
				v.speedy = 0
			end
			v.y = t.y - v.height
			return true
		end
	end
	return false
end

function collisionscalls(dir, obj, a, b, c, d)
	local r
	
	if obj.gravitydirection > math.pi/4*1 and obj.gravitydirection <= math.pi/4*3 then
		if dir == "floor" then
			if obj.floorcollide then
				r = obj:floorcollide(a, b, c, d)
			end
		elseif dir == "left" then
			if obj.leftcollide then
				r = obj:leftcollide(a, b, c, d)
			end
		elseif dir == "ceil" then
			if obj.ceilcollide then
				r = obj:ceilcollide(a, b, c, d)
			end
		elseif dir == "right" then
			if obj.rightcollide then
				r = obj:rightcollide(a, b, c, d)
			end
		end
	elseif obj.gravitydirection > math.pi/4*3 and obj.gravitydirection <= math.pi/4*5 then
		if dir == "floor" then
			if obj.rightcollide then
				r = obj:rightcollide(a, b, c, d)
			end
		elseif dir == "left" then
			if obj.floorcollide then
				r = obj:floorcollide(a, b, c, d)
			end
		elseif dir == "ceil" then
			if obj.leftcollide then
				r = obj:leftcollide(a, b, c, d)
			end
		elseif dir == "right" then
			if obj.ceilcollide then
				r = obj:ceilcollide(a, b, c, d)
			end
		end
	elseif obj.gravitydirection > math.pi/4*5 and obj.gravitydirection <= math.pi/4*7 then
		if dir == "floor" then
			if obj.ceilcollide then
				r = obj:ceilcollide(a, b, c, d)
			end
		elseif dir == "left" then
			if obj.rightcollide then
				r = obj:rightcollide(a, b, c, d)
			end
		elseif dir == "ceil" then
			if obj.floorcollide then
				r = obj:floorcollide(a, b, c, d)
			end
		elseif dir == "right" then
			if obj.leftcollide then
				r = obj:leftcollide(a, b, c, d)
			end
		end
	else
		if dir == "floor" then
			if obj.leftcollide then
				r = obj:leftcollide(a, b, c, d)
			end
		elseif dir == "left" then
			if obj.ceilcollide then
				r = obj:ceilcollide(a, b, c, d)
			end
		elseif dir == "ceil" then
			if obj.rightcollide then
				r = obj:rightcollide(a, b, c, d)
			end
		elseif dir == "right" then
			if obj.floorcollide then
				r = obj:floorcollide(a, b, c, d)
			end
		end
	end
	
	return r
end

function callcollision(dir, obj, a, b, c, d)
	if not obj.gravitydirection then
		if dir == "floor" then
			return obj:floorcollide(a, b, c, d)
		elseif dir == "left" then
			return obj:leftcollide(a, b, c, d)
		elseif dir == "ceil" then
			return obj:ceilcollide(a, b, c, d)
		elseif dir == "right" then
			return obj:rightcollide(a, b, c, d)
		end
	end
	
	obj.speedx, obj.speedy = converttostandard(obj, obj.speedx, obj.speedy)
	
	local r
	
	--PRE ROTATION CALLS!!! WOAAAH
	if prerotatecall(a, b) then
		r = collisionscalls(dir, obj, a, b, c, d)
	end
	
	if a == "tile" then
		local purplegel = false
		local x, y = b.cox, b.coy
		
		--Find a more suitable block if available	
		if dir == "floor" or dir == "ceil" then
			if inmap(x+1, y) and tilequads[map[x+1][y][1]]:getproperty("collision", x+1, y) and obj.x+obj.width/2+.5 > x + .5 then
				x = x + 1
			elseif inmap(x-1, y) and tilequads[map[x-1][y][1]]:getproperty("collision", x-1, y) and obj.x+obj.width/2+.5 < x - .5 then
				x = x - 1
			end
		end
		if dir == "left" or dir == "right" then
			if inmap(x, y+1) and tilequads[map[x][y+1][1]]:getproperty("collision", x, y+1) and obj.y+obj.height/2+.5 > y + .5 then
				y = y + 1
			elseif inmap(x, y-1) and tilequads[map[x][y-1][1]]:getproperty("collision", x, y-1) and obj.y+obj.height/2+.5 < y - .5 then
				y = y - 1
			end
		end		
		
		if not obj.runanimationprogress or obj.size == 1 then --cheap check for player
			if dir == "left" and map[x][y]["gels"]["right"] == 4 then
				if obj.gravitydirection == 0 then
					obj.speedx = -obj.speedx
				end
				obj.gravitydirection = math.pi
				purplegel = true
			elseif dir == "floor" and map[x][y]["gels"]["top"] == 4 then
				if obj.gravitydirection == math.pi*1.5 then
					obj.speedx = -obj.speedx
				end
				obj.gravitydirection = math.pi/2
				purplegel = true
				allowskip = false
			elseif dir == "right" and map[x][y]["gels"]["left"] == 4 then
				if obj.gravitydirection == math.pi then
					obj.speedx = -obj.speedx
				end
				obj.gravitydirection = 0
				purplegel = true
			elseif dir == "ceil" and map[x][y]["gels"]["bottom"] == 4 then
				if obj.gravitydirection == math.pi/2 then
					obj.speedx = -obj.speedx
				end
				obj.gravitydirection = math.pi*1.5
				purplegel = true
			end
		end
		
		if purplegel then
			obj.speedy = 0
		elseif obj.gravitydirection ~= math.pi/2 then
			--check if wall is a side. and stuff.
			local resetgravity = false
			
			if obj.gravitydirection > math.pi/4*1 and obj.gravitydirection <= math.pi/4*3 then --down
				if dir == "ceil" or dir == "floor" then
					resetgravity = true
				end
			elseif obj.gravitydirection > math.pi/4*3 and obj.gravitydirection <= math.pi/4*5 then --left
				if dir == "right" or dir == "left" then
					resetgravity = true
				end
			elseif obj.gravitydirection > math.pi/4*5 and obj.gravitydirection <= math.pi/4*7 then --up
				if dir == "floor" or dir == "ceil" then
					resetgravity = true
				end
			else --right
				if dir == "left" or dir == "right" then
					resetgravity = true
				end
			end
			
			if resetgravity then
				obj.gravitydirection = math.pi/2
				obj.speedy = 0
				obj.speedx = -obj.speedx
			end
		end
	elseif obj.gravitydirection ~= math.pi/2 and (not b.gravitydirection or b.gravitydirection ~= obj.gravitydirection) then
		--Player vs box hardcode fix
		if (a == "box" and obj.category == 3) or (a == "player" and obj.category == 9) then
			print("something something hardcore")
		else
			obj.gravitydirection = math.pi/2
			obj.speedy = 0
			obj.speedx = -obj.speedx
		end
	end
	
	--AFTER ROTATION CALLS!!! WOAAAH
	if not prerotatecall(a, b) then
		r = collisionscalls(dir, obj, a, b, c, d)
	end
	
	obj.speedx, obj.speedy = convertfromstandard(obj, obj.speedx, obj.speedy)
	
	return r
end

function collisionexists(dir, obj)
	if not obj.gravitydirection or (obj.gravitydirection > math.pi/4*1 and obj.gravitydirection <= math.pi/4*3) then
		if dir == "floor" then
			return obj.floorcollide
		elseif dir == "left" then
			return obj.leftcollide
		elseif dir == "ceil" then
			return obj.ceilcollide
		elseif dir == "right" then
			return obj.rightcollide
		end
	elseif obj.gravitydirection > math.pi/4*3 and obj.gravitydirection <= math.pi/4*5 then
		if dir == "floor" then
			return obj.rightcollide
		elseif dir == "left" then
			return obj.floorcollide
		elseif dir == "ceil" then
			return obj.leftcollide
		elseif dir == "right" then
			return obj.ceilcollide
		end
	elseif obj.gravitydirection > math.pi/4*5 and obj.gravitydirection <= math.pi/4*7 then
		if dir == "floor" then
			return obj.ceilcollide
		elseif dir == "left" then
			return obj.rightcollide
		elseif dir == "ceil" then
			return obj.floorcollide
		elseif dir == "right" then
			return obj.leftcollide
		end
	else
		if dir == "floor" then
			return obj.leftcollide
		elseif dir == "left" then
			return obj.ceilcollide
		elseif dir == "ceil" then
			return obj.rightcollide
		elseif dir == "right" then
			return obj.floorcollide
		end
	end
end

function adjustcollside(side, gravitydirection)
	if side == "left" then
		if gravitydirection > math.pi/4*1 and gravitydirection <= math.pi/4*3 then --down
			return "left"
		elseif gravitydirection > math.pi/4*3 and gravitydirection <= math.pi/4*5 then --left
			return "up"
		elseif gravitydirection > math.pi/4*5 and gravitydirection <= math.pi/4*7 then --up
			return "right"
		else --right
			return "down"
		end
	elseif side == "up" then
		if gravitydirection > math.pi/4*1 and gravitydirection <= math.pi/4*3 then --down
			return "up"
		elseif gravitydirection > math.pi/4*3 and gravitydirection <= math.pi/4*5 then --left
			return "right"
		elseif gravitydirection > math.pi/4*5 and gravitydirection <= math.pi/4*7 then --up
			return "down"
		else --right
			return "left"
		end
	elseif side == "right" then
		if gravitydirection > math.pi/4*1 and gravitydirection <= math.pi/4*3 then --down
			return "right"
		elseif gravitydirection > math.pi/4*3 and gravitydirection <= math.pi/4*5 then --left
			return "down"
		elseif gravitydirection > math.pi/4*5 and gravitydirection <= math.pi/4*7 then --up
			return "left"
		else --right
			return "up"
		end
	elseif side == "down" then
		if gravitydirection > math.pi/4*1 and gravitydirection <= math.pi/4*3 then --down
			return "down"
		elseif gravitydirection > math.pi/4*3 and gravitydirection <= math.pi/4*5 then --left
			return "left"
		elseif gravitydirection > math.pi/4*5 and gravitydirection <= math.pi/4*7 then --up
			return "up"
		else --right
			return "right"
		end
	end
end

function aabb(ax, ay, awidth, aheight, bx, by, bwidth, bheight)
	return ax+awidth > bx and ax < bx+bwidth and ay+aheight > by and ay < by+bheight
end

function aabt(ax, ay, awidth, aheight, bx, by, bwidth, bheight, bdir)
    if bdir == "ur" then
        return ax+awidth > bx and ax < bx+bwidth and ay+aheight > by and ay < by+bheight and ay + aheight - by > ax - bx
    elseif bdir == "ul" then
        return ax+awidth > bx and ax < bx+bwidth and ay+aheight > by and ay < by+bheight and ay + aheight - by > bheight - ax - awidth + bx
    elseif bdir == "dl" then
        return ax+awidth > bx and ax < bx+bwidth and ay+aheight > by and ay < by+bheight and ay - by < ax+awidth - bx
    elseif bdir == "dr" then
        return ax+awidth > bx and ax < bx+bwidth and ay+aheight > by and ay < by+bheight and ay - by < bwidth- ax + bx
    end
end

function checkrect(x, y, width, height, list, statics)
	local out = {}
	
	local inobj
	
	if type(list) == "table" and list[1] == "exclude" then
		inobj = {unpack(list)}
		table.remove(inobj, 1)
		list = "all"
	end

	for i, v in pairs(objects) do
		local contains = false
		
		if list and list ~= "all" then			
			for j = 1, #list do
				if list[j] == i then
					contains = true
				end
			end
		end
		
		if list == "all" or contains then
			for j, w in pairs(v) do
				if statics or w.moves or list ~= "all" then
					local skip = false
					if inobj then
						for i, v in pairs(inobj) do
							if v == w then
								skip = true
							end
							
							if (v.mask ~= nil and v.mask[w.category] == true) or (w.mask ~= nil and w.mask[v.category] == true) then
								skip = true
							end
						end
					end
					if not skip then
						if w.active then
							if aabb(x, y, width, height, w.x, w.y, w.width, w.height) then
								table.insert(out, i)
								table.insert(out, j)
							end
						end
					end
				end
			end
		end
	end
	
	return out
end

function inportal(self)
	if self.mask[2] then
		return
	end
	for i, v in pairs(portals) do
		if v.x1 ~= false and v.x2 ~= false then
			local portal1xplus = 0
			local portal2xplus = 0
			local portal1Y = v.y1
			local portal2Y = v.y2
			local portal1yplus = 0
			local portal2yplus = 0
			local portal1X = v.x1
			local portal2X = v.x2
			
			--Get the extra block of each portal
			if v.facing1 == "up" then
				portal1xplus = 1
			elseif v.facing1 == "down" then
				portal1xplus = -1
			end
			
			if v.facing2 == "up" then
				portal2xplus = 1
			elseif v.facing2 == "down" then
				portal2xplus = -1
			end
			
			if v.facing1 == "right" then
				portal1yplus = 1
			elseif v.facing1 == "left" then
				portal1yplus = -1
			end
			
			if v.facing2 == "right" then
				portal2yplus = 1
			elseif v.facing2 == "left" then
				portal2yplus = -1
			end
			
			local x = math.floor(self.x+self.width/2)+1
			local y = math.floor(self.y+self.height/2)+1
			
			if (x == portal1X or x == portal1X + portal1xplus) and (y == portal1Y or y == portal1Y + portal1yplus) then
				local entryportalX = v.x1
				local entryportalY = v.y1
				local entryportalfacing = v.facing1
				
				local exitportalX = v.x2
				local exitportalY = v.y2
				local exitportalfacing = v.facing2
				
				self.x, self.y, self.speedx, self.speedy, self.rotation = portalcoords(self.x, self.y, self.speedx, self.speedy, self.width, self.height, self.rotation, self.animationdirection, entryportalX, entryportalY, entryportalfacing, exitportalX, exitportalY, exitportalfacing, self, true)

			elseif (x == portal2X or x == portal2X + portal2xplus) and (y == portal2Y or y == portal2Y + portal2yplus) then
				local entryportalX = v.x2
				local entryportalY = v.y2
				local entryportalfacing = v.facing2
				
				local exitportalX = v.x1
				local exitportalY = v.y1
				local exitportalfacing = v.facing1
				
				self.x, self.y, self.speedx, self.speedy, self.rotation = portalcoords(self.x, self.y, self.speedx, self.speedy, self.width, self.height, self.rotation, self.animationdirection, entryportalX, entryportalY, entryportalfacing, exitportalX, exitportalY, exitportalfacing, self)

			end
		end
	end
	
	return false
end

function checkportalHOR(self, nextY) --handles horizontal (up- and down facing) portal teleportation
	for i, v in pairs(portals) do
		if v.x1 ~= false and v.x2 ~= false then
		
			local portal1xplus = 0
			local portal2xplus = 0
			local portal1Y = v.y1
			local portal2Y = v.y2
			
			--Get the extra block of each portal
			if v.facing1 == "up" then
				portal1xplus = 1
				portal1Y = portal1Y - 1
			elseif v.facing1 == "down" then
				portal1xplus = -1
			end
			
			if v.facing2 == "up" then
				portal2xplus = 1
				portal2Y = portal2Y - 1
			elseif v.facing2 == "down" then
				portal2xplus = -1
			end
			
			--first part checks whether object is in the portal's x range,                                  second part whether object just moved through the portal's Y value
			if ((v.x1 == math.floor(self.x+1) or v.x1+portal1xplus == math.floor(self.x+1)) and inrange(portal1Y, self.y+self.height/2, nextY+self.height/2))
			or ((v.x2 == math.floor(self.x+1) or v.x2+portal2xplus == math.floor(self.x+1)) and inrange(portal2Y, self.y+self.height/2, nextY+self.height/2)) then
			
				--check which portal is entry
				local entryportalX, entryportalY, entryportalfacing
				local exitportalX, exitportalY, exitportalfacing
				local entryportalxplus, entryportalyplus, exitportalxplus, exitportalyplus
				if (v.x1 == math.floor(self.x+1) or v.x1+portal1xplus == math.floor(self.x+1)) and inrange(portal1Y, self.y+self.height/2, nextY+self.height/2) then
					entryportalX = v.x1
					entryportalY = v.y1
					entryportalfacing = v.facing1
					entryportalxplus = portal1xplus
					
					exitportalX = v.x2
					exitportalY = v.y2
					exitportalfacing = v.facing2
					exitportalxplus = portal2xplus
				else
					entryportalX = v.x2
					entryportalY = v.y2
					entryportalfacing = v.facing2	
					entryportalxplus = portal2xplus
					
					exitportalX = v.x1
					exitportalY = v.y1
					exitportalfacing = v.facing1
					exitportalxplus = portal1xplus
				end
				
				--check if movement makes that portal even a possibility
				if entryportalfacing == "up" then
					if self.speedy < 0 then
						return false
					end
				elseif entryportalfacing == "down" then
					if self.speedy > 0 then
						return false
					end
				end
				
				if entryportalfacing == "left" or entryportalfacing == "right" then
					return false
				end
				
				local testx, testy, testspeedx, testspeedy, testrotation = portalcoords(self.x, self.y, self.speedx, self.speedy, self.width, self.height, self.rotation, self.animationdirection, entryportalX, entryportalY, entryportalfacing, exitportalX, exitportalY, exitportalfacing, self, true)
			
				if #checkrect(testx, testy, self.width, self.height, {"exclude", self}, false) == 0 then --Check if exit position is free
					self.x, self.y, self.speedx, self.speedy, self.rotation = testx, testy, testspeedx, testspeedy, testrotation
				else
					self.speedy = -self.speedy*0.95
					if math.abs(self.speedy) < 2 then
						if self.speedy > 0 then
							self.speedy = 2
						else
							self.speedy = -2
						end
					end
				end
				
				
				if (entryportalfacing == "down" and exitportalfacing == "up") or (entryportalfacing == "up" and exitportalfacing == "down") then
					
				else
					self.jumping = false
					self.falling = true
				end
				
				if self.portaled then
					self:portaled(v, entryportalfacing, exitportalfacing)
				end
				
				return true
			end
		end
	end
	return false
end

function checkportalVER(self, nextX) --handles vertical (left- and right facing) portal teleportation
	for i, v in pairs(portals) do
		if v.x1 ~= false and v.x2 ~= false then
			local portal1yplus = 0
			local portal2yplus = 0
			local portal1X = v.x1
			local portal2X = v.x2
			
			--Get the extra block of each portal
			if v.facing1 == "right" then
				portal1yplus = 1
			elseif v.facing1 == "left" then
				portal1yplus = -1
				portal1X = portal1X - 1
			end
			
			if v.facing2 == "right" then
				portal2yplus = 1
			elseif v.facing2 == "left" then
				portal2yplus = -1
				portal2X = portal2X - 1
			end
			
			if ((v.y1 == math.floor(self.y+1) or v.y1+portal1yplus == math.floor(self.y+1)) and inrange(portal1X, self.x+self.width/2, nextX+self.width/2))
			or ((v.y2 == math.floor(self.y+1) or v.y2+portal2yplus == math.floor(self.y+1)) and inrange(portal2X, self.x+self.width/2, nextX+self.width/2)) then
				--check which portal is entry
				local entryportalX, entryportalY, entryportalfacing
				local exitportalX, exitportalY, exitportalfacing
				local entryportalxplus, entryportalyplus, exitportalxplus, exitportalyplus
				if (v.y1 == math.floor(self.y+1) or v.y1+portal1yplus == math.floor(self.y+1)) and inrange(portal1X, self.x+self.width/2, nextX+self.width/2) then
					entryportalX = v.x1
					entryportalY = v.y1
					entryportalfacing = v.facing1
					entryportalyplus = portal1yplus
					
					exitportalX = v.x2
					exitportalY = v.y2
					exitportalfacing = v.facing2
					exitportalyplus = portal2yplus
				else
					entryportalX = v.x2
					entryportalY = v.y2
					entryportalfacing = v.facing2
					entryportalyplus = portal2yplus
					
					exitportalX = v.x1
					exitportalY = v.y1
					exitportalfacing = v.facing1
					exitportalyplus = portal1yplus
				end
				
				--check if movement makes that portal even a possibility
				if entryportalfacing == "right" then
					if self.speedx > 0 then
						return false
					end
				elseif entryportalfacing == "left" then
					if self.speedx < 0 then
						return false
					end
				end
				
				if entryportalfacing == "up" or entryportalfacing == "down" then
					return false
				end
				
				local testx, testy, testspeedx, testspeedy, testrotation = portalcoords(self.x, self.y, self.speedx, self.speedy, self.width, self.height, self.rotation, self.animationdirection, entryportalX, entryportalY, entryportalfacing, exitportalX, exitportalY, exitportalfacing, self, true)
			
				if #checkrect(testx, testy, self.width, self.height, {"exclude", self}, false) == 0 then
					self.x, self.y, self.speedx, self.speedy, self.rotation = testx, testy, testspeedx, testspeedy, testrotation
				else
					self.speedx = -self.speedx
				end
				
				self.jumping = false
				self.falling = true
				
				if self.portaled then
					self:portaled(v, entryportalfacing, exitportalfacing)
				end
				
				return true
			end
		end
	end
	return false
end

function portalcoords(x, y, speedx, speedy, width, height, rotation, animationdirection, entryportalX, entryportalY, entryportalfacing, exitportalX, exitportalY, exitportalfacing, self, live)
	x = x + width/2
	y = y + height/2
	
	local directrange --vector orthogonal to portal vector T
	local relativerange --vector symmetrical to portal vector =
	
	if entryportalfacing == "up" then
		directrange = entryportalY - y - 1
		if width == 2 then
			relativerange = 0
		else
			relativerange = ((x-width/2) - entryportalX + 1) / (2-width)
		end
	elseif entryportalfacing == "right" then
		directrange = x - entryportalX
		if height == 2 then
			relativerange = 0
		else
			relativerange = ((y-height/2) - entryportalY + 1) / (2-height)
		end
	elseif entryportalfacing == "down" then
		directrange = y - entryportalY	
		if width == 2 then
			relativerange = 0
		else
			relativerange = ((x-width/2) - entryportalX + 2) / (2-width)
		end
	elseif entryportalfacing == "left" then
		directrange = entryportalX - x - 1
		if height == 2 then
			relativerange = 0
		else
			relativerange = ((y-height/2) - entryportalY + 2) / (2-height)
		end
	end
	
	relativerange = math.min(1, math.max(0, relativerange))
	
	if entryportalfacing == "up" and exitportalfacing == "up" then --up -> up
		newx = x + (exitportalX - entryportalX)
		newy = exitportalY + directrange - 1
		speedy = -speedy
		
		rotation = rotation - math.pi
		
		if live then
			local grav = yacceleration
			if self and self.gravity then
				grav = self.gravity
			end

			--keep it from bugging out by having a minimum exit speed
			
			local minspeed = math.sqrt(2*grav*(height))
			
			if speedy > -minspeed then
				speedy = -minspeed
			end
		end
	elseif (entryportalfacing == "down" and exitportalfacing == "down") then --down -> down
		newx = x + (exitportalX - entryportalX)
		newy = exitportalY - directrange
		speedy = -speedy
		
		rotation = rotation - math.pi
		
	elseif entryportalfacing == "up" and exitportalfacing == "right" then --up -> right
		newy = exitportalY - relativerange*(2-height) - height/2 + 1
		newx = exitportalX - directrange
		
		speedx, speedy = speedy, -speedx
		
		rotation = rotation - math.pi/2
		
	elseif entryportalfacing == "up" and exitportalfacing == "left" then --up -> left
		newy = exitportalY + relativerange*(2-height) + height/2 - 2
		newx = exitportalX + directrange - 1
		
		speedx, speedy = -speedy, speedx
		
		rotation = rotation + math.pi/2
		
	elseif (entryportalfacing == "up" and exitportalfacing == "down") then --up -> down
		newx = x + (exitportalX - entryportalX) - 1
		newy = exitportalY - directrange
		
	
		--prevent low-fps bugs in a cheap way:
		if entryportalY > exitportalY then
			while newy+.5 + speedy*gdt > entryportalY do
				newy = newy - 0.01
			end
			
			while newy+.5 < exitportalY do
				newy = newy + 0.01
			end
		end
		
		--prevent porting into block by limiting X, yo
		if newx <= exitportalX - 2 + width/2 then
			newx = exitportalX - 2 + width/2
		elseif newx > exitportalX - width/2 then
			newx = exitportalX - width/2
		end
		
	elseif (entryportalfacing == "down" and exitportalfacing == "up") then --down -> up
		newx = x + (exitportalX - entryportalX) + 1
		newy = exitportalY + directrange - 1
		
	elseif (entryportalfacing == "down" and exitportalfacing == "left") then --down -> left
		newy = exitportalY - relativerange*(2-height) - height/2
		newx = exitportalX + directrange - 1
		
		speedx, speedy = speedy, -speedx
		
		rotation = rotation - math.pi/2
		
	elseif (entryportalfacing == "down" and exitportalfacing == "right") then --down -> right
		newy = exitportalY + relativerange*(2-height) + height/2 - 1
		newx = exitportalX - directrange
		
		speedx, speedy = -speedy, speedx
		
		rotation = rotation + math.pi/2
		
	--LEFT/RIGHT CODE!
	elseif (entryportalfacing == "left" and exitportalfacing == "right") then --left -> right
		newx = exitportalX - directrange
		newy = y + (exitportalY - entryportalY)+1
	elseif (entryportalfacing == "right" and exitportalfacing == "left") then --right -> left
		newx = exitportalX + directrange - 1
		newy = y + (exitportalY - entryportalY)-1
	elseif (entryportalfacing == "right" and exitportalfacing == "right") then --right -> right
		newx = exitportalX - directrange
		newy = y + (exitportalY - entryportalY)
		
		speedx = -speedx
		if animationdirection == "left" then
			animationdirection = "right"
		elseif animationdirection == "right" then
			animationdirection = "left"
		end
		
	elseif (entryportalfacing == "left" and exitportalfacing == "left") then --left -> left
		newx = exitportalX + directrange - 1
		newy = y + (exitportalY - entryportalY)
		
		speedx = -speedx
		if animationdirection == "left" then
			animationdirection = "right"
		elseif animationdirection == "right" then
			animationdirection = "left"
		end
		
	elseif (entryportalfacing == "left" and exitportalfacing == "up") then --left -> up
		newx = exitportalX + relativerange*(2-width) + width/2 - 1
		newy = exitportalY + directrange - 1
		
		speedx, speedy = speedy, -speedx
		
		rotation = rotation - math.pi/2
		
		if live then		
			--keep it from bugging out by having a minimum exit speed
			local grav = yacceleration
			if self and self.gravity then
				grav = self.gravity
			end
			
			local minspeed = math.sqrt(2*grav*(height))
			
			if speedy > -minspeed then
				speedy = -minspeed
			end
		end
		
	elseif (entryportalfacing == "right" and exitportalfacing == "up") then --right -> up
		newx = exitportalX - relativerange*(2-width) - width/2 + 1
		newy = exitportalY + directrange - 1
		
		speedx, speedy = -speedy, speedx
		
		rotation = rotation + math.pi/2
		
		if live then
			--keep it from bugging out by having a minimum exit speed
			local grav = yacceleration
			if self and self.gravity then
				grav = self.gravity
			end
			
			local minspeed = math.sqrt(2*grav*(height))
			
			if speedy > -minspeed then
				speedy = -minspeed
			end
		end
		
	elseif (entryportalfacing == "left" and exitportalfacing == "down") then --left -> down
		newx = exitportalX - relativerange*(2-width) - width/2
		newy = exitportalY - directrange
		
		speedx, speedy = -speedy, speedx
		
		rotation = rotation + math.pi/2
		
	elseif (entryportalfacing == "right" and exitportalfacing == "down") then --right -> down
		newx = exitportalX + relativerange*(2-width) + width/2 - 2
		newy = exitportalY - directrange
		
		speedx, speedy = speedy, -speedx
		
		rotation = rotation - math.pi/2
	end
	
	newx = newx - width/2
	newy = newy - height/2
	
	return newx, newy, speedx, speedy, rotation, animationdirection
end

function converttostandard(obj, speedx, speedy)
	--Convert speedx and speedy to horizontal values
	local speed = math.sqrt(speedx^2+speedy^2)
	local speeddir = math.atan2(speedy, speedx)
	
	local speedx, speedy = math.cos(speeddir-obj.gravitydirection+math.pi/2)*speed, math.sin(speeddir-obj.gravitydirection+math.pi/2)*speed
				
	if math.abs(speedy) < 0.00001 then
		speedy = 0
	end
	if math.abs(speedx) < 0.00001 then
		speedx = 0
	end
	
	return speedx, speedy
end

function convertfromstandard(obj, speedx, speedy)
	--reconvert speedx and speedy to actual directions
	local speed = math.sqrt(speedx^2+speedy^2)
	local speeddir = math.atan2(speedy, speedx)
	
	local speedx, speedy = math.cos(speeddir+obj.gravitydirection-math.pi/2)*speed, math.sin(speeddir+obj.gravitydirection-math.pi/2)*speed
	
	if math.abs(speedy) < 0.00001 then
		speedy = 0
	end
	if math.abs(speedx) < 0.00001 then
		speedx = 0
	end
	
	return speedx, speedy
end

function unrotate(rotation, gravitydirection, dt)
	--rotate back to gravitydirection (portals)
	rotation = math.mod(rotation, math.pi*2)
	
	if rotation < -math.pi then
		rotation = rotation + math.pi*2
	elseif rotation > math.pi then
		rotation = rotation - math.pi*2
	end
	
	if rotation == math.pi and gravitydirection == 0 then
		rotation = rotation + portalrotationalignmentspeed*dt
	elseif rotation <= -math.pi/2 and gravitydirection == math.pi*1.5 then
		rotation = rotation - portalrotationalignmentspeed*dt
	elseif rotation > (gravitydirection-math.pi/2) then
		rotation = rotation - portalrotationalignmentspeed*dt
		if rotation < (gravitydirection-math.pi/2) then
			rotation = (gravitydirection-math.pi/2)
		end
	elseif rotation < (gravitydirection-math.pi/2) then
		rotation = rotation + portalrotationalignmentspeed*dt
		if rotation > (gravitydirection-math.pi/2) then
			rotation = (gravitydirection-math.pi/2)
		end
	end
	
	return rotation
end
end end)()end;
do require("package").preload["quad"] = (function() local package;return function(...)-- <pack quad> --
quad = class("quad")

--COLLIDE?
--INVISIBLE?
--BREAKABLE?
--COINBLOCK?
--COIN?
--_NOT_ PORTALABLE?
--LEFT SLANT?
--RIGHT SLANT?
--MIRROR?
--GRATE? 
--PLATFORM TYPE?
--WATER TILE?
--BRIDGE?
--SPIKES?
--FOREGROUND?

function quad:init(img, imgdata, x, y, width, height)
	--get if empty?

	self.image = img
	self.quadobj = love.graphics.newQuad((x-1)*17, (y-1)*17, 16, 16, width, height)
	
	self.props = getquadprops(imgdata, x, y)
end

function quad:getproperty(s)
	return self.props[s]
end

function quad:quad()
	return self.quadobj
end

function getquadprops(imgdata, x, y)
	local self = {}
	
	--get collision
	self.collision = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17)
	if a > 127 then
		self.collision = true
	end
	
	--get invisible
	self.invisible = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+1)
	if a > 127 then
		self.invisible = true
	end
	
	--get breakable
	self.breakable = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+2)
	if a > 127 then
		self.breakable = true
	end
	
	--get coinblock
	self.coinblock = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+3)
	if a > 127 then
		self.coinblock = true
	end
	
	--get coin
	self.coin = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+4)
	if a > 127 then
		self.coin = true
	end
	
	--get not portalable
	self.portalable = true
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+5)
	if a > 127 then
		self.portalable = false
	end
	
	--get left slant
	self.slantupleft = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+6)
	if a > 127 then
		self.slantupleft = true
	end
	
	--get right slant
	self.slantupright = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+7)
	if a > 127 then
		self.slantupright = true
	end
	
	--get mirror
	self.mirror = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+8)
	if a > 127 then
		self.mirror = true
	end
	
	--get grate
	self.grate = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+9)
	if a > 127 then
		self.grate = true
	end
	
	--get platform
	self.platform = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+10)
	if a > 127 then
		self.platform = true
	end
	
	--get watertile
	self.water = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+11)
	if a > 127 then
		self.water = true
	end
	
	--get bridge
	self.bridge = false
	local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+12)
	if a > 127 then
		self.bridge = true
	end
	
	--get spikes
	local t = {"left", "top", "right", "bottom"}
	for i = 1, #t do
		local v = t[i]
		self["spikes" .. v] = false
		local r, g, b, a = imgdata:getPixel(x*17-1, (y-1)*17+12+i)
		if a > 127 then
			self["spikes" .. v] = true
		end
	end
	
	--get foreground
	self.foreground = false
	local r, g, b, a = imgdata:getPixel(x*17-2, (y-1)*17+16)
	if a > 127 then
		self.foreground = true
	end
	
	return self
end
end end)()end;
do require("package").preload["backwards_compat"] = (function() local package;return function(...)-- <pack backwards_compat> --
--[[@NOTE: This is a lua file so that I can take advantage of [ZeroBrane's markdown](http://studio.zerobrane.com/doc-markdown-formatting.html).
	This document illustrates the significant changes between Mari0 SE and Marin0 SE.
	This will only point out changes crucial to getting old Mari0 mappacks working
	so that a converter of some sort can be made.
]]

--[[
	# Entities
	some names got changed
]]
end end)()end;
do require("package").preload["magic"] = (function() local package;return function(...)-- <pack magic> --
magic = class("magic")

function magic:init()
	self.lifetime = 0.5
	self.t = 0
	self.x = math.floor(7+math.random()*188)*scale
	self.y = math.floor(88+math.random()*12)*scale
	self.color = {202+(math.random()-.7)*50, 170+(math.random()-.7)*50, 209+(math.random()-.7)*50}
end

function magic:update(dt)
	self.t = self.t + dt
	if self.t >= self.lifetime then
		return true
	end
end

function magic:draw()
	love.graphics.setColor(unpack(self.color))
	love.graphics.draw(magicimg, magicquad[math.floor(self.t/self.lifetime*6)+1], self.x, self.y, 0, scale, scale, 5, 5)
end
end end)()end;
do require("package").preload["main"] = (function() local package;return function(...)-- <pack main> --
require("hook")
require("libs.tserial")
require("utils")
require("globals")
require("loveutils")
require("libs.cupid")
require("libs.filter")
--[[
	STEAL MY SHIT AND I'LL FUCK YOU UP
	PRETTY MUCH EVERYTHING BY MAURICE GUGAN AND IF SOMETHING ISN'T BY ME THEN IT SHOULD BE OBVIOUS OR NOBODY CARES

	Please keep in mind that for obvious reasons, I do not hold the rights to artwork, audio or trademarked elements of the game.
	This license only applies to the code and original other assets. Obviously. Duh.
	Anyway, enjoy.
	
	
	
	DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
              Version 2, December 2004

	Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

	Everyone is permitted to copy and distribute verbatim or modified
	copies of this license document, and changing it is allowed as long
	as the name is changed.

			DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
	TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

	0. You just DO WHAT THE FUCK YOU WANT TO.
]]
--[[distance models
	none: basically everything stays the same, always
	inverse: things get quieter as you move away
	linear: basically things just move around but never fade, you get the most dopple out of this
	exponent: like inverse, except happens quicker
	x clamped: gain gets clamped
]]
love.audio.setDistanceModel("exponent clamped")

function love.run()
	love.math.setRandomSeed(os.time())
	
	
    love.load(arg)

    -- Main loop time.
    while true do
        -- Process events.
		love.event.pump()
		for e,a,b,c,d in love.event.poll() do
			if e == "quit" then
				if not love.quit() then
					love.audio.stop()
					return
				end
			end
			love.handlers[e](a,b,c,d)
		end

        -- Update dt, as we'll be passing it to update
		love.timer.step()
		local dt = love.timer.getDelta()

        -- Call update and draw
        love.update(dt) -- will pass 0 if love.timer is disabled
		love.graphics.clear()
		love.graphics.origin()
		
		--Fullscreen hack
		if not mkstation and fullscreen and gamestate ~= "intro" then
			completecanvas:clear()
			love.graphics.setScissor()
			completecanvas:renderTo(love.draw)
			love.graphics.setScissor()
			if fullscreenmode == "full" then
				love.graphics.draw(completecanvas, 0, 0, 0, desktopsize.width/(width*16*scale), desktopsize.height/(height*16*scale))
			else
				love.graphics.draw(completecanvas, 0, touchfrominsidemissing/2, 0, touchfrominsidescaling/scale, touchfrominsidescaling/scale)
				love.graphics.setColor(0, 0, 0)
				love.graphics.rectangle("fill", 0, 0, desktopsize.width, touchfrominsidemissing/2)
				love.graphics.rectangle("fill", 0, desktopsize.height-touchfrominsidemissing/2, desktopsize.width, touchfrominsidemissing/2)
				love.graphics.setColor(255, 255, 255, 255)
			end
		else
			love.graphics.setScissor()
			love.draw()
		end
		
		love.graphics.present()
		love.timer.sleep(0.001)
    end
end

function add(desc)
	print((desc or "") .. "\n" .. round((love.timer.getTime()-starttime)*1000) .. "ms\tlines " .. lastline+1 .. " - " .. debug.getinfo(2).currentline-1 .. "\n")
	lastline = debug.getinfo(2).currentline
	totaltime = totaltime + round((love.timer.getTime()-starttime)*1000)
	starttime = love.timer.getTime()
end

function love.load(args)
	hook.Call("LovePreLoad", args)
	game = {}
	debugmode = "none"
	userectdebug = true
	args = args or {}
	for k,v in pairs(args) do
		if v=="-zbs" then
			-- debug features exclusive to zerobrane
			io.stdout:setvbuf("no")
			require("mobdebug").start()
		elseif v=="-debug" then
			skipintro = true
			uploadoncrash = true
			--DEBUG = false
			--editordebug = DEBUG
			--skiplevelscreen = DEBUG
			--debugbinds = DEBUG
			--debugclasses = false
			debugmode = args[k+1] or "none"
		end
	end
	hook.Add("GameConsoleOpened", "ConsoleDisableControls", function()
		if objects and objects["player"] and objects["player"][1] then
			objects["player"][1].controlsenabled = false
		end
	end)
	hook.Add("GameConsoleClosed", "ConsoleReEnableControls", function()
		--@WARNING: This might enable someone's controls at the wrong time, like when the game is paused.
		if objects and objects["player"] and objects["player"][1] then
			objects["player"][1].controlsenabled = false
		end
	end)
	expectedconnections = 2
	if debugmode=="client" or debugmode=="server" then
		uploadoncrash = false
		hook.Add("GameLoaded", "DebugImmediate", function()
			onlinemenu_load()
		end)
		hook.Add("GameOnlineMenuLoaded", "DebugImmediate", function()
			if debugmode=="server" then
				creategame()
				hook.Add("ServerClientConnected", "DebugImmediate", function()
					expectedconnections = expectedconnections - 1
					if expectedconnections==0 then
						server_start()
					end
				end)
			elseif debugmode=="client" then
				guielements.ipentry.value = "127.0.0.1"
				joingame()
			end
		end)
	end
	marioversion = 1107
	versionstring = "version 1.0se"
	
	--version check by checking for a const that was added in 0.8.0 --todo: change to 0.9.0
	if love._version_major == nil or (love._version_minor and love._version_minor < 9) then 
		versionerror = true
		error("You have an outdated version of Love! Get 0.9.0 and retry.") 
	end

	math.mod = math.fmod
	math.random = love.math.random
	-- I'm literally doing this just so the title load text gets shaken up.
	math.random()
	for i=1,math.random(5) do
		math.random()
	end
	
	print("Loading Mari0 SE!")
	print("=======================")
	lastline = debug.getinfo(1).currentline
	starttime = love.timer.getTime()
	totaltime = 0
	JSON = require("libs.JSON")
	require "timer"
	require "notice"
	
	--Get biggest screen size
	
	local sizes = love.window.getFullscreenModes()
	desktopsize = sizes[1]
	
	for i = 2, #sizes do
		if sizes[i].width > desktopsize.width or sizes[i].height > desktopsize.height then
			desktopsize = sizes[i]
		end
	end
	
	recordtarget = 1/40
	recordskip = 1
	recordframe = 1
	
	shaderlist = love.filesystem.getDirectoryItems( "shaders/" )
	local rem
	for i, v in pairs(shaderlist) do
		if v == "init.lua" then
			rem = i
		else
			shaderlist[i] = string.sub(v, 1, string.len(v)-5)
		end
	end
	
	table.remove(shaderlist, rem)
	table.insert(shaderlist, 1, "none")
	
	love.graphics.setDefaultFilter("nearest", "nearest")
	
	overwrittenimages = {}
	imagelist = {"coinblockanimation", "coinanimation", "coinblock", "coin", "axe", "spring", "springhigh", "toad", "peach", "platform", "oddjobhud", "redcoin", "redcointall", "redcoinbig", "firework",
	"platformbonus", "scaffold", "seesaw", "vine", "bowser", "decoys", "flag", "castleflag", "bubble", "emanceparticle", "emanceside", "doorpiece", "doorcenter", "pswitch",
	"button", "pushbutton", "wallindicator", "walltimer", "lightbridge", "lightbridgeglow", "lightbridgeside", "laser", "laserside", "excursionbase", "excursionfunnel", "excursionfunnel2", "excursionfunnelend", 
	"excursionfunnel2end", "faithplateplate", "laserdetector", "gel1", "gel2", "gel3", "gel4", "gel5", "gel6", "gel1ground", "gel2ground", "gel3ground", "gel4ground", "gel5ground", "gel6ground", "geldispenser", "cubedispenser", "panel", "pedestalbase", "cursorarea", 
	"pedestalgun", "actionblock", "portal", "markbase", "markoverlay", "andgate", "notgate", "orgate", "squarewave", "rsflipflop", "portalglow", "sfxentity", "animationtarget", "musicentity", "smbtiles", "portaltiles", "transparency", "smokepuff",
	"animatedtiletrigger", "delayer", "leaf", "groundlight"}
	
	graphicspacki = 1
	graphicspack = "DEFAULT"
	graphicspacklist = {}
	--@WARNING: This will be inaccurate for any mappacks that provide a namespaced graphicspack or potential mods.
	for k,v in pairs(love.filesystem.getDirectoryItems( "graphics" )) do
		if love.filesystem.isDirectory("graphics/"..v) and string.upper(v)==v then
			table.insert(graphicspacklist, v)
		end
	end
	
	soundpacki = 1
	soundpack = "DEFAULT"
	soundpacklist = {}
	--@WARNING: Same goes for me.
	for k,v in pairs(love.filesystem.getDirectoryItems( "sounds" )) do
		if love.filesystem.isDirectory("graphics/"..v) and string.upper(v)==v then
			table.insert(soundpacklist, v)
		end
	end
	
	add("Variables, shaderlist")
	
	local suc, err = pcall(loadconfig)
	if not suc then
		players = 1
		defaultconfig()
		print("== FAILED TO LOAD CONFIG ==")
		print(err)
	end
	
	--@DEBUG: here are some vars that are used elsewhere, maybe
	physicsdebug = false
	incognito = false
	portalwalldebug = false
	speeddebug = false
	
	frameskip = false -- false/0     true is not valid, so stop accidentally writing that.
	
	replaysystem = false
	drawreplays = false
	drawalllinks = false
	bdrawui = true
	skippedframes = 0
	
	width = 25	--! default 25
	height = 14
	fsaa = 0
	
	steptimer = 0
	targetdt = 1/60
	
	--Calculate relative scaling factor
	touchfrominsidescaling = math.min(desktopsize.width/(width*16), desktopsize.height/(height*16))
	touchfrominsidemissing = desktopsize.height-height*16*touchfrominsidescaling
	
	add("Variables")
	changescale(scale, true)
	add("Resolution change")
	require "characterloader"
	add("Characterloader")
	
	dlclist = {}
	
	hatcount = #love.filesystem.getDirectoryItems("graphics/standardhats")
	saveconfig()
	love.window.setTitle( "Marin0 SE" )
	
	love.graphics.setBackgroundColor(0, 0, 0)
	
	cursorareaquads = {}
	for i = 1, 4 do
		cursorareaquads[i] = love.graphics.newQuad((i-1)*18, 0, 18, 18, 72, 18)
	end
	
	--[[@DEV:
		I'm getting really tired of |nonstandard global containers| for entities, so
		to reduce the number of crazy all-over-the-place codepoints I'm creating an
		iterable whitelist of entities that adhere to a specific standard.
		Those being:
			* **being located in** _"/entities/classname.lua"_
			* **a classname that matches the filename, ex:** `classname = class:("classname")`
			* **a function creation signature of** `classname:init(x, y, r)`
				* if not placable in maps, then this isn't entirely necessary, but it helps
			* **having instances stored in the array** `objects["classname"]`
	]]
	saneents = {
		"sfxentity", "portalwall", "tile", "vine", "door", "button",
		"groundlight", "wallindicator", "animatedtiletrigger", "delayer",
		"walltimer", "notgate", "rsflipflop", "orgate", "andgate",
		"musicentity", "enemyspawner", "squarewave", "lightbridge",
		"faithplate", "laser", "noportal", "bulletbill", "animationtarget", 
		"portalprojectile", "portalprojectileparticle", "portalparticle",
		"laserdetector", "gel", "geldispenser", "pushbutton",
		"cubedispenser", "platform", "castlefire", "platformspawner",
		"bowser", "spring", "seesawplatform", "checkpoint", "seesaw",
		"ceilblocker", "funnel", "panel", "scaffold", "axe",
		"regiontrigger", "animationtrigger", "castlefirefire", "portalent",
		"portalent", "actionblock", "leaf", "enemy", "lightbridgebody", "weapon",
		"pedestal", "textentity", "firework", "emancipationgrill", "redcoin",
		"generatorwind", "generatorbullet", "generatorcheeps", "generatorflames",
		"pswitch", "smokepuff", "emancipateanimation", "userect"
	}
	-- we made weapon a saneent because tracing mario's draw is REALLY TOUGH
	-- testing removal of "fireball",
	
	--[[ here are a list of entities that have BROKEN THE LAW ]]
	insaneents = {
		"player", --discrepency in class names
		"warppipe", --this doesn't have any code, it's just a marker
		"spawn", --"  "
		"manycoins", --"  "
		"pipespawn", --"  "
		"axe", --"  "
		"flag", --"  "
		
		"mazestart", "mazeend", --doesn't have its own logic, is implicit and global
		"firestart", "fireend", --"  "
		"flyingfishstart", "flyingfishend", --"  "
		"bulletbillstart", "bulletbillend", --"  "
		"windstart", "windend", --"  "
		"lakitoend", --"  ", except it doesn't even have a start?!
		
		"gel", --this alters the map when loaded, which is an extreme anomoly
	}
	
	-- this is for global allocation of images + quads
	globalimages = {}
	--[[structure:{
			imagename = {
				dims = {xdim, ydim}, --size of a single graphic
				frames = num, --how many times dims fits in the image
				quads = {},
				img = imgdata,
			}
		}
		
		if errors ever arise in reference to this, it's because an entity
		is trying to reach this when its assets have been unloaded for mysterious reasons
	]]
	
	add("Variables")
	
	--require ALL the files!
	require("libs.lube")
	class = require("libs.middleclass")
	require("libs.neubind")
	nb = neubind:new(neuControlTable)
	TLbind = require("libs.TLbind")
	binds, controls = TLbind.giveInstance(controlTable)
	require("libs.monocle")
	Monocle.new({
		isActive=false,
		customPrinter=false,
		customColor = {0, 128, 0, 255},
		debugToggle = 'f1',
		filesToWatch = {}
	})
	--[[watchfunction = function()
		local str = "n/a"
		if activeeditortool then
			str=  ""
			for k,v in pairs(activeeditortool) do str=str..tostring(k).."="..tostring(v).."\n" end
		end
		return str
	end]]
	--Monocle.watch("misc", watchfunction)
	
	require("libs.von")
	--require "netplay2"
	require "netplay"
	--require "client"
	require "server"
	require "lobby"
	
	require "shaders"
	require "variables"
	
	-- gui elements??
	require "gui.onlinemenu"
	require "gui.killfeed"
	require "gui.nodetree"
	require "gui.maptree"
	require "gui.tiletree"
	
	reloadGraphics()
	reloadSounds()
	
	spritebatches = {} --global spritebatch array, keyed by tileset name
	
	fontglyphs = "0123456789abcdefghijklmnopqrstuvwxyz.:/,\"C-_A* !{}?'()+=><#%"
	fontquads = {}
	for i = 1, string.len(fontglyphs) do
		fontquads[string.sub(fontglyphs, i, i)] = love.graphics.newQuad((i-1)*8, 0, 8, 8, fontimage:getWidth(), fontimage:getHeight())
	end
	fontquadsback = {}
	for i = 1, string.len(fontglyphs) do
		fontquadsback[string.sub(fontglyphs, i, i)] = love.graphics.newQuad((i-1)*10, 0, 10, 10, fontimageback:getWidth(), fontimageback:getHeight())
	end
	
	-- injecting this here, I'm sorry
		love.graphics.clear()
		love.graphics.setColor(100, 100, 100)
		loadingtext = loadingtexts[math.random(1,#loadingtexts)]
		
		local logoscale = scale
		if logoscale <= 1 then
			logoscale = 0.5
		else
			logoscale = 1
		end
		
		love.graphics.setColor(255, 255, 255)
		
		love.graphics.draw(logo, love.graphics.getWidth()/2, love.graphics.getHeight()/2, 0, logoscale, logoscale, 142, 150)
		love.graphics.setColor(150, 150, 150)
		properprint(loading_header, love.graphics.getWidth()/2-string.len(loading_header)*4*scale, love.graphics.getHeight()/2-170*logoscale-7*scale)
		love.graphics.setColor(50, 50, 50)
		properprint(loadingtext, love.graphics.getWidth()/2-string.len(loadingtext)*4*scale, love.graphics.getHeight()/2+165*logoscale)
		love.graphics.present()
	-- whew, that's over with
	require("libs.sha1")
	require "magic"
	require "camera"
	require "baseentity"
	require "entity"
	
	local mixins = love.filesystem.getDirectoryItems("basedmixins")

	for k,v in pairs(mixins) do
		require("basedmixins."..v:sub(0,-5))
		
		-- precache all the images used by this entity type, eventually this will be dynamic
		--for k2,v2 in pairs(_G[basedents[k]].image_sigs) do
		--	allocate_image(k2, v2[1], v2[2])
		--end]]
	end
	
	-- basedents are used for the transition from saneents to entities that actually inherit and have some common ground
	-- this is very confusing and I'm sorry for that but it's what must be done
	basedents = love.filesystem.getDirectoryItems("basedents")

	for k,v in pairs(basedents) do
		basedents[k] = v:sub(0,-5)
		require("basedents."..basedents[k])
		
		-- precache all the images used by this entity type, eventually this will be dynamic
		--for k2,v2 in pairs(_G[basedents[k]].image_sigs) do
		--	allocate_image(k2, v2[1], v2[2])
		--end]]
	end
	
	
	
	-- we don't use the saneents list here because entity name weirdness 
	--for _,v in pairs(love.filesystem.getDirectoryItems("entities")) do
	for _,v in pairs(saneents) do
		-- we're doing sub because I forgot how not to \o/
		--require("entities."..v:sub(0, -5))
		require("entities."..v)
	end
	require("weapons.portalgun")
	require("weapons.gelcannon")
	
	require "animatedquad"
	require "intro"
	require "menu"
	require "levelscreen"
	require "game"
	require "editor"
	require "animationguiline"
	require "physics"
	require "quad"
	require "hatconfigs"
	require "bighatconfigs"
	require "customhats"
	require "coinblockanimation"
	require "screenboundary"
	require "gui"
	require "musicloader"
	require "rightclickmenu"
	require "animation"
	require "animationsystem"
	require "regiondrag"
	require "animatedtimer"
	require "entitylistitem"
	require "entitytooltip"
	require "imgurupload"
	
	require "player"
	require "fire"
	require "portal"
	require "dialogbox"
	require "itemanimation"
	
	require "enemies"
	add("Requires")
	
	http = require("socket.http")
	http.PORT = 55555
	http.TIMEOUT = 1
	
	updatenotification = false
	if getupdate() then
		updatenotification = true
	end
	http.TIMEOUT = 4
	
	playertypei = 1
	playertype = playertypelist[playertypei] --portal, gelcannon
	
	if volume == 0 then
		soundenabled = false
	else
		soundenabled = true
	end
	love.filesystem.createDirectory( "mappacks" )
	editormode = false
	yoffset = 0
	love.graphics.setPointSize(3*scale)
	love.graphics.setLineWidth(2*scale)
	
	uispace = math.floor(width*16*scale/4)
	guielements = {}
	
	--limit hats
	for playerno = 1, players do
		for i = 1, #mariohats[playerno] do
			if mariohats[playerno][i] > hatcount then
				mariohats[playerno][i] = hatcount
			end
		end
	end
	
	--Backgroundcolors
	backgroundcolor = {
						{92, 148, 252},
						{0, 0, 0},
						{32, 56, 236},
						{158, 219, 248},
						{210, 159, 229},
						{237, 241, 243},
						{244, 178, 92},
						{253, 246, 175},
						{249, 183, 206},
					}
	add("Update Check, variables")
	
	--tiles
	tilequads = {}
	rgblist = {}
	
	--add smb tiles
	local imgwidth, imgheight = smbtilesimg:getWidth(), smbtilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata = love.image.newImageData("smbtiles.png")
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(smbtilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	smbtilecount = width*height
	
	--add portal tiles
	local imgwidth, imgheight = portaltilesimg:getWidth(), portaltilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata = love.image.newImageData("portaltiles.png")
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(portaltilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	portaltilecount = width*height
	
	--add entities
	entityquads = {}
	local imgwidth, imgheight = entitiesimg:getWidth(), entitiesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata = love.image.newImageData("/guihud/entities.png")
	
	for y = 1, height do
		for x = 1, width do
			table.insert(entityquads, entity:new(entitiesimg, x, y, imgwidth, imgheight))
			entityquads[#entityquads]:sett(#entityquads)
		end
	end
	entitiescount = width*height
	
	-- overload table because we can't change the timing of the above
	for k,v in pairs(entityquad_overloads) do
		entityquads[k] = v
	end
	
	numberglyphs = "0123456789"
	font2quads = {}
	for i = 1, 10 do
		font2quads[string.sub(numberglyphs, i, i)] = love.graphics.newQuad((i-1)*4, 0, 4, 8, 40, 8)
	end

	symbolglyphs = "0123"
	font3quads = {}
	for i = 1, 4 do
		font3quads[string.sub(symbolglyphs, i, i)] = love.graphics.newQuad((i-1)*4, 0, 4, 8, 40, 8)
	end
	
	popupfontquads = {}
	for i = 1, 6 do
		popupfontquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 8, 96, 8)
	end

	fireworkquads = {}
	for i = 1, 4 do
		fireworkquads[i] = love.graphics.newQuad((i-1)*32, 0, 32, 32, 128, 32)
	end
	
	oddjobhudquads = {}
	for i = 1, 5 do
		oddjobhudquads[i] = love.graphics.newQuad((i-1)*8, 0, 8, 8, 40, 8)
	end
	
	coinblockanimationquads = {}
	for i = 1, 30 do
		coinblockanimationquads[i] = love.graphics.newQuad((i-1)*8, 0, 8, 52, 256, 64)
	end
	
	coinanimationquads = {}
	for j = 1, 4 do
		coinanimationquads[j] = {}
		for i = 1, 5 do
			coinanimationquads[j][i] = love.graphics.newQuad((i-1)*5, (j-1)*8, 5, 8, 25, 32)
		end
	end
	
	--coinblock
	coinblockquads = {}
	for j = 1, 4 do
		coinblockquads[j] = {}
		for i = 1, 5 do
			coinblockquads[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*16, 16, 16, 80, 64)
		end
	end
	
	--coin
	coinquads = {}
	for j = 1, 4 do
		coinquads[j] = {}
		for i = 1, 5 do
			coinquads[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*16, 16, 16, 80, 64)
		end
	end

	--redcoin
	redcoinquads = {}
	for i = 1, 4 do
		redcoinquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end	
	
	redcointallquads = {}
	for i = 1, 4 do
		redcointallquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 32, 64, 32)
	end	
	
	redcoinbigquads = {}
	for i = 1, 4 do
		redcoinbigquads[i] = love.graphics.newQuad((i-1)*32, 0, 32, 32, 128, 32)
	end	
	
	--smoke puff
	smokepuffquads = {}
	for i = 1, 4 do
		smokepuffquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end	
	
	--leaf
	leafquad = {}
	for y = 1, 4 do
		leafquad[y] = {}
		for x = 1, 2 do
			leafquad[y][x] = love.graphics.newQuad((x-1)*8, (y-1)*8, 8, 8, 16, 32)
		end
	end
	
	--axe
	axequads = {}
	for i = 1, 5 do
		axequads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 80, 16)
	end
	
	--spring
	springquads = {}
	for i = 1, 4 do
		springquads[i] = {}
		for j = 1, 3 do
			springquads[i][j] = love.graphics.newQuad((j-1)*16, (i-1)*32, 16, 32, 48, 128)
		end
	end
	
	-- pswitch
	pswitchquads = {}
	for i = 1, 2 do
		pswitchquads[i] = {}
		for j = 1, 4 do
			pswitchquads[i][j] = love.graphics.newQuad((j-1)*16, (i-1)*16, 16, 16, 64, 32)
		end	
	end
	
	seesawquad = {}
	for i = 1, 4 do
		seesawquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end
	
	starquad = {}
	for i = 1, 4 do
		starquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end
	
	flowerquad = {}
	for i = 1, 4 do
		flowerquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end
	
	vinequad = {}
	for i = 1, 4 do
		vinequad[i] = {}
		for j = 1, 2 do
			vinequad[i][j] = love.graphics.newQuad((j-1)*16, (i-1)*16, 16, 16, 32, 64) 
		end
	end
	
	--enemies
	goombaquad = {}
	
	for y = 1, 4 do
		goombaquad[y] = {}
		for x = 1, 2 do
			goombaquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*16, 16, 16, 32, 64)
		end
	end
		
	spikeyquad = {}
	for y = 1, 4 do
		spikeyquad[y] = {}
		for x = 1, 4 do
			spikeyquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*16, 16, 16, 64, 64)
		end
	end
	
	lakitoquad = {}
	for y = 1, 4 do
		lakitoquad[y] = {}
		for x = 1, 2 do
			lakitoquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*24, 16, 24, 32, 96)
		end
	end
	
	koopaquad = {}
	
	for y = 1, 4 do
		koopaquad[y] = {}
		for x = 1, 5 do
			koopaquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*24, 16, 24, 80, 96)
		end
	end
	
	singlequad = love.graphics.newQuad(0, 0, 16, 16, 16, 16)
	
	cheepcheepquad = {}
	
	cheepcheepquad[1] = {}
	cheepcheepquad[1][1] = love.graphics.newQuad(0, 0, 16, 16, 32, 32)
	cheepcheepquad[1][2] = love.graphics.newQuad(16, 0, 16, 16, 32, 32)
	
	cheepcheepquad[2] = {}
	cheepcheepquad[2][1] = love.graphics.newQuad(0, 16, 16, 16, 32, 32)
	cheepcheepquad[2][2] = love.graphics.newQuad(16, 16, 16, 16, 32, 32)
	
	squidquad = {}
	for x = 1, 2 do
		squidquad[x] = love.graphics.newQuad((x-1)*16, 0, 16, 24, 32, 24)
	end
	
	bulletbillquad = {}
	
	for y = 1, 4 do
		bulletbillquad[y] = love.graphics.newQuad(0, (y-1)*16, 16, 16, 16, 64)
	end
	
	hammerbrosquad = {}
	for y = 1, 4 do
		hammerbrosquad[y] = {}
		for x = 1, 4 do
			hammerbrosquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*34, 16, 34, 64, 136)
		end
	end	
	
	hammerquad = {}
	for j = 1, 4 do
		hammerquad[j] = {}
		for i = 1, 4 do
			hammerquad[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*16, 16, 16, 64, 64)
		end
	end
	
	plantquads = {}
	for j = 1, 4 do
		plantquads[j] = {}
		for i = 1, 2 do
			plantquads[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*23, 16, 23, 32, 92)
		end
	end
	
	firequad = {love.graphics.newQuad(0, 0, 24, 8, 48, 8), love.graphics.newQuad(24, 0, 24, 8, 48, 8)}
	
	
	bowserquad = {}
	bowserquad[1] = {love.graphics.newQuad(0, 0, 32, 32, 64, 64), love.graphics.newQuad(32, 0, 32, 32, 64, 64)}
	bowserquad[2] = {love.graphics.newQuad(0, 32, 32, 32, 64, 64), love.graphics.newQuad(32, 32, 32, 32, 64, 64)}
	
	decoysquad = {}
	for y = 1, 7 do
		decoysquad[y] = love.graphics.newQuad(0, (y-1)*32, 32, 32, 64, 256)
	end
	
	--magic!
	magicquad = {}
	for x = 1, 6 do
		magicquad[x] = love.graphics.newQuad((x-1)*9, 0, 9, 9, 54, 9)
	end
	
	--GUI
	checkboxquad = {{love.graphics.newQuad(0, 0, 9, 9, 18, 18), love.graphics.newQuad(9, 0, 9, 9, 18, 18)}, {love.graphics.newQuad(0, 9, 9, 9, 18, 18), love.graphics.newQuad(9, 9, 9, 9, 18, 18)}}
	
	--portals
	portalquad = {}
	for i = 0, 7 do
		portalquad[i] = love.graphics.newQuad(0, i*4, 32, 4, 32, 28)
	end
	
	--Portal props	
	buttonquad = {love.graphics.newQuad(0, 0, 32, 5, 64, 5), love.graphics.newQuad(32, 0, 32, 5, 64, 5)}
	
	pushbuttonquad = {love.graphics.newQuad(0, 0, 16, 16, 32, 16), love.graphics.newQuad(16, 0, 16, 16, 32, 16)}
	
	wallindicatorquad = {love.graphics.newQuad(0, 0, 16, 16, 32, 16), love.graphics.newQuad(16, 0, 16, 16, 32, 16)}
	
	walltimerquad = {}
	for i = 1, 10 do
		walltimerquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 160, 16)
	end
	
	groundlightquad = {}
	for i = 1, 6 do
		groundlightquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 96, 16)
	end
	
	directionsquad = {}
	for x = 1, 6 do
		directionsquad[x] = love.graphics.newQuad((x-1)*7, 0, 7, 7, 42, 7)
	end
	
	excursionquad = {}
	for x = 1, 8 do
		excursionquad[x] = love.graphics.newQuad((x-1)*8, 0, 8, 32, 64, 32)
	end
	
	faithplatequad = {love.graphics.newQuad(0, 0, 32, 16, 32, 32), love.graphics.newQuad(0, 16, 32, 16, 32, 32)}
	
	gelquad = {love.graphics.newQuad(0, 0, 12, 12, 36, 12), love.graphics.newQuad(12, 0, 12, 12, 36, 12), love.graphics.newQuad(24, 0, 12, 12, 36, 12)}
	
	panelquad = {}
	for x = 1, 2 do
		panelquad[x] = love.graphics.newQuad((x-1)*16, 0, 16, 16, 32, 16)
	end
	
	add("Images, quads")
	
	--AUDIO
	delaylist = {}
	delaylist["blockhit"] = 0.2
	
	musicname = "overworld.ogg"
	
	add("Sounds")
	shaders:init()
	add("Shaders init")
	
	for i, v in pairs(dlclist) do
		delete_mappack(v)
	end
	
	firstload = true
	
	--@DEV: Copied this over, too. Probably making a mess.
	magicdns_session_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	magicdns_session = ""
	for i = 1, 8 do
		rand = math.random(string.len(magicdns_session_chars))
		magicdns_session = magicdns_session .. string.sub(magicdns_session_chars, rand, rand)
	end
	--use love.filesystem.getIdentity() when it works
	magicdns_identity = love.filesystem.getSaveDirectory():split("/")
	magicdns_identity = string.upper(magicdns_identity[#magicdns_identity])
	
	add("Intro Load")
	print("TOTAL: " .. totaltime .. "ms")
	
	mycamera = camera:new()
	mycamera:zoomTo(0.4)
	
	skipintro=true
	if skipintro then
		menu_load()
	else
		intro_load()
	end
	
	hook.Call("LovePostLoad", args)
end

function love.update(dt)
	hook.Call("LovePreUpdate", dt)
	if music then
		music:update()
	end
	timer.Update(dt)
	Monocle.update()
	nb:update(dt)
	TLbind:update()
	binds:update()
	controlsUpdate(dt)
	realdt = dt
	dt = math.min(0.5, dt) --ignore any dt higher than half a second
	
	if recording then
		dt = recordtarget
	end
	
	steptimer = steptimer + dt
	dt = targetdt
	
	if skipupdate then
		steptimer = 0
		skipupdate = false
		return
	end
	
	--speed
	if bullettime and speed ~= speedtarget then
		if speed > speedtarget then
			speed = math.max(speedtarget, speed+(speedtarget-speed)*dt*5)
		elseif speed < speedtarget then
			speed = math.min(speedtarget, speed+(speedtarget-speed)*dt*5)
		end
		
		if math.abs(speed-speedtarget) < 0.02 then
			speed = speedtarget
		end
		
		if speed > 0 then
			for i, v in pairs(soundlist) do
				v.source:setPitch( speed )
			end
			music.pitch = speed
			love.audio.setVolume(volume)
		else	
			love.audio.setVolume(0)
		end
	end
	
	while steptimer >= targetdt do
		steptimer = steptimer - targetdt
		
		if frameskip then
			if frameskip > skippedframes then
				skippedframes = skippedframes + 1
				return
			else
				skippedframes = 0
			end
		end
		
		keyprompt_update()
		
		if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" or gamestate == "lobby" then
			menu_update(dt)
		elseif gamestate == "levelscreen" or gamestate == "gameover" or gamestate == "sublevelscreen" or gamestate == "mappackfinished" then
			levelscreen_update(dt)
		elseif gamestate == "game" then
			game_update(dt)	
		elseif gamestate == "intro" then
			intro_update(dt)	
		end
		if onlinemp then
			if clientisnetworkhost then
				server_update(dt)
			end
			network_update(dt)
		end
		
		for i, v in pairs(guielements) do
			v:update(dt)
		end
		
		--netplay_update(dt)
		
		notice.update(dt)
		killfeed.update(dt)
		
		love.window.setTitle("NCN:"..networkclientnumber.."; FPS:" .. love.timer.getFPS())
	end
	hook.Call("LovePostUpdate", dt)
end

function love.draw()
	hook.Call("LovePreDraw")
	shaders:predraw()
	
	--mycamera:attach()
	if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" or gamestate == "lobby" then
		menu_draw()
	elseif gamestate == "levelscreen" or gamestate == "gameover" or gamestate == "mappackfinished" then
		levelscreen_draw()
	elseif gamestate == "game" then
		game_draw()
	elseif gamestate == "intro" then
		intro_draw()
	end
	
	notice.draw()
	killfeed.draw()
	
	--mycamera:detach()
	
	shaders:postdraw()
		
	love.graphics.setColor(255, 255,255)
	
	if recording then
		screenshotimagedata = love.graphics.newScreenshot( )
		screenshotimagedata:encode("recording/" .. recordframe .. ".png")
		recordframe = recordframe + 1
		screenshotimagedata = nil
		
		if recordframe%100 == 0 then
			collectgarbage("collect")
		end
	end
	Monocle.draw()
	hook.Call("LovePostDraw")
end

function saveconfig()
	if CLIENT or SERVER then
		return
	end
	
	local s = ""
	for i = 1, #oldcontrols do
		s = s .. "playercontrols:" .. i .. ":"
		local count = 0
		for j, k in pairs(oldcontrols[i]) do
			local c = ""
			for l = 1, #oldcontrols[i][j] do
				c = c .. oldcontrols[i][j][l]
				if l ~= #oldcontrols[i][j] then
					c = c ..  "-"
				end
			end
			s = s .. j .. "-" .. c
			count = count + 1
			if count == 12 then
				s = s .. ";"
			else
				s = s .. ","
			end
		end
	end	
	
	for i = 1, #mariocolors do --players
		s = s .. "playercolors:" .. i .. ":"
		if #mariocolors[i] > 0 then
			for j = 1, #mariocolors[i] do --colorsets (dynamic)
				for k = 1, 3 do --R, G or B values
					s = s .. mariocolors[i][j][k]
					if j == #mariocolors[i] and k == 3 then
						s = s .. ";"
					else
						s = s .. ","
					end
				end
			end
		else
			s = s .. ";"
		end
	end
	
	for i = 1, #mariocharacter do
		s = s .. "mariocharacter:" .. i .. ":"
		s = s .. mariocharacter[i]
		s = s .. ";"
	end
	
	for i = 1, #portalhues do
		s = s .. "portalhues:" .. i .. ":"
		s = s .. round(portalhues[i][1], 4) .. "," .. round(portalhues[i][2], 4) .. ";"
	end
	
	for i = 1, #mariohats do
		s = s .. "mariohats:" .. i
		if #mariohats[i] > 0 then
			s = s .. ":"
		end
		for j = 1, #mariohats[i] do
			s = s .. mariohats[i][j]
			if j == #mariohats[i] then
				s = s .. ";"
			else
				s = s .. ","
			end
		end
		
		if #mariohats[i] == 0 then
			s = s .. ";"
		end
	end
	
	s = s .. "scale:" .. scale .. ";"
	
	s = s .. "shader1:" .. shaderlist[currentshaderi1] .. ";"
	s = s .. "shader2:" .. shaderlist[currentshaderi2] .. ";"
	
	s = s .. "graphicspack:" .. graphicspacklist[graphicspacki] .. ";"
	s = s .. "soundpack:" .. soundpacklist[soundpacki] .. ";"
	
	s = s .. "volume:" .. volume .. ";"
	s = s .. "mouseowner:" .. mouseowner .. ";"
	
	s = s .. "mappack:" .. mappack .. ";"
	
	if vsync then
		s = s .. "vsync;"
	end
	
	if gamefinished then
		s = s .. "gamefinished;"
	end
	
	s = s .. "fullscreen:" .. tostring(fullscreen) .. ";"
	s = s .. "fullscreenmode:" .. fullscreenmode .. ";"
	
	--reached worlds
	for i, v in pairs(reachedworlds) do
		s = s .. "reachedworlds:" .. i .. ":"
		for j = 1, 8 do
			if v[j] then
				s = s .. 1
			else
				s = s .. 0
			end
			
			if j == 8 then
				s = s .. ";"
			else
				s = s .. ","
			end
		end
	end
	
	love.filesystem.write("options.txt", s)
end

function loadconfig()
	players = 1
	defaultconfig()
	
	if not love.filesystem.exists("options.txt") then
		return
	end
	
	local s = love.filesystem.read("options.txt")
	s1 = s:split(";")
	
	for i = 1, #s1-1 do
		s2 = s1[i]:split(":")
		if s2[1] == "playercontrols" then
			if oldcontrols[tonumber(s2[2])] == nil then
				oldcontrols[tonumber(s2[2])] = {}
			end
			
			s3 = s2[3]:split(",")
			for j = 1, #s3 do
				s4 = s3[j]:split("-")
				oldcontrols[tonumber(s2[2])][s4[1]] = {}
				for k = 2, #s4 do
					if tonumber(s4[k]) ~= nil then
						oldcontrols[tonumber(s2[2])][s4[1]][k-1] = tonumber(s4[k])
					else
						oldcontrols[tonumber(s2[2])][s4[1]][k-1] = s4[k]
					end
				end
			end
			players = math.max(players, tonumber(s2[2]))
			
		elseif s2[1] == "playercolors" then
			if mariocolors[tonumber(s2[2])] == nil then
				mariocolors[tonumber(s2[2])] = {}
			end
			s3 = s2[3]:split(",")
			mariocolors[tonumber(s2[2])] = {}
			for i = 1, #s3/3 do
				mariocolors[tonumber(s2[2])][i] = {tonumber(s3[1+(i-1)*3]), tonumber(s3[2+(i-1)*3]), tonumber(s3[3+(i-1)*3])}
			end
		elseif s2[1] == "portalhues" then
			if portalhues[tonumber(s2[2])] == nil then
				portalhues[tonumber(s2[2])] = {}
			end
			s3 = s2[3]:split(",")
			portalhues[tonumber(s2[2])] = {tonumber(s3[1]), tonumber(s3[2])}
		
		elseif s2[1] == "mariohats" then
			local playerno = tonumber(s2[2])
			mariohats[playerno] = {}
			
			if s2[3] == "mariohats" then --SAVING WENT WRONG OMG
			
			elseif s2[3] then
				s3 = s2[3]:split(",")
				for i = 1, #s3 do
					local hatno = tonumber(s3[i])
					mariohats[playerno][i] = hatno
				end
			end
			
		elseif s2[1] == "scale" then
			scale = tonumber(s2[2])
			
		elseif s2[1] == "shader1" then
			for i = 1, #shaderlist do
				if shaderlist[i] == s2[2] then
					currentshaderi1 = i
				end
			end
		elseif s2[1] == "shader2" then
			for i = 1, #shaderlist do
				if shaderlist[i] == s2[2] then
					currentshaderi2 = i
				end
			end
		elseif s2[1] == "graphicspack" then
			for i = 1, #graphicspacklist do
				if graphicspacklist[i] == s2[2] then
					graphicspacki = i
					graphicspack = s2[2]
				end
			end
		elseif s2[1] == "soundpack" then
			for i = 1, #soundpacklist do
				if soundpacklist[i] == s2[2] then
					soundpacki = i
					soundpack = s2[2]
				end
			end
		elseif s2[1] == "volume" then
			volume = tonumber(s2[2])
			love.audio.setVolume( volume )
		elseif s2[1] == "mouseowner" then
			mouseowner = tonumber(s2[2])
		elseif s2[1] == "mappack" then
			if love.filesystem.exists("mappacks/" .. s2[2] .. "/settings.txt") then
				mappack = s2[2]
			end
		elseif s2[1] == "gamefinished" then
			gamefinished = true
		elseif s2[1] == "vsync" then
			vsync = true
		elseif s2[1] == "reachedworlds" then
			reachedworlds[s2[2]] = {}
			local s3 = s2[3]:split(",")
			for i = 1, #s3 do
				if tonumber(s3[i]) == 1 then
					reachedworlds[s2[2]][i] = true
				end
			end
		elseif s2[1] == "mariocharacter" then
			mariocharacter[tonumber(s2[2])] = s2[3]
		elseif s2[1] == "fullscreen" then
			fullscreen = s2[2] == "true"
		elseif s2[1] == "fullscreenmode" then
			fullscreenmode = s2[2]
		end
	end
	
	for i = 1, math.max(4, players) do
		portalcolor[i] = {getrainbowcolor(portalhues[i][1]), getrainbowcolor(portalhues[i][2])}
	end
	
	players = 1
end

function defaultconfig()
	--------------
	-- CONTORLS --
	--------------
	
	-- Joystick stuff:
	-- joy, #, hat, #, direction (r, u, ru, etc)
	-- joy, #, axe, #, pos/neg
	-- joy, #, but, #
	-- You cannot set Hats and Axes as the jump button. Bummer.
	
	mouseowner = 1
	
	oldcontrols = {}
	
	local i = 1
	oldcontrols[i] = {}
	oldcontrols[i]["right"] = {"d"}
	oldcontrols[i]["left"] = {"a"}
	oldcontrols[i]["down"] = {"s"}
	oldcontrols[i]["up"] = {"w"}
	oldcontrols[i]["run"] = {"lshift"}
	oldcontrols[i]["jump"] = {" "}
	oldcontrols[i]["aimx"] = {""} --mouse aiming, so no need
	oldcontrols[i]["aimy"] = {""}
	oldcontrols[i]["portal1"] = {""}
	oldcontrols[i]["portal2"] = {""}
	oldcontrols[i]["reload"] = {"r"}
	oldcontrols[i]["use"] = {"e"}
	
	for i = 2, 4 do
		oldcontrols[i] = {}		
		oldcontrols[i]["right"] = {"joy", i-1, "hat", 1, "r"}
		oldcontrols[i]["left"] = {"joy", i-1, "hat", 1, "l"}
		oldcontrols[i]["down"] = {"joy", i-1, "hat", 1, "d"}
		oldcontrols[i]["up"] = {"joy", i-1, "hat", 1, "u"}
		oldcontrols[i]["run"] = {"joy", i-1, "but", 3}
		oldcontrols[i]["jump"] = {"joy", i-1, "but", 1}
		oldcontrols[i]["aimx"] = {"joy", i-1, "axe", 5, "neg"}
		oldcontrols[i]["aimy"] = {"joy", i-1, "axe", 4, "neg"}
		oldcontrols[i]["portal1"] = {"joy", i-1, "but", 5}
		oldcontrols[i]["portal2"] = {"joy", i-1, "but", 6}
		oldcontrols[i]["reload"] = {"joy", i-1, "but", 4}
		oldcontrols[i]["use"] = {"joy", i-1, "but", 2}
	end
	-------------------
	-- PORTAL COLORS --
	-------------------
	
	portalhues = {}
	portalcolor = {}
	for i = 1, 4 do
		local players = 4
		portalhues[i] = {(i-1)*(1/players), (i-1)*(1/players)+0.5/players}
		portalcolor[i] = {getrainbowcolor(portalhues[i][1]), getrainbowcolor(portalhues[i][2])}
	end
	
	--hats.
	mariohats = {}
	for i = 1, 4 do
		mariohats[i] = {1}
	end
	
	------------------
	-- MARIO COLORS --
	------------------
	--1: hat, pants (red)
	--2: shirt, shoes (brown-green)
	--3: skin (yellow-orange)
	
	mariocolors = {}
	mariocolors[1] = {{224,  32,   0}, {136, 112,   0}, {252, 152,  56}}
	mariocolors[2] = {{255, 255, 255}, {  0, 160,   0}, {252, 152,  56}}
	mariocolors[3] = {{  0,   0,   0}, {200,  76,  12}, {252, 188, 176}}
	mariocolors[4] = {{ 32,  56, 236}, {  0, 128, 136}, {252, 152,  56}}
	for i = 5, players do
		mariocolors[i] = mariocolors[math.random(4)]
	end
	
	--STARCOLORS
	starcolors = {}
	starcolors[1] = {{  0,   0,   0}, {200,  76,  12}, {252, 188, 176}}
	starcolors[2] = {{  0, 168,   0}, {252, 152,  56}, {252, 252, 252}}
	starcolors[3] = {{252, 216, 168}, {216,  40,   0}, {252, 152,  56}}
	starcolors[4] = {{216,  40,   0}, {252, 152,  56}, {252, 252, 252}}
	
	flowercolor = {{252, 216, 168}, {216,  40,   0}, {252, 152,  56}}
	
	--CHARACTERS
	mariocharacter = {"mario", "mario", "mario", "mario"}
	
	--options
	scale = 2
	volume = 1
	mappack = "smb"
	vsync = false
	currentshaderi1 = 1
	currentshaderi2 = 1
	graphicspacki = 1
	graphicspack = "DEFAULT"
	soundpacki = 1
	soundpack = "DEFAULT"
	firstpersonview = false
	firstpersonrotate = false
	seethroughportals = false
	fullscreen = false
	fullscreenmode = "letterbox"
	
	reachedworlds = {}
end

function loadcustomimages(path)
	for i = 1, #overwrittenimages do
		local s = overwrittenimages[i]
		_G[s .. "img"] = _G["default" .. s .. "img"]
	end
	overwrittenimages = {}

	local fl = love.filesystem.getDirectoryItems(path)
	for i = 1, #fl do
		local v = fl[i]
		if love.filesystem.isFile(path .. "/" .. v) then
			local s = string.sub(v, 1, -5)
			if table.contains(imagelist, s) then
				_G[s .. "img"] = love.graphics.newImage(path .. "/" .. v)
				table.insert(overwrittenimages, s)
			end
		end
	end
	
	--tiles
	tilequads = {}
	rgblist = {}
	
	--add smb tiles
	local imgwidth, imgheight = smbtilesimg:getWidth(), smbtilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata
	if love.filesystem.isFile(path .. "/smbtiles.png") then
		imgdata = love.image.newImageData(path .. "/smbtiles.png")
	else
		imgdata = love.image.newImageData("graphics/DEFAULT/smbtiles.png")
	end
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(smbtilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	smbtilecount = width*height
	
	--add portal tiles
	local imgwidth, imgheight = portaltilesimg:getWidth(), portaltilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata
	if love.filesystem.isFile(path .. "/portaltiles.png") then
		imgdata = love.image.newImageData(path .. "/portaltiles.png")
	else
		imgdata = love.image.newImageData("graphics/DEFAULT/portaltiles.png")
	end
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(portaltilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	portaltilecount = width*height
end

--[[function suspendgame()
	local s = ""
	if marioworld == "M" then
		marioworld = 1
		mariolevel = 3
	end
	s = s .. "a/" .. marioworld .. "|"
	s = s .. "b/" .. mariolevel .. "|"
	s = s .. "c/" .. mariocoincount .. "|"
	s = s .. "d/" .. marioscore .. "|"
	s = s .. "e/" .. players .. "|"
	for i = 1, players do
		if mariolivecount ~= false then
			s = s .. "f/" .. i .. "/" .. mariolives[i] .. "|"
		end
		if objects["player"][i] then
			s = s .. "g/" .. i .. "/" .. objects["player"][i].size .. "|"
		else
			s = s .. "g/" .. i .."/1|"
		end
	end
	s = s .. "h/" .. mappack
	
	love.filesystem.write("suspend.txt", s)
	
	love.audio.stop()
	menu_load()
end]]

--[[function continuegame()
	if not love.filesystem.exists("suspend.txt") then
		return
	end
	
	local s = love.filesystem.read("suspend.txt")
	
	mariosizes = {}
	mariolives = {}
	
	local split = s:split("|")
	--@TODO: Gotta make room for currentmap = "1-1" in the save.
	for i = 1, #split do
		local split2 = split[i]:split("/")
		if split2[1] == "a" then
			marioworld = tonumber(split2[2])
		elseif split2[1] == "b" then
			mariolevel = tonumber(split2[2])
		elseif split2[1] == "c" then
			mariocoincount = tonumber(split2[2])
		elseif split2[1] == "d" then
			marioscore = tonumber(split2[2])
		elseif split2[1] == "e" then
			players = tonumber(split2[2])
		elseif split2[1] == "f" and mariolivecount ~= false then
			mariolives[tonumber(split2[2])] = tonumber(split2[3])
		elseif split2[1] == "g" then
			mariosizes[tonumber(split2[2])] = tonumber(split2[3])
		elseif split2[1] == "h" then
			mappack = split2[2]
		end
	end
	
	love.filesystem.remove("suspend.txt")
end]]

function changescale(s, init)
	scale = s
	
	if not init then
		if width*16*scale > desktopsize.width then
			if fullscreen and fullscreenmode == "full" then
				scale = scale - 1
				return
			end
			
			if fullscreen and fullscreenmode == "touchfrominside" then
				fullscreenmode = "full"
				scale = scale - 1
				return
			end
			
			if love.graphics.isSupported("canvas") then
				fullscreen = true
			end
			
			scale = scale - 1
			fullscreenmode = "touchfrominside"
			
		elseif fullscreen then
			if fullscreenmode == "full" then
				fullscreenmode = "touchfrominside"
				scale = scale + 1
				return
			else
				fullscreen = false
			end
			scale = scale + 1
			fullscreenmode = "full"
			
		end
	end
	
	if fullscreen then
		love.window.setMode(desktopsize.width, desktopsize.height, {fullscreen=fullscreen, vsync=vsync, fsaa=fsaa})
	else
		uispace = math.floor(width*16*scale/4)
		love.window.setMode(width*16*scale, height*16*scale, {fullscreen=fullscreen, vsync=vsync, fsaa=fsaa}) --25x14 blocks (15 blocks actual height)
	end
	
	if love.graphics.isSupported("canvas") then
		completecanvas = love.graphics.newCanvas()
		completecanvas:setFilter("linear", "linear")
	end
	
	gamewidth = love.window.getWidth()
	gameheight = love.window.getHeight()
	
	if shaders then
		shaders:refresh()
	end
	
	if generatespritebatch then
		generatespritebatch()
	end
end
function screenshotUploadWrap(iname, idata)
	local t=upload_imagedata(iname, idata)
	if t.success then
		print("Your image was uploaded to: "..t.data.link)
		love.system.setClipboardText(t.data.link)
		notice.new("screenshot uploaded")
		--love.filesystem.write("screenshot_url.txt", t.data.link)
		--openImage(t.data.link)
	else
		print("Your image upload failed, please upload '"..outname.."' manually.")
		notice.new("upload failed, try manually")
		openSaveFolder()
	end
end

function controlsUpdate(dt)
	if controls.tap.gameScreenshot then
		screenshotUploadWrap("screenshot.png", love.graphics.newScreenshot())
	end
	
	if controls.tap.editorGetMousePosition then
		local x, y = getMouseTile(mouse.getX(), mouse.getY())
		print("mouse position", x, y)
	end
	
	if controls.debugModifier then
		
		if controls.tap.recordToggle then
			recording = not recording
		end
		if replaysystem and controls.tap.replaySave then
			objects["player"][1]:savereplaydata()
		end
		if controls.tap.debugLua then
			debug.debug()
		end
		if controls.tap.debugCrash then
			totallynonexistantfunction()
		end
	end
	
	if controls.tap.gameGrabMouseToggle then
		love.mouse.setGrabbed(not love.mouse.isGrabbed())
	end
	
	if gamestate == "lobby" or gamestate == "onlinemenu" then
		if controls.tap.menuBack then
			net_quit()
			return
		end
	end
	
	if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" then
		menu_controlupdate(dt)
	elseif gamestate == "game" then
		game_controlupdate(dt)
	elseif gamestate == "intro" then
		intro_skip()
	end
end

function love.keypressed(key, isrepeat)
	if keyprompt then
		keypromptenter("key", key)
		return
	end

	--@WARNING: This is the sample of code that causes the online lobby to edit all textboxes at once.
	for i, v in pairs(guielements) do
		if v:keypress(string.lower(key)) then
			--return
		end
	end
	
	if testbed then
		for k,v in pairs(testbed) do
			if v.active then
				v:keypressed(key)
			end
		end
	end
	
	
	if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" then
		table.insert(konamitable, key)
		table.remove(konamitable, 1)
		local s = ""
		for i = 1, #konamitable do
			s = s .. konamitable[i]
		end
		
		if sha1(s) == konamihash then --Before you wonder how dumb this is; This used to be a different code than konami because I thought it'd be fun to make people figure it out before they can tell others how to easily unlock cheats (without editing files). It wasn't, really.
			playsound("konami") --allowed global
			gamefinished = true
			saveconfig()
			notice.new("Cheats unlocked!")
		end
	elseif gamestate == "game" and editormode and rightclickm then
		-- aside from the transplanted code above, this was the only thing left in the editor's keypressed
		rightclickm:keypressed(key)
	elseif gamestate == "intro" then
		intro_skip()
	end
end

function getMousePos()
	--[[local x, y = love.mouse.getX(), love.mouse.getY()
	if fullscreen then
		if fullscreenmode == "full" then
			x, y = x/(desktopsize.width/(width*16*scale)), y/(desktopsize.height/(height*16*scale))
		else
			x, y = x/(touchfrominsidescaling/scale), y/(touchfrominsidescaling/scale)-touchfrominsidemissing/2
		end
	end]]
	return mouse.getX(), mouse.getY()
end

function love.mousepressed(ox, oy, button)
	local x, y = getMousePos()
	if gamestate == "intro" then
		intro_skip()
	end
	
	--editor transplant because I guess the editor doesn't use the standard guielements array
	
	--editor transplant because ???
	if rightclickm then
		allowdrag = false
		if button == "r" or not rightclickm:mousepressed(x, y, button) then
			closerightclickmenu()
			return
		else
			return
		end
	end
	
	if testbed then
		for k,v in pairs(testbed) do
			if v.active then
				v:mousepressed(x, y, button)
			end
		end
	end
	
	for i, v in pairs(guielements) do
		if v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(guielements) do
		if not v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
end

function love.mousereleased(ox, oy, button)
	local x, y = getMousePos()
	--desktopsize.width/(width*16*scale)*x, desktopsize.height/(height*16*scale)*y
	
	for i, v in pairs(guielements) do
		v:unclick(x, y, button)
	end
	
	if testbed then
		for k,v in pairs(testbed) do
			if v.active then
				v:mousereleased(x, y, button)
			end
		end
	end
	
	--same as above
	if rightclickm then
		rightclickm:mousereleased(x, y, button)
	end
end

function round(num, idp) --Not by me
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

function keyPromptSignal(itype, ...)
	
end

function getrainbowcolor(i)
	local whiteness = 255
	local r, g, b
	if i < 1/6 then
		r = 1
		g = i*6
		b = 0
	elseif i >= 1/6 and i < 2/6 then
		r = (1/6-(i-1/6))*6
		g = 1
		b = 0
	elseif i >= 2/6 and i < 3/6 then
		r = 0
		g = 1
		b = (i-2/6)*6
	elseif i >= 3/6 and i < 4/6 then
		r = 0
		g = (1/6-(i-3/6))*6
		b = 1
	elseif i >= 4/6 and i < 5/6 then
		r = (i-4/6)*6
		g = 0
		b = 1
	else
		r = 1
		g = 0
		b = (1/6-(i-5/6))*6
	end
	
	return {round(r*whiteness), round(g*whiteness), round(b*whiteness), 255}
end

function newRecoloredImage(path, tablein, tableout)
	local imagedata = love.image.newImageData( path )
	local width, height = imagedata:getWidth(), imagedata:getHeight()
	
	for y = 0, height-1 do
		for x = 0, width-1 do
			local oldr, oldg, oldb, olda = imagedata:getPixel(x, y)
			
			if olda > 128 then
				for i = 1, #tablein do
					if oldr == tablein[i][1] and oldg == tablein[i][2] and oldb == tablein[i][3] then
						local r, g, b = unpack(tableout[i])
						imagedata:setPixel(x, y, r, g, b, olda)
					end
				end
			end
		end
	end
	
	return love.graphics.newImage(imagedata)
end

function getaveragecolor(imgdata, cox, coy)	
	local xstart = (cox-1)*17
	local ystart = (coy-1)*17
	
	local r, g, b = 0, 0, 0
	
	local count = 0
	
	for x = xstart, xstart+15 do
		for y = ystart, ystart+15 do
			local pr, pg, pb, a = imgdata:getPixel(x, y)
			if a > 127 then
				r, g, b = r+pr, g+pg, b+pb
				count = count + 1
			end
		end
	end
	
	r, g, b = r/count, g/count, b/count
	
	return r, g, b
end

function keyprompt_update()
	if keyprompt then
		for i = 1, prompt.joysticks do
			for j = 1, #prompt.joystick[i].validhats do
				local dir = love.joystick.getHat(i, prompt.joystick[i].validhats[j])
				if dir ~= "c" then
					keypromptenter("joyhat", i, prompt.joystick[i].validhats[j], dir)
					return
				end
			end
			
			for j = 1, prompt.joystick[i].axes do
				local value = love.joystick.getAxis(i, j)
				if value > prompt.joystick[i].axisposition[j] + joystickdeadzone then
					keypromptenter("joyaxis", i, j, "pos")
					return
				elseif value < prompt.joystick[i].axisposition[j] - joystickdeadzone then
					keypromptenter("joyaxis", i, j, "neg")
					return
				end
			end
		end
	end
end

function print_r (t, indent) --Not by me
	local indent=indent or ''
	for key,value in pairs(t) do
		io.write(indent,'[',tostring(key),']') 
		if type(value)=="table" then io.write(':\n') print_r(value,indent..'\t')
		else io.write(' = ',tostring(value),'\n') end
	end
end

--[[function love.focus(f)
	if not f and gamestate == "game"and not editormode and not levelfinished and not everyonedead  then
		pausemenuopen = true
		love.audio.pause()
	end
end]]
function openImage(img)
	local path = love.filesystem.getSaveDirectory()
	
	local cmdstr
	local successval = 0
	
	if os.getenv("WINDIR") then -- windows
		cmdstr = "Explorer \"%s\""
	elseif os.getenv("HOME") then
		if path:match("/Library/Application Support") then -- OSX
			cmdstr = "open \"%s\""
		else -- linux?
			cmdstr = "xdg-open \"%s\""
		end
	end
	
	os.execute(cmdstr:format(img))
	return cmdstr~=nil
end
function openSaveFolder(subfolder) --By Slime
	local path = love.filesystem.getSaveDirectory()
	path = subfolder and path.."/"..subfolder or path
	
	local cmdstr
	local successval = 0
	
	if os.getenv("WINDIR") then -- lolwindows
		--cmdstr = "Explorer /root,%s"
		if path:match("LOVE") then --hardcoded to fix ISO characters in usernames and made sure release mode doesn't mess anything up -saso
			cmdstr = "Explorer %%appdata%%\\LOVE\\Marin0SE"
		else
			cmdstr = "Explorer %%appdata%%\\Marin0SE"
		end
		path = path:gsub("/", "\\")
		successval = 1
	elseif os.getenv("HOME") then
		if path:match("/Library/Application Support") then -- OSX
			cmdstr = "open \"%s\""
		else -- linux?
			cmdstr = "xdg-open \"%s\""
		end
	end
	
	-- returns true if successfully opened folder
	return cmdstr and os.execute(cmdstr:format(path)) == successval
end

function getupdate()
	local onlinedata, code = http.request("http://server.stabyourself.net/mari0/?mode=mappacks")
	if code ~= 200 then
		return false
	elseif not onlinedata then
		return false
	end
	
	local latestversion
	
	local split1 = onlinedata:split("<")
	for i = 2, #split1 do
		local split2 = split1[i]:split(">")
		if split2[1] == "latestversion" then
			latestversion = tonumber(split2[2])
		end
	end
	
	if latestversion and latestversion > marioversion then
		return true
	end
	return false
end

function properprint(s, x, y, sc)
	local scale = sc or scale
	local startx = x
	local skip = 0
	for i = 1, string.len(tostring(s)) do
		if skip > 0 then
			skip = skip - 1
		else
			local char = string.sub(s, i, i)
			if string.sub(s, i, i+3) == "_dir" and tonumber(string.sub(s, i+4, i+4)) then
				love.graphics.draw(directionsimg, directionsquad[tonumber(string.sub(s, i+4, i+4))], x+((i-1)*8+1)*scale, y, 0, scale, scale)
				skip = 4
			elseif char == "|" then
				x = startx-((i)*8)*scale
				y = y + 10*scale
			elseif fontquads[char] then
				love.graphics.draw(fontimage, fontquads[char], x+((i-1)*8)*scale, y, 0, scale, scale)
			end
		end
	end
end

function properprintbackground(s, ox, oy, include, dcolor, sc)
	--[[if type(s)~="string" then
		print("WARNING: Tried to properprint a non-string.")
		return
	end]]
	local scale = sc or scale
	local x = ox
	local y = oy
	local startx = x
	local dcolor = dcolor or {255,255,255}
	local skip = 0
	local precolor = {love.graphics.getColor()}
	love.graphics.setColor(unpack(dcolor))
	for i = 1, string.len(tostring(s)) do
		if skip > 0 then
			skip = skip - 1
		else
			local char = string.sub(s, i, i)
			if char == "|" then
				x = startx-((i)*8)*scale
				y = y + 10*scale
			elseif fontquadsback[char] then
				love.graphics.draw(fontimageback, fontquadsback[char], x+((i-1)*8)*scale, y-1*scale, 0, scale, scale)
			end
		end
	end
	love.graphics.setColor(unpack(precolor))
	if include ~= false then
		properprint(s, ox, oy, scale)
	end
end

function loadcustombackgrounds()
	custombackgrounds = {}

	custombackgroundimg = {}
	custombackgroundwidth = {}
	custombackgroundheight = {}
	local fl = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/backgrounds")
	
	for i = 1, #fl do
		local v = "mappacks/" .. mappack .. "/backgrounds/" .. fl[i]
		
		if love.filesystem.isFile(v) then
			if string.sub(v, -5, -5) == "1" then
				local name = string.sub(fl[i], 1, -6)
				local bg = string.sub(v, 1, -6)
				local i = 1
				
				custombackgroundimg[name] = {}
				custombackgroundwidth[name] = {}
				custombackgroundheight[name] = {}
					
				while love.filesystem.exists(bg .. i .. ".png") do
					print("background", bg, "index", i)
					custombackgroundimg[name][i] = love.graphics.newImage(bg .. i .. ".png")
					custombackgroundwidth[name][i] = custombackgroundimg[name][i]:getWidth()/16
					custombackgroundheight[name][i] = custombackgroundimg[name][i]:getHeight()/16
					i = i + 1
				end
				table.insert(custombackgrounds, name)
			--[[else
				local name = string.sub(fl[i], 1, -5)
				local bg = string.sub(v, 1, -5)
				
				custombackgroundimg[name] = {love.graphics.newImage(bg .. ".png")}
				custombackgroundwidth[name] = {custombackgroundimg[name][1]:getWidth()/16}
				custombackgroundheight[name] = {custombackgroundimg[name][1]:getHeight()/16}
				
				table.insert(custombackgrounds, name)]]
			end
		end
	end
end

function loadlevelscreens()
	levelscreens = {}
	
	local fl = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/levelscreens")
	
	for i = 1, #fl do
		local v = "mappacks/" .. mappack .. "/levelscreens/" .. fl[i]
		if love.filesystem.isFile(v) then
			table.insert(levelscreens, string.lower(string.sub(fl[i], 1, -5)))
		end
	end
end

function loadcustommusics()
	musiclist = {"none.ogg", "overworld.ogg", "underground.ogg", "castle.ogg", "underwater.ogg", "starmusic.ogg", "athletic.ogg",}
	local fl = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/music")
	custommusics = {}
	
	for i = 1, #fl do
		local v = fl[i]
		if (v:match(".ogg") or v:match(".mp3")) and v:sub(-9, -5) ~= "-fast" then
			table.insert(musiclist, v)
			--music:load(v) --Sometimes I come back to code and wonder why things are commented out. This is one of those cases. But it works so eh.
		end
	end
end

function loadanimatedtiles()
	if animatedtilecount then
		for i = 1, animatedtilecount do
			tilequads["a" .. i] = nil
		end
	end
	
	local function loadfolder(folder)
		local fl = love.filesystem.getDirectoryItems(folder)
		
		local i = 1
		while love.filesystem.isFile(folder .. "/" .. i .. ".png") do
			local v = folder .. "/" .. i .. ".png"
			if love.filesystem.isFile(v) and string.sub(v, -4) == ".png" then
				if love.filesystem.isFile(string.sub(v, 1, -5) .. ".txt") then
					animatedtilecount = animatedtilecount + 1
					local number = animatedtilecount+10000
					local t = animatedquad:new(v, love.filesystem.read(string.sub(v, 1, -5) .. ".txt"), number)
					tilequads[number] = t
					table.insert(animatedtiles, t)
				end
			end
			i = i + 1
		end
	end
	
	animatedtilecount = 0
	animatedtiles = {}
	loadfolder("graphics/animated")
	loadfolder("mappacks/" .. mappack .. "/animated")
end

function loadcustomtiles()
	if love.filesystem.exists("mappacks/" .. mappack .. "/tiles.png") then
		customtiles = true
		customtilesimg = love.graphics.newImage("mappacks/" .. mappack .. "/tiles.png")
		local imgwidth, imgheight = customtilesimg:getWidth(), customtilesimg:getHeight()
		local width = math.floor(imgwidth/17)
		local height = math.floor(imgheight/17)
		local imgdata = love.image.newImageData("mappacks/" .. mappack .. "/tiles.png")
		
		for y = 1, height do
			for x = 1, width do
				table.insert(tilequads, quad:new(customtilesimg, imgdata, x, y, imgwidth, imgheight))
				local r, g, b = getaveragecolor(imgdata, x, y)
				table.insert(rgblist, {r, g, b})
			end
		end
		customtilecount = width*height
	else
		customtiles = false
		customtilecount = 0
	end
end

function reloadGraphics()
	-- this doesn't rebuild quads so if any of these change resolution we're royally hosed
	iconimg = love.image.newImageData("/guihud/icon.gif")
	love.window.setIcon(iconimg)

	fontimage = love.graphics.newImage("/guihud/font.png")
	fontimageback = love.graphics.newImage("/guihud/fontback.png")
	
	logo = love.graphics.newImage("/guihud/stabyourself.png")
	logoblood = love.graphics.newImage("/guihud/stabyourselfblood.png")
	
	for _, v in pairs(imagelist) do
		_G[v .. "img"] = love.graphics.newImage( v .. ".png")
	end
	
	transparencyimg:setWrap("repeat", "repeat")
	
	menuselection = love.graphics.newImage("/guihud/menuselect.png")
	mappackback = love.graphics.newImage("/guihud/mappackback.png")
	mappacknoicon = love.graphics.newImage("/guihud/mappacknoicon.png")
	mappackoverlay = love.graphics.newImage("/guihud/mappackoverlay.png")
	mappackhighlight = love.graphics.newImage("/guihud/mappackhighlight.png")
	
	mappackscrollbar = love.graphics.newImage("/guihud/mappackscrollbar.png")
	
	fontimage2 = love.graphics.newImage("/guihud/smallfont.png")
	fontimage3 = love.graphics.newImage("/guihud/smallsymbols.png")
	
	entitiesimg = love.graphics.newImage("/guihud/entities.png")
	
	popupfontimage = love.graphics.newImage("/guihud/popupfont.png")
	
	linktoolpointerimg = love.graphics.newImage("/guihud/linktoolpointer.png")
	
	titleimage = love.graphics.newImage("/guihud/title.png")
	playerselectimg = love.graphics.newImage("/guihud/playerselectarrow.png")
	
	magicimg = love.graphics.newImage("/guihud/magic.png")
	
	checkboximg = love.graphics.newImage("/guihud/checkbox.png")
	
	dropdownarrowimg = love.graphics.newImage("/guihud/dropdownarrow.png")
	
	portalparticleimg = love.graphics.newImage("portalparticle.png")
	portalcrosshairimg = love.graphics.newImage("portalcrosshair.png")
	portaldotimg = love.graphics.newImage("portaldot.png")
	portalprojectileimg = love.graphics.newImage("portalprojectile.png")
	portalprojectileparticleimg = love.graphics.newImage("portalprojectileparticle.png")
	portalbackgroundimg = love.graphics.newImage("portalbackground.png")
	
	--Menu shit
	huebarimg = love.graphics.newImage("/guihud/huebar.png")
	huebarmarkerimg = love.graphics.newImage("/guihud/huebarmarker.png")
	volumesliderimg = love.graphics.newImage("/guihud/volumeslider.png")
	directionsimg = love.graphics.newImage("/guihud/directions.png")
	
	gradientimg = love.graphics.newImage("/guihud/gradient.png")
	gradientimg:setFilter("linear", "linear")
	
	--@WARNING: This code is a bad influence because icons that don't already exist can't be introduced by a modpack. I'll fix it later.
	killfeed.icons = {}
	killfeed.exicons = {}
	local gdir = "graphics/DEFAULT/"
	local idir = "ui/icons/kill"
	for h,s in ipairs(love.filesystem.getDirectoryItems(gdir..idir)) do
		if love.filesystem.isFile(gdir..idir.."/"..s) then
			killfeed.icons[s:sub(0,-5)] = love.graphics.newImage(gdir..idir.."/"..s)
		end
	end
	idir = "ui/icons"
	for h,s in ipairs(love.filesystem.getDirectoryItems(gdir..idir)) do
		if love.filesystem.isFile(gdir..idir.."/"..s) then
			killfeed.exicons[s:sub(0,-5)] = love.graphics.newImage(gdir..idir.."/"..s)
		end
	end
	
end

function reloadSounds() -- mastersfx, master list of sounds current being looked at.
	soundstoload = {"none", "jump", "jumpbig", "stomp", "shot", "blockhit", "blockbreak", "coin", "pipe", "boom", "mushroomappear", "mushroomeat", "shrink", "death", "gameover", "fireball", "redcoin1", "redcoin2", "redcoin3", "redcoin4", "redcoin5", "boss_spit", "enemy_hit", "rainboom", "kirbyenemy",
					"oneup", "levelend", "castleend", "scorering", "intermission", "fire", "bridgebreak", "bowserfall", "vine", "swim", "konami", "pause", "bulletbill", "addtime", "throw", "trophy", "switch",
					"lowtime", "tailwag", "planemode", "stab", "spring", "portal1open", "portal2open", "portalenter", "portalfizzle"}
				
	soundlist = {}
	
	for i, v in pairs(soundstoload) do
		local dat = love.sound.newSoundData(v..".ogg")
		soundlist[v] = {}
		soundlist[v].duration = dat:getDuration()
		soundlist[v].samplecount = dat:getSampleCount()
		soundlist[v].samplerate = dat:getSampleRate()
		soundlist[v].source = love.audio.newSource(dat)
		soundlist[v].lastplayed = 0
	end
	
	soundlist["scorering"].source:setLooping(true)
	soundlist["planemode"].source:setLooping(true)
	soundlist["portal1open"].source:setVolume(0.3)
	soundlist["portal2open"].source:setVolume(0.3)
	soundlist["portalenter"].source:setVolume(0.3)
	soundlist["portalfizzle"].source:setVolume(0.3)
end

function love.quit()
	
end

function savestate(i)
	serializetable(_G)
end

function serializetable(t)
	tablestodo = {t}
	tableindex = {}
	repeat
		nexttablestodo = {}
		for i, v in pairs(tablestodo) do
			if type(v) == "table" then
				local tableexists = false
				for j, k in pairs(tableindex) do
					if k == v then
						tableexists = true
					end
				end
				
				if tableexists then
					
				else
					table.insert(nexttablestodo, v)
					table.insert(tableindex, v)
				end
			end
		end
		tablestodo = nexttablestodo
	until #tablestodo == 0
end

mouse = {}

function mouse.getPosition()
	if fullscreen then
		if fullscreenmode == "full" then
			return love.mouse.getX()/(desktopsize.width/(width*16*scale)), love.mouse.getY()/(desktopsize.height/(height*16*scale))
		else
			return love.mouse.getX()/(touchfrominsidescaling/scale), love.mouse.getY()/(touchfrominsidescaling/scale)-touchfrominsidemissing/2
		end
	else
		return love.mouse.getPosition()
	end
end

function mouse.getX()
	if fullscreen then
		if fullscreenmode == "full" then
			return love.mouse.getX()/(desktopsize.width/(width*16*scale))
		else
			return love.mouse.getX()/(touchfrominsidescaling/scale)
		end
	else
		return love.mouse.getX()
	end
end

function mouse.getY()
	if fullscreen then
		if fullscreenmode == "full" then
			return love.mouse.getY()/(desktopsize.height/(height*16*scale))
		else
			return love.mouse.getY()/(touchfrominsidescaling/scale)-touchfrominsidemissing/2
		end
	else
		return love.mouse.getY()
	end
end

function net_quit()
	gamestate = "menu"
	guielements = {}
	if onlinemp then
		if not clientisnetworkhost then
			local unconnectedstring = tostring(udp)
			local splitstring = unconnectedstring:split(":")
			if splitstring[1] == "udp{connected}" then
				udp:send("clientquit;" .. networkclientnumber)
			end
		else
			server_shutserver()
			print("shutting server")
		end
		if clientisnetworkhost then
			magicdns_remove()
		end
	end
end
end end)()end;
do require("package").preload["basedmixins.CanEmancipate"] = (function() local package;return function(...)-- <pack basedmixins.CanEmancipate> --
CanEmancipate = {
	emancipatecheck = true,
	-- this will be used to prevent further updates once emancipated
	was_emancipated = false
}

function CanEmancipate:emancipate()
	print("baseentity told to emancipate")
	if not self.was_emancipated then
		local speedx, speedy = self.speedx, self.speedy
		if self.carrier then
			speedx = speedx + self.carrier.speedx
			speedy = speedy + self.carrier.speedy
			self.carrier:drop_held()
			self.carrier = nil --in the event that our carrier doesn't call our dropped method
		end
		table.insert(objects["emancipateanimation"], emancipateanimation:new(self.x, self.y, self.width, self.height, self.graphic, self.quad, speedx, speedy, self.rotation, self.offsetX, self.offsetY, self.quadcenterX, self.quadcenterY))
		self:remove()
		self.was_emancipated = true
		self.drawable = false
	end
end
end end)()end;
do require("package").preload["basedmixins.CanCollect"] = (function() local package;return function(...)-- <pack basedmixins.CanCollect> --
CanCollect = {}

function CanCollect:collect(ply)
	-- the presence of this will cause the player that collides with it to invoke it,
	-- usually this should be the same as destroy but with context of being player-oriented
	-- additionally it prevents having to employ custom handlers
end
end end)()end;
do require("package").preload["basedmixins.CanFunnel"] = (function() local package;return function(...)-- <pack basedmixins.CanFunnel> --
CanFunnel = {
	-- can the object be funneled?
	can_funnel = false,
	-- true when this is being handled by a funnel
	funnel = false,
	-- this is an edge-switch against funnel so that we can detect entry/exit
	infunnel = false,
}

function CanFunnel:funnelcallback(entering)
	-- if we go into a funnel, this is what we do
	if entering then
		self.infunnel = true
	else
		self.infunnel = false
		self.gravity = nil
	end
end
end end)()end;
do require("package").preload["basedmixins.CanFaithplate"] = (function() local package;return function(...)-- <pack basedmixins.CanFaithplate> --
CanFaithplate = {
	can_faithplate = true,
	falling = true,
}

function CanFaithplate:faithPlate(dir)
	self.falling = true
end

function CanFaithplate:startFall() -- this is presumably used by a faithplate as a callback, I can't be sure
	self.falling = true
end
end end)()end;
do require("package").preload["basedmixins.HasSounds"] = (function() local package;return function(...)-- <pack basedmixins.HasSounds> --
HasSounds = {
	activesounds = {},
	filters = {},
	
}
--[[
	REQUIRES ATTRIBUTES:
	r
	
	EXPECTED STATIC PROPERTIES:
	sig_sounds = {
		soundname = {
			volume = 1.0,
			pitch = 1.0,
			relative = true,
			use_velocity = true,
			use_
		}
	}
]]
function HasSounds.filters.delete_sounds(k, v)
	return v.source:tell("samples") >= v.samplecount
end

function HasSounds:playSound(sound, is_static, use_velocity)
	if not soundlist[sound] then
		print("WARNING: Entity tried to play nonexistant sound: "..sound)
		return
	end

	if soundenabled then
		if delaylist[sound] then
			local currenttime = love.timer.getTime()
			if currenttime-soundlist[sound].lastplayed > delaylist[sound] then
				soundlist[sound].lastplayed = currenttime
			else
				return
			end
		end
		local soundclone = table.combine(soundlist[sound])
		soundclone.source = soundlist[sound].source:clone()
		soundclone.moves = true
		soundclone.use_velocity = false
		if is_static then
			soundclone.moves = false
		end
		soundclone.source:setRelative(false)
		soundclone.source:setPosition(self.x, self.y, self.z)
		if use_velocity then
			-- velocity has the potential to sound weird, so, it's optional
			soundclone.use_velocity = true
			soundclone.source:setVelocity(self.speedx, self.speedy, self.speedz)
		else
			soundclone.source:setVelocity(0, 0, 0)
		end
		soundclone.source:play()
		table.insert(self.activesounds, soundclone)
	end
end

function HasSounds:cacheSound(sound, settings)
	if soundlist[sound] then
		print("WARNING: Tried to load existing sound.")
		return false
	end
	
	local dat = love.sound.newSoundData(v..".ogg")
	soundlist[sound] = {}
	soundlist[sound].duration = dat:getDuration()
	soundlist[sound].samplecount = dat:getSampleCount()
	soundlist[sound].samplerate = dat:getSampleRate()
	soundlist[sound].source = love.audio.newSource(dat)
	soundlist[sound].lastplayed = 0
	if settings.volume then
		soundlist[sound].source:setVolume(settings.volume)
	end
	if settings.pitch then
		soundlist[sound].source:setPitch(settings.pitch)
	end
	if settings.looping then
		soundlist[sound].source:setLooping(settings.looping)
	end
end

function HasSounds:included(klass)
	-- import the noises
	for k,v in pairs(klass.SOUND_SIGS) do
		self:cacheSound(k, v)
	end
end
end end)()end;
do require("package").preload["basedmixins.HasOutputs"] = (function() local package;return function(...)-- <pack basedmixins.HasOutputs> --
HasOutputs = {
	outputTable = {},
	hasOutput = true,
}

function HasOutputs:addoutput(a, t)
	table.insert(self.outputTable, {a, t})
end

function HasOutputs:out(t)
	for i = 1, #self.outputTable do
		-- if it has an input method, feed it the data
		if self.outputTable[i][1].input then
			self.outputTable[i][1]:input(t, self.outputTable[i][2])
		end
		-- if it doesn't, how did it get here to begin with?
	end
end

function HasOutputs:toggle_all_outputs()
	for i = 1, #self.outputTable do
		if self.outputTable[i][1].input then
			self.outputTable[i][1]:input("toggle", self.outputTable[i][2])
		end
	end
end

function HasOutputs:included(klass)
	if entitylist[klass.EDITOR_ENTDEX] then
		entitylist[klass.EDITOR_ENTDEX].output = true
		
		if outputs and outputsi then
			table.insert(outputs, klass.name)
			table.insert(outputsi, klass.EDITOR_ENTDEX)
		else
			print("CRITICAL: Mixin HasOutputs tried to append a property to outputs and outputsi but they didn't exist.")
		end
	else
		print("CRITICAL: Mixin HasOutputs tried to append a property to the entitylist but it didn't exist.")
	end
end
end end)()end;
do require("package").preload["basedmixins.IsMappable"] = (function() local package;return function(...)-- <pack basedmixins.IsMappable> --
IsMappable = {}
--[[
	REQUIRES ATTRIBUTES:
	r
	
	EXPECTED STATIC PROPERTIES:
	
]]

--[[Takes inputs similarly to how we save the data through the editor, where signature is:
	{t="optiontype", 
]]
function IsMappable:getBasicInput(vartoset)
	--vartoset corresponds to a local variable to overwrite
	if #self.r > 0 and self.r[1] ~= "link" then
		self[vartoset] = self.r[1]
		table.remove(self.r, 1)
		-- we got the data correctly
		return true
	else
		print("CRITICAL: Entity wasn't able to read data from the r table.")
		-- we did not get the data correctly
		return false
	end
end

-- this shouldn't be used on include but I'll leave it dummied for fun
function IsMappable:included(klass)
	-- list entry
	if entitylist then
		entitylist[klass.EDITOR_ENTDEX] = {
			t=klass.name,
			category=klass.EDITOR_CATEGORY,
			description=klass.EDITOR_DESC,
			iconauthor=klass.EDITOR_ICONAUTHOR,
		}
	else
		print("CRITICAL: Mixin IsMappable tried to set entitylist but it didn't exist.")
	end
	
	-- tooltip image
	if tooltipimages then
		local path = "entitytooltips/" .. klass.name .. ".png"
		tooltipimages[klass.EDITOR_ENTDEX] = love.graphics.newImage(path)
	else
		print("CRITICAL: Mixin IsMappable tried to set tooltipimages but it didn't exist.")
	end
	
	-- rightclick menus
	if rightclickmenues then
		rightclickmenues[klass.name] = klass.EDITOR_RCM
	else
		print("CRITICAL: Mixin IsMappable tried to set rightclickmenues but it didn't exist.")
	end
	
	-- entity quads
	if entityquad_overloads then
		entityquad_overloads[klass.EDITOR_ENTDEX] = entity:new(
			globalimages[klass.name].img,
			globalimages[klass.name].quads[1]
		)
		entityquad_overloads[klass.EDITOR_ENTDEX].t = klass.name
	else
		print("CRITICAL: Mixin IsMappable tried to set entityquads but it didn't exist.")
	end
	
	-- consider incremeting this, but not really 
	--entitiescount
end

end end)()end;
do require("package").preload["basedmixins.Base"] = (function() local package;return function(...)-- <pack basedmixins.Base> --
-- this is a convenience collection while I clean house of baseentity
--[[
	this is a stub for static entities that control their own movement
	
	if you think you might need collision at any point, use HasPhysics instead
]]

Base = {
	x = 0, width  = 0, speedx = 0, centerx = 0,
	y = 0, height = 0, speedy = 0, centery = 0,
	z = 0, depth  = 0, speedz = 0, centerz = 0,
	
	moves = false,
	category = 1,
	mask = {true, false},
	active = true,
	drawable = true, --try to use the global drawhandler if possible, disable if we can't
}
--[[
	REQUIRES ATTRIBUTES:
	r
	
	EXPECTED STATIC PROPERTIES:
	
]]

function Base:setPosition(nx, ny, nz)
	if type(nx) == "table" then
		nz = nx[3]
		ny = nx[2]
		nx = nx[1]
	end
	self.x = nx or 0
	self.y = ny or 0
	self.z = nz or 0
end
end end)()end;
do require("package").preload["basedmixins.HasInputs"] = (function() local package;return function(...)-- <pack basedmixins.HasInputs> --
-- OtherClass:include(HasInputs) gives it all elements of that table
HasInputs = {
	inputTable = {},
}

function HasInputs:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do -- factor this out please
			for i, v in pairs(objects[w]) do -- this also seems unnecessary
				--check if the coordinates match a linked object
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					-- alert the item that they have a new listener
					v:addoutput(self, self.r[2])
					-- initialize the input table index with nothing
					self.inputTable[tonumber(self.r[2])] = "off"
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function HasInputs:input(signaltype, inputindex)
	local inp = tonumber(inputindex)
	if inp then
		if signaltype == "toggle" then
			if self.inputTable[inp] == "on" then
				self.inputTable[inp] = "off"
			else
				self.inputTable[inp] = "on"
			end
		else
			-- assuming that this is either "on" or "off"
			self.inputTable[inp] = signaltype
		end
		
		-- if we want to have a purely reactive element, we would signal outputs here
		-- instead of doing it on next update
	else
		print("WARNING: Entity received an input signal that wasn't valid.")
	end
end
end end)()end;
do require("package").preload["basedmixins.CanPortal"] = (function() local package;return function(...)-- <pack basedmixins.CanPortal> --
CanPortal = {
	-- whether or not we override the default portal method with a local one
	portaloverride = true,
	-- this has to do with being carried and portalability, I don't know, it's confusing
	portaledframe = false
}

function CanPortal:portaled()
	-- this is only triggered if we have portaloverride
	self.portaledframe = true
end
end end)()end;
do require("package").preload["basedmixins.CanDamage"] = (function() local package;return function(...)-- <pack basedmixins.CanDamage> --
CanDamage = {
	-- what kind of damage this does
	doesdamagetype = "toilet",
}

function CanDamage:doDamage(target, ...)
	target:do_damage(self.doesdamagetype, self.lastinfluence, ...)
end
end end)()end;
do require("package").preload["basedmixins.HasPhysics"] = (function() local package;return function(...)-- <pack basedmixins.HasPhysics> --
HasPhysics = {
	-- keep in mind that x/y are linked to draw positions 
	x = 0, roll  = 0, width  = 0, speedx = 0, centerx = 0,
	y = 0, pitch = 0, height = 0, speedy = 0, centery = 0,
	z = 0, yaw   = 0, depth  = 0, speedz = 0, centerz = 0,
	--[[
		"center" attributes are provided as a convenience
		if you offset them I'll break your fingers, you monster
	]]
	
	mass = 0, --this is here because supplying gravity as a number makes no sense
	
	-- gravity should be a product of these things here
	gravity = 80, --added/subtracted across x/y/z
	gravitydirection = math.pi/2, --(in radians) the angle to apply gravity to
	friction = 14, --14 is the player's base friction, the box is 20
	friction_airmult = 0, --calculated from friction to get air friction
	
	-- is this falling? should gravity be applied?
	falling = true,
	
	-- if the player and other things can push 
	pushable = false,
	-- a flag for whether or not we're actively being pushed
	pushed = false,
	
	-- regardless of influence we do this
	doesdamagetype = "physics",
	
	-- collision
	category = 1,
	mask = {true},
	
	--[[
		these both control physics updates
		
		moves is used to discriminate against checkrect
		active is used to determine whether it should be considered for physupdate
	]]
	active = true, --this is meant to be turned on and off
	moves = true, --man what does this do
}

function HasPhysics:setPosition(nx, ny, nz)
	if type(nx) == "table" then
		nz = nx[3]
		ny = nx[2]
		nx = nx[1]
	end
	self.x = nx or 0
	self.y = ny or 0
	self.z = nz or 0
end

function HasPhysics:setSpeed(nx, ny, nz)
	if type(nx) == "table" then
		nz = nx[3]
		ny = nx[2]
		nx = nx[1]
	end
	if not ny then ny = nx end
	if not nz then nz = ny end
	
	self.speedx = nx or 0
	self.speedy = ny or 0
	self.speedz = nz or 0
end

function HasPhysics:setOSize(nw, nh, nd)
	if type(nw) == "table" then
		nd = nd[3]
		nh = nh[2]
		nw = nw[1]
	end
	if not nh then nh = nw end
	if not nd then nd = nh end
	
	self.width  = nw/16 or 0
	self.height = nh/16 or 0
	self.depth  = nd/16 or 0
	
	self.centerx = self.width/2
	self.centery = self.height/2
	self.centerz = self.depth/2
end

function HasPhysics:setSize(nw, nh, nd)
	if type(nw) == "table" then
		nd = nd[3]
		nh = nh[2]
		nw = nw[1]
	end
	if not nh then nh = nw end
	if not nd then nd = nh end
	
	self.width  = nw or 0
	self.height = nh or 0
	self.depth  = nd or 0
	
	self.centerx = self.width/2
	self.centery = self.height/2
	self.centerz = self.depth/2
end



--[[Takes inputs similarly to how we save the data through the editor, where signature is:
	{t="optiontype", 
]]
--[[function IsMappable:included(klass)
	-- Go through the input map
	for k,v in pairs(klass.INPUT_MAP) do
		self:getBasicInput(v)
	end
end]]
end end)()end;
do require("package").preload["basedmixins.CanCarry"] = (function() local package;return function(...)-- <pack basedmixins.CanCarry> --
-- this provides the info so the object can be carried and held in the player's hands like a box

CanCarry = {
	carrier = nil, --who is carrying the this, if anybody at all
	carriable = true, --if, for whatever reason, we wish to not be carriable
}

function CanCarry:used(ply)
	-- where ply is a reference to the player object
	if self.carriable then
		self.carrier = ply
		self.active = false
		ply:pick_up(self)
		self:setInfluence(ply) 
	end
end

function CanCarry:drop()
	if self.carriable then
		self.carrier = nil
		self.active = true
	else
		print("WARNING: CanCarry was dropped but it wasn't supposed to be carried in the first place.")
	end
end
end end)()end;
do require("package").preload["basedmixins.CanInfluence"] = (function() local package;return function(...)-- <pack basedmixins.CanInfluence> --
--[[
	this is primarily for tracking who touched something last for kill attribution
]]
CanInfluence = {
	canInfluence = true,
	influencers = {},
	lastInfluence = nil,
	
	-- if this is capable of being influenced by a player to kill someone
	influencable = true,
	-- last player to touch this, or nobody
}

function CanInfluence:setInfluence(inf)
	if self.influencable then
		self.lastinfluence = inf
		return true
	else
		return false
	end
end
end end)()end;
do require("package").preload["basedmixins.HasGraphics"] = (function() local package;return function(...)-- <pack basedmixins.HasGraphics> --
--[[
	this doesn't supply a prefab draw method because we use it's presence 
	
]]

--[[
	USED STATICS:
	image_sigs
]]

HasGraphics = {
	-- offsets for drawing
	cox = 0, offsetX = 0, quadcenterX = 0,
	coy = 0, offsetY = 0, quadcenterY = 0,
	coz = 0, offsetZ = 0, quadcenterZ = 0,
	
	--this is technically a physical property but it's also a visual one, I'm sorry
	rotation = 0,
	
	drawable = true, --by turning this off, you can disable drawing by the global handler
	visible = true, --this is for e
	
	graphicid = nil, --should be classname by default
	graphic = nil, --globalimages[self.graphicid].img or missinggraphicimg
	
	quad = nil, --this is a reference to the global quad list
	quadi = 1, --index in the quadlist
}

function HasGraphics:setGraphic(id, quadwrap)
	-- if quadwrap is true, we'll modulo the current quadi to the new graphic, else, reset to 1
	self.graphicid = id
	self.graphic = globalimages[self.graphicid].img or missinggraphicimg
	if not quadwrap then
		self.quadi = 1
	end
	self:setQuad(self.quadi)
	-- worst case scenario, this call is redundant; best: we wrap number that's too big/small
end

function HasGraphics:setQuad(ind)
	ind = ind or self.quadi
	-- set the quad based on the current graphics set
	self.quadi = ind%(globalimages[self.graphicid].frames+1)
	if self.quadi == 0 then
		--the only thing modulo and 1-indexed languages weren't prepared for
		self.quadi = 1
	end
	self.quad = globalimages[self.graphicid].quads[self.quadi]
end
--hoo boy
function HasGraphics:setOffset(nx, ny, nz)
	if type(nx) == "table" then
		nz = nx[3]
		ny = nx[2]
		nx = nx[1]
	end
	if not ny then ny = nx end
	if not nz then nz = ny end
	
	self.offsetX = nx or 0
	self.offsetY = ny or 0
	self.offsetZ = nz or 0
end

function HasGraphics:setQuadCenter(nx, ny, nz)
	if type(nx) == "table" then
		nz = nx[3]
		ny = nx[2]
		nx = nx[1]
	end
	if not ny then ny = nx end
	if not nz then nz = ny end
	
	self.quadcenterX = nx or 0
	self.quadcenterY = ny or 0
	self.quadcenterZ = nz or 0
end

function HasGraphics:setCo(nx, ny, nz)
	if type(nx) == "table" then
		nz = nx[3]
		ny = nx[2]
		nx = nx[1]
	end
	if not ny then ny = nx end
	if not nz then nz = ny end
	
	self.cox = nx or 0
	self.coy = ny or 0
	self.coz = nz or 0
end

--@TODO: Needs a static method to pre-queue assets.
function HasGraphics:cacheImage(imgname, dimx, dimy)
	globalimages[imgname] = {quads = {}, dims={dimx,dimy}}
	local gl = globalimages[imgname]
	
	gl.img = love.image.newImageData(imgname..".png")
	local timg = love.graphics.newImage(gl.img)
	local w, h = math.floor(timg:getWidth()/dimx), math.floor(timg:getHeight()/dimy)
	gl.img = timg
	gl.frames=w*h
	for y = 1, h do
		-- Yeah, I'm not entirely certain why I'm allowing the use of y>1, but here we are.
		for x = 1, w do
			table.insert(gl.quads, love.graphics.newQuad((x-1)*dimx, (y-1)*dimy, dimx, dimy, timg:getDimensions()))
		end
	end
end

function HasGraphics:nextFrame()
	-- I don't know why I let this quirk exist but I haven't enough sample data to factor it out yet.
	self:setQuad(self.quadi)
	self.quadi = self.quadi + 1
end

-- doing it upon load is dubious but we don't have a way to get all resources used in a level yet
function HasGraphics:included(klass)
	-- Go through the input map
	for k,v in pairs(klass.GRAPHIC_SIGS) do
		self:cacheImage(k, v[1],v[2])
	end
end
end end)()end;
do require("package").preload["rightclickmenu"] = (function() local package;return function(...)-- <pack rightclickmenu> --
rightclickmenu = class("rightclickmenu")

rightclickwidth = 110
rightclickcellheight = 9
rightclickcellspacing = 2

rightclickelementslist = {"scrollbar", "input", "checkbox", "directionbuttons", "submenu", "regionselect"}

function rightclickmenu:init(x, y, elements, tx, ty)
	self.elements = elements
	self.x = x 
	self.y = y
	
	self.tx = tx
	self.ty = ty
	
	--keep menu in window
	if self.x + rightclickwidth > width*16 then
		self.x = width*16 - rightclickwidth
	end
	
	if self.y + ((rightclickcellheight+rightclickcellspacing)*#self.elements+1) > height*16 then
		self.y = height*16 - ((rightclickcellheight+rightclickcellspacing)*#self.elements+1)
	end
	
	self.t = {}
	self.variables = {}
	local actuali = 1
	for i = 1, #self.elements do
		local v = self.elements[i]
		local set = false
		local variablesadd = {}
		if v.t == "text" then
			table.insert(self.t, guielement:new(v.t, self.x, self.y+2+(rightclickcellheight+rightclickcellspacing)*(i-1), v.value))
			table.insert(self.variables, v)
			
		elseif v.t == "button" then
			table.insert(self.t, guielement:new(v.t, self.x, self.y+(rightclickcellheight+rightclickcellspacing)*(i-1), v.value, nil, nil, nil, nil, rightclickwidth-3))
			table.insert(self.variables, v)
			
		elseif v.t == "linkbutton" then
			table.insert(self.t, guielement:new("button", self.x, self.y+(rightclickcellheight+rightclickcellspacing)*(i-1), v.value, nop, nil, {nil, self, v.link, false}, nil, rightclickwidth-14, false, rightclickmenu.linkcallback))
			table.insert(self.t, guielement:new("button", self.x+rightclickwidth-11, self.y+(rightclickcellheight+rightclickcellspacing)*(i-1), "x", nop, nil, {nil, self, v.link, true}, nil, 8, false, rightclickmenu.linkcallback))
			self.t[#self.t].textcolor = {200, 0, 0}
			table.insert(self.variables, v)
			
		elseif v.t == "regionselect" then
			table.insert(self.t, guielement:new("button", self.x, self.y+(rightclickcellheight+rightclickcellspacing)*(i-1), v.value, nop, nil, {nil, self, v.region}, nil, rightclickwidth-3, false, rightclickmenu.regioncallback))
			table.insert(self.variables, v)
			
		elseif v.t == "scrollbar" then
			local current = 0
			if string.sub(map[tx][ty][actuali+2], 1, 1) == "m" then
				current = -tonumber(string.sub(map[tx][ty][actuali+2], 2))
			else
				current = tonumber(map[tx][ty][actuali+2])
			end
			
			table.insert(self.t, guielement:new(v.t, self.x+1, self.y+1+(rightclickcellheight+rightclickcellspacing)*(i-1), rightclickwidth-2, 33, rightclickcellheight, current, "hor", true, v.min, v.max, v.step))
			set = true
			self.t[#self.t].backgroundcolor = {0, 0, 0, 255}
			
		elseif v.t == "input" then
			local default = v.default
			if map[tx][ty][actuali+2] then
				default = map[tx][ty][actuali+2]
			end
			table.insert(self.t, guielement:new(v.t, self.x, self.y+(rightclickcellheight+rightclickcellspacing)*(i-1), rightclickwidth/8-5/8, nil, default, v.max))
			set = true
			
		elseif v.t == "checkbox" then
			local start = false
			if map[tx][ty][actuali+2] == "true" then
				start = true
			end
			table.insert(self.t, guielement:new(v.t, self.x+1, self.y+1+(rightclickcellheight+rightclickcellspacing)*(i-1), nil, start, v.text))
			set = true
			
		elseif v.t == "directionbuttons" then
			local j = 0
			local add = {}
			
			for k = 1, 6 do
				local dir
				if k == 1 then
					dir = "hor"
				elseif k == 2 then
					dir = "ver"
				elseif k == 3 then
					dir = "left"
				elseif k == 4 then
					dir = "up"
				elseif k == 5 then
					dir = "right"
				elseif k == 6 then
					dir = "down"
				end
				
				if v[dir] then
					table.insert(add, guielement:new("button", self.x+j*12, self.y+(rightclickcellheight+rightclickcellspacing)*(i-1), "_dir" .. k, rightclickmenu.directioncallback, nil, {nil, self, #self.t+1, dir}, nil, rightclickcellheight-1))
					j = j + 1
					
					if map[tx][ty][actuali+2] == dir then
						add[#add].bordercolor = {255, 0, 0}
						add[#add].bordercolorhigh = {255, 127, 127}
						
						
						variablesadd["value"] = dir
					end				
				end
			end
			
			table.insert(self.t, add)
			set = true
			
		elseif v.t == "submenu" then
		
			local values
			if type(v.entries) == "function" then
				values = v.entries()
			else
				values = v.entries
			end
			
			local start = map[tx][ty][actuali+2]
			
			if v.actualvalue then
				for i, w in pairs(values) do
					if w == start then
						start = i
					end
				end
			end
			
			if not tonumber(start) then
				start = 1
			end
			
			table.insert(self.t, guielement:new(v.t, self.x, self.y+(rightclickcellheight+rightclickcellspacing)*(i-1), 12.5, v.width or 6, values, start))
			self.t[#self.t].actualvalue = v.actualvalue
			set = true
			
		end
		
		if set then
			actuali = actuali + 1
			table.insert(self.variables, v)
			
			for j, k in pairs(variablesadd) do
				self.variables[#self.variables][j] = k
			end
		end
			
		
		self.t[#self.t].active = true
	end
end

function rightclickmenu:update(dt)
	for i = 1, #self.t do
		if type(self.t[i][1]) == "table" then
			for j = 1, #self.t[i] do
				self.t[i][j]:update(dt)
			end
		else
			self.t[i]:update(dt)
		end
	end
end

function rightclickmenu:draw()
	love.graphics.setColor(50, 50, 50, 180*rightclicka)
	--background
	love.graphics.rectangle("fill", self.x*scale, self.y*scale, rightclickwidth*scale, ((rightclickcellheight+rightclickcellspacing)*#self.elements+1)*scale)
	
	for i, v in pairs(self.t) do
		if type(self.t[i][1]) == "table" then
			for j = 1, #self.t[i] do
				self.t[i][j]:draw(rightclicka*255)
			end
		else
			self.t[i]:draw(rightclicka*255)
		end
	end
end

function rightclickmenu:mousepressed(x, y, button)
	local r = false
	for i = 1, #self.t do
		if type(self.t[i][1]) == "table" then
			for j = 1, #self.t[i] do
				if self.t[i][j]:click(x, y, button) then
					r = true
				end
			end
		else
			if self.t[i]:click(x, y, button) then
				r = true
			end
		end
	end
	
	if r then
		return true
	end
	
	if x < self.x*scale or x >= (self.x+rightclickwidth)*scale or y < self.y*scale or y > (self.y+(rightclickcellheight+rightclickcellspacing)*#self.elements+1)*scale then
		return false
	end
	
	return true
end

function rightclickmenu:mousereleased(x, y, button)
	for i = 1, #self.t do
		if type(self.t[i][1]) == "table" then
			for j = 1, #self.t[i] do
				self.t[i][j]:unclick(x, y, button)
			end
		else
			self.t[i]:unclick(x, y, button)
		end
	end
end

function rightclickmenu:keypressed(key)
	for i = 1, #self.t do
		if self.t[i].type then
			if self.t[i]:keypress(key) then
				return
			end
		end
	end
end

function rightclickmenu:linkcallback(self, t, rem)
	if rem then
		removelink(self.tx, self.ty, t)
	else
		startlinking(self.tx, self.ty, t)
	end
end

function rightclickmenu:regioncallback(self, t)
	startregion(self.tx, self.ty, t)
end

function rightclickmenu:directioncallback(self, y, x)
	for i = 1, #self.t[y] do
		self.t[y][i].bordercolor = {127, 127, 127}
		self.t[y][i].bordercolorhigh = {255, 255, 255}
	end
	
	for i = 1, #self.t[y] do
		if self.t[y][i].arguments[4] == x then
			self.t[y][i].bordercolor = {255, 0, 0}
			self.t[y][i].bordercolorhigh = {255, 127, 127}
			break
		end
	end
	
	self.variables[y].value = x
end
end end)()end;
do require("package").preload["basedents.scrollingtext"] = (function() local package;return function(...)-- <pack basedents.scrollingtext> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

-- custom stuff
thisclass.static.frametime = 0.8
thisclass.static.scrollheight = 2.5

--[[
thisclass.static.GRAPHIC_QUADCENTER = {8,4,0}
thisclass.static.GRAPHIC_OFFSET = {8,4,0}
thisclass.static.GRAPHIC_SIGS = {
	popupfont = {16,8}
}
]]

thisclass:include(Base)
--thisclass:include(HasGraphics)

function thisclass:init(x, y, text, stype)
	baseentity.init(self, x, y+.5, 0, nil)
	--baseentity.init(self, thisclass, classname, x-.5, y-.5, 0, nil, parent)
	self.text = text
	self.stype = stype or "score" --score, life, time, coin
	
	--[[ reference this if things go weird
		self.width, self.height = 16, 8
		self.offsetX, self.offsetY = self.width/2, self.height/2
		self.quadcenterX, self.quadcenterY = self.width/2, self.height/2
		self.width, self.height = 16/16, 8/16
	]]
	--[[ not used because HasGraphics currently disabled
		self.graphicid = "popupfont"
		self.graphic = globalimages[self.graphicid].img or missinggraphicimg
		-- the comment below about self.quad also applies here
		self.quadi = 1
		self.quad = globalimages[self.graphicid].quads[self.quadi]
	]]
	--self.timermax = thisclass.frametime
	--self.timer = 0
	
	--self.maxy = self.y-thisclass.scrollheight
	
	self.drawable = false
	
	timer.Simple(thisclass.frametime, 
		function()
			self:remove()
		end
	)
	
	--table.insert(objects[classname], self)
end

function thisclass:update(dt)
	baseentity.update(self, dt)
	
	self.y = self.y - (thisclass.scrollheight/thisclass.frametime)*dt
	--math.floor((self.y-1.5-2.8*(dt/0.8))*16*scale)
	--math.floor((self.y-1.5-thisclass.scrollheight*(self.timer/thisclass.frametime))*16*scale)
	
	--[[if self.y < self.maxy or self.destroy then
		return true
	end]]
	
	return self.destroy
end

function thisclass:draw()
	--properprintbackground(self.s, self.x*16*scale, (self.y-.5-self.timer)*16*scale, true, nil, scale)
	properprint2(self.text, math.floor((self.x-0.4-xscroll)*16*scale), math.floor((self.y-1.5-yscroll)*16*scale))
	if self.stype == "life" then
		--love.graphics.draw(popupfontimage, popupfontquads[1], math.floor((scrollingscores[i].x)*16*scale), math.floor((scrollingscores[i].y-1.5-scrollingscoreheight*(scrollingscores[i].timer/scrollingscoretime))*16*scale), 0, scale, scale)
	elseif self.stype == "time" then
		--love.graphics.draw(popupfontimage, popupfontquads[6], math.floor((scrollingscores[i].x)*16*scale)-32, math.floor((scrollingscores[i].y-1.5-scrollingscoreheight*(scrollingscores[i].timer/scrollingscoretime))*16*scale), 0, scale, scale)
		--properprint2(self.text, math.floor((self.x-0.4)*16*scale)+8, math.floor((self.y-1.5-thisclass.scrollheight*(self.timer/thisclass.frametime))*16*scale))
	elseif self.stype == "coin" then
		--I dunno, man
	end
end
end end)()end;
do require("package").preload["basedents.blockdebris"] = (function() local package;return function(...)-- <pack basedents.blockdebris> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

-- custom stuff
thisclass.static.frametime = 0.1
thisclass.static.basexspeed = 3.5
thisclass.static.baseyspeed = -14
thisclass.static.yspeedstep = 9
thisclass.static.gravity = 80

-- engine stuff
thisclass.static.GRAPHIC_QUADCENTER = {4,4,0}
thisclass.static.GRAPHIC_OFFSET = {4,4,0}
thisclass.static.GRAPHIC_SIGS = {
	blockdebris = {8,8}
}

thisclass:include(Base)
thisclass:include(HasGraphics)

function thisclass:init(x, y, dir, forcemultiplier)
	baseentity.init(self, x-.5, y-.5, 0, nil, parent)
	forcemultiplier = forcemultiplier or 0
	
	self.dir = dir or self.dir
	if self.dir == "right" then
		self.speedx = thisclass.basexspeed
	elseif self.dir == "left" then
		self.speedx = -thisclass.basexspeed
	end
	self.speedy = thisclass.baseyspeed-(thisclass.yspeedstep*forcemultiplier)
	
	timer.Create(self, thisclass.frametime, 0,
		function()
			self:nextFrame()
		end
	)
	timer.Start(self)
end

function thisclass:update(dt)
	baseentity.update(self, dt)
	
	self.speedy = self.speedy + thisclass.gravity*dt
	
	self.x = self.x + self.speedx*dt
	self.y = self.y + self.speedy*dt
	
	
	if self.y > mapheight then
		self:remove()
	end
	
	return self.destroy
end
end end)()end;
do require("package").preload["basedents.fireball"] = (function() local package;return function(...)-- <pack basedents.fireball> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

thisclass.static.PHYS_SIZE			= {8/16, 8/16, 8/16}

thisclass.static.GRAPHIC_QUADCENTER = {4,4,0}
thisclass.static.GRAPHIC_OFFSET = {4,4,0}
thisclass.static.GRAPHIC_SIGS = {
	fireball = {8,8},
	fireball_explosion = {16,16}
}

thisclass.static.SOUND_SIGS = {
	fireball = {},
	blockhit = {},
}


-- custom stuff
thisclass.static.fireballspeed = 15 --15 was good before making it physical, now it bounces too far with a gravity of 40 7.5
thisclass.static.fireballjumpforce = 12 --12 was good, toning it down 10
thisclass.static.frametime = 0.04
thisclass.static.deadtable = {"tile", "portalwall", "spring"}
-- bulletbill was once in this list, but since he was promoted to an enemy, ignore that

-- get some mixins
thisclass:include(HasPhysics)
thisclass:include(HasGraphics)
thisclass:include(HasSounds)

thisclass:include(CanEmancipate)
thisclass:include(CanInfluence)
thisclass:include(CanPortal)
thisclass:include(CanDamage)
thisclass:include(CanFunnel)

function thisclass:init(x, y, dir, parent)
	baseentity.init(self, x, y, 0, nil, parent)
	
	-- baseentity overrides
	self.y = y-4/16 --this was positive, now it's negative so that firing on top of a single block is accurate
	self.dir = dir or self.dir
	if self.dir == "right" then
		self.speedx = thisclass.fireballspeed
		self.x = x+6/16
	elseif self.dir == "left" then
		self.speedx = -thisclass.fireballspeed
		self.x = x
	else
		print("WARNING: Tried to spawn a fireball in a nonstandard direction: ", dir)
	end
	self.category = 13
	self.mask = {	true,
					false, true, false, false, true,
					false, true, false, true, false,
					false, true, false, true, false,
					true, true, false, false, false,
					false, true, false, false, true,
					false, false, false, false, true}
	self.doesdamagetype = "fireball"
	--self.gravity = 40
	--unused, because we get a better value elsewhere I guess
	
	-- custom vars
	self.exploded = false
	-- used for when the fireball hits something
	
	timer.Create(self, thisclass.frametime, 0,
		function()
			if self.exploded and self.quadi > globalimages[self.graphicid].frames then
				self.destroy = true
			end
			
			self:nextFrame()
		end
	)
	timer.Start(self)
	
	self:playSound(classname, false, true)
end

function thisclass:remove()
	if not self.exploded then
		self.parent:fireballcallback()
	end
	baseentity.remove(self)
end

function thisclass:update(dt)
	return baseentity.update(self, dt)
end

--@NOTE: I'm not even sure all these collides are necessary, but here we are
function thisclass:leftcollide(a, b)
	self.x = self.x-.5
	self:hitstuff(a, b)
	
	self.speedx = thisclass.fireballspeed
	return false
end

function thisclass:rightcollide(a, b)
	self:hitstuff(a, b)
	
	self.speedx = -thisclass.fireballspeed
	return false
end

function thisclass:floorcollide(a, b)
	if not table.contains(thisclass.deadtable, a) then
		self:hitstuff(a, b)
		if a=="spring" then
			print("ALERT: The code for fireballs and springs is unverified, please ensure nothing terrible happened.")
		end
	end
	
	self.speedy = -thisclass.fireballjumpforce
	return false
end

function thisclass:ceilcollide(a, b)
	self:hitstuff(a, b)
end

function thisclass:passivecollide(a, b)
	self:ceilcollide(a, b)
	return false
end

-- custom methods
function thisclass:hitstuff(a, b)
	if table.contains(thisclass.deadtable, a) then
		self:explode()
		self:playSound("blockhit", true, false)
	elseif a == "enemy" then
		--@NOTE: If we don't do damage here, we could make a koopa shell turn around post-explosion.
		self:doDamage(b, self.dir)
		self:explode()
	--else
		--print("NOTE: Investigating collisions, fireball went past a", a)
	end
end

function thisclass:explode()
	if self.active then
		self.parent:fireballcallback()
		
		self.exploded = true
		self:setGraphic("fireball_explosion")
		self.active = false
	end
end
end end)()end;
do require("package").preload["basedents.bigbox"] = (function() local package;return function(...)-- <pack basedents.bigbox> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

thisclass.static.UNI_SIZE			= {24, 24, 24}

thisclass.static.MAPPABLE_CENTERX = true
thisclass.static.MAPPABLE_FLUSHY = true
thisclass.static.GRAPHIC_SIGS = {
	[classname] = thisclass.static.UNI_SIZE,
	[classname.."_companion"] = thisclass.static.UNI_SIZE,
}
--@NOTE: These aren't used yet.
thisclass.static.EDITOR_ENTDEX		= 21
thisclass.static.EDITOR_CATEGORY	= "portal elements"
thisclass.static.EDITOR_DESC		= "place on empty tile - big weighted storage cube"
thisclass.static.EDITOR_ICONAUTHOR	= "alesan99"
thisclass.static.EDITOR_RCM			= {
	{t="text", value="variant:"},
	{t="submenu", entries={"weighted", "companion"}, default="weighted", width=9, name="variant", actualvalue=true},
}

-- get some mixins
thisclass:include(CanDamage) --before physics so that we maintain 

thisclass:include(HasPhysics)
thisclass:include(HasGraphics)
thisclass:include(HasOutputs)

thisclass:include(CanEmancipate)
thisclass:include(CanInfluence)
thisclass:include(CanPortal)
thisclass:include(CanCarry)
thisclass:include(CanFunnel)

thisclass:include(IsMappable) --must be preceeded by HasGraphics and optionally HasOutputs

function thisclass:init(x, y, r)
	baseentity.init(self, x, y, 0, r)
	--PHYSICS STUFF
	self.category = 9
	self.mask = {	true,
					false, false, false, false, false,
					false, true, false, true, true,
					false, false, true, false, false,
					true, true, false, false, true,
					false, true, true, false, false,
					true, false, true, true, true}
	self.friction = 20
	self.base_friction = 20
	
	if self.variant and self.variant == "companion" then
		self:setGraphic("box_companion", true)
	end
	
	
	
	-- custom vars
	self.portaledframe = false
	-- whether we were pushed by the player
	self.pushed = false --this *should* be further up the chain, but, being pushable isn't demonstrated with any other object
	--self.userect = userect:new(self.x, self.y, self.class.PHYS_SIZE[1], self.class.PHYS_SIZE[2], self)
end

function thisclass:update(dt)
	baseentity.update(self, dt) --remember: this modifies self.destroy + returns it
	
	-- not sure if this is necessary, I think it should be elevated to 
	if not self.pushed then
		if self.speedx > 0 then
			self.speedx = self.speedx - self.friction*dt
			if self.speedx < 0 then
				self.speedx = 0
			end
		else
			self.speedx = self.speedx + self.friction*dt
			if self.speedx > 0 then
				self.speedx = 0
			end
		end
	else
		self.pushed = false
	end
	
	return self.destroy
end

function thisclass:globalcollide(a, b, c, d, dir)
	if a == "platform" or a == "seesawplatform" then
		if dir == "floor" then
			if self.jumping and self.speedy < -jumpforce + 0.1 then
				return true
			end
		else
			return true
		end
	end
end

function thisclass:ceilcollide(a, b)
	if self:globalcollide(a, b, c, d, "ceil") then
		return false
	end
end

function thisclass:leftcollide(a, b)
	if self:globalcollide(a, b, c, d, "left") then
		return false
	end

	if a == "button" then
		self.y = b.y - self.height
		self.x = b.x + b.width - 0.01
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "player" then
		self.pushed = true
		return false
	end
end

function thisclass:rightcollide(a, b)
	if self:globalcollide(a, b, c, d, "right") then
		return false
	end
	
	if a == "button" then
		self.y = b.y - self.height
		self.x = b.x - self.width+0.01
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "player" then
		self.pushed = true
		return false
	end
end

function thisclass:floorcollide(a, b)
	if self:globalcollide(a, b, c, d, "floor") then
		return false
	end
	
	if self.falling then
		self.falling = false
	end
	
	if a == "enemy" and b.stompable then
		self:doDamage(b)
		--addpoints(200, self.x, self.y)
		--playsound("stomp", self.x, self.y, self.speedx, self.speedy)
		self.falling = true
		self.speedy = -10
		return false
	end
end

--[[@NOTE: this is here because boxes, when shoved, weren't properly evaluating emancipation rects,
			it's still broken, but, now it's less broken
function debugbox()
	for k,v in pairs(objects["box"]) do
		print("box#", k, "is", v.pushed, "at", v.x, v.y, v.cox, v.coy)
		local u = objects["emancipationgrill"][1]
		if u.dir == "hor" then
			print("grill was hor")
			print("test1", inrange(v.x+6/16, u.startx-1, u.endx, true))
			print("test2", inrange(u.coy-14/16, v.y, v.y+v.speedy*gdt, true))
		else
			print("grill was ver")
			local b1 = u.cox-14/16
			local b2 = v.x-14/16
			local b3 = v.x+v.speedx*gdt+14/16
			print("test1", inrange(v.y+6/16, u.starty-1, u.endy, true))
			print("test2", inrange(b1, b2, b3, true)) --
			print("inv", b1, b2, b3)
		end
	end
end
]]

function thisclass:passivecollide(a, b)
	if self:globalcollide(a, b, c, d, "passive") then
		return false
	end
	
	if a == "player" then
		if self.x+self.width > b.x+b.width then
			self.x = b.x+b.width
		else
			self.x = b.x-self.width
		end
	end
end


function thisclass:remove()
	self.userect.destroy = true --need a better way of handling this, but userects aren't their own entity yet
	self.destroy = true
	self:toggle_all_outputs()
end

-- custom methods
function thisclass:onbutton(s)
	-- this is making the assumption that lighting up has no animation
	if s then
		self:setQuad(1)
	else
		self:setQuad(2)
	end
end
end end)()end;
do require("package").preload["basedents.rainboom"] = (function() local package;return function(...)-- <pack basedents.rainboom> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

-- custom stuff
thisclass.static.basespeed = 45
thisclass.static.colortable = {
	{242, 111, 51},
	{251, 244, 174},
	{95, 186, 76},
	{29, 151, 212},
	{101, 45, 135},
	{238, 64, 68},
}
thisclass.static.effectstripes = 24
thisclass.static.frametime = 0.03
thisclass.static.effectframes = 49
thisclass.static.effectearthquake = 50

-- engine stuff
thisclass.static.GRAPHIC_QUADCENTER = {102,91,0}
thisclass.static.GRAPHIC_OFFSET = {102,91,0}
thisclass.static.GRAPHIC_SIGS = {
	rainboom = {204,182}
}
thisclass.static.SOUND_SIGS = {
	rainboom = {}
}

thisclass:include(Base)
thisclass:include(HasGraphics)
thisclass:include(HasSounds)

function thisclass:init(x, y, dir, parent)
	baseentity.init(self, x, y, 0, nil, parent)
	
	--@WARNING: we touched a global and feel filthy
	earthquake = thisclass.effectearthquake
	
	if parent then
		parent.rainboomallowed = false
		-- dio brando the horse shaped husbando
		parent.hats = {34}
	end
	
	-- due to a technicality, everything that is visible is also everything this player knows about
	--@WARNING: When we make a method to get things visible, use it here.
	for i, v in pairs(objects["enemy"]) do
		v:do_damage("pow", parent)
		--parent:getscore(firepoints[v.t] or 100, v.x, v.y)
	end
	
	self.roll = 0 
	if dir == "up" then
		self.roll = -math.pi/2
	elseif dir == "down" then
		self.roll = math.pi/2
	elseif dir == "left" then
		self.roll = math.pi
	end
	
	self.drawable=false --@WARNING: prevent the global drawhandler for now
	
	timer.Create(self, thisclass.frametime, 0,
		function()
			if self.quadi > globalimages[self.graphicid].frames then
				self.destroy = true
			else
				self:nextFrame()
			end
		end
	)
	timer.Start(self)
	
	self:playSound(classname, false, true)
end

function thisclass:draw()
	love.graphics.draw(self.graphic, self.quad, (self.x-xscroll)*16*scale, (self.y-yscroll-0.5)*16*scale, self.roll, scale, scale, 29, 92)
end
end end)()end;
do require("package").preload["basedents.box"] = (function() local package;return function(...)-- <pack basedents.box> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

thisclass.static.UNI_SIZE			= {12, 12, 12}

thisclass.static.MAPPABLE_CENTERX = true
thisclass.static.MAPPABLE_FLUSHY = true
thisclass.static.GRAPHIC_SIGS = {
	[classname] = thisclass.static.UNI_SIZE,
	[classname.."_companion"] = thisclass.static.UNI_SIZE,
}
--@NOTE: These aren't used yet.
thisclass.static.EDITOR_ENTDEX		= 20
thisclass.static.EDITOR_CATEGORY	= "portal elements"
thisclass.static.EDITOR_DESC		= "place on empty tile - weighted storage cube"
thisclass.static.EDITOR_ICONAUTHOR	= "alesan99"
thisclass.static.EDITOR_RCM			= {
	{t="text", value="variant:"},
	{t="submenu", entries={"weighted", "companion"}, default="weighted", width=9, name="variant", actualvalue=true},
}

-- get some mixins
thisclass:include(CanDamage) --before physics so that we maintain 

thisclass:include(HasPhysics)
thisclass:include(HasGraphics)
thisclass:include(HasOutputs)

thisclass:include(CanEmancipate)
thisclass:include(CanInfluence)
thisclass:include(CanPortal)
thisclass:include(CanCarry)
thisclass:include(CanFunnel)

thisclass:include(IsMappable) --must be preceeded by HasGraphics and optionally HasOutputs

function thisclass:init(x, y, r)
	baseentity.init(self, x, y, 0, r)
	--PHYSICS STUFF
	self.category = 9
	self.mask = {	true,
					false, false, false, false, false,
					false, true, false, true, true,
					false, false, true, false, false,
					true, true, false, false, true,
					false, true, true, false, false,
					true, false, true, true, true}
	self.friction = 20
	self.base_friction = 20
	
	if self.variant and self.variant == "companion" then
		self:setGraphic("box_companion", true)
	end
	
	
	
	-- custom vars
	self.portaledframe = false
	-- whether we were pushed by the player
	self.pushed = false --this *should* be further up the chain, but, being pushable isn't demonstrated with any other object
end

function thisclass:update(dt)
	baseentity.update(self, dt) --remember: this modifies self.destroy + returns it
	
	-- not sure if this is necessary, I think it should be elevated to 
	if not self.pushed then
		if self.speedx > 0 then
			self.speedx = self.speedx - self.friction*dt
			if self.speedx < 0 then
				self.speedx = 0
			end
		else
			self.speedx = self.speedx + self.friction*dt
			if self.speedx > 0 then
				self.speedx = 0
			end
		end
	else
		self.pushed = false
	end
	
	return self.destroy
end

function thisclass:globalcollide(a, b, c, d, dir)
	if a == "platform" or a == "seesawplatform" then
		if dir == "floor" then
			if self.jumping and self.speedy < -jumpforce + 0.1 then
				return true
			end
		else
			return true
		end
	end
end

function thisclass:ceilcollide(a, b)
	if self:globalcollide(a, b, c, d, "ceil") then
		return false
	end
end

function thisclass:leftcollide(a, b)
	if self:globalcollide(a, b, c, d, "left") then
		return false
	end

	if a == "button" then
		self.y = b.y - self.height
		self.x = b.x + b.width - 0.01
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "player" then
		self.pushed = true
		return false
	end
end

function thisclass:rightcollide(a, b)
	if self:globalcollide(a, b, c, d, "right") then
		return false
	end
	
	if a == "button" then
		self.y = b.y - self.height
		self.x = b.x - self.width+0.01
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "player" then
		self.pushed = true
		return false
	end
end

function thisclass:floorcollide(a, b)
	if self:globalcollide(a, b, c, d, "floor") then
		return false
	end
	
	if self.falling then
		self.falling = false
	end
	
	if a == "enemy" and b.stompable then
		self:doDamage(b)
		--addpoints(200, self.x, self.y)
		--playsound("stomp", self.x, self.y, self.speedx, self.speedy)
		self.falling = true
		self.speedy = -10
		return false
	end
end

--[[@NOTE: this is here because boxes, when shoved, weren't properly evaluating emancipation rects,
			it's still broken, but, now it's less broken
function debugbox()
	for k,v in pairs(objects["box"]) do
		print("box#", k, "is", v.pushed, "at", v.x, v.y, v.cox, v.coy)
		local u = objects["emancipationgrill"][1]
		if u.dir == "hor" then
			print("grill was hor")
			print("test1", inrange(v.x+6/16, u.startx-1, u.endx, true))
			print("test2", inrange(u.coy-14/16, v.y, v.y+v.speedy*gdt, true))
		else
			print("grill was ver")
			local b1 = u.cox-14/16
			local b2 = v.x-14/16
			local b3 = v.x+v.speedx*gdt+14/16
			print("test1", inrange(v.y+6/16, u.starty-1, u.endy, true))
			print("test2", inrange(b1, b2, b3, true)) --
			print("inv", b1, b2, b3)
		end
	end
end
]]

function thisclass:passivecollide(a, b)
	if self:globalcollide(a, b, c, d, "passive") then
		return false
	end
	
	if a == "player" then
		if self.x+self.width > b.x+b.width then
			self.x = b.x+b.width
		else
			self.x = b.x-self.width
		end
	end
end


function thisclass:remove()
	self.userect.destroy = true --need a better way of handling this, but userects aren't their own entity yet
	self.destroy = true
	self:toggle_all_outputs()
end

-- custom methods
function thisclass:onbutton(s)
	-- this is making the assumption that lighting up has no animation
	if s then
		self:setQuad(1)
	else
		self:setQuad(2)
	end
end
end end)()end;
do require("package").preload["basedents.emancipationfizzle"] = (function() local package;return function(...)-- <pack basedents.emancipationfizzle> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

-- custom stuff
thisclass.static.frametime = 0.4

-- engine stuff
thisclass.static.GRAPHIC_QUADCENTER = {2,1,0}
thisclass.static.GRAPHIC_OFFSET = {2,1,0}
thisclass.static.GRAPHIC_SIGS = {
	emancipationfizzle = {4,2}
}

thisclass:include(Base)
thisclass:include(HasGraphics)

function thisclass:init(x, y, speedx, speedy)
	baseentity.init(self, x-.5, y-.5, 0)
	self.r = math.random()*math.pi*2
	self.rotspeed = (math.random()-.5)*2
	self.speedx = speedx+(math.random()-.5)*1
	self.speedy = speedy+(math.random()-.5)*1
	
	self.drawable = false
	
	timer.Create(self, thisclass.frametime, 0,
		function()
			self:remove()
		end
	)
	timer.Start(self)
end

function thisclass:update(dt)
	baseentity.update(self, dt)
	
	self.x = self.x + self.speedx*dt
	self.y = self.y + self.speedy*dt
	self.r = self.r + self.rotspeed*dt
	
	return self.destroy
end

function thisclass:draw()
	local da = 255*(1-timer.TimeLeft(self)/thisclass.frametime)
	love.graphics.setColor(da, da, da, da)
	love.graphics.draw(
		self.graphic,
		(self.x-xscroll)*16*scale,
		(self.y-yscroll-.5)*16*scale,
		self.r, scale, scale, 2, 1
	)
end
end end)()end;
do require("package").preload["basedents.bubble"] = (function() local package;return function(...)-- <pack basedents.bubble> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, baseentity)
local thisclass = _G[classname]

thisclass.static.bubblesmaxy = 2.5
thisclass.static.bubblesspeed = 2.3
thisclass.static.bubblesmargin = 0.5
thisclass.static.bubblestime = {1.2, 1.6}

thisclass.static.GRAPHIC_QUADCENTER = {2,2,0}
thisclass.static.GRAPHIC_OFFSET = {2,2,0}
thisclass.static.GRAPHIC_SIGS = {
	[classname] = {4,4}
}

thisclass:include(Base)
thisclass:include(HasGraphics)

function thisclass:init(x, y)
	baseentity.init(self, x-.5, y-.5, 0, nil, parent)
	
	self.speedy = -self.class.bubblesspeed
end

function thisclass:update(dt)
	baseentity.update(self, dt)
	-- what the heck is going on here
	self.speedy = self.speedy + (math.random()-0.5)*dt*100
	
	if self.speedy < -self.class.bubblesspeed-self.class.bubblesmargin then
		self.speedy = -self.class.bubblesspeed-self.class.bubblesmargin
	elseif self.speedy > -self.class.bubblesspeed+self.class.bubblesmargin then
		self.speedy = -self.class.bubblesspeed+self.class.bubblesmargin
	end
	
	self.y = self.y + self.speedy*dt
	
	if underwater then
		if self.y < self.class.bubblesmaxy then
			self:remove()
		end
	else
		local x = math.floor(self.x)+1
		local y = math.floor(self.y)+1
		
		if not inmap(x, y) then
			self:remove()
		end
		
		if not tilequads[map[x][y][1]]:getproperty("water", x, y) then
			self:remove()
		end
	end
	
	return self.destroy
end

function bubble:draw()
	love.graphics.draw(self.graphic, self.quad, math.floor((self.x-xscroll)*16*scale), math.floor((self.y-yscroll-.5)*16*scale), 0, scale, scale, 2, 2)
end
end end)()end;
do require("package").preload["timer"] = (function() local package;return function(...)-- <pack timer> --
--[[
	Modeled after garry's mod's timer implementation.
	
	http://wiki.garrysmod.com/page/Category:timer
]]

timer = {
	namedTimers = {},
	--[[
		active,
		delay,
		delayTimer, --dt gets added to it until it is delay
		repetitions,
		repetitionsDone, --gets added to each cycle, 
		func,
	]]
	simpleTimers = {},
	--[[
		delay,
		delayTimer, --dt gets added to it until it is delay
		func,
	]]
}
--timer.namedTimers[identifier]
-- repetitions=0 for infinity
function timer.Adjust(identifier, delay, repetitions, func)
	if timer.namedTimers[identifier] then
		timer.namedTimers[identifier].delay = delay
		-- check for lower?
		timer.namedTimers[identifier].repetitions = repetitions
		-- check for lower?
		timer.namedTimers[identifier].func = func
		return true
	else
		return false
	end
end
timer.Check = timer.Update
function timer.Update(dt)
	for k,v in pairs(timer.namedTimers) do
		if v.active then
			v.delayTimer = v.delayTimer + dt
			if v.delayTimer >= v.delay then
				v.func()
				v.repetitionsDone = v.repetitionsDone + 1
				if v.repetitions ~= 0 and v.repetitionsDone >= v.repetitions then
					timer.namedTimers[k] = nil
				else
					v.delayTimer = 0
				end
			end
		end
	end
	for k,v in pairs(timer.simpleTimers) do
		v.delayTimer = v.delayTimer + dt
		if v.delayTimer >= v.delay then
			v.func()
			timer.simpleTimers[k]=nil
		end
	end
end --[[internal: go through all functions and do whatever is done]]
function timer.Create(identifier, delay, repetitions, func)
	if delay <= 0 then return false end
	timer.namedTimers[identifier] = {
		active = false,
		delay = delay,
		delayTimer = delay,
		repetitions = repetitions or 0,
		repetitionsDone = repetitions or 0,
		func = func
	}
end 
function timer.Destroy(identifier) 
	timer.namedTimers[identifier] = nil
end
function timer.Exists(identifier)
	return timer.namedTimers[identifier]~=nil
end
function timer.Pause(identifier)
	if timer.namedTimers[identifier] and timer.namedTimers[identifier].active then
		timer.namedTimers[identifier].active = false
		return true
	else
		return false
	end
end
timer.Remove = timer.Destroy
function timer.RepsLeft(identifier) 
	if timer.namedTimers[identifier] then
		return timer.namedTimers[identifier].repetitionsLeft
	end
end
function timer.Simple(delay, func)
	table.insert(timer.simpleTimers, {delay=delay,delayTimer=0,func=func})
end
function timer.Start(identifier) 
	if timer.namedTimers[identifier] then
		timer.namedTimers[identifier].active = true
		timer.namedTimers[identifier].delayTimer = 0
		timer.namedTimers[identifier].repetitionsDone = 0
		return true
	else
		return false
	end
end
function timer.Stop(identifier)
	if timer.namedTimers[identifier] and timer.namedTimers[identifier].active then
		timer.namedTimers[identifier].active = false
		timer.namedTimers[identifier].delayTimer = 0
		timer.namedTimers[identifier].repetitionsDone = 0
		return true
	else
		return false
	end
end
function timer.TimeLeft(identifier)
	if timer.namedTimers[identifier] then
		return timer.namedTimers[identifier].delay-timer.namedTimers[identifier].delayTimer
	else
		return 0
	end
end
function timer.Toggle(identifier)
	if timer.namedTimers[identifier] then
		if timer.namedTimers[identifier].active then
			timer.Pause(identifier)
		else
			timer.UnPause(identifier)
		end
		return timer.namedTimers[identifier].active
	end
end
function timer.UnPause(identifier)
	if timer.namedTimers[identifier] and not timer.namedTimers[identifier].active then
		timer.namedTimers[identifier].active = true
		return true
	else
		return false
	end
end
end end)()end;
do require("package").preload["loveutils"] = (function() local package;return function(...)-- <pack loveutils> --
-- credits to [Robin](http://love2d.org/forums/viewtopic.php?p=69006&sid=d263c1c1d69a5ffe6fd6259bb7d4ae9c#p69006)
function love.graphics.roundrect(mode, x, y, width, height, xround, yround)
	local points = {}
	local precision = (xround + yround) * .1
	local tI, hP = table.insert, .5*math.pi
	if xround > width*.5 then xround = width*.5 end
	if yround > height*.5 then yround = height*.5 end
	local X1, Y1, X2, Y2 = x + xround, y + yround, x + width - xround, y + height - yround
	local sin, cos = math.sin, math.cos
	for i = 0, precision do
		local a = (i/precision-1)*hP
		tI(points, X2 + xround*cos(a))
		tI(points, Y1 + yround*sin(a))
	end
	for i = 0, precision do
		local a = (i/precision)*hP
		tI(points, X2 + xround*cos(a))
		tI(points, Y2 + yround*sin(a))
	end
	for i = 0, precision do
		local a = (i/precision+1)*hP
		tI(points, X1 + xround*cos(a))
		tI(points, Y2 + yround*sin(a))
	end
	for i = 0, precision do
		local a = (i/precision+2)*hP
		tI(points, X1 + xround*cos(a))
		tI(points, Y1 + yround*sin(a))
	end
	love.graphics.polygon(mode, unpack(points))
end

-- overloads for safe fallbacks with resources
love.audio.oldSource = love.audio.newSource
love.audio.newSource = function(snd, stype)
	local finalpath = snd
	stype = stype or "static"
	if type(snd)=="string" and not love.filesystem.exists(snd) then
		local depth = 0
		for k,v in pairs(soundsearchdirs) do
			local p = v % {mappack=mappack,file=snd,soundpack=soundpack}
			if love.filesystem.exists(p) then
				depth = k
				finalpath = p
				break
			end
		end
		if depth == #soundsearchdirs then
			print("ALERT: Engine couldn't find sound '"..snd.."' anywhere!")
		elseif depth == #soundsearchdirs-1 then
			print("WARNING: Engine couldn't find sound '"..snd.."', used fallback.")
		elseif depth == 0 then
			assert(false, "CALL THE COPS: The fallback missingsound file is GONE.")
		end
		snd = finalpath
	end
	return love.audio.oldSource(snd, stype)
end

love.sound.oldSoundData = love.sound.newSoundData
love.sound.newSoundData = function(snd, x, y, z)
	local finalpath = snd
	if type(snd)=="string" and not love.filesystem.exists(snd) then
		local depth = 0
		for k,v in pairs(soundsearchdirs) do
			local p = v % {mappack=mappack,file=snd,soundpack=soundpack}
			if love.filesystem.exists(p) then
				depth = k
				finalpath = p
				break
			end
		end
		if depth == #soundsearchdirs then
			print("ALERT: Engine couldn't find sounddata '"..snd.."' anywhere!")
		elseif depth == #soundsearchdirs-1 then
			print("WARNING: Engine couldn't find sounddata '"..snd.."', used fallback.")
		elseif depth == 0 then
			assert(false, "CALL THE COPS: The fallback missingsound(data) file is GONE.")
		end
		snd = finalpath
	end
	return love.sound.oldSoundData(snd, x, y, z)
end

love.graphics.oldImage = love.graphics.newImage
love.graphics.newImage = function(img, ex)
	local finalpath = img
	if type(img)=="string" and not love.filesystem.exists(img) then
		local depth = 0
		for k,v in pairs(graphicssearchdirs) do
			local p = v % {mappack=mappack,file=img,graphicspack=graphicspack}
			if love.filesystem.exists(p) then
				depth = k
				finalpath = p
				break
			end
		end
		if depth == #graphicssearchdirs then
			print("ALERT: Engine couldn't find graphic '"..img.."' anywhere!")
		elseif depth == #graphicssearchdirs-1 then
			print("WARNING: Engine couldn't find graphic '"..img.."', used fallback.")
		elseif depth == 0 then
			assert(false, "CALL THE COPS: The fallback missinggraphic image is GONE.")
		end
		img = finalpath
	end
	return love.graphics.oldImage(img, ex)
end

love.image.oldImageData = love.image.newImageData
love.image.newImageData = function(img, ex)
	local finalpath = img
	if type(img)=="string" and not love.filesystem.exists(img) then
		local depth = 0
		for k,v in pairs(graphicssearchdirs) do
			local p = v % {mappack=mappack,file=img,graphicspack=graphicspack}
			if love.filesystem.exists(p) then
				depth = k
				finalpath = p
				break
			end
		end
		if depth == #graphicssearchdirs then
			print("ALERT: Engine couldn't find graphic '"..img.."' anywhere!")
		elseif depth == #graphicssearchdirs-1 then
			print("WARNING: Engine couldn't find graphic '"..img.."', used fallback.")
		elseif depth == 0 then
			assert(false, "CALL THE COPS: The fallback missinggraphic image is GONE.")
		end
		img = finalpath
	end
	return love.image.oldImageData(img, ex)
end
end end)()end;
do require("package").preload["dialogbox"] = (function() local package;return function(...)-- <pack dialogbox> --
dialogbox = class("dialogbox")

function dialogbox:init(text, speaker)
	self.text = string.lower(text)
	self.speaker = string.lower(speaker)
	self.timer = 0
	self.curchar = 0
	self.chartimer = 0
	 
	self.lifetime = 5
	self.chardelay = 0.05
	
	--initialize colors
	local curcolor = {255, 255, 255}
	local i = 1
	self.textcolors = {}
	while i <= #self.text do
		if string.sub(self.text, i, i) == "%" then
			local j = i
			repeat
				j = j + 1
			until string.sub(self.text, j, j) == "%" or j > #self.text
			
			curcolor = string.sub(self.text, i+1, j-1):split(",")
			
			--take out that string
			self.text = string.sub(self.text, 1, i-1) .. string.sub(self.text, j+1)
		else
			self.textcolors[i] = {tonumber(curcolor[1]), tonumber(curcolor[2]), tonumber(curcolor[3])}
			i = i + 1
		end
	end
end

function dialogbox:update(dt)
	if self.curchar < #self.text then
		self.chartimer = self.chartimer + dt
		while self.chartimer > self.chardelay do
			self.curchar = self.curchar + 1
			self.chartimer = self.chartimer - self.chardelay
		end
	else
		self.timer = self.timer + dt
		if self.timer > self.lifetime then
			return true
		end
	end
end

function dialogbox:draw()
	local boxheight = 45
	local margin = 4
	local lineheight = 10
	love.graphics.setColor(0, 0, 0, 127)
	love.graphics.rectangle("fill", scale*margin, (height*16-boxheight-margin)*scale, (width*16-margin*2)*scale, boxheight*scale)
	love.graphics.setColor(255, 255, 255)
	drawrectangle(5, (height*16-margin-boxheight+1), (width*16-margin*2-2), boxheight-2)
	
	local availablepixelsx = width*16-margin*2-6
	local availablepixelsy = boxheight-5
	
	local charsx = math.floor(availablepixelsx / 8)
	local charsy = math.floor(availablepixelsy / lineheight)
	
	for i = 1, self.curchar do
		local x = math.mod(i-1, charsx)+1
		local y = math.ceil(i/charsx)
		
		if y <= charsy then
			love.graphics.setColor(self.textcolors[i])
			properprint(string.sub(self.text, i, i), (7+(x-1)*8)*scale, (height*16-boxheight-margin+4+(y-1)*lineheight)*scale)
		else
			--abort!
			self.curchar = #self.text
		end
	end
	
	if self.speaker then
		love.graphics.setColor(0, 0, 0, 127)
		love.graphics.rectangle("fill", scale*margin, (height*16-boxheight-margin-10)*scale, (5+#self.speaker*8)*scale, 10*scale)
		
		--love.graphics.setColor(255, 255, 255)
		--drawrectangle(5, (height*16-margin-boxheight+1-10), (3+#self.speaker*8), 11)
		
		love.graphics.setColor(self.color or {232, 130, 30})
		properprint(self.speaker, (margin+2)*scale, (height*16-margin-boxheight+1-9)*scale)
	end
end
end end)()end;
do require("package").preload["camera"] = (function() local package;return function(...)-- <pack camera> --
--[[
Copyright (c) 2010-2013 Matthias Richter

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

Except as contained in this notice, the name(s) of the above copyright holders
shall not be used in advertising or otherwise to promote the sale, use or
other dealings in this Software without prior written authorization.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
]]--

local cos, sin = math.cos, math.sin

camera = class("camera")

function camera:init(x,y, zoom, rot)
	x,y  = x or love.graphics.getWidth()/2, y or love.graphics.getHeight()/2
	zoom = zoom or 1
	rot  = rot or 0
	self.x = x
	self.y = y
	
	self.scale = zoom
	self.rot = rot
end

function camera:lookAt(x,y)
	self.x, self.y = x,y
	return self
end

function camera:move(x,y)
	self.x, self.y = self.x + x, self.y + y
	return self
end

function camera:pos()
	return self.x, self.y
end

function camera:rotate(phi)
	self.rot = self.rot + phi
	return self
end

function camera:rotateTo(phi)
	self.rot = phi
	return self
end

function camera:zoom(mul)
	self.scale = self.scale * mul
	return self
end

function camera:zoomTo(zoom)
	self.scale = zoom
	return self
end

function camera:attach()
	local cx,cy = love.graphics.getWidth()/(2*self.scale), love.graphics.getHeight()/(2*self.scale)
	love.graphics.push()
	love.graphics.scale(self.scale)
	love.graphics.translate(cx, cy)
	love.graphics.rotate(self.rot)
	love.graphics.translate(-self.x, -self.y)
end

function camera:detach()
	love.graphics.pop()
end

function camera:draw(func)
	self:attach()
	func()
	self:detach()
end

function camera:cameraCoords(x,y)
	-- x,y = ((x,y) - (self.x, self.y)):rotated(self.rot) * self.scale + center
	local w,h = love.graphics.getWidth(), love.graphics.getHeight()
	local c,s = cos(self.rot), sin(self.rot)
	x,y = x - self.x, y - self.y
	x,y = c*x - s*y, s*x + c*y
	return x*self.scale + w/2, y*self.scale + h/2
end

function camera:worldCoords(x,y)
	-- x,y = (((x,y) - center) / self.scale):rotated(-self.rot) + (self.x,self.y)
	local w,h = love.graphics.getWidth(), love.graphics.getHeight()
	local c,s = cos(-self.rot), sin(-self.rot)
	x,y = (x - w/2) / self.scale, (y - h/2) / self.scale
	x,y = c*x - s*y, s*x + c*y
	return x+self.x, y+self.y
end

function camera:mousepos()
	return self:worldCoords(love.mouse.getPosition())
end
end end)()end;
do require("package").preload["mappacks.tiled_example.1-1"] = (function() local package;return function(...)-- <pack mappacks.tiled_example.1-1> --
return {
  version = "1.1",
  luaversion = "5.1",
  orientation = "orthogonal",
  width = 224,
  height = 15,
  tilewidth = 16,
  tileheight = 16,
  properties = {},
  tilesets = {
    {
      name = "smbtiles",
      firstgid = 1,
      tilewidth = 16,
      tileheight = 16,
      spacing = 1,
      margin = 0,
      image = "../../graphics/DEFAULT/smbtiles.png",
      imagewidth = 374,
      imageheight = 119,
      tileoffset = {
        x = 0,
        y = 0
      },
      properties = {},
      tiles = {
        {
          id = 1,
          properties = {
            ["solid"] = "true, true, true, true"
          }
        },
        {
          id = 2,
          properties = {
            ["background"] = "true"
          }
        },
        {
          id = 23,
          properties = {
            ["background"] = "true"
          }
        },
        {
          id = 24,
          properties = {
            ["background"] = "true"
          }
        },
        {
          id = 25,
          properties = {
            ["background"] = "true"
          }
        },
        {
          id = 69,
          properties = {
            ["solid"] = "true, true, true, true"
          }
        },
        {
          id = 70,
          properties = {
            ["solid"] = "true, true, true, true"
          }
        },
        {
          id = 71,
          properties = {
            ["solid"] = "true, true, true, true"
          }
        },
        {
          id = 92,
          properties = {
            ["background"] = "true"
          }
        }
      }
    }
  },
  layers = {
    {
      type = "tilelayer",
      name = "tiles",
      x = 0,
      y = 0,
      width = 224,
      height = 15,
      visible = true,
      opacity = 1,
      properties = {},
      encoding = "lua",
      data = {
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 33, 34, 34, 34, 35, 0, 0, 0, 0, 55, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 33, 34, 34, 34, 35, 0, 0, 0, 0, 55, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 33, 34, 34, 34, 35, 0, 0, 0, 0, 55, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 33, 34, 34, 34, 35, 0, 0, 0, 0, 55, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 33, 34, 35, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 33, 34, 34, 34, 35,
        0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 56, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 55, 56, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 55, 56, 56, 56, 57,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 0, 0, 0, 7, 7, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 7, 0, 0, 0, 0, 7, 8, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 78, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 78, 78, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 0, 45, 45, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0, 7, 8, 7, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 8, 0, 0, 8, 0, 0, 8, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 0, 0, 0, 0, 0, 0, 78, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 7, 8, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 78, 78, 78, 0, 0, 0, 0, 0, 0, 0, 0, 103, 0, 0, 0, 0, 67, 47, 69, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0, 38, 39, 0, 0, 3, 0, 0, 0, 0, 0, 0, 38, 39, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 0, 0, 78, 78, 0, 0, 0, 0, 3, 0, 0, 0, 78, 78, 78, 0, 0, 78, 78, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 78, 78, 78, 78, 0, 0, 0, 0, 3, 0, 0, 0, 103, 0, 0, 0, 45, 23, 23, 23, 45, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 24, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 38, 39, 0, 0, 0, 0, 0, 0, 38, 39, 0, 24, 25, 26, 0, 0, 0, 0, 0, 38, 39, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 24, 25, 26, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 78, 0, 0, 78, 78, 78, 0, 0, 24, 25, 26, 0, 78, 78, 78, 78, 0, 0, 78, 78, 78, 0, 0, 0, 3, 0, 16, 17, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16, 17, 0, 0, 78, 78, 78, 78, 78, 78, 78, 0, 0, 0, 24, 25, 26, 0, 0, 103, 0, 0, 0, 47, 47, 46, 47, 47, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        24, 25, 27, 28, 26, 0, 0, 0, 0, 0, 0, 4, 5, 5, 5, 6, 24, 25, 26, 0, 0, 0, 0, 4, 5, 6, 0, 0, 38, 39, 0, 0, 0, 0, 0, 0, 0, 0, 38, 39, 0, 4, 5, 5, 6, 0, 38, 39, 24, 25, 27, 28, 26, 0, 0, 0, 0, 38, 39, 4, 5, 5, 5, 6, 24, 25, 26, 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 5, 5, 6, 0, 0, 0, 24, 25, 27, 28, 26, 0, 0, 0, 0, 0, 0, 4, 5, 5, 5, 6, 24, 25, 26, 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 78, 78, 78, 78, 5, 5, 78, 78, 78, 78, 24, 25, 27, 28, 78, 78, 78, 78, 78, 0, 0, 78, 78, 78, 78, 6, 24, 25, 26, 38, 39, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 38, 39, 0, 78, 78, 78, 78, 78, 78, 78, 78, 0, 0, 24, 25, 27, 28, 26, 0, 78, 0, 0, 0, 47, 47, 68, 47, 47, 6, 24, 25, 26, 0, 0, 0, 0, 4, 5, 6, 0, 0, 0, 0, 0, 0,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
        2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
      }
    },
    {
      type = "objectgroup",
      name = "ents",
      visible = true,
      opacity = 1,
      properties = {},
      objects = {
        {
          name = "",
          type = "mariospawn",
          shape = "rectangle",
          x = 32,
          y = 192,
          width = 32,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 352,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "item",
          shape = "rectangle",
          x = 336,
          y = 144,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 640,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 816,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goombahalf",
          shape = "rectangle",
          x = 832,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "1up",
          shape = "rectangle",
          x = 1040,
          y = 128,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "warparea",
          shape = "rectangle",
          x = 912,
          y = 144,
          width = 32,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {
            ["destination"] = "1-1-1"
          }
        },
        {
          name = "",
          type = "triggerkill",
          shape = "rectangle",
          x = 1104,
          y = 224,
          width = 32,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "triggerkill",
          shape = "rectangle",
          x = 1376,
          y = 224,
          width = 48,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "checkpoint",
          shape = "rectangle",
          x = 1312,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 1280,
          y = 64,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 1312,
          y = 64,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "manycoin",
          shape = "rectangle",
          x = 1504,
          y = 144,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "item",
          shape = "rectangle",
          x = 1248,
          y = 144,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goombahalf",
          shape = "rectangle",
          x = 1568,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 1552,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "starman",
          shape = "rectangle",
          x = 1616,
          y = 144,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "koopa",
          shape = "rectangle",
          x = 1712,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "item",
          shape = "rectangle",
          x = 1744,
          y = 80,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 1824,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goombahalf",
          shape = "rectangle",
          x = 1840,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goombahalf",
          shape = "rectangle",
          x = 1999,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 1983,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goombahalf",
          shape = "rectangle",
          x = 2064,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 2048,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goombahalf",
          shape = "rectangle",
          x = 2800,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "goomba",
          shape = "rectangle",
          x = 2784,
          y = 192,
          width = 16,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "flag",
          shape = "rectangle",
          x = 3168,
          y = 32,
          width = 16,
          height = 160,
          rotation = 0,
          visible = true,
          properties = {}
        },
        {
          name = "",
          type = "warparea",
          shape = "rectangle",
          x = 2608,
          y = 176,
          width = 32,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {
            ["source"] = "1-1-1"
          }
        },
        {
          name = "",
          type = "triggerkill",
          shape = "rectangle",
          x = 2448,
          y = 224,
          width = 32,
          height = 16,
          rotation = 0,
          visible = true,
          properties = {}
        }
      }
    }
  }
}
end end)()end;
do require("package").preload["menu"] = (function() local package;return function(...)-- <pack menu> --
function menu_load()
	loadconfig()
	love.audio.stop()
	editormode = false
	gamestate = "menu"
	
	for i, v in pairs(guielements) do
		v.active = false
	end
	
	selection = 1
	coinanimation = 1
	love.graphics.setBackgroundColor(92, 148, 252)
	scrollsmoothrate = 4
	optionstab = 2
	optionsselection = 1
	skinningplayer = 1
	rgbselection = 1
	mappackselection = 1
	onlinemappackselection = 1
	mappackhorscroll = 0
	mappackhorscrollsmooth = 0
	colorsetedit = 1
	love.graphics.setBackgroundColor(backgroundcolor[1])
	
	controlstable = {"left", "right", "up", "down", "run", "jump", "reload", "use", "aimx", "aimy", "portal1", "portal2"}
	
	portalanimation = 1
	portalanimationtimer = 0
	portalanimationdelay = 0.08
	
	infmarioY = 0
	infmarioR = 0
	
	infmarioYspeed = 200
	infmarioRspeed = 4
	
	RGBchangespeed = 200
	huechangespeed = 0.5
	spriteset = 1
	
	portalcolors = {}
	for i = 1, players do
		portalcolors[i] = {}
	end
	
	continueavailable = false
	if love.filesystem.exists("suspend.txt") then
		continueavailable = true
	end
	currentmap = "1-1"
	mariolevel = 1
	marioworld = 1
	mariosublevel = 0
	
	--load 1-1 as background
	loadbackgroundsafe("1-1.txt")
	
	skipupdate = true
	onlinemp = false
	if (arcade or mkstation) and firstload then
		firstload = false
		if arcade then
			mappack = "smb"
		elseif mkstation then
		--	mappack = "portal"
		end
		game_load()
	end
	if server_udp then
		server_udp:close()
	end
	if udp then
		udp:close()
	end
	classicmodeactive = false
	singularmariogamemode = false
	playersaresharingportals = false
	hook.Call("GameLoaded")
end

function menu_update(dt)
	--coinanimation
	coinanimation = coinanimation + dt*6.75
	while coinanimation > 6 do
		coinanimation = coinanimation - 5
	end	
	coinframe = math.floor(coinanimation)
	
	--Animate animated tiles because I say so
	for i = 1, #animatedtiles do
		animatedtiles[i]:update(dt)
	end
	
	if mappackscroll then
		--smooth the scroll
		if mappackscrollsmooth > mappackscroll then
			mappackscrollsmooth = mappackscrollsmooth - (mappackscrollsmooth-mappackscroll)*dt*5-0.1*dt
			if mappackscrollsmooth < mappackscroll then
				mappackscrollsmooth = mappackscroll
			end
		elseif mappackscrollsmooth < mappackscroll then
			mappackscrollsmooth = mappackscrollsmooth - (mappackscrollsmooth-mappackscroll)*dt*5+0.1*dt
			if mappackscrollsmooth > mappackscroll then
				mappackscrollsmooth = mappackscroll
			end
		end
	end
	
	if onlinemappackscroll then
		--smooth the scroll
		if onlinemappackscrollsmooth > onlinemappackscroll then
			onlinemappackscrollsmooth = onlinemappackscrollsmooth - (onlinemappackscrollsmooth-onlinemappackscroll)*dt*5-0.1*dt
			if onlinemappackscrollsmooth < onlinemappackscroll then
				onlinemappackscrollsmooth = onlinemappackscroll
			end
		elseif onlinemappackscrollsmooth < onlinemappackscroll then
			onlinemappackscrollsmooth = onlinemappackscrollsmooth - (onlinemappackscrollsmooth-onlinemappackscroll)*dt*5+0.1*dt
			if onlinemappackscrollsmooth > onlinemappackscroll then
				onlinemappackscrollsmooth = onlinemappackscroll
			end
		end
	end
	
	if mappackhorscroll then
		if mappackhorscrollsmooth > mappackhorscroll then
			mappackhorscrollsmooth = mappackhorscrollsmooth - (mappackhorscrollsmooth-mappackhorscroll)*dt*5-0.03*dt
			if mappackhorscrollsmooth < mappackhorscroll then
				mappackhorscrollsmooth = mappackhorscroll
			end
		elseif mappackhorscrollsmooth < mappackhorscroll then
			mappackhorscrollsmooth = mappackhorscrollsmooth - (mappackhorscrollsmooth-mappackhorscroll)*dt*5+0.03*dt
			if mappackhorscrollsmooth > mappackhorscroll then
				mappackhorscrollsmooth = mappackhorscroll
			end
		end
	end
	
	if gamestate == "options" and optionstab == 2 then
		portalanimationtimer = portalanimationtimer + dt
		while portalanimationtimer > portalanimationdelay do
			portalanimation = portalanimation + 1
			if portalanimation > 6 then
				portalanimation = 1
			end
			portalanimationtimer = portalanimationtimer - portalanimationdelay
		end
		
		infmarioY = infmarioY + infmarioYspeed*dt
		while infmarioY > 64 do
			infmarioY = infmarioY - 64
		end
		
		infmarioR = infmarioR + infmarioRspeed*dt
		while infmarioR > math.pi*2 do
			infmarioR = infmarioR - math.pi*2
		end
	
		if characters[mariocharacter[skinningplayer]].colorables and optionsselection > 5 and optionsselection < 9 then
			local colorRGB = optionsselection-5
			
			if (controls.menuRight) and mariocolors[skinningplayer][colorsetedit][colorRGB] < 255 then
				mariocolors[skinningplayer][colorsetedit][colorRGB] = mariocolors[skinningplayer][colorsetedit][colorRGB] + RGBchangespeed*dt
				if mariocolors[skinningplayer][colorsetedit][colorRGB] > 255 then
					mariocolors[skinningplayer][colorsetedit][colorRGB] = 255
				end
			elseif (controls.menuLeft) and mariocolors[skinningplayer][colorsetedit][colorRGB] > 0 then
				mariocolors[skinningplayer][colorsetedit][colorRGB] = mariocolors[skinningplayer][colorsetedit][colorRGB] - RGBchangespeed*dt
				if mariocolors[skinningplayer][colorsetedit][colorRGB] < 0 then
					mariocolors[skinningplayer][colorsetedit][colorRGB] = 0
				end
			end
			
		elseif (characters[mariocharacter[skinningplayer]].colorables and optionsselection == 9) or (not characters[mariocharacter[skinningplayer]].colorables and optionsselection == 5) then
			if (controls.menuRight) and portalhues[skinningplayer][1] < 1 then
				portalhues[skinningplayer][1] = portalhues[skinningplayer][1] + huechangespeed*dt
				if portalhues[skinningplayer][1] > 1 then
					portalhues[skinningplayer][1] = 1
				end
				portalcolor[skinningplayer][1] = getrainbowcolor(portalhues[skinningplayer][1])
				
			elseif (controls.menuLeft) and portalhues[skinningplayer][1] > 0 then
				portalhues[skinningplayer][1] = portalhues[skinningplayer][1] - huechangespeed*dt
				if portalhues[skinningplayer][1] < 0 then
					portalhues[skinningplayer][1] = 0
				end
				portalcolor[skinningplayer][1] = getrainbowcolor(portalhues[skinningplayer][1])
			end
			
		elseif (characters[mariocharacter[skinningplayer]].colorables and optionsselection == 10) or (not characters[mariocharacter[skinningplayer]].colorables and optionsselection == 6) then
			if (controls.menuRight) and portalhues[skinningplayer][2] < 1 then
				portalhues[skinningplayer][2] = portalhues[skinningplayer][2] + huechangespeed*dt
				if portalhues[skinningplayer][2] > 1 then
					portalhues[skinningplayer][2] = 1
				end
				portalcolor[skinningplayer][2] = getrainbowcolor(portalhues[skinningplayer][2])
				
			elseif (controls.menuLeft) and portalhues[skinningplayer][2] > 0 then
				portalhues[skinningplayer][2] = portalhues[skinningplayer][2] - huechangespeed*dt
				if portalhues[skinningplayer][2] < 0 then
					portalhues[skinningplayer][2] = 0
				end
				portalcolor[skinningplayer][2] = getrainbowcolor(portalhues[skinningplayer][2])
			end
		end
	elseif gamestate == "onlinemenu" then
		onlinemenu_update(dt)
	elseif gamestate == "lobby" then
		lobby_update(dt)
	end
end

function menu_draw()
	--GUI LIBRARY?! Never heard of that.
	--I'm not proud of this at all; But I'm even lazier than not proud. Seriously, don't take this as an example of what to do.
	
	drawlevel()
	drawui()
	
	for j = 1, players do
		local v = characters[mariocharacter[j]]
		local angle = 3
		if v.nopointing then
			angle = 1
		end
		
		local pid = j
		if pid > 4 then
			pid = 5
		end
		
		local portalcolor1, portalcolor2 = portalcolor[j][1], portalcolor[j][2]
		
		if players == 1 then
			portalcolor1, portalcolor2 = {60, 188, 252}, {232, 130, 30}
		end
		
		drawplayer(nil, ((startx[pid]-xscroll)*16)+8*(j-1), ((starty[pid]-yscroll)*16-12), scale,     v.smalloffsetX, v.smalloffsetY, 0, v.smallquadcenterX, v.smallquadcenterY, "idle", false, false, mariohats[j], v.animations, v.idle[angle], 0, false, false, mariocolors[j], 1, portalcolor1, portalcolor2, nil, nil, nil, nil, nil, nil, characters[mariocharacter[j]])
	end
	
	love.graphics.setColor(255, 255, 255, 255)
	drawforeground()
	
	if gamestate == "menu" then
		love.graphics.draw(titleimage, 40*scale, 24*scale, 0, scale, scale)
		
		if updatenotification then
			love.graphics.setColor(255, 0, 0)
			properprint("version outdated!|go to stabyourself.net|to download latest", 220*scale, 90*scale)
			love.graphics.setColor(255, 255, 255, 255)
		end
		
		if selection == 0 then
			love.graphics.draw(menuselection, 73*scale, (122+(selection-1)*16)*scale, 0, scale, scale)
		elseif selection == 1 then
			love.graphics.draw(menuselection, 73*scale, (122+(selection-1)*16)*scale, 0, scale, scale)
		elseif selection == 2 then
			love.graphics.draw(menuselection, 81*scale, (122+(selection-1)*16)*scale, 0, scale, scale)
		elseif selection == 3 then
			love.graphics.draw(menuselection, 81*scale, (122+(selection-1)*16)*scale, 0, scale, scale)
		elseif selection == 4 then
			love.graphics.draw(menuselection, 73*scale, (122+(selection-1)*16)*scale, 0, scale, scale)
		elseif selection == 5 then
			love.graphics.draw(menuselection, 98*scale, (122+(selection-1)*16)*scale, 0, scale, scale)
		end
		
		if custombackground then
			if continueavailable then
				properprintbackground("continue game", 87*scale, 106*scale, true)
			end
			
			properprintbackground(players, 87*scale, 122*scale, true)
			
			properprintbackground("player game", 103*scale, 122*scale, true)
			
			properprintbackground("level editor", 95*scale, 138*scale, true)
			
			properprintbackground("online menu", 95*scale, 154*scale, true)
			
			properprintbackground("select mappack", 83*scale, 170*scale, true)
			
			properprintbackground("options", 111*scale, 186*scale, true)
			
		else
			if continueavailable then
				properprint("continue game", 87*scale, 106*scale)
			end
			
			properprint(players, 87*scale, 122*scale)
			
			properprint("player game", 103*scale, 122*scale)
			
			properprint("level editor", 95*scale, 138*scale)
			
			properprint("online menu", 95*scale, 154*scale)
			
			properprint("select mappack", 83*scale, 170*scale)
			
			properprint("options", 111*scale, 186*scale)
		end
		
		if players > 1 then
			love.graphics.draw(playerselectimg, 82*scale, 122*scale, 0, scale, scale)
		end
		
		if players < 4 then
			love.graphics.draw(playerselectimg, 102*scale, 122*scale, 0, -scale, scale)
		end
		
		if selectworldopen then
			love.graphics.setColor(0, 0, 0)
			love.graphics.rectangle("fill", 30*scale, 92*scale, 200*scale, 60*scale)
			love.graphics.setColor(255, 255, 255)
			drawrectangle(31, 93, 198, 58)
			properprint("select world", 83*scale, 105*scale)
			for i = 1, 8 do
				if selectworldcursor == i then
					love.graphics.setColor(255, 255, 255)
				elseif reachedworlds[mappack][i] then
					love.graphics.setColor(200, 200, 200)
				elseif selectworldexists[i] then
					love.graphics.setColor(50, 50, 50)
				else
					love.graphics.setColor(0, 0, 0)
				end
				
				properprint(i, (55+(i-1)*20)*scale, 130*scale)
				if i == selectworldcursor then
					properprint("v", (55+(i-1)*20)*scale, 120*scale)
				end
			end
		end
		
	elseif gamestate == "mappackmenu" then
		--background
		love.graphics.setColor(0, 0, 0, 100)
		love.graphics.rectangle("fill", 21*scale, 16*scale, 218*scale, 200*scale)
		love.graphics.setColor(255, 255, 255, 255)
		
		--set scissor
		love.graphics.setScissor(21*scale, 16*scale, 218*scale, 200*scale)
		
		if loadingonlinemappacks then
			love.graphics.setColor(0, 0, 0, 200)
			love.graphics.rectangle("fill", 21*scale, 16*scale, 218*scale, 200*scale)
			love.graphics.setColor(255, 255, 255, 255)
			properprint("a little patience..|downloading " .. currentdownload .. " of " .. downloadcount, 50*scale, 30*scale)
			drawrectangle(50, 55, 152, 10)
			love.graphics.rectangle("fill", 50*scale, 55*scale, 152*((currentfiledownload-1)/(filecount-1))*scale, 10*scale)
		else
			love.graphics.translate(-round(mappackhorscrollsmooth*scale*mappackhorscrollrange), 0)
			
			if mappackhorscrollsmooth < 1 then
				--draw each butten (even if all you do, is press ONE. BUTTEN.)
				--scrollbar offset
				love.graphics.translate(0, -round(mappackscrollsmooth*60*scale))
				
				love.graphics.setScissor(240*scale, 16*scale, 200*scale, 200*scale)
				love.graphics.setColor(0, 0, 0, 200)
				love.graphics.rectangle("fill", 240*scale, 81*scale, 115*scale, 61*scale)
				love.graphics.setColor(255, 255, 255)
				if not savefolderfailed then
					properprint("press right to|access the dlc||press m to|open your|mappack folder", 241*scale, 83*scale)
				else
					properprint("press right to|access the dlc||could not|open your|mappack folder", 241*scale, 83*scale)
				end
				love.graphics.setScissor(21*scale, 16*scale, 218*scale, 200*scale)
				
				for i = 1, #mappacklist do
					--back
					love.graphics.draw(mappackback, 25*scale, (20+(i-1)*60)*scale, 0, scale, scale)
					
					--icon
					if mappackicon[i] ~= nil then
						local scale2w = scale*50 / math.max(1, mappackicon[i]:getWidth())
						local scale2h = scale*50 / math.max(1, mappackicon[i]:getHeight())
						love.graphics.draw(mappackicon[i], 29*scale, (24+(i-1)*60)*scale, 0, scale2w, scale2h)
					else
						love.graphics.draw(mappacknoicon, 29*scale, (24+(i-1)*60)*scale, 0, scale, scale)
					end
					love.graphics.draw(mappackoverlay, 29*scale, (24+(i-1)*60)*scale, 0, scale, scale)
					
					--name
					love.graphics.setColor(200, 200, 200)
					if mappackselection == i then
						love.graphics.setColor(255, 255, 255)
					end
					
					properprint(string.sub(mappackname[i]:lower(), 1, 17), 83*scale, (26+(i-1)*60)*scale)
					
					--author
					love.graphics.setColor(100, 100, 100)
					if mappackselection == i then
						love.graphics.setColor(100, 100, 100)
					end
					
					if mappackauthor[i] then
						properprint(string.sub("by " .. mappackauthor[i]:lower(), 1, 16), 91*scale, (35+(i-1)*60)*scale)
					end
					
					--description
					love.graphics.setColor(130, 130, 130)
					if mappackselection == i then
						love.graphics.setColor(180, 180, 180)
					end
					
					if mappackdescription[i] then
						properprint( string.sub(mappackdescription[i]:lower(), 1, 17), 83*scale, (47+(i-1)*60)*scale)
						
						if mappackdescription[i]:len() > 17 then
							properprint( string.sub(mappackdescription[i]:lower(), 18, 34), 83*scale, (56+(i-1)*60)*scale)
						end
						
						if mappackdescription[i]:len() > 34 then
							properprint( string.sub(mappackdescription[i]:lower(), 35, 51), 83*scale, (65+(i-1)*60)*scale)
						end
					end
					
					love.graphics.setColor(255, 255, 255)
					
					--highlight
					if i == mappackselection then
						love.graphics.draw(mappackhighlight, 25*scale, (20+(i-1)*60)*scale, 0, scale, scale)
					end
				end
			
				love.graphics.translate(0, round(mappackscrollsmooth*60*scale))
			
				local i = mappackscrollsmooth / (#mappacklist-3.233)
			
				love.graphics.draw(mappackscrollbar, 227*scale, (20+i*160)*scale, 0, scale, scale)
			
			end
			
			love.graphics.translate(round(mappackhorscrollsmooth*scale*mappackhorscrollrange), 0)
			----------
			--ONLINE--
			----------
			
			love.graphics.translate(round(mappackhorscrollrange*scale - mappackhorscrollsmooth*scale*mappackhorscrollrange), 0)
			
			if mappackhorscrollsmooth > 0 then
				if #onlinemappacklist == 0 then
					properprint("something went wrong||      sorry d:||maybe your internet|does not work right?", 40*scale, 80*scale)
				end
				
				love.graphics.setScissor()
				love.graphics.setColor(0, 0, 0, 200)
				love.graphics.rectangle("fill", 241*scale, 16*scale, 150*scale, 200*scale)
				love.graphics.setColor(255, 255, 255, 255)
				properprint("wanna contribute?|make a mappack and|send an email to|mappack at|stabyourself.net!||include your map-|pack! you can find|it in your appdata|love/mari0 dir.", 244*scale, 19*scale)
				if outdated then
					love.graphics.setColor(255, 0, 0, 255)
					properprint("version outdated!|you have an old|version of mari0!|mappacks could not|be downloaded.|go to|stabyourself.net|to download latest", 244*scale, 130*scale)
					love.graphics.setColor(255, 255, 255, 255)
				elseif downloaderror then
					love.graphics.setColor(255, 0, 0, 255)
					properprint("download error!|something went|wrong while|downloading|mappacks.|press left and|right to try|again.  sorry.", 244*scale, 130*scale)
					love.graphics.setColor(255, 255, 255, 255)
				end
					
				love.graphics.setScissor(21*scale, 16*scale, 218*scale, 200*scale)
				
				--scrollbar offset
				love.graphics.translate(0, -round(onlinemappackscrollsmooth*60*scale))
				for i = 1, #onlinemappacklist do
					--back
					love.graphics.draw(mappackback, 25*scale, (20+(i-1)*60)*scale, 0, scale, scale)
					
					--icon
					if onlinemappackicon[i] ~= nil then
						love.graphics.draw(onlinemappackicon[i], 29*scale, (24+(i-1)*60)*scale, 0, scale, scale)
					else
						love.graphics.draw(mappacknoicon, 29*scale, (24+(i-1)*60)*scale, 0, scale, scale)
					end
					love.graphics.draw(mappackoverlay, 29*scale, (24+(i-1)*60)*scale, 0, scale, scale)
					
					--name
					love.graphics.setColor(200, 200, 200)
					if onlinemappackselection == i then
						love.graphics.setColor(255, 255, 255)
					end
					
					properprint(string.sub(onlinemappackname[i]:lower(), 1, 17), 83*scale, (26+(i-1)*60)*scale)
					
					--author
					love.graphics.setColor(100, 100, 100)
					if onlinemappackselection == i then
						love.graphics.setColor(100, 100, 100)
					end
					
					if onlinemappackauthor[i] then
						properprint(string.sub("by " .. onlinemappackauthor[i]:lower(), 1, 16), 91*scale, (35+(i-1)*60)*scale)
					end
					
					--description
					love.graphics.setColor(130, 130, 130)
					if onlinemappackselection == i then
						love.graphics.setColor(180, 180, 180)
					end
					
					if onlinemappackdescription[i] then
						properprint( string.sub(onlinemappackdescription[i]:lower(), 1, 17), 83*scale, (47+(i-1)*60)*scale)
						
						if onlinemappackdescription[i]:len() > 17 then
							properprint( string.sub(onlinemappackdescription[i]:lower(), 18, 34), 83*scale, (56+(i-1)*60)*scale)
						end
						
						if onlinemappackdescription[i]:len() > 34 then
							properprint( string.sub(onlinemappackdescription[i]:lower(), 35, 51), 83*scale, (65+(i-1)*60)*scale)
						end
					end
					
					love.graphics.setColor(255, 255, 255)
					
					--highlight
					if i == onlinemappackselection then
						love.graphics.draw(mappackhighlight, 25*scale, (20+(i-1)*60)*scale, 0, scale, scale)
					end
				end
			
				love.graphics.translate(0, round(onlinemappackscrollsmooth*60*scale))
			
				local i = onlinemappackscrollsmooth / (#onlinemappacklist-3.233)
			
				love.graphics.draw(mappackscrollbar, 227*scale, (20+i*160)*scale, 0, scale, scale)
			end
			
			love.graphics.translate(- round(mappackhorscrollrange*scale - mappackhorscrollsmooth*scale*mappackhorscrollrange), 0)
		end
		
		love.graphics.setScissor()
		
		if mappackhorscroll == 0 then
			love.graphics.setColor(255, 255, 255)
			love.graphics.rectangle("fill", 22*scale, 3*scale, 44*scale, 13*scale)
			love.graphics.setColor(0, 0, 0)
			properprint("local", 23*scale, 6*scale)
			drawrectangle(22, 3, 44, 13)
			love.graphics.setColor(0, 0, 0)
			love.graphics.rectangle("fill", 70*scale, 3*scale, 29*scale, 13*scale)
			love.graphics.setColor(255, 255, 255)
			properprint("dlc", 72*scale, 6*scale)
		else
			love.graphics.setColor(0, 0, 0)
			love.graphics.rectangle("fill", 22*scale, 3*scale, 44*scale, 13*scale)
			love.graphics.setColor(255, 255, 255)
			properprint("local", 23*scale, 6*scale)
			love.graphics.setColor(255, 255, 255)
			love.graphics.rectangle("fill", 70*scale, 3*scale, 29*scale, 13*scale)
			love.graphics.setColor(0, 0, 0)
			properprint("dlc", 72*scale, 6*scale)
			drawrectangle(70, 3, 29, 13)
		end
	elseif gamestate == "options" then
		love.graphics.setColor(0, 0, 0, 200)
		love.graphics.rectangle("fill", 21*scale, 16*scale, 218*scale, 200*scale)
		
		--Controls tab head
		if optionstab == 1 then
			love.graphics.setColor(100, 100, 100, 100)
			love.graphics.rectangle("fill", 25*scale, 20*scale, 67*scale, 11*scale)
		end
		
		if optionstab == 1 and optionsselection == 1 then
			love.graphics.setColor(255, 255, 255, 255)
		else
			love.graphics.setColor(100, 100, 100, 255)
		end
		properprint("controls", 26*scale, 22*scale)
		
		--Skins tab head
		if optionstab == 2 then
			love.graphics.setColor(100, 100, 100, 100)
			love.graphics.rectangle("fill", 96*scale, 20*scale, 43*scale, 11*scale)
		end
		
		
		if optionstab == 2 and optionsselection == 1 then
			love.graphics.setColor(255, 255, 255, 255)
		else
			love.graphics.setColor(100, 100, 100, 255)
		end
		properprint("skins", 97*scale, 22*scale)
		
		--Miscellaneous tab head
		if optionstab == 3 then
			love.graphics.setColor(100, 100, 100, 100)
			love.graphics.rectangle("fill", 145*scale, 20*scale, 39*scale, 11*scale)
		end
		
		if optionstab == 3 and optionsselection == 1 then
			love.graphics.setColor(255, 255, 255, 255)
		else
			love.graphics.setColor(100, 100, 100, 255)
		end
		properprint("misc.", 146*scale, 22*scale)
		
		--Cheat tab head
		if optionstab == 4 then
			love.graphics.setColor(100, 100, 100, 100)
			love.graphics.rectangle("fill", 190*scale, 20*scale, 43*scale, 11*scale)
		end
		
		if optionstab == 4 and optionsselection == 1 then
			love.graphics.setColor(255, 255, 255, 255)
		else
			love.graphics.setColor(100, 100, 100, 255)
		end
		properprint("cheat", 191*scale, 22*scale)
		
		love.graphics.setColor(255, 255, 255, 255)
		
		if optionstab == 1 then
			--CONTROLS
			if optionsselection == 2 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("edit player:" .. skinningplayer, 74*scale, 40*scale)
			
			if optionsselection == 3 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			if mouseowner == skinningplayer then
				properprint("uses the mouse: yes", 46*scale, 52*scale)
			else
				properprint("uses the mouse: no", 46*scale, 52*scale)
			end
			
			for i = 1, #controlstable do
				if mouseowner ~= skinningplayer or i <= 8 then		
					if optionsselection == 3+i then
						love.graphics.setColor(255, 255, 255, 255)
					else
						love.graphics.setColor(100, 100, 100, 255)
					end
					
					properprint(controlstable[i], 30*scale, (70+(i-1)*12)*scale)
					
					local s = ""
					
					if oldcontrols[skinningplayer][controlstable[i]] then
						for j = 1, #oldcontrols[skinningplayer][controlstable[i]] do
							s = s .. oldcontrols[skinningplayer][controlstable[i]][j]
						end
					end
					if s == " " then
						s = "space"
					end
					properprint(s, 120*scale, (70+(i-1)*12)*scale)
				end
			end
				
			if keyprompt then
				love.graphics.setColor(0, 0, 0, 255)
				love.graphics.rectangle("fill", 30*scale, 100*scale, 200*scale, 60*scale)
				love.graphics.setColor(255, 255, 255, 255)
				drawrectangle(30, 100, 200, 60)
				if controlstable[optionsselection-3] == "aimx" then
					properprint("move stick right", 40*scale, 110*scale)
				elseif controlstable[optionsselection-3] == "aimy" then
					properprint("move stick down", 40*scale, 110*scale)
				else
					properprint("press key for \"" .. controlstable[optionsselection-3] .. "\"", 40*scale, 110*scale)
				end
				properprint("press \"esc\" to cancel", 40*scale, 140*scale)
				
				if buttonerror then
					love.graphics.setColor(200, 0, 0)
					properprint("you can only set", 40*scale, 120*scale)
					properprint("buttons for this", 40*scale, 130*scale)
				elseif axiserror then
					love.graphics.setColor(200, 0, 0)
					properprint("you can only set", 40*scale, 120*scale)
					properprint("axes for this", 40*scale, 130*scale)
				end
			end
		elseif optionstab == 2 then
			--SKINS
			if optionsselection == 2 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("edit player:" .. skinningplayer, 74*scale, 32*scale)
			
			--PREVIEW MARIO IN BIG. WITH BIG LETTERS
			local v = characters[mariocharacter[skinningplayer]]
			local angle = 3
			if v.nopointing then
				angle = 1
			end
			drawplayer(nil, 46, 32, scale*2,     v.smalloffsetX, v.smalloffsetY, 0, v.smallquadcenterX, v.smallquadcenterY, "idle", false, false, mariohats[skinningplayer], v.animations, v.idle[angle], 0, false, false, mariocolors[skinningplayer], 1, portalcolor[skinningplayer][1], portalcolor[skinningplayer][2], nil, nil, nil, nil, nil, nil, characters[mariocharacter[skinningplayer]])
	
			
			--PREVIEW PORTALS WITH FALLING MARIO BECAUSE I CAN AND IT LOOKS RAD
			love.graphics.setScissor(142*scale, 42*scale, 32*scale, 32*scale)
			
			for j = 1, 3 do
				--158*scale, (2+((j-1)*32)+infmarioY)*scale
				local v = characters[mariocharacter[skinningplayer]]
				local angle = 3
				if v.nopointing then
					angle = 1
				end
				drawplayer(nil, 158, ((j-1)*32)+infmarioY+2, scale,     v.smalloffsetX, v.smalloffsetY, infmarioR, v.smallquadcenterX, v.smallquadcenterY, "jumping", false, false, mariohats[skinningplayer], v.animations, v.jump[angle][1], 0, false, false, mariocolors[skinningplayer], 1, portalcolor[skinningplayer][1], portalcolor[skinningplayer][2], nil, nil, nil, 1, nil, nil, characters[mariocharacter[skinningplayer]])
			end
			
			local portalframe = portalanimation
			
			love.graphics.setColor(255, 255, 255, 80 - math.abs(portalframe-3)*10)
			love.graphics.draw(portalglowimg, 174*scale, 59*scale, math.pi, scale, scale)
			love.graphics.draw(portalglowimg, 142*scale, 57*scale, 0, scale, scale)
			
			love.graphics.setColor(unpack(portalcolor[skinningplayer][1]))
			love.graphics.draw(portalimg, portalquad[portalframe], 174*scale, 46*scale, math.pi, scale, scale)
			love.graphics.setColor(unpack(portalcolor[skinningplayer][2]))
			love.graphics.draw(portalimg, portalquad[portalframe], 142*scale, 70*scale, 0, scale, scale)
			
			love.graphics.setScissor()
			
			--Character change
			if optionsselection == 3 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("{", 65*scale, 54*scale)
			properprint("}", 110*scale, 54*scale)
			properprint(characters[mariocharacter[skinningplayer]].name, (118-#characters[mariocharacter[skinningplayer]].name*4)*scale, 80*scale)
			
			--HAT
			if optionsselection == 4 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			if mariohats[skinningplayer][1] == 0 then
				properprint("hat: none", (83)*scale, 90*scale)
			else
				properprint("hat: " .. mariohats[skinningplayer][1], (99-string.len(mariohats[skinningplayer][1])*4)*scale, 90*scale)
			end
			
			if v.colorables then
				if optionsselection == 5 then
					love.graphics.setColor(255, 255, 255, 255)
				else
					love.graphics.setColor(100, 100, 100, 255)
				end
				
				--NEW SKIN CUSTOMIZATION
				local v = characters[mariocharacter[skinningplayer]]
				properprint("{ " .. v.colorables[colorsetedit] .. " }", 120*scale-string.len("{ " .. v.colorables[colorsetedit] .. " }")*4*scale, 105*scale)
				
				if optionsselection > 5 and optionsselection < 9 then
					love.graphics.setColor(255, 255, 255, 255)
					love.graphics.rectangle("fill", 39*scale, 114*scale + (optionsselection-6)*10*scale, 142*scale, 10*scale)
				end
			
				love.graphics.setColor(100, 0, 0)
				properprint("r", 40*scale, (116)*scale)
				love.graphics.setColor(255, 0, 0)	
				properprint("r", 39*scale, (115)*scale)
				
				love.graphics.setColor(0, 100, 0)
				properprint("g", 40*scale, (126)*scale)
				love.graphics.setColor(0, 255, 0)	
				properprint("g", 39*scale, (125)*scale)
				
				love.graphics.setColor(0, 0, 100)
				properprint("b", 40*scale, (136)*scale)
				love.graphics.setColor(0, 0, 255)	
				properprint("b", 39*scale, (135)*scale)
				
				love.graphics.setColor(100, 0, 0)
				love.graphics.rectangle("fill", 51*scale, (116)*scale, math.floor(129*scale * (mariocolors[skinningplayer][colorsetedit][1]/255)), 7*scale)
				love.graphics.setColor(255, 0, 0)
				love.graphics.rectangle("fill", 50*scale, (115)*scale, math.floor(129*scale * (mariocolors[skinningplayer][colorsetedit][1]/255)), 7*scale)
				
				love.graphics.setColor(100, 100, 100)
				local s = math.floor(mariocolors[skinningplayer][colorsetedit][1])
				properprint(s, 200*scale-string.len(s)*4*scale, 116*scale)
				
				love.graphics.setColor(0, 100, 0)
				love.graphics.rectangle("fill", 51*scale, (126)*scale, math.floor(129*scale * (mariocolors[skinningplayer][colorsetedit][2]/255)), 7*scale)
				love.graphics.setColor(0, 255, 0)
				love.graphics.rectangle("fill", 50*scale, (125)*scale, math.floor(129*scale * (mariocolors[skinningplayer][colorsetedit][2]/255)), 7*scale)
				
				love.graphics.setColor(100, 100, 100)
				local s = math.floor(mariocolors[skinningplayer][colorsetedit][2])
				properprint(s, 200*scale-string.len(s)*4*scale, 126*scale)
				
				love.graphics.setColor(0, 0, 100)
				love.graphics.rectangle("fill", 51*scale, (136)*scale, math.floor(129*scale * (mariocolors[skinningplayer][colorsetedit][3]/255)), 7*scale)
				love.graphics.setColor(0, 0, 255)
				love.graphics.rectangle("fill", 50*scale, (135)*scale, math.floor(129*scale * (mariocolors[skinningplayer][colorsetedit][3]/255)), 7*scale)
				
				love.graphics.setColor(100, 100, 100)
				local s = math.floor(mariocolors[skinningplayer][colorsetedit][3])
				properprint(s, 200*scale-string.len(s)*4*scale, 136*scale)
			end
			
			--Portalhuehues
			--hue
			local alpha = 100
			
			if characters[mariocharacter[skinningplayer]].colorables then
				if optionsselection == 9 then
					alpha = 255
				end
			else
				if optionsselection == 5 then
					alpha = 255
				end
			end
			
			love.graphics.setColor(255, 255, 255, alpha)
			
			properprint("coop portal 1 color:", 31*scale, 150*scale)
			
			love.graphics.draw(huebarimg, 32*scale, 170*scale, 0, scale, scale)
			
			--marker
			love.graphics.setColor(unpack(portalcolor[skinningplayer][1]))
			love.graphics.rectangle("fill", math.floor(29 + (portalhues[skinningplayer][1])*178)*scale, 161*scale, 7*scale, 6*scale)
			love.graphics.setColor(alpha, alpha, alpha)
			love.graphics.draw(huebarmarkerimg, math.floor(28 + (portalhues[skinningplayer][1])*178)*scale, 160*scale, 0, scale, scale)
			
			alpha = 100
			if characters[mariocharacter[skinningplayer]].colorables then
				if optionsselection == 10 then
					alpha = 255
				end
			else
				if optionsselection == 6 then
					alpha = 255
				end
			end
			
			love.graphics.setColor(255, 255, 255, alpha)
			
			properprint("coop portal 2 color:", 31*scale, 180*scale)
			
			love.graphics.draw(huebarimg, 32*scale, 200*scale, 0, scale, scale)
			
			--marker
			love.graphics.setColor(unpack(portalcolor[skinningplayer][2]))
			love.graphics.rectangle("fill", math.floor(29 + (portalhues[skinningplayer][2])*178)*scale, 191*scale, 7*scale, 6*scale)
			love.graphics.setColor(alpha, alpha, alpha)
			love.graphics.draw(huebarmarkerimg, math.floor(28 + (portalhues[skinningplayer][2])*178)*scale, 190*scale, 0, scale, scale)
		elseif optionstab == 3 then
			if optionsselection == 2 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			properprint("size:", 30*scale, 40*scale)
			if fullscreen then
				if fullscreenmode == "touchfrominside" then
					properprint("letterbox", (180-string.len("letterbox")*8)*scale, 40*scale)
				else
					properprint("fullscreen", (180-string.len("fullscreen")*8)*scale, 40*scale)
				end
			else
				properprint("*" .. scale, (180-(string.len(scale)+1)*8)*scale, 40*scale)
			end
			
			
			if optionsselection == 3 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("shader1:", 30*scale, 55*scale)
			if shaderssupported == false then
				properprint("unsupported", (180-string.len("unsupported")*8)*scale, 55*scale)
			else
				properprint(string.lower(shaderlist[currentshaderi1]), (180-string.len(shaderlist[currentshaderi1])*8)*scale, 55*scale)
			end
			
			if optionsselection == 4 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			properprint("shader2:", 30*scale, 65*scale)
			if shaderssupported == false then
				properprint("unsupported", (180-string.len("unsupported")*8)*scale, 65*scale)
			else
				properprint(string.lower(shaderlist[currentshaderi2]), (180-string.len(shaderlist[currentshaderi2])*8)*scale, 65*scale)
			end
			
			if optionsselection == 5 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			properprint("graphics:", 30*scale, 80*scale)
			properprint(string.lower(graphicspack), (180-(string.len(graphicspack))*8)*scale, 80*scale)
			
			if optionsselection == 6 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			properprint("sounds:", 30*scale, 90*scale)
			properprint(string.lower(soundpack), (180-(string.len(soundpack))*8)*scale, 90*scale)
			
			if optionsselection == 7 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			properprint("volume:", 30*scale, 105*scale)
			drawrectangle(90, 108, 90, 1)
			drawrectangle(90, 105, 1, 7)
			drawrectangle(179, 105, 1, 7)
			love.graphics.draw(volumesliderimg, math.floor((89+89*volume)*scale), 105*scale, 0, scale, scale)
			
			if optionsselection == 8 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("reset game mappacks", 30*scale, 120*scale)
			
			if optionsselection == 9 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("reset all settings", 30*scale, 135*scale)
			
			if optionsselection == 10 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("vsync:", 30*scale, 150*scale)
			if vsync then
				properprint("on", (180-16)*scale, 150*scale)
			else
				properprint("off", (180-24)*scale, 150*scale)
			end
			
			love.graphics.setColor(100, 100, 100, 255)
			properprint("you can lock the|mouse with f12", 30*scale, 165*scale)
			
			love.graphics.setColor(255, 255, 255, 255)
			properprint(versionstring, 134*scale, 207*scale)
		elseif optionstab == 4 then
			love.graphics.setColor(255, 255, 255, 255)
			if not gamefinished then
				properprint("unlock this by completing", 30*scale, 40*scale)
				properprint("the original levels pack!", 30*scale, 50*scale)
			else
				properprint("have fun with these!", 30*scale, 45*scale)
			end
			
			if optionsselection == 2 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("mode:", 30*scale, 65*scale)
			properprint("{" .. playertype .. "}", (180-(string.len(playertype)+2)*8)*scale, 65*scale)
			
			if optionsselection == 3 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("knockback:", 30*scale, 80*scale)
			if portalknockback then
				properprint("on", (180-16)*scale, 80*scale)
			else
				properprint("off", (180-24)*scale, 80*scale)
			end
			
			if optionsselection == 4 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("bullettime:", 30*scale, 95*scale)
			properprint("use mousewheel", 30*scale, 105*scale)
			if bullettime then
				properprint("on", (180-16)*scale, 95*scale)
			else
				properprint("off", (180-24)*scale, 95*scale)
			end
			
			if optionsselection == 5 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("huge mario:", 30*scale, 120*scale)
			if bigmario then
				properprint("on", (180-16)*scale, 120*scale)
			else
				properprint("off", (180-24)*scale, 120*scale)
			end
			
			if optionsselection == 6 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("goomba attack:", 30*scale, 135*scale)
			if goombaattack then
				properprint("on", (180-16)*scale, 135*scale)
			else
				properprint("off", (180-24)*scale, 135*scale)
			end
			
			if optionsselection == 7 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("sonic rainboom:", 30*scale, 150*scale)
			if cheats_active.rainboom then
				properprint("on", (180-16)*scale, 150*scale)
			else
				properprint("off", (180-24)*scale, 150*scale)
			end
			
			if optionsselection == 8 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("playercollision:", 30*scale, 165*scale)
			if playercollisions then
				properprint("on", (180-16)*scale, 165*scale)
			else
				properprint("off", (180-24)*scale, 165*scale)
			end
			
			if optionsselection == 9 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("infinite time:", 30*scale, 180*scale)
			if infinitetime then
				properprint("on", (180-16)*scale, 180*scale)
			else
				properprint("off", (180-24)*scale, 180*scale)
			end
			
			if optionsselection == 10 then
				love.graphics.setColor(255, 255, 255, 255)
			else
				love.graphics.setColor(100, 100, 100, 255)
			end
			
			properprint("infinite lives:", 30*scale, 195*scale)
			if infinitelives then
				properprint("on", (180-16)*scale, 195*scale)
			else
				properprint("off", (180-24)*scale, 195*scale)
			end
		end
	elseif gamestate == "onlinemenu" then
		onlinemenu_draw()
	elseif gamestate == "lobby" then
		lobby_draw()
	end
	love.graphics.translate(0, yoffset*scale)
end

function loadbackgroundsafe(background)
	if loadbackground(background) == false then
		map = {}
		coinmap = {}
		mapwidth = width
		for x = 1, width do
			map[x] = {}
			coinmap[x] = {}
			for y = 1, 13 do
				map[x][y] = {1}
			end
		
			for y = 14, 15 do
				map[x][y] = {2}
			end
		end
		mapheight = 15
		startx = {3, 3, 3, 3, 3}
		starty = {13, 13, 13, 13, 13}
		custombackground = false
		backgroundi = 1
		love.graphics.setBackgroundColor(backgroundcolor[backgroundi])
		notice.new("Couldn't properly load|background " .. background .. "!", notice.red)
		
		xscroll = 0
		yscroll = 0
		
		smbspritebatch = love.graphics.newSpriteBatch( smbtilesimg, 10000 )
		smbspritebatchfront = love.graphics.newSpriteBatch( smbtilesimg, 10000 )
		portalspritebatch = love.graphics.newSpriteBatch( portaltilesimg, 10000 )
		portalspritebatchfront = love.graphics.newSpriteBatch( portaltilesimg, 10000 )
	end
	
	generatespritebatch()
end

function loadbackground(backgroundlevel)
	loadcustomimages("mappacks/" .. mappack .. "/graphics")
	loadcustombackgrounds()
	loadcustommusics()
	loadanimatedtiles()
	loadcustomtiles()
	loadlevelscreens()
	
	blockbouncex = {}
	blockbouncey = {}
	
	marioworld = 1
	mariolevel = 1
	mariotime = ""
	levelfinished = false
	
	startx = {3, 3, 3, 3, 3}
	starty = {13, 13, 13, 13, 13}
	
	coinframe = 1
	redcoinframe = 1
	
	itemanimations = {}
	
	if love.filesystem.exists("mappacks/" .. mappack .. "/" .. backgroundlevel) == false then
		return false
	else
		loadmap(backgroundlevel:sub(1, -5))
	end
	
	--Adjust start X scroll
	xscroll = startx[1]-scrollingleftcomplete-2
	if xscroll > mapwidth - width then
		xscroll = mapwidth - width
	end
	
	if xscroll < 0 then
		xscroll = 0
	end
	
	--and Y too
	yscroll = starty[1]-height+downscrollborder
	if yscroll > mapheight - height - 1 then
		yscroll = mapheight - height - 1
	end
	
	if yscroll < 0 then
		yscroll = 0
	end
	
	love.graphics.setBackgroundColor(background)
end

function updatescroll()
	--check if current focus is completely onscreen
	if inrange(mappackselection, 1+mappackscroll, 3+mappackscroll, true) == false then
		if mappackselection < 1+mappackscroll then --above window
			mappackscroll = mappackselection-1
		else
			mappackscroll = mappackselection-3.233
		end
	end
end

function onlineupdatescroll()
	--check if current focus is completely onscreen
	if inrange(onlinemappackselection, 1+onlinemappackscroll, 3+onlinemappackscroll, true) == false then
		if onlinemappackselection < 1+onlinemappackscroll then --above window
			onlinemappackscroll = onlinemappackselection-1
		else
			onlinemappackscroll = onlinemappackselection-3.233
		end
	end
end

function mappacks()
	if mappackhorscroll == 0 then
		loadmappacks()
	else
		loadonlinemappacks()
	end
end

function loadmappacks()
	mappacktype = "local"
	mappacklist = love.filesystem.getDirectoryItems( "mappacks" )
	
	local delete = {}
	for i = 1, #mappacklist do
		if love.filesystem.exists( "mappacks/" .. mappacklist[i] .. "/version.txt") or not love.filesystem.exists( "mappacks/" .. mappacklist[i] .. "/settings.txt") then
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		table.remove(mappacklist, v) --remove
	end
	
	mappackicon = {}
	
	--get info
	mappackname = {}
	mappackauthor = {}
	mappackdescription = {}
	mappackbackground = {}
	
	for i = 1, #mappacklist do
		if love.filesystem.exists( "mappacks/" .. mappacklist[i] .. "/icon.png" ) then
			mappackicon[i] = love.graphics.newImage("mappacks/" .. mappacklist[i] .. "/icon.png")
		else
			mappackicon[i] = nil
		end
		
		mappackauthor[i] = ""
		mappackdescription[i] = ""
		if love.filesystem.exists( "mappacks/" .. mappacklist[i] .. "/settings.txt" ) then		
			local s = love.filesystem.read( "mappacks/" .. mappacklist[i] .. "/settings.txt" )
			local s1 = s:split("\n")
			for j = 1, #s1 do
				local s2 = s1[j]:split("=")
				if s2[1] == "name" then
					mappackname[i] = s2[2]
				elseif s2[1] == "author" then
					mappackauthor[i] = s2[2]
				elseif s2[1] == "description" then
					mappackdescription[i] = s2[2]
				end
			end
		else
			mappackname[i] = mappacklist[i]
		end
	end
	
	table.insert(mappacklist, "custom_mappack")
	table.insert(mappackname, "{new mappack}")
	table.insert(mappackauthor, "you")
	table.insert(mappackdescription, "create a mappack from scratch withthis!")
	
	--get the current cursorposition
	for i = 1, #mappacklist do
		if mappacklist[i] == mappack then
			mappackselection = i
		end
	end
	
	mappack = mappacklist[mappackselection]
	
	--load background
	--loadbackground("1-1.txt")
	
	mappackscroll = 0
	updatescroll()
	mappackscrollsmooth = mappackscroll
end

function loadonlinemappacks()
	mappacktype = "online"
	downloadmappacks()
	onlinemappacklist = love.filesystem.getDirectoryItems( "mappacks" )
	
	local delete = {}
	for i = 1, #onlinemappacklist do
		if not love.filesystem.exists( "mappacks/" .. onlinemappacklist[i] .. "/version.txt") or not love.filesystem.exists( "mappacks/" .. onlinemappacklist[i] .. "/settings.txt") then
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		table.remove(onlinemappacklist, v) --remove
	end
	
	onlinemappackicon = {}
	
	--get info
	onlinemappackname = {}
	onlinemappackauthor = {}
	onlinemappackdescription = {}
	onlinemappackbackground = {}
	
	for i = 1, #onlinemappacklist do
		if love.filesystem.exists( "mappacks/" .. onlinemappacklist[i] .. "/icon.png" ) then
			onlinemappackicon[i] = love.graphics.newImage("mappacks/" .. onlinemappacklist[i] .. "/icon.png")
		else
			onlinemappackicon[i] = nil
		end
		
		onlinemappackauthor[i] = nil
		onlinemappackdescription[i] = nil
		if love.filesystem.exists( "mappacks/" .. onlinemappacklist[i] .. "/settings.txt" ) then		
			local s = love.filesystem.read( "mappacks/" .. onlinemappacklist[i] .. "/settings.txt" )
			local s1 = s:split("\n")
			for j = 1, #s1 do
				local s2 = s1[j]:split("=")
				if s2[1] == "name" then
					onlinemappackname[i] = s2[2]
				elseif s2[1] == "author" then
					onlinemappackauthor[i] = s2[2]
				elseif s2[1] == "description" then
					onlinemappackdescription[i] = s2[2]
				end
			end
		else
			onlinemappackname[i] = onlinemappacklist[i]
		end
	end
	
	--get the current cursorposition
	for i = 1, #onlinemappacklist do
		if onlinemappacklist[i] == mappack then
			onlinemappackselection = i
		end
	end
	
	if #onlinemappacklist >= 1 then
		mappack = onlinemappacklist[onlinemappackselection]
	end
	
	--load background
	--loadbackground("1-1.txt")
	
	onlinemappackscroll = 0
	onlineupdatescroll()
	onlinemappackscrollsmooth = onlinemappackscroll
end

function downloadmappacks()	
	downloaderror = false
	local onlinedata, code = http.request("http://server.stabyourself.net/mari0/index2.php?mode=mappacks")
	
	if code ~= 200 then
		downloaderror = true
		return false
	elseif not onlinedata then
		downloaderror = true
		return false
	end
	
	local maplist = {}
	local versionlist = {}
	local latestversion = marioversion
	
	local split1 = onlinedata:split("<")
	for i = 2, #split1 do
		local split2 = split1[i]:split(">")
		if split2[1] == "latestversion" then
			latestversion = tonumber(split2[2])
		elseif split2[1] == "mapfile" then
			table.insert(maplist, split2[2])
		elseif split2[1] == "version" then
			table.insert(versionlist, tonumber(split2[2]))
		end
	end
	
	if latestversion > marioversion then
		outdated = true
		return false
	end
	
	success = true
	
	--download all mappacks
	for i = 1, #maplist do
		--check if current version is equal or newer
		local version = 0
		if love.filesystem.exists("mappacks/" .. maplist[i] .. "/version.txt") then
			local data = love.filesystem.read("mappacks/" .. maplist[i] .. "/version.txt")
			if data then
				version = tonumber(data)
			end
		end
		
		if version < versionlist[i] then
			print("DOWNLOADING MAPPACK: " .. maplist[i])
			
			--draw
			currentdownload = i
			downloadcount = #maplist
			
			if love.filesystem.exists("mappacks/" .. maplist[i] .. "/") then
				love.filesystem.remove("mappacks/" .. maplist[i] .. "/")
			end
			
			love.filesystem.createDirectory("mappacks/" .. maplist[i])
			local onlinedata, code = http.request("http://server.stabyourself.net/mari0/index2.php?mode=getmap&get=" .. maplist[i])
			
			if code == 200 then
				filecount = 0
				local checksums = {}
				
				local split1 = onlinedata:split("<")
				for j = 2, #split1 do
					local split2 = split1[j]:split(">")
					if split2[1] == "asset" then
						filecount = filecount + 1
					elseif split2[1] == "checksum" then
						table.insert(checksums, split2[2])
					end
				end
				
				currentfiledownload = 1
				
				local split1 = onlinedata:split("<")
				for j = 2, #split1 do
					local split2 = split1[j]:split(">")
					if split2[1] == "asset" then
						loadingonlinemappacks = true
						love.graphics.clear()
						love.draw()
						love.graphics.present()
						loadingonlinemappacks = false
						
						local target = "mappacks/" .. maplist[i] .. "/" .. split2[2]:match("([^/]-)$")
						
						local tries = 0
						success = false
						while not success and tries < 3 do
							success = downloadfile(split2[2], target, checksums[currentfiledownload])
							tries = tries + 1
						end
						
						if not success then
							break
						end
						currentfiledownload = currentfiledownload + 1
					end
				end
				if success then
					love.filesystem.write( "mappacks/" .. maplist[i] .. "/version.txt", versionlist[i])
				end
			else
				success = false
			end
		end
		
		--Delete stuff and stuff.
		if not success then
			if love.filesystem.exists("mappacks/" .. maplist[i] .. "/") then
				local list = love.filesystem.getDirectoryItems("mappacks/" .. maplist[i] .. "/")
				for j = 1, #list do
					love.filesystem.remove("mappacks/" .. maplist[i] .. "/" .. list[j])
				end
				
				love.filesystem.remove("mappacks/" .. maplist[i] .. "/")
			end
			downloaderror = true
			break
		else
			print("Download successful.")
		end
	end
	
	return true
end

function menu_controlupdate(dt)
	if gamestate == "menu" then --PLEASE don't use this menu system as an example. It's fucking awful. But you knew that.
		if selectworldopen then
			if controls.tap.menuRight then
				local target = selectworldcursor+1
				while target < 9 and not reachedworlds[mappack][target] do
					target = target + 1
				end
				if target < 9 then
					selectworldcursor = target
				end
			elseif controls.tap.menuLeft then
				local target = selectworldcursor-1
				while target > 0 and not reachedworlds[mappack][target] do
					target = target - 1
				end
				if target > 0 then
					selectworldcursor = target
				end
			elseif controls.tap.menuSelect then
				selectworldopen = false
				game_load(selectworldcursor)
			elseif controls.tap.menuBack then
				selectworldopen = false
			end
			return
		end
		if controls.tap.menuUp then
			if continueavailable then
				if selection > 0 then
					selection = selection - 1
				end
			else
				if selection > 1 then
					selection = selection - 1
				end
			end
		elseif controls.tap.menuDown then
			if selection < 5 then
				selection = selection + 1
			end
		elseif controls.tap.menuSelect then
			if selection == 0 then
				game_load(true)
			elseif selection == 1 then
				selectworld()
			elseif selection == 2 then
				editormode = true
				players = 1
				game_load()
			elseif selection == 3 then
				gamestate = "onlinemenu"
				--@DEV: Throwing this in here to cover bases.
				players = 1
				playertype = "portal"
				playertypei = 1
				for k,v in pairs(cheats_active) do
					cheats_active[k] = false
				end
				onlinemenu_load()
				playersaresharingportals = false
			elseif selection == 4 then
				gamestate = "mappackmenu"
				mappacks()
			elseif selection == 5 then
				gamestate = "options"
			end
		elseif controls.tap.menuBack then
			love.event.quit()
		elseif controls.tap.menuLeft then
			if players > 1 then
				players = players - 1
			end
		elseif controls.tap.menuRight then
			players = players + 1
			if players > 4 then
				players = 4
			end
		end
	elseif gamestate == "mappackmenu" then
		if controls.tap.menuUp then
			if mappacktype == "local" then
				if mappackselection > 1 then
					mappackselection = mappackselection - 1
					mappack = mappacklist[mappackselection]
					
					updatescroll()
				end
			else
				if onlinemappackselection > 1 then
					onlinemappackselection = onlinemappackselection - 1
					mappack = onlinemappacklist[onlinemappackselection]
					
					onlineupdatescroll()
				end
			end
		elseif controls.tap.menuDown then
			if mappacktype == "local" then
				if mappackselection < #mappacklist then
					mappackselection = mappackselection + 1
					mappack = mappacklist[mappackselection]
					
					updatescroll()
				end
			else
				if onlinemappackselection < #onlinemappacklist then
					onlinemappackselection = onlinemappackselection + 1
					mappack = onlinemappacklist[onlinemappackselection]
					
					onlineupdatescroll()
				end
			end	
		elseif controls.tap.menuSelect or controls.tap.menuBack then
			gamestate = "menu"
			saveconfig()
			if mappack == "custom_mappack" then
				createmappack()
			end
			
			--load background
			loadbackgroundsafe("1-1.txt")
		elseif controls.tap.menuRight then
			loadonlinemappacks()
			mappackhorscroll = 1
		elseif controls.tap.menuLeft then
			loadmappacks()
			mappackhorscroll = 0
		elseif controls.tap.gameShortcutMappackFolder then
			if not openSaveFolder("mappacks") then
				savefolderfailed = true
			end
		end
	elseif gamestate == "options" then
		if optionsselection == 1 then
			if controls.tap.menuLeft then
				if optionstab > 1 then
					optionstab = optionstab - 1
				end
			elseif controls.tap.menuRight then
				if optionstab < 4 then
					optionstab = optionstab + 1
				end
			end
		elseif optionsselection == 2 then
			if controls.tap.menuLeft then
				if optionstab == 2 or optionstab == 1 then
					if skinningplayer > 1 then
						skinningplayer = skinningplayer - 1
					end
				end
			elseif controls.tap.menuRight then
				if optionstab == 2 or optionstab == 1 then
					if skinningplayer < 4 then
						skinningplayer = skinningplayer + 1
						if players > #oldcontrols then
							loadconfig()
						end
					end
				end
			end
		end
		
		if controls.tap.menuSelect then
			if optionstab == 1 then
				if optionsselection == 3 then
					if mouseowner == skinningplayer then
						mouseowner = 0
					else
						mouseowner = skinningplayer
					end
				elseif optionsselection > 3 then
					keypromptstart()
				end
			elseif optionstab == 3 then
				if optionsselection == 8 then
					reset_mappacks()
				elseif optionsselection == 9 then
					resetconfig()
				end
			end
		elseif controls.tap.menuDown then
			if optionstab == 1 then
				if skinningplayer ~= mouseowner then
					if optionsselection < 15 then
						optionsselection = optionsselection + 1
					else
						optionsselection = 1
					end
				else
					if optionsselection < 11 then
						optionsselection = optionsselection + 1
					else
						optionsselection = 1
					end
				end
			elseif optionstab == 2 then
				local limit = 6
				if characters[mariocharacter[skinningplayer]].colorables then
					limit = 10
				end
				
				if optionsselection < limit then
					optionsselection = optionsselection + 1
				else
					optionsselection = 1
				end
			elseif optionstab == 3 then
				if optionsselection < 10 then
					optionsselection = optionsselection + 1
				else
					optionsselection = 1
				end
			elseif optionstab == 4 and gamefinished then
				if optionsselection < 10 then
					optionsselection = optionsselection + 1
				else
					optionsselection = 1
				end
			end
		elseif controls.tap.menuUp then
			if optionsselection > 1 then
				optionsselection = optionsselection - 1
			else
				if optionstab == 1 then
					if skinningplayer ~= mouseowner then
						optionsselection = 15
					else
						optionsselection = 11
					end
				elseif optionstab == 2 then
					local limit = 6
					if characters[mariocharacter[skinningplayer]].colorables then
						limit = 10
					end
					optionsselection = limit
				elseif optionstab == 3 then
					optionsselection = 10
				elseif optionstab == 4 and gamefinished then
					optionsselection = 10
				end
			end
		elseif controls.tap.menuRight then
			if optionstab == 2 then
				if optionsselection == 3 then
					nextcharacter()
				elseif optionsselection == 4 then
					if mariohats[skinningplayer][1] < #hat then
						mariohats[skinningplayer][1] = mariohats[skinningplayer][1] + 1
					end
				elseif characters[mariocharacter[skinningplayer]].colorables and optionsselection == 5 then
					--next color set
					colorsetedit = colorsetedit + 1
					if colorsetedit > #characters[mariocharacter[skinningplayer]].colorables then
						colorsetedit = 1
					end
				end
			elseif optionstab == 3 then
				if optionsselection == 2 then
					if scale < 5 then
						changescale(scale+1)
					end
				elseif optionsselection == 3 then
					currentshaderi1 = currentshaderi1 + 1
					if currentshaderi1 > #shaderlist then
						currentshaderi1 = 1
					end
					if shaderlist[currentshaderi1] == "none" then
						shaders:set(1, nil)
					else
						shaders:set(1, shaderlist[currentshaderi1])
					end
					
				elseif optionsselection == 4 then
					currentshaderi2 = currentshaderi2 + 1
					if currentshaderi2 > #shaderlist then
						currentshaderi2 = 1
					end
					if shaderlist[currentshaderi2] == "none" then
						shaders:set(2, nil)
					else
						shaders:set(2, shaderlist[currentshaderi2])
					end
				elseif optionsselection == 5 then
					graphicspacki = graphicspacki + 1
					if graphicspacki > #graphicspacklist then
						graphicspacki = 1
					end
					graphicspack = graphicspacklist[graphicspacki]
					reloadGraphics()
				elseif optionsselection == 6 then
					soundpacki = soundpacki + 1
					if soundpacki > #soundpacklist then
						soundpacki = 1
					end
					soundpack = soundpacklist[soundpacki]
					reloadSounds()
					playsound("coin") --allowed global
				elseif optionsselection == 7 then
					if volume < 0.99 then
						volume = volume + 0.1
						if volume > 1 then
							volume = 1
						end
						love.audio.setVolume( volume )
						playsound("coin") --allowed global
						soundenabled = true
					end
				elseif optionsselection == 9 then
					vsync = not vsync
					changescale(scale)
				end
			elseif optionstab == 4 then
				if optionsselection == 2 then
					playertypei = playertypei + 1
					if playertypei > #playertypelist then
						playertypei = 1
					end
					playertype = playertypelist[playertypei]
				elseif optionsselection == 3 then
					portalknockback = not portalknockback
				elseif optionsselection == 4 then
					bullettime = not bullettime
				elseif optionsselection == 5 then
					bigmario = not bigmario
				elseif optionsselection == 6 then
					goombaattack = not goombaattack
				elseif optionsselection == 7 then
					cheats_active.rainboom = not cheats_active.rainboom
				elseif optionsselection == 8 then
					playercollisions = not playercollisions
				elseif optionsselection == 9 then
					infinitetime = not infinitetime
				elseif optionsselection == 10 then
					infinitelives = not infinitelives
				end
			end				
		elseif controls.tap.menuLeft then
			if optionstab == 2 then
				if optionsselection == 3 then
					previouscharacter()
				elseif optionsselection == 4 then
					if mariohats[skinningplayer][1] > 0 then
						mariohats[skinningplayer][1] = mariohats[skinningplayer][1] - 1
					end
				elseif characters[mariocharacter[skinningplayer]].colorables and optionsselection == 5 then
					--previous color set
					colorsetedit = colorsetedit - 1
					if colorsetedit < 1 then
						colorsetedit = #characters[mariocharacter[skinningplayer]].colorables
					end
				end
			elseif optionstab == 3 then
				if optionsselection == 2 then
					if scale > 1 then
						changescale(scale-1)
					end
				elseif optionsselection == 3 then
					currentshaderi1 = currentshaderi1 - 1
					if currentshaderi1 < 1 then
						currentshaderi1 = #shaderlist
					end
					
					if shaderlist[currentshaderi1] == "none" then
						shaders:set(1, nil)
					else
						shaders:set(1, shaderlist[currentshaderi1])
					end
				elseif optionsselection == 4 then
					currentshaderi2 = currentshaderi2 - 1
					if currentshaderi2 < 1 then
						currentshaderi2 = #shaderlist
					end
					
					if shaderlist[currentshaderi2] == "none" then
						shaders:set(2, nil)
					else
						shaders:set(2, shaderlist[currentshaderi2])
					end
				elseif optionsselection == 5 then
					graphicspacki = graphicspacki - 1
					if graphicspacki < 1 then
						graphicspacki = #graphicspacklist
					end
					graphicspack = graphicspacklist[graphicspacki]
					reloadGraphics()
				elseif optionsselection == 6 then
					soundpacki = soundpacki - 1
					if soundpacki < 1 then
						soundpacki = #soundpacklist
					end
					soundpack = soundpacklist[soundpacki]
					reloadSounds()
					playsound("coin") --allowed global
				elseif optionsselection == 7 then
					if volume > 0 then
						volume = volume - 0.1
						if volume <= 0 then
							volume = 0
							soundenabled = false
						end
						love.audio.setVolume( volume )
						playsound("coin") --allowed global
					end
				elseif optionsselection == 9 then
					vsync = not vsync
					changescale(scale)
				end
			elseif optionstab == 4 then
				if optionsselection == 2 then
					playertypei = playertypei - 1
					if playertypei < 1 then
						playertypei = #playertypelist
					end
					playertype = playertypelist[playertypei]
				elseif optionsselection == 3 then
					portalknockback = not portalknockback
				elseif optionsselection == 4 then
					bullettime = not bullettime
				elseif optionsselection == 5 then
					bigmario = not bigmario
				elseif optionsselection == 6 then
					goombaattack = not goombaattack
				elseif optionsselection == 7 then
					cheats_active.rainboom = not cheats_active.rainboom
					playertype = "portalgun"
					playertypei = 1
				elseif optionsselection == 8 then
					playercollisions = not playercollisions
				elseif optionsselection == 9 then
					infinitetime = not infinitetime
				elseif optionsselection == 10 then
					infinitelives = not infinitelives
				end
			end
		elseif controls.tap.menuBack then
			gamestate = "menu"
			saveconfig()
		end
	end
end

function keypromptenter(t, ...)
	arg = {...}
	if t == "key" and (arg[1] == ";" or arg[1] == "," or arg[1] == "," or arg[1] == "-") then
		return
	end
	buttonerror = false
	axiserror = false
	local buttononly = {"run", "jump", "reload", "use", "portal1", "portal2"}
	local axisonly = {"aimx", "aimy"}
	if t ~= "key" or arg[1] ~= "escape" then
		if t == "key" then
			if table.contains(axisonly, controlstable[optionsselection-3]) then
				axiserror = true
			else
				oldcontrols[skinningplayer][controlstable[optionsselection-3]] = {arg[1]}
			end
		elseif t == "joybutton" then
			if table.contains(axisonly, controlstable[optionsselection-3]) then
				axiserror = true
			else
				controls[skinningplayer][controlstable[optionsselection-3]] = {"joy", arg[1], "but", arg[2]}
			end
		elseif t == "joyhat" then
			if table.contains(buttononly, controlstable[optionsselection-3]) then
				buttonerror = true
			elseif table.contains(axisonly, controlstable[optionsselection-3]) then
				axiserror = true
			else
				controls[skinningplayer][controlstable[optionsselection-3]] = {"joy", arg[1], "hat", arg[2], arg[3]}
			end
		elseif t == "joyaxis" then
			if table.contains(buttononly, controlstable[optionsselection-3]) then
				buttonerror = true
			else
				controls[skinningplayer][controlstable[optionsselection-3]] = {"joy", arg[1], "axe", arg[2], arg[3]}
			end
		end
	end
	
	if (not buttonerror and not axiserror) or arg[1] == "escape" then
		keyprompt = false
	end
end

function keypromptstart()
	keyprompt = true
	buttonerror = false
	axiserror = false
	
	--save number of stuff
	prompt = {}
	prompt.joystick = {}
	prompt.joysticks = love.joystick.getJoystickCount()
	
	for i = 1, prompt.joysticks do
		prompt.joystick[i] = {}
		prompt.joystick[i].hats = love.joystick.getHatCount(i)
		prompt.joystick[i].axes = love.joystick.getAxisCount(i)
		
		prompt.joystick[i].validhats = {}
		for j = 1, prompt.joystick[i].hats do
			if love.joystick.getHat(i, j) == "c" then
				table.insert(prompt.joystick[i].validhats, j)
			end
		end
		
		prompt.joystick[i].axisposition = {}
		for j = 1, prompt.joystick[i].axes do
			table.insert(prompt.joystick[i].axisposition, love.joystick.getAxis(i, j))
		end
	end
end

function downloadfile(url, target, checksum)
	local data, code = http.request(url)
	
	if code ~= 200 then
		return false
	end
	
	if checksum ~= sha1(data) then
		print("Checksum doesn't match!")
		return false
	end
	
	if data then
		love.filesystem.write(target, data)
		return true
	else
		return false
	end
end

function reset_mappacks()
	delete_mappack("smb")
	delete_mappack("portal")
	
	loadbackgroundsafe("1-1.txt")
	
	playsound("oneup") --@DEV: no origin is fine
end

function delete_mappack(pack)
	if not love.filesystem.exists("mappacks/" .. pack .. "/") then
		return false
	end
	
	local list = love.filesystem.getDirectoryItems("mappacks/" .. pack .. "/")
	for i = 1, #list do
		love.filesystem.remove("mappacks/" .. pack .. "/" .. list[i])
	end
	
	love.filesystem.remove("mappacks/" .. pack .. "/")
end

function createmappack()
	local i = 1
	while love.filesystem.exists("mappacks/custom_mappack_" .. i .. "/") do
		i = i + 1
	end
	
	mappack = "custom_mappack_" .. i
	
	love.filesystem.createDirectory("mappacks/" .. mappack .. "/")
	
	local s = ""
	s = s .. "name=new mappack" .. "\n"
	s = s .. "author=you" .. "\n"
	s = s .. "description=the newest best  mappack?" .. "\n"
	
	love.filesystem.write("mappacks/" .. mappack .. "/settings.txt", s)
	
	--Create folders for all sorts of stuff.
	local folderlist = {"animated", "animations", "backgrounds", "enemies", "graphics", "levelscreens", "music"}
	
	for i, v in pairs(folderlist) do
		love.filesystem.createDirectory("mappacks/" .. mappack .. "/" .. v .. "/")
	end
end

function resetconfig()
	defaultconfig()
	
	changescale(scale)
	love.audio.setVolume(volume)
	currentshaderi1 = 1
	currentshaderi2 = 1
	shaders:set(1, nil)
	shaders:set(2, nil)
	saveconfig()
	loadbackgroundsafe("1-1.txt")
end

function selectworld()
	if not reachedworlds[mappack] then
		game_load()
	end
	
	local noworlds = true
	for i = 2, 8 do
		if reachedworlds[mappack][i] then
			noworlds = false
			break
		end
	end
	
	if noworlds then
		game_load()
		return
	end
	
	selectworldopen = true
	selectworldcursor = 1
	
	selectworldexists = {}
	for i = 1, 8 do
		if love.filesystem.exists("mappacks/" .. mappack .. "/" .. i .. "-1.txt") then
			selectworldexists[i] = true
		end
	end
end

function previouscharacter()
	--get current character
	local char
	for i = 1, #characterlist do
		if characterlist[i] == mariocharacter[skinningplayer] then
			char = i
			break
		end
	end
	
	if not char then return end
	
	if char > 1 then
		changecharacter(char - 1)
	else
		changecharacter(#characterlist)
	end
end

function nextcharacter()
	--get current character
	local char
	for i = 1, #characterlist do
		if characterlist[i] == mariocharacter[skinningplayer] then
			char = i
			break
		end
	end
	
	if not char then return end
	
	if char < #characterlist then
		changecharacter(char + 1)
	else
		changecharacter(1)
	end
end

function changecharacter(i)
	mariocharacter[skinningplayer] = characterlist[i]
	
	--change colors
	mariocolors[skinningplayer] = {}
	if characters[characterlist[i]].defaultcolors then
		if characters[characterlist[i]].defaultcolors[skinningplayer] then
			for j = 1, #characters[characterlist[i]].defaultcolors[skinningplayer] do
				mariocolors[skinningplayer][j] = {characters[characterlist[i]].defaultcolors[skinningplayer][j][1], characters[characterlist[i]].defaultcolors[skinningplayer][j][2], characters[characterlist[i]].defaultcolors[skinningplayer][j][3]}
			end
		end
	end
	
	if characters[characterlist[i]].defaulthat then
		mariohats[skinningplayer] = { characters[characterlist[i]].defaulthat}
	end
	
	colorsetedit = 1
end
end end)()end;
do require("package").preload["lobby"] = (function() local package;return function(...)-- <pack lobby> --
function lobby_load(hostnick)
	objects = nil
	if guielements.hideip then
		lobby_showmagicdns = not guielements.hideip.var
	else
		lobby_showmagicdns = false
	end
	loadmappacks(true)
	gamestate = "lobby"
	guielements = {}
	guielements.chatentry = guielement:new("input", 4, 207, 43+7/8, sendchat, "", 0)
	guielements.chatentry.usecoolvetica = true
	guielements.sendbutton = guielement:new("button", 359, 207, "send", sendchat, 1)
	guielements.playerscroll = guielement:new("scrollbar", 389, 3, 104, 8, 50, 0)

	lobby_playerlist = {}

	LOBBY_HOSTNICK = hostnick
	
	if clientisnetworkhost then
		guielements.startbutton = guielement:new("button", 4, 80, "start game", server_start, 1)
	end
	lobby_playerlist[1] = {connected=true, hats=mariohats[playerconfig], colors=mariocolors[playerconfig], nick=hostnick}
	guielements.quitbutton = guielement:new("button", 100, 80, "quit to menu", network_quit, 1)
	
	magicdns_timer = 0
	magicdns_delay = 30
	guielements.livescheckbox = guielement:new("checkbox", 10, 10, toggleinflives, infinitelives)

	lobby_mappackselectionnumber = 1
	mappacklist = love.filesystem.getDirectoryItems("mappacks")

	for x = 1, #mappacklist do
		if mappacklist[x] == mappack then
			lobby_mappackselectionnumber = x
			break
		end
	end

	lobby_numberofpages = 2
	lobby_currentpage = 1

	lobby_guielementspageactive = {{"livescheckbox", "mappackdecrease", "mappackincrease", "maxplayersincrease", "maxplayersdecrease"},
	{"shareportalscheckbox", "infinitetimecheckbox", "singularmariocheckbox", "classicmodecheckbox"}
	}


	guielements.mappackdecrease = guielement:new("button", 8, 23, "{", mappackdecrease, 0)
	guielements.mappackincrease = guielement:new("button", 78+(string.len(mappackname[lobby_mappackselectionnumber])+1)*8, 23, "}", mappackincrease, 0)

	guielements.maxplayersdecrease = guielement:new("button", 8, 45, "{", maxplayersdecrease, 0)
	guielements.maxplayersincrease = guielement:new("button", 128, 45, "}", maxplayersincrease, 0)



	guielements.showmagicdnsbutton = guielement:new("checkbox", 10, 67, toggleshowmagicdns, lobby_showmagicdns)

	guielements.changepagedecrease = guielement:new("button", 70, 95, "{", lobby_pagedecrease, 0)
	guielements.changepageincrease = guielement:new("button", 150, 95, "}", lobby_pageincrease, 0)

	guielements.shareportalscheckbox = guielement:new("checkbox", 10, 10, togglesharedportals, playersaresharingportals)
	guielements.shareportalscheckbox.active = false

	guielements.infinitetimecheckbox = guielement:new("checkbox", 10, 23, toggleinfinitetime, infinitetime)
	guielements.infinitetimecheckbox.active = false

	singularmariogamemode = false

	guielements.singularmariocheckbox = guielement:new("checkbox", 10, 36, togglesingularmario, singularmariogamemode)
	guielements.singularmariocheckbox.active = false

	classicmodeactive = false

	guielements.classicmodecheckbox = guielement:new("checkbox", 10, 49, toggleclassicmode, classicmodeactive)
	guielements.classicmodecheckbox.active = false



	lobby_currentmappackallowed = true

	lobby_maxplayers = 4

	hovertextdata = {{gui="singularmariocheckbox", hoverwidth= "1 mario, x portals", title="competitive mode", titlecolor={255, 0, 0}, text="see how far you can travel|with others controlling|your portals"},
	{gui="shareportalscheckbox", hoverwidth = "share portals", title="cooperative mode", titlecolor={0, 0, 255}, text="everyone shares 2 portals"}
	}

	pausemenuoptions = {"resume", "return to", "volume", "quit to", "quit to"}
	if clientisnetworkhost then
		pausemenuoptions2 = {"", "lobby", "", "menu", "desktop"}
	else
		pausemenuoptions2 = {"", "onlinemenu", "", "menu", "desktop"}
	end

end

function lobby_update(dt)
	runanimationtimer = runanimationtimer + dt
	while runanimationtimer > runanimationdelay do
		runanimationtimer = runanimationtimer - runanimationdelay
		runanimationframe = runanimationframe - 1
		if runanimationframe == 0 then
			runanimationframe = 3
		end
	end
	
	if clientisnetworkhost then
		magicdns_timer = magicdns_timer + dt
		while magicdns_timer > magicdns_delay do
			magicdns_timer = magicdns_timer - magicdns_delay
			--this needs to be changed so the delay is like 2 seconds until the external port is known
			magicdns_keep()
		end
	end
	for i, v in pairs(hovertextdata) do
		if _G["guielements"][v.gui] then
			local element = _G["guielements"][v.gui]
			if element.active then
				local mousex, mousey = love.mouse.getX(), love.mouse.getY()
				if mousex >= element.x*scale and mousex <= element.x*scale + 9*scale + 8*string.len(v.hoverwidth)*scale and mousey >= element.y*scale and mousey <= element.y*scale + 9*scale then
					v.showing = true
				else
					v.showing = false
				end
			end
		end
	end
end

function lobby_draw()
	--STUFF
	love.graphics.setColor(0, 0, 0, 200)
	love.graphics.rectangle("fill", 3*scale, 3*scale, 233*scale, 104*scale)
	
	love.graphics.setColor(255, 255, 255, 255)
	--[[if usemagic and adjective and noun and lobby_showmagicdns then
		properprintbackground("magicdns: " .. adjective .. " " .. noun, 4*scale, 98*scale, true)
	end--]]
	if clientisnetworkhost then
		guielements.startbutton:draw()
	end
	guielements.quitbutton:draw()
	
	--lobby_playerlist

	
	local missingpixels = math.max(0, (#lobby_playerlist*41-3)-104)
	
	love.graphics.setColor(0, 0, 0, 200)
	love.graphics.rectangle("fill", 239*scale, 3*scale, 150*scale, 104*scale)
	
	love.graphics.translate(0, -missingpixels*guielements.playerscroll.value*scale)
	
	local y = 1
	for i = 1, #lobby_playerlist do
		--if lobby_playerlist[i].connected then
			local ping = nil
			if networkclientnumber and networkclientnumber ~= 0 and lobby_playerlist[i] then
				if convertclienttoplayer(i) > 1 and lobby_playerlist[i].ping then
					ping = lobby_playerlist[i].ping
				end
			end
			local ypos = (y-1)*41*scale+3*scale-missingpixels*guielements.playerscroll.value*scale
			if ypos < 3*scale then
				ypos = 3*scale
			end
			if ypos < 107*scale then
				local height = 38*scale
				if ypos + 38*scale > 107*scale then
					height = math.abs(ypos-107*scale)
				end
				love.graphics.setScissor(239*scale, ypos, 161*scale, height)
				if lobby_playerlist[i] then
					if lobby_playerlist[i].colors and lobby_playerlist[i].hats and lobby_playerlist[i].nick then
						drawplayercard(239, (y-1)*41+3, lobby_playerlist[i].colors or mariocolors[i], lobby_playerlist[i].hats or mariohats[i], lobby_playerlist[i].nick or localnicks[math.random(#localnicks)], ping, focus)
					end
				end
				love.graphics.setScissor()
			end

			y = y + 1
		--end
	end
	
	love.graphics.translate(0, missingpixels*guielements.playerscroll.value*scale)
	guielements.playerscroll:draw()
	love.graphics.setScissor()
	
	--chat
	love.graphics.setColor(0, 0, 0, 200)
	love.graphics.rectangle("fill", 3*scale, 110*scale, 394*scale, 111*scale)
	love.graphics.setColor(255, 255, 255, 255)
	drawrectangle(4, 111, 392, 109)
	
	guielements.chatentry:draw()
	guielements.sendbutton:draw()
	
	--chat messages
	local height = 0
	for i = 1, math.min(#chatlog, 7) do


		local pid = 0
		for j = 1, #lobby_playerlist do
			if lobby_playerlist[j].nick == chatlog[i].id then
				pid = j
				break
			end
		end
		
		if pid ~= 0 then
			local nick = lobby_playerlist[pid].nick .. ":"
			
			local background = {255, 255, 255}
			
			local adds = 0
			for i = 1, 3 do
				adds = adds + lobby_playerlist[pid].colors[1][i]
			end
			
			if adds/3 > 40 then
				background = {0, 0, 0}
			end
			
			love.graphics.setColor(unpack(lobby_playerlist[pid].colors[1]))
			love.graphics.print(string.upper(nick), 8*scale, (190-(height*12))*scale)
			love.graphics.setColor(255, 255, 255)
			love.graphics.setFont(bigchatlogfont)
			love.graphics.print(chatlog[i].message, (8+(string.len(nick))*8)*scale, (190-(height*12))*scale)
			height = height + 1
		end

	end


	if guielements.livescheckbox.active then
		guielements.livescheckbox:draw()
		properprint("infinite lives", 20*scale, 11*scale)
	end

	if guielements.mappackincrease.active then
		guielements.mappackincrease:draw()
		guielements.mappackdecrease:draw()
		if lobby_currentmappackallowed then 
			love.graphics.setColor(0, 255, 0)
			properprint("all peers own this map", 20*scale, 36*scale)
		else
			love.graphics.setColor(255, 0, 0)
			properprint("not all peers own this map", 20*scale, 36*scale)
		end
		properprint("mappack:" .. string.lower(mappackname[lobby_mappackselectionnumber]), 20*scale, 25*scale)
	end



	love.graphics.setColor(255, 255, 255)
	if guielements.maxplayersincrease.active then
		guielements.maxplayersincrease:draw()
		guielements.maxplayersdecrease:draw()

		properprint("max players:" .. lobby_maxplayers, 20*scale, 47*scale)
	end

	if lobby_maxplayers > 4 then
		love.graphics.setColor(255, 0, 0)
		properprint("possibly", 154*scale, 47*scale)
		properprint("unstable", 154*scale, 58*scale)
	end
	love.graphics.setColor(0, 0, 0)
	if usemagic then
		guielements.showmagicdnsbutton:draw()
		properprint("show magicdns: ", 20*scale, 68*scale)
		love.graphics.setColor(0, 0, 255, 255)
		if usemagic and adjective and noun and lobby_showmagicdns then
			properprintbackground(adjective .. " " .. noun, 132*scale, 68*scale, true)
		else
			local constructedstring = ""
			for x = 1, string.len(adjective .. " " .. noun) do
				constructedstring = constructedstring .. "x"
			end
			properprintbackground(constructedstring, 132*scale, 68*scale, true)
		end
	end

	love.graphics.setColor(255, 255, 255, 255)
	properprint("page " .. lobby_currentpage .. "/" .. lobby_numberofpages, 83*scale, 97*scale)

	guielements.changepageincrease:draw()
	guielements.changepagedecrease:draw()

	if guielements.shareportalscheckbox.active then
		guielements.shareportalscheckbox:draw()
		properprint("share portals", 20*scale, 11*scale)
	end

	if guielements.infinitetimecheckbox.active then
		guielements.infinitetimecheckbox:draw()
		properprint("infinite time", 20*scale, 24*scale)
	end


	if guielements.singularmariocheckbox.active then
		guielements.singularmariocheckbox:draw()
		properprint("1 mario, " .. #lobby_playerlist*2 .. " portals", 20*scale, 37*scale)
	end

	if guielements.classicmodecheckbox.active then
		guielements.classicmodecheckbox:draw()
		properprint("classic mode", 20*scale, 50*scale)
	end

	for i, v in pairs(hovertextdata) do
		if _G["guielements"][v.gui] then
			local element = _G["guielements"][v.gui]
			if element.active and v.showing then
				local split = v.text:split("|")
				local longesttext = 1
				for x = 2, #split do
					if string.len(split[x]) > string.len(split[longesttext]) then
						longesttext = x
					end
				end
				local x, y, width, height = love.mouse.getX()/scale, love.mouse.getY()/scale, (string.len(split[longesttext])+1)*8, (#split+1)*10
				love.graphics.setColor(0, 0, 0, 255)
				love.graphics.rectangle("fill", (x-1)*scale, (y-1)*scale, (width+2)*scale, (height+2)*scale)
				love.graphics.setColor(255, 255, 255, 255)
				drawrectangle(x, y, width, height)
				love.graphics.setColor(v.titlecolor)
				properprintbackground(v.title, (x+2)*scale, (y+2)*scale, true)
				love.graphics.setColor(255, 255, 255)
				properprint(v.text, (x+2)*scale, (y+12)*scale)
			end
		end
	end

end

function sendchat()
	if string.len(guielements.chatentry.value) > 0 then 
		local stringtosend = lobby_playerlist[1].nick .. ":"
		network_sendchat(stringtosend .. guielements.chatentry.value)
		guielements.chatentry.value = ""
		guielements.chatentry.cursorpos = 1
		guielements.chatentry.inputting = true
	end
end

function toggleinflives()
	if clientisnetworkhost then
		infinitelives = not infinitelives
		guielements.livescheckbox.var = infinitelives
		local toggle = "0"
		if infinitelives then
			toggle = "1"
		end
		udp:send("inflives;1;" .. toggle)
	end
end

function mappackincrease()
	if clientisnetworkhost then
		lobby_mappackselectionnumber = lobby_mappackselectionnumber + 1
		if lobby_mappackselectionnumber > #mappacklist then
			lobby_mappackselectionnumber = 1
		end
		mappack = mappacklist[lobby_mappackselectionnumber]

		guielements.mappackincrease.x = 78+(string.len(mappackname[lobby_mappackselectionnumber])+1)*8

		loadbackground("1-1.txt")
		udp:send("changemappack;1;" .. mappackname[lobby_mappackselectionnumber])
		lobby_currentmappackallowed = false

		for x = 1, #allowedmappacklist do
			if allowedmappacklist[x] == mappackname[lobby_mappackselectionnumber] then
				lobby_currentmappackallowed = true
			end
		end
	end
end

function mappackdecrease()
	if clientisnetworkhost then
		lobby_mappackselectionnumber = lobby_mappackselectionnumber - 1
		if lobby_mappackselectionnumber < 1 then
			lobby_mappackselectionnumber = #mappacklist
		end
		mappack = mappacklist[lobby_mappackselectionnumber]

		guielements.mappackincrease.x = 78+(string.len(mappackname[lobby_mappackselectionnumber])+1)*8

		loadbackground("1-1.txt")
		udp:send("changemappack;1;" .. mappackname[lobby_mappackselectionnumber])

		lobby_currentmappackallowed = false

		for x = 1, #allowedmappacklist do
			if allowedmappacklist[x] == mappackname[lobby_mappackselectionnumber] then
				lobby_currentmappackallowed = true
			end
		end
	end
end

function lobby_globalmappacks(datatable)
	print("got all mappacks")
	allowedmappacklist = {}
	for x = 2, #datatable do 
		table.insert(allowedmappacklist, datatable[x])
	end

	lobby_currentmappackallowed = false

	for x = 1, #allowedmappacklist do
		if allowedmappacklist[x] == mappackname[lobby_mappackselectionnumber] then
			lobby_currentmappackallowed = true
		end
	end
end

function lobby_changemappack(datatable)
	for x = 1, #mappackname do
		if mappackname[x] == datatable[2] then
			mappack = mappacklist[x]
			loadbackground("1-1.txt")
			lobby_mappackselectionnumber = x
			guielements.mappackincrease.x = 78+(string.len(mappackname[lobby_mappackselectionnumber])+1)*8
			break
		end
	end
end

function maxplayersdecrease()
	if clientisnetworkhost then
		lobby_maxplayers = lobby_maxplayers - 1
		if lobby_maxplayers < 2 then
			lobby_maxplayers = 99
		end
		server_resyncmaxplayers = true
		guielements.maxplayersincrease.x = 128+(string.len(tostring(lobby_maxplayers))-1)*8

	end
end

function maxplayersincrease()
	if clientisnetworkhost then
		lobby_maxplayers = lobby_maxplayers + 1
		if lobby_maxplayers > 99 then
			lobby_maxplayers = 2
		end
		server_resyncmaxplayers = true
		guielements.maxplayersincrease.x = 128+(string.len(tostring(lobby_maxplayers))-1)*8

	end
end

function lobby_changemaxplayers(datatable)
	lobby_maxplayers = tonumber(datatable[2])
	guielements.maxplayersincrease.x = 128+(string.len(tostring(lobby_maxplayers))-1)*8
end

function toggleshowmagicdns()
	lobby_showmagicdns = not lobby_showmagicdns
	guielements.showmagicdnsbutton.var = lobby_showmagicdns
end

function lobby_pageincrease()
	lobby_currentpage = math.min(lobby_currentpage+1, lobby_numberofpages)
	for x = 1, #lobby_guielementspageactive do
		if x == lobby_currentpage then
			for i, v in pairs(lobby_guielementspageactive[x]) do
				_G["guielements"][v].active = true
			end
		else
			for i, v in pairs(lobby_guielementspageactive[x]) do
				_G["guielements"][v].active = false
			end
		end
	end

end

function lobby_pagedecrease()
	lobby_currentpage = math.max(lobby_currentpage-1, 1)
	for x = 1, #lobby_guielementspageactive do
		if x == lobby_currentpage then
			for i, v in pairs(lobby_guielementspageactive[x]) do
				_G["guielements"][v].active = true
			end
		else
			for i, v in pairs(lobby_guielementspageactive[x]) do
				_G["guielements"][v].active = false
			end
		end
	end
end

function togglesharedportals()
	if clientisnetworkhost then
		playersaresharingportals = not playersaresharingportals
		guielements.shareportalscheckbox.var = playersaresharingportals
		local toggle = "0"
		if playersaresharingportals then
			toggle = "1"
		end
		udp:send("sharingportals;1;" .. toggle)
	end
end

function lobby_changesharedportalsvalue(datatable)
	playersaresharingportals = (datatable[2] == "1")
	if guielements.shareportalscheckbox then
		guielements.shareportalscheckbox.var = playersaresharingportals
	end
end

function toggleinfinitetime()
	if clientisnetworkhost then
		infinitetime = not infinitetime
		guielements.infinitetimecheckbox.var = infinitetime
		local toggle = "0"
		if infinitetime then
			toggle = "1"
		end
		udp:send("infinitetimefunction;1;" .. toggle)
	end
end

function lobby_setinfinitetime(datatable)
	infinitetime = (datatable[2] == "1")
	if guielements.infinitetimecheckbox then
		guielements.infinitetimecheckbox.var = infinitetime
	end
end

function togglesingularmario()
	if clientisnetworkhost then
		singularmariogamemode = not singularmariogamemode
		guielements.singularmariocheckbox.var = singularmariogamemode
		lobby_sendcheckboxvalue(singularmariogamemode, "singularmario")
	end
end

function lobby_sendcheckboxvalue(togglevalue, identifierstring)
	local togglestring = "0"
	if togglevalue then
		togglestring = "1"
	end
	udp:send("checkboxvaluechange;1;" .. togglestring .. ";" .. identifierstring)
end

function lobby_synccheckboxvalue(datatable)
	if datatable[3] == "singularmario" then
		singularmariogamemode = (datatable[2] == "1")
		if guielements.singularmariocheckbox then
			guielements.singularmariocheckbox.var = singularmariogamemode
		end
	elseif datatable[3] == "classicmode" then
		classicmodeactive = (datatable[2] == "1")
		if guielements.classicmodecheckbox then
			guielements.classicmodecheckbox.var = classicmodeactive
		end
	end
end

function toggleclassicmode()
	if clientisnetworkhost then
		classicmodeactive = not classicmodeactive
		guielements.classicmodecheckbox.var = classicmodeactive
		lobby_sendcheckboxvalue(classicmodeactive, "classicmode")
	end
end

end end)()end;
do require("package").preload["entity"] = (function() local package;return function(...)-- <pack entity> --
entity = class("entity")

entitylist = {	
	{t="remove", category="misc", description="place anywhere - acts as an entity eraser", iconauthor="Assasin-Kiashi"}, --0
	{t="powerup", category="smb stuff", description="place on block - will give either a mushroom or a flower", iconauthor=""},
	{t="cheepcheep", category="smb stuff", description="place on empty tile - red or white cheep cheep", iconauthor="alesan99"},
	{t="musicentity", category="misc", description="place anywhere - takes an input and will play specified music track", iconauthor="idiot9.0"},
	{t="manycoins", category="smb stuff", description="place on a non question mark block - gives several coins", iconauthor="TheCanadianToast"},
	{t="enemyspawner", category="misc", description="place on empty tile - will spawn enemies on input", iconauthor=""},
	{t="animatedtiletrigger", category="i/o objects", description="place anywhere - will animate tiles with the trigger attribute", iconauthor=""},
	{t="spawn", category="level markers", description="place on empty tile - mario's starting point", iconauthor="TripleXero"},
	{t="delayer", category="gates", description="place anywhere - will delay an input", output=true, iconauthor=""},
	{t="rsflipflop", category="gates", description="place anywhere - can be toggled on and off", output=true, iconauthor=""},
	{t="flag", category="level markers", description="place on block - bottom of the flag, end of level", iconauthor="TripleXero"}, --10
	{t="sfxentity", category="misc", description="place anywhere - takes an input and will play specified sound effect", iconauthor="EntranceJew"},
	{t="animationtarget", category="i/o objects", description="place anywhere - sends output when called by animation trigger", output=true, iconauthor="EntranceJew"},
	{t="vine", category="smb stuff", description="place on block - vine - right click to choose destination", iconauthor="Superjustinbros"},
	{t="vinestop", category="smb stuff", description="place anywhere - will stop a vine's growth at this point", iconauthor="alesan99"},
	{t=""},
	{t=""},
	{t="platform", category="smb stuff", description="place on empty tile - oscillating platform", iconauthor="Assasin-Kiashi"},
	{t="regiontrigger", category="i/o objects", description="place anywhere - will output when there's an object in a region", output=true, iconauthor="alesan99"},
	{t=""},
	{t=""}, --20
	{t=""},
	{t="mazestart", category="level markers", description="place anywhere - logical maze start", hidden=not DEBUG, iconauthor=""},
	{t="mazeend", category="level markers", description="place anywhere - logical maze end", hidden=not DEBUG, iconauthor=""},
	{t="mazegate", category="level markers", description="place on empty tile - maze gate", hidden=not DEBUG, iconauthor=""},
	{t="emancipationgrill", category="portal elements", description="place on empty tile - emancipation grill, stops portals and objects other than mario", iconauthor="Assasin-Kiashi"},
	{t="scaffold", category="portal elements", description="place on empty tile - platform with an input", iconauthor=""},
	{t="door", category="portal elements", description="place on empty tile - it's a door. it opens, it closes, it doors.", iconauthor="idiot9.0"},
	{t="pedestal", category="portal elements", description="place on empty tile - portal gun ready for pickup", iconauthor=""},
	{t="wallindicator", category="i/o objects", description="place anywhere - shows on or off state", iconauthor=""},
	{t=""}, --30
	{t="platformfall", category="smb stuff", description="place on empty tile - falling platforms", iconauthor=""},
	{t="pswitch", category="smb stuff", description="place on empty tile or in block", iconauthor=""},
	{t=""},
	{t="drain", category="level markers", description="place at the very bottom in an underwater level - drain, attracts mario down", iconauthor="Bobfan"},
	{t="lightbridge", category="portal elements", description="place on empty tile - light bridge", iconauthor="ChrisGin"},
	{t="portalent", category="misc", description="place on block - create a portal on input", iconauthor="Firaga"},
	{t=""},
	{t="actionblock", category="i/o objects", description="place on empty tile - will create a coinblock style toggle button", output=true, iconauthor=""},
	{t="button", category="portal elements", description="place on empty tile - floor button", output=true, iconauthor=""},
	{t="platformspawner", category="smb stuff", description="place on empty tile - platform spawner", iconauthor=""}, --40
	{t="animationtrigger", category="i/o objects", description="place anywhere - will start an animation when getting an input signal", iconauthor=""},
	{t="groundlight", category="portal elements", description="place anywhere - use to show on/off state", iconauthor="idiot9.0"},
	{t=""},
	{t=""},
	{t=""},
	{t=""},
	{t=""},
	{t="faithplate", category="portal elements", description="place on ground - f-f--fling yourself.", iconauthor="idiot9.0"},
	{t=""},
	{t=""}, --50
	{t="laser", category="portal elements", description="place on empty tile - laser pew pew", iconauthor="Pixelworker"},
	{t="noportal", category="portal elements", description="all portals shot into this region will be destroyed", output=true, iconauthor="EntranceJew"},
	{t=""},
	{t=""},
	{t="laserdetector", category="portal elements", description="place on empty tile - will send signal if laser is detected", output=true, iconauthor="QwertymanO07"},
	{t=""},
	{t=""},
	{t=""},
	{t="bulletbill", category="smb stuff", description="place on bulletbill launchers - will make the launcher actually launch bulletbills", iconauthor="Mari0Maker"},
	{t="geldispenser", category="portal elements", description="place on empty tile - will produce gel", iconauthor=""}, --60
	{t=""},
	{t=""},
	{t=""},
	{t=""},
	{t=""},
	{t="boxtube", category="portal elements", description="place on empty tile - will drop an object and remove previous one", iconauthor="Mari0Maker"},
	{t="pushbutton", category="portal elements", description="place on empty tile - will send a toggle signal when used", output=true, iconauthor=""},
	{t=""},
	{t=""},
	{t=""}, --70
	{t=""},
	{t=""},
	{t="walltimer", category="i/o objects", description="place anywhere - will send on signal for a duration", output=true, iconauthor=""},
	{t="generatorbullet", category="smb stuff", description="place anywhere - generates bullet bills", iconauthor="sorrynothing"},
	{t="generatorcheeps", category="smb stuff", description="place anywhere - generates flying cheep cheeps", iconauthor="sorrynothing"},
	{t="generatorflames", category="smb stuff", description="place anywhere - generates bowser's flames", iconauthor="sorrynothing"},
	{t="generatorwind", category="smb stuff", description="place anywhere - generates wind", iconauthor="sorrynothing"},
	{t="castlefire", category="smb stuff", description="place anywhere - rotating fire stick", iconauthor="Assasin-Kiashi"},
	{t="seesaw", category="smb stuff", description="place on empty tile - see-saw", iconauthor="Firaga"},
	{t="warppipe", category="level markers", description="place on block - level warp", iconauthor="BobTheLawyer"}, --80
	{t="squarewave", category="gates", description="place anywhere - sends on signal for x seconds and off signal for y seconds", output=true, iconauthor="crazyal02"},
	{t="lakitoend", category="level markers", description="place anywhere - defines a right border for lakito", iconauthor=""},
	{t="notgate", category="gates", description="place anywhere - turns in input around", output=true, iconauthor="Pixelworker"},
	{t="gel", category="portal elements", description="place on tile - creates gel on this block", iconauthor="MissingWorld"},
	{t="orgate", category="gates", description="place anywhere - or gate", output=true, iconauthor=""},
	{t="andgate", category="gates", description="place anywhere - and gate", output=true, iconauthor="Turtle95"},
	{t="redcoin", category="smb stuff", description="place in air - a red coin to collect", iconauthor="sorrynothing"},
	{t=""},
	{t="bowser", category="level markers", description="place on empty tile preferably on the first block on a bridge with an axe - bowser", iconauthor="renhoek"},
	{t="axe", category="level markers", description="place on empty tile preferably behind a bridge - axe, end of level", output=true, iconauthor="alesan99"}, --90
	{t="platformbonus", category="smb stuff", description="place on empty tile - platform in coin worlds", iconauthor=""},
	{t="spring", category="smb stuff", description="place on empty tile - spring", iconauthor="Firaga"},
	{t=""},
	{t=""},
	{t=""},
	{t=""},
	{t=""},
	{t=""},
	{t="checkpoint", category="level markers", description="place on empty tile - checkpoint - mario will spawn there if he dies after reaching it", iconauthor="TripleXero"},
	{t="ceilblocker", category="level markers", description="place an	ywhere - makes it impossible to jump over the top row of blocks", iconauthor="alesan99"},
	{t=""},
	{t=""},
	{t=""},
	{t="funnel", category="portal elements", description="place on empty tile - portal excursion funnel", iconauthor=""},
	{t=""},
	{t=""},
	{t=""},
	{t="panel", category="portal elements", description="place on block - will probably be removed anyway. todo!", iconauthor=""},
	{t="textentity", category="i/o objects", description="place anywhere - creates a text in the level, supports input", iconauthor=""},
}

outputs = {}
outputsi = {}
for i = 1, #entitylist do
	if entitylist[i].output then
		table.insert(outputs, entitylist[i].t)
		table.insert(outputsi, i)
	end
end

tooltipimages = {}

for i = 1, #entitylist do
	if entitylist[i].t~="" then
		local path = "entitytooltips/" .. entitylist[i].t .. ".png"
		tooltipimages[i] = love.graphics.newImage(path)
	end
end

rightclickmenues = {}

rightclickmenues.seesaw = {
	{t="text", value="distance:"},
	{t="scrollbar", min=2, max=10, step=1, default=7},
	{t="text", value="left height:"},
	{t="scrollbar", min=1, max=10, step=1, default=4},
	{t="text", value="right height:"},
	{t="scrollbar", min=1, max=10, step=1, default=6},
	{t="text", value="platf. width:"},
	{t="scrollbar", min=1, max=10, step=0.5, default=3},
}

rightclickmenues.spawn = {
	{t="text", value="for players:"},
	{t="checkbox", text="all", default="true"},
	{t="checkbox", text="1", default="false"},
	{t="checkbox", text="2", default="false"},
	{t="checkbox", text="3", default="false"},
	{t="checkbox", text="4", default="false"}
}

rightclickmenues.castlefire = {
	{t="text", value="length:"},
	{t="scrollbar", min=1, max=16, step=1, default=6},
	{t="text", value="delay:"},
	{t="scrollbar", min=0.03, max=1, step=0.01, default=0.11},
	{},
	{t="checkbox", text="counter-cw", default="false"}
}

rightclickmenues.walltimer = {
	{t="text", value="time:"},
	{t="scrollbar", min=1, max=10, step=0.01, default=1},
	{},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.delayer = {
	{t="checkbox", text="visible", default="true"},
	{},
	{t="text", value="delay:"},
	{t="scrollbar", min=0.01, max=10, step=0.01, default=1},
	{},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.wallindicator = {
	{t="checkbox", text="reversed", default="false"},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.notgate = {
	{t="checkbox", text="visible", default="true"},
	{},
	{t="linkbutton", value="link in", link="in"}
}

rightclickmenues.rsflipflop = {
	{t="checkbox", text="visible", default="true"},
	{},
	{t="linkbutton", value="link set", link="set"},
	{t="linkbutton", value="link reset", link="reset"}
}

rightclickmenues.orgate = {
	{t="checkbox", text="visible", default="true"},
	{},
	{t="linkbutton", value="link in 1", link="1"},
	{t="linkbutton", value="link in 2", link="2"},
	{t="linkbutton", value="link in 3", link="3"},
	{t="linkbutton", value="link in 4", link="4"}
}

rightclickmenues.andgate = {
	{t="checkbox", text="visible", default="true"},
	{},
	{t="linkbutton", value="link in 1", link="1"},
	{t="linkbutton", value="link in 2", link="2"},
	{t="linkbutton", value="link in 3", link="3"},
	{t="linkbutton", value="link in 4", link="4"}
}

rightclickmenues.musicentity = {
	{t="checkbox", text="visible", default="true"},
	{t="checkbox", text="single use", default="true"},
	{},
	{t="submenu", entries=function() local t = {} for i, v in pairs(musiclist) do table.insert(t, v) end return t end, actualvalue=true, default=1, width=15},
	{},
	{t="linkbutton", value="link trigger", link="trigger"}
}

rightclickmenues.sfxentity = {
	{t="checkbox", text="visible", default="true"},
	{t="checkbox", text="single use", default="true"},
	{},
	{t="submenu", entries=function() local t = {} for i, v in pairs(soundstoload) do table.insert(t, v) end return t end, actualvalue=true, default=1, width=15},
	{},
	{t="linkbutton", value="link trigger", link="trigger"}
}

rightclickmenues.enemyspawner = {
	{t="submenu", entries=function() return {unpack(enemies)} end, actualvalue=true, default=1, width=15},
	{},
	{t="text", value="velocity x:"},
	{t="scrollbar", min=-50, max=50, default=0},
	{t="text", value="velocity y:"},
	{t="scrollbar", min=-50, max=50, default=0},
	{},
	{t="linkbutton", value="link trigger", link="trigger"}
}

rightclickmenues.boxtube = {
	{t="text", value="on load:"},
	{t="checkbox", text="drop box", default="true"},
	{},
	{t="checkbox", text="respawn obj", default="true"},
	{t="text", value="if destroyed"},
	{},
	{t="text", value="object:"},
	{t="submenu", entries=function() return {"box", unpack(enemies)} end, actualvalue=true, default=1, width=15},
	{},
	{t="linkbutton", value="link drop", link="drop"}
}

rightclickmenues.laserdetector = {
	{t="text", value="direction:"},
	{t="directionbuttons", left=true, right=true, up=true, down=true, default="right"}
}

rightclickmenues.pushbutton = {
	{t="text", value="direction:"},
	{t="directionbuttons", left=true, right=true, default="left"},
	{},
	{t="text", value="base:"},
	{t="directionbuttons", left=true, right=true, up=true, down=true, default="down"}
}

rightclickmenues.platformfall = {
	{t="text", value="width:"},
	{t="scrollbar", min=1, max=10, step=0.5, default=3}
}

rightclickmenues.pipe = {
	{t="text", value="destination:"},
	{t="submenu", entries={"main", "sub-1", "sub-2", "sub-3", "sub-4", "sub-5"}, default=1, width=5},
}

rightclickmenues.vine = {
	{t="text", value="destination:"},
	{t="submenu", entries={"main", "sub-1", "sub-2", "sub-3", "sub-4", "sub-5"}, default=1, width=5},
}

rightclickmenues.mazegate = {
	{t="text", value="gatenumber:"},
	{t="submenu", entries={"main", "gate 1", "gate 2", "gate 3", "gate 4", "gate 5"}, default=1, width=6},
}

rightclickmenues.warppipe = {
	{t="text", value="this id:"},
	{t="input", default="1"},
	{},
	{t="text", value="dest map:"},
	{t="input", default="1-1-1"},
	{t="text", value="dest id:"},
	{t="input", default="1"},
	{},
	{t="text", value="enter dir:"},
	{t="directionbuttons", left=true, right=true, up=true, down=true, default="down"},
	{t="text", value="exit dir:"},
	{t="directionbuttons", left=true, right=true, up=true, down=true, default="up"},
	{},
	{t="checkbox", text="is usable", default="true"}, 
	{t="checkbox", text="is sublevel", default="true"}, 
}

rightclickmenues.funnel = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", left=true, up=true, right=true, down=true, default="right"}, 
	{}, 
	{t="text", value="speed:"}, 
	{t="scrollbar", min=funnelminspeed, max=funnelmaxspeed, step=0.01, default=3}, 
	{}, 
	{t="checkbox", text="reverse", default="false"}, 
	{t="checkbox", text="default off", default="false"}, 
	{},
	{t="linkbutton", value="link reverse", link="reverse"},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.emancipationgrill = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", hor=true, ver=true, default="ver"}, 
	{}, 
	{t="checkbox", text="default off", default="false"}, 
	{}, 
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.laser = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", left=true, up=true, right=true, down=true, default="right"}, 
	{}, 
	{t="checkbox", text="default off", default="false"}, 
	{}, 
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.lightbridge = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", left=true, up=true, right=true, down=true, default="right"}, 
	{}, 
	{t="checkbox", text="default off", default="false"}, 
	{}, 
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.platformspawner = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", up=true, down=true, default="up"}, 
	{}, 
	{t="text", value="width:"},
	{t="scrollbar", min=1, max=10, step=0.5, default=3},
	{t="text", value="speed:"},
	{t="scrollbar", min=0.5, max=10, step=0.01, default=3.5},
	{t="text", value="delay:"},
	{t="scrollbar", min=1, max=10, step=0.01, default=2.18}
}

rightclickmenues.platform = {
	{t="text", value="width:"},
	{t="scrollbar", min=1, max=10, step=0.5, default=3},
	{t="text", value="distance x:"},
	{t="scrollbar", min=-15, max=15, step=0.5, default=3.3125},
	{t="text", value="distance y:"},
	{t="scrollbar", min=-15, max=15, step=0.5, default=0},
	{t="text", value="duration:"},
	{t="scrollbar", min=1, max=10, step=0.01, default=4}
}

rightclickmenues.scaffold = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", down=true, left=true, right=true, up=true, default="right"},
	{t="checkbox", text="default off", default="false"}, 
	{t="text", value="width:"},
	{t="scrollbar", min=0.5, max=15, step=0.5, default=3},
	{t="text", value="distance:"},
	{t="scrollbar", min=0.5, max=15, step=0.01, default=3},
	{t="text", value="speed:"},
	{t="scrollbar", min=0.5, max=10, step=0.01, default=5.5},
	{t="text", value="wait start:"},
	{t="scrollbar", min=0, max=10, step=0.01, default=0.5},
	{t="text", value="wait end:"},
	{t="scrollbar", min=0, max=10, step=0.01, default=0.5},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.faithplate = {
	{t="text", value="velocity x:"},
	{t="scrollbar", min=-50, max=50, step=0.01, default=30},
	{t="text", value="velocity y:"},
	{t="scrollbar", min=5, max=50, step=0.01, default=30},
	{},
	{t="checkbox", text="default off", default="false"},
	{},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.door = {
	{t="text", value="direction:"},
	{t="directionbuttons", hor=true, ver=true, default="ver"},
	{},
	{t="checkbox", text="start open", default="false"},
	{t="checkbox", text="force close", default="false"},
	{},
	{t="linkbutton", value="link open", link="open"}
}

rightclickmenues.gel = {
	{t="text", value="type:"},
	{t="submenu", entries=enum_gels, default=1, width=6},
	{},
	{t="text", value="direction:"}, 
	{t="checkbox", text="left", default="false"},
	{t="checkbox", text="top", default="true"},
	{t="checkbox", text="right", default="false"},
	{t="checkbox", text="bottom", default="false"}
}

rightclickmenues.geldispenser = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", left=true, right=true, down=true, up=true, default="down"}, 
	{},
	{t="text", value="type:"},
	{t="submenu", entries=enum_gels, default=1, width=6},
	{},
	{t="checkbox", text="default off", default="false"},
	{},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.panel = {
	{t="text", value="direction:"}, 
	{t="directionbuttons", left=true, up=true, right=true, down=true, default="right"}, 
	{}, 
	{t="checkbox", text="start white", default="false"}, 
	{}, 
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.button = {
	{t="text", value="direction:"},
	{t="directionbuttons", left=true, right=true, up=true, down=true, default="down"}
}

rightclickmenues.textentity = {
	{t="input", default="text", max=50},
	{},
	{t="checkbox", text="default off", default="false"},
	{},
	{t="text", value="red:"},
	{t="scrollbar", min=0, max=255, step=1, default=255},
	{t="text", value="green:"},
	{t="scrollbar", min=0, max=255, step=1, default=255},
	{t="text", value="blue:"},
	{t="scrollbar", min=0, max=255, step=1, default=255},
	{},
	{t="text", value="x offset:"},
	{t="scrollbar", min=0, max=16, step=1, default=0},
	{t="text", value="y offset:"},
	{t="scrollbar", min=0, max=16, step=1, default=0},
	{},
	{t="linkbutton", value="link power", link="power"},
}

rightclickmenues.squarewave = {
	{t="text", value="off time"},
	{t="scrollbar", min=0.01, max=10, step=0.01, default=2},
	{t="text", value="on time"},
	{t="scrollbar", min=0.01, max=10, step=0.01, default=2},
	{},
	{t="text", value="wave offset"},
	{t="scrollbar", min=0, max=1, step=0.01, default=0},
	{},
	{t="checkbox", text="visible", default="true"}
}

rightclickmenues.regiontrigger = {
	{t="text", value="trigger on:"},
	{t="checkbox", text="players", default="true"},
	{t="checkbox", text="enemies", default="true"},
	{},
	{t="regionselect", value="select region", region="region", default="region:0:0:1:1"}
}

rightclickmenues.noportal = {
	{t="text", value="trigger on:"},
	{t="checkbox", text="shot portals", default="true"},
	{},
	{t="checkbox", text="default on", default="true"},
	{},
	{t="linkbutton", value="link power", link="power"},
	{},
	{t="regionselect", value="select region", region="region", default="region:0:0:1:1"}
}

rightclickmenues.animationtrigger = {
	{t="text", value="animation id"},
	{t="input", default="myanim", max=12},
	{},
	{t="linkbutton", value="link in", link="in"}
}

rightclickmenues.animationtarget = {
	{t="text", value="target name"},
	{t="input", default="mytarget", max=12},
}

rightclickmenues.animatedtiletrigger = {
	{t="checkbox", text="visible", default="true"},
	{},
	{t="regionselect", value="select tiles", region="region", default="region:0:0:1:1"},
	{},
	{t="linkbutton", value="link trigger", link="trigger"}
}

rightclickmenues.checkpoint = {
	{t="text", value="for players:"},
	{t="checkbox", text="all", default="true"},
	{t="checkbox", text="1", default="false"},
	{t="checkbox", text="2", default="false"},
	{t="checkbox", text="3", default="false"},
	{t="checkbox", text="4", default="false"},
	{t="checkbox", text="the rest", default="false"},
	{},
	{t="checkbox", text="visible", default="false"},
	{},
	{t="regionselect", value="select region", region="region", default="region:0:0:1:1"},
	{},
	{t="linkbutton", value="link trigger", link="trigger"}
}

rightclickmenues.portalent = {
	{t="text", value="type:"},
	{t="submenu", entries={"blue", "orange"}, default=1, width=6},
	{},
	{t="text", value="direction:"}, 
	{t="directionbuttons", left=true, right=true, down=true, up=true, default="up"}, 
	{},
	{t="text", value="portal id:"},
	{t="submenu", entries={"1", "2", "3", "4", "5", "6", "7", "8"}, default=1, width=1},
	{},
	{t="checkbox", text="default on", default="false"},
	{},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.pedestal = {
	{t="text", value="portal:"},
	{t="checkbox", text="blue", default="true"},
	{t="checkbox", text="orange", default="true"}
}

rightclickmenues.spring = {
	{t="text", value="type:"},
	{t="submenu", entries={"regular", "high"}, default=1, width=7, actualvalue=true}
}

rightclickmenues.groundlight = {
	{t="text", value="type:"},
	{t="submenu", entries={"vertical", "horizontal", "upright", "rightdown", "downleft", "leftup"}, default=2, width=10},
	{},
	{t="checkbox", text="default on", default="false"},
	{},
	{t="linkbutton", value="link power", link="power"}
}

rightclickmenues.redcoin = {
	{t="text", value="value:"},
	{t="scrollbar", min=1, max=5, step=1, default=1},
	{},
	{t="text", value="size:"},
	{t="submenu", entries={"small", "tallthin", "large"}, default=1, width=8, actualvalue=true},
}

rightclickmenues.axe = {
	{t="text", value="value:"},
	{t="scrollbar", min=1, max=5, step=1, default=1},
	{},
	{t="text", value="size:"},
	{t="submenu", entries={"small", "tallthin", "large"}, default=1, width=8, actualvalue=true},
}

rightclickmenues.pswitch = {
	{t="text", value="type:"},
	{t="submenu", entries={"blue", "grey"}, default=1, width=4, actualvalue=true},
	{},
	{t="checkbox", text="reuse:", default="false"},
	{t="checkbox", text="carry:", default="false"}
}

rightclickmenues.generatorwind = {
	{t="text", value="direction:"},
	{t="submenu", entries={"right", "left"}, default=1, width=5, actualvalue=true},
	{},
	{t="text", value="intensity:"},
	{t="scrollbar", min=1, max=10, step=1, default=6},
	{},
	{t="regionselect", value="select region", region="region", default="region:0:0:1:1"}
}

rightclickmenues.generatorbullet = {
	{t="text", value="direction:"},
	{t="checkbox", text="left", default="true"},
	{t="checkbox", text="right", default="false"},
	{t="checkbox", text="up", default="false"},
	{t="checkbox", text="down", default="false"},
	{},
	{t="regionselect", value="trigger region", region="region", default="region:0:0:1:1"},
}

rightclickmenues.generatorcheeps = {
	{t="regionselect", value="select region", region="region", default="region:0:0:1:1"}
}

rightclickmenues.generatorflames = {
	{t="regionselect", value="select region", region="region", default="region:0:0:1:1"}
}

function entity:init(img, x, y, width, height)
	self.image = img
	if type(x)~="number" then
		self.quad = x
	else
		self.quad = love.graphics.newQuad((x-1)*17, (y-1)*17, 16, 16, width, height)
	end
end

function entity:sett(i)
	for j = 1, #entitylist do
		if i == j then
			self.t = entitylist[j].t
		end
	end
end

entityquad_overloads = {} --this is for overloading whatever is done to entityquads because we can't use it normally
end end)()end;
do require("package").preload["entities.faithplate"] = (function() local package;return function(...)-- <pack entities.faithplate> --
faithplate = class("faithplate")

function faithplate:init(x, y, r)
	self.cox = x
	self.coy = y
	
	self.x = x-1
	self.y = y-1
	self.width = 2
	self.height = 0.125
	self.active = true
	self.moves = false
	self.category = 26
	
	self.power = true
	
	self.mask = {true}
	
	self.animationtimer = 1
	
	self.includetable = {"player", "box", "enemy"}
	
	self.xspeed = 0
	self.yspeed = 20
	
	self.input1state = "off"
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--Xspeed
	if #self.r > 0 then
		if string.sub(self.r[1], 1, 1) == "m" then
			self.xspeed = -tonumber(string.sub(self.r[1], 2))
		else
			self.xspeed = tonumber(self.r[1])
		end
		table.remove(self.r, 1)
	end
	--Yspeed
	if #self.r > 0 then
		self.yspeed = tonumber(self.r[1]) or 20
		table.remove(self.r, 1)
	end
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.power = false
		end
		table.remove(self.r, 1)
	end
	
	--determine rough direction
	if self.yspeed > math.abs(self.xspeed)*2 then
		self.dir = "up"
	elseif self.xspeed > 0 then
		self.dir = "right"
	else
		self.dir = "left"
	end
end

function faithplate:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		
		self.input1state = t
	end
end

function faithplate:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function faithplate:update(dt)
	if self.animationtimer < 1 then
		self.animationtimer = self.animationtimer + dt / faithplatetime
	end
	
	if self.power then
		local intable = checkrect(self.x+.5, self.y-0.125, 1, 0.125, self.includetable)
		
		for i = 1, #intable, 2 do
			if not objects[intable[i]][intable[i+1]].ignorefaithplates then
				if objects[intable[i]][intable[i+1]].speedy >= 0 then
					objects[intable[i]][intable[i+1]].speedy = -self.yspeed
					objects[intable[i]][intable[i+1]].speedx = self.xspeed
					
					objects[intable[i]][intable[i+1]].x = self.x+1-objects[intable[i]][intable[i+1]].width/2
					
					
					if objects[intable[i]][intable[i+1]].faithplate then
						objects[intable[i]][intable[i+1]]:faithplate(self.dir)
					end
					
					self.animationtimer = 0
				end
			end
		end
	end
end

function faithplate:draw()
	local quad = 2
	if self.power then
		quad = 1
	end
	
	love.graphics.setScissor(math.floor((self.cox-1-xscroll)*16*scale), (self.coy-yscroll-4)*16*scale, 32*scale, (2.5+2/16)*16*scale)
	
	love.graphics.setColor(unpack(background))
	love.graphics.rectangle("fill", math.floor((self.cox-1-xscroll)*16*scale), (self.coy-yscroll-1.5)*16*scale, 32*scale, 2*scale)
	love.graphics.setColor(255, 255, 255)
	

	if self.animationtimer < 1 then
		if self.dir == "right" then
			local rot = 0
			if self.animationtimer < 0.1 then
				rot = math.pi/4*(self.animationtimer/0.1)
			elseif self.animationtimer < 0.3 then
				rot = math.pi/4
			else
				rot = math.pi/4*(1 - (self.animationtimer-0.3)/0.7)
			end
				
			love.graphics.draw(faithplateplateimg, faithplatequad[quad], math.floor((self.cox+1-xscroll)*16*scale), (self.coy-yscroll-1.5)*16*scale, rot, scale, scale, 32)
		elseif self.dir == "left" then
			local rot = 0
			if self.animationtimer < 0.1 then
				rot = math.pi/4*(self.animationtimer/0.1)
			elseif self.animationtimer < 0.3 then
				rot = math.pi/4
			else
				rot = math.pi/4*(1 - (self.animationtimer-0.3)/0.7)
			end
			
			love.graphics.draw(faithplateplateimg, faithplatequad[quad], math.floor((self.cox-1-xscroll)*16*scale), (self.coy-yscroll-1.5)*16*scale, -rot, -scale, scale, 32)
		elseif self.dir == "up" then
			local ymod = 0
			if self.animationtimer < 0.1 then
				ymod = .5*(self.animationtimer/0.1)
			elseif self.animationtimer < 0.3 then
				ymod = .5
			else
				ymod = .5*(1 - (self.animationtimer-0.3)/0.7)
			end
			
			love.graphics.draw(faithplateplateimg, faithplatequad[quad], math.floor((self.cox-1-xscroll)*16*scale), (self.coy-yscroll-1.5-ymod)*16*scale, 0, scale, scale)
		end
	else
		if self.dir ~= "left" then
			love.graphics.draw(faithplateplateimg, faithplatequad[quad], math.floor((self.cox-1-xscroll)*16*scale), (self.coy-yscroll-1.5)*16*scale, 0, scale, scale)
		else
			love.graphics.draw(faithplateplateimg, faithplatequad[quad], math.floor((self.cox+1-xscroll)*16*scale), (self.coy-yscroll-1.5)*16*scale, 0, -scale, scale)
		end
	end
	
	love.graphics.setScissor()
end
end end)()end;
do require("package").preload["entities.vine"] = (function() local package;return function(...)-- <pack entities.vine> --
vine = class("vine")

function vine:init(x, y, t)
	self.cox = x
	self.coy = y
	self.t = t
	
	if self.t == "start" then
		self.limit = mapheight-5-15/16
	else
		self.limit = -1
		for y = self.coy-1, 1, -1 do
			if map[self.cox][y][2] and entitylist[map[self.cox][y][2]] and entitylist[map[self.cox][y][2]].t == "vinestop" then
				self.limit = y-1
				if tilequads[map[self.cox][y][1]]:getproperty("collision", self.cox, y) then
					self.hidetop = true
					self.limit = self.limit + 0.5
				end
				break
			end
		end
	end
	
	self.timer = 0
	
	self.width = 10/16
	self.height = 0
	
	self.x = x-0.5-self.width/2
	self.y = y-1
	
	self.moves = false
	self.active = true
	
	self.category = 18
	
	self.mask = {true}
	
	testtimer = love.timer.getTime()
	
	--IMAGE STUFF
	self.drawable = false
	
	--@DEV: This won't work when vines can go sideways.
	playsound("vine", self.x, self.y, 0, -vinespeed)
end

function vine:update(dt)
	if self.y > self.limit then
		self.y = self.y - vinespeed*dt
		if self.y <= self.limit then
			self.y = self.limit
		end
		self.height = math.max(0, self.coy-1-self.y)
	end
end

function vine:draw()
	local top = (self.limit-yscroll)*16*scale
	if not self.hidetop then
		top = (top) - 16*scale
	end
	local bottom = math.floor((self.coy-1.5-yscroll)*16*scale)
	
	if bottom > top then
		love.graphics.setScissor(0, top, width*16*scale, bottom-top)
		
		love.graphics.draw(vineimg, vinequad[spriteset][1], math.floor((self.x-xscroll-1/16-((1-self.width)/2))*16*scale), (self.y-yscroll-0.5-2/16)*16*scale, 0, scale, scale)
		for i = 1, math.ceil(self.height-14/16+.7) do
			love.graphics.draw(vineimg, vinequad[spriteset][2], math.floor((self.x-xscroll-1/16-((1-self.width)/2))*16*scale), (self.y-yscroll-0.5-2/16+i)*16*scale, 0, scale, scale)
		end
			
		
		love.graphics.setScissor()
	end
end
end end)()end;
do require("package").preload["entities.portalprojectile"] = (function() local package;return function(...)-- <pack entities.portalprojectile> --
portalprojectile = class("portalprojectile")

function portalprojectile:init(x, y, tx, ty, color, hit, payload, mirror, mirrored)
	self.x = x
	self.y = y
	
	self.startx = x
	self.starty = y
	self.endx = tx
	self.endy = ty
	
	--PHYSICS STUFF
	self.speedx = 0
	self.speedy = 0
	self.active = true
	self.moves = false
	self.width = 0
	self.height = 0
	self.category = 1
	self.mask = {true, false}
	self.gravity = 0
	
	--[[@NOTE:
		the physics object isn't dead center of the projectile but since we don't use the physics
		collision this doesn't matter, really -- we'd want to fix it for things like a bullet
	]]
	
	self.destroy = false
	
	self.color = color
	self.hit = hit
	self.payload = payload
	self.payloaddelivered = false
	
	self.mirror = mirror
	
	self.sinestart = math.random(math.pi*10)/10
	if mirrored then
		self.timer = 0
	else
		self.timer = 0.005
	end
	
	self.length = math.sqrt((tx-x)^2 + (ty-y)^2)
	self.time = self.length/portalprojectilespeed
	self.angle = math.atan2(tx-x, ty-y)
	
	self.particles = {}
	self.lastparticle = math.floor(self.timer/portalprojectileparticledelay)
end

function portalprojectile:update(dt)
	self.timer = self.timer + dt

	if self.timer < self.time then
		self.x = self.startx + (self.endx-self.startx)*(self.timer/self.time)
		self.y = self.starty + (self.endy-self.starty)*(self.timer/self.time)
		
		local currentparticle = math.floor(self.timer/portalprojectileparticledelay)
		
		for i = self.lastparticle+1, currentparticle do
			local t = i*portalprojectileparticledelay
			local tx = self.startx + (self.endx-self.startx)*(t/self.time)
			local ty = self.starty + (self.endy-self.starty)*(t/self.time)
			
			--INNER LINE
			local r, g, b = unpack(self.color)			
			table.insert(self.particles, portalprojectileparticle:new(tx, ty, {r, g, b}))
			
			--OUTER LINES
			local r, g, b = unpack(self.color)
			r, g, b = r/2, g/2, b/2
			
			--Sine
			local x = tx + math.sin(self.angle+math.pi/2)*(math.sin(t*portalprojectilesinemul+self.sinestart))*portalprojectilesinesize
			local y = ty + math.cos(self.angle+math.pi/2)*(math.sin(t*portalprojectilesinemul+self.sinestart))*portalprojectilesinesize
			
			table.insert(self.particles, portalprojectileparticle:new(x, y, {r, g, b}))
			
			--Sine
			local x = tx + math.sin(self.angle-math.pi/2)*(math.sin(t*portalprojectilesinemul+self.sinestart))*portalprojectilesinesize
			local y = ty + math.cos(self.angle-math.pi/2)*(math.sin(t*portalprojectilesinemul+self.sinestart))*portalprojectilesinesize
			
			table.insert(self.particles, portalprojectileparticle:new(x, y, {r, g, b}))
		end
			
		self.lastparticle = currentparticle
	end	
	
	--Update particles
	local delete = {}
	
	for i, v in pairs(self.particles) do
		if v:update(dt) == true then
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		table.remove(self.particles, v)
	end
	
	if (self.timer >= self.time and self.timer-dt < self.time) or (self.time <= 0.005 and self.payloaddelivered == false) then
		self:createportal()
		self.payloaddelivered = true
	end
	
	if self.timer >= self.time + portalprojectiledelay then
		return true
	end
	
	if self.destroy then
		return true
	end
	
	return false
end

function portalprojectile:draw()
	for i, v in pairs(self.particles) do
		v:draw()
	end
	
	if self.timer < self.time then
		love.graphics.setColor(unpack(self.color))
		
		love.graphics.draw(portalprojectileimg, math.floor((self.x-xscroll)*16*scale), math.floor((self.y-yscroll-0.5)*16*scale), 0, scale, scale, 6, 6)
	end
end

function portalprojectile:createportal()
	if self.mirror then
		local portal, i, cox, coy, side, tendency, x, y = unpack(self.payload)
		portaldelay[portal.number] = 0
		
		local angle
		if side == "up" or side == "down" then
			angle = -math.atan2(self.endx-self.startx, self.endy-self.starty)
		else
			angle = math.atan2(self.endx-self.startx, self.starty-self.endy)
		end
		
		shootportal(portal.number, i, self.endx, self.endy, angle, true)
	else
		portal.createportal(unpack(self.payload))
	end
	self.destroy = true
end
end end)()end;
do require("package").preload["entities.castlefire"] = (function() local package;return function(...)-- <pack entities.castlefire> --
castlefire = class("castlefire")

function castlefire:init(x, y, r)
	self.x = x
	self.y = y+1/16
	self.length = 6
	self.dir = "cw"
	self.quadi = 1
	self.child = {}
	self.delay = castlefiredelay
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--RANGE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.length = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	--DELAY
	if #self.r > 0 and self.r[1] ~= "link" then
		self.delay = tonumber(self.r[1])/10
		table.remove(self.r, 1)
	end
	--DIR
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.dir = "ccw"
			table.remove(self.r, 1)
		end
	end
	
	for i = 1, self.length do
		local temp = castlefirefire:new()
		table.insert(objects["castlefirefire"], temp)
		table.insert(self.child, temp)
	end
	self.angle = 0
	self.timer = 0
	self.timer2 = 0
	
	self:updatepos()
	self:updatequad()
end

function castlefire:update(dt)
	self.timer = self.timer + dt
	
	while self.timer > self.delay do
		self.timer = self.timer - self.delay
		if self.dir == "cw" then
			self.angle = self.angle + castlefireangleadd
			self.angle = math.mod(self.angle, 360)
		else
			self.angle = self.angle - castlefireangleadd
			while self.angle < 0 do
				self.angle = self.angle + 360
			end
		end
		
		self:updatepos()
	end
	
	self.timer2 = self.timer2 + dt
	while self.timer2 > castlefireanimationdelay do
		self.timer2 = self.timer2 - castlefireanimationdelay
		self.quadi = self.quadi + 1
		if self.quadi > 4 then
			self.quadi = 1
		end
		self:updatequad()
	end
end

function castlefire:updatepos()
	local x = self.x-.5
	local y = self.y-.5
	
	for i = 1, self.length do
		local xadd = math.cos(math.rad(self.angle))*(i-1)*0.5
		local yadd = math.sin(math.rad(self.angle))*(i-1)*0.5
		
		self.child[i].x = x+xadd-0.25
		self.child[i].y = y+yadd-0.25
	end
end

function castlefire:updatequad()	
	for i = 1, self.length do
		self.child[i].quad = fireballquad[self.quadi]
	end
end
end end)()end;
do require("package").preload["entities.laserdetector"] = (function() local package;return function(...)-- <pack entities.laserdetector> --
laserdetector = class("laserdetector")

function laserdetector:init(x, y, r)
	self.cox = x
	self.coy = y
	self.dir = "right"
	
	self.drawable = false
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	self.outtable = {}
	self.allowclear = true
	self.out = "off"
end

function laserdetector:update(dt)
	self.allowclear = true
	
	if self.out ~= self.prevout then
		self.prevout = self.out
		for i = 1, #self.outtable do
			if self.outtable[i][1].input then
				self.outtable[i][1]:input(self.out, self.outtable[i][2])
			end
		end
	end
end

function laserdetector:input(t)
	self.allowclear = false
	if t == "on" then
		self.out = "on"
	end
end

function laserdetector:draw()
	local rot = 0
	if self.dir == "down" then
		rot = math.pi/2
	elseif self.dir == "left" then
		rot = math.pi
	elseif self.dir == "up" then
		rot = math.pi*1.5
	end
	love.graphics.draw(laserdetectorimg, math.floor((self.cox-xscroll-0.5)*16*scale), (self.coy-yscroll-1)*16*scale, rot, scale, scale, 8, 8)
end

function laserdetector:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function laserdetector:clear()
	if self.allowclear then
		self.allowclear = false
		self.out = "off"
	end
end
end end)()end;
do require("package").preload["entities.door"] = (function() local package;return function(...)-- <pack entities.door> --
door = class("door")

function door:init(x, y, r)
	self.cox = x
	self.coy = y
	self.dir = "ver"
	
	self.open = false
	self.timer = 0
	
	self.input1state = "off"
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		self.open = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	--FORCE CLOSE (for the padawans)
	if #self.r > 0 and self.r[1] ~= "link" then
		self.forceclose = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	--PHYSICS STUFF
	if self.dir == "hor" then
		self.x = x-1
		self.y = y-12/16
		self.width = 32/16
		self.height = 8/16
	else
		self.x = x-12/16
		self.y = y-2
		self.width = 8/16
		self.height = 32/16
	end
	self.category = 25
	
	self.mask = {true}
		
	self.moves = false
	self.active = true
	
	self.drawable = false
	self.firstupdate = true
	
	self:closeopen(self.open)
	self.targetopen = self.open
end

function door:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function door:update(dt)	
	if self.targetopen ~= self.open then
		if self.forceclose then
			self:closeopen(self.targetopen)
		else
			if #checkrect(self.x, self.y, self.width, self.height, {"exclude", self}) == 0 then
				self:closeopen(self.targetopen)
			end
		end
	end
	
	if self.open then
		if self.timer < 1 then
			self.timer = self.timer + doorspeed*dt
			if self.timer >= 1 then
				self.timer = 1
				self.active = false
				updateranges()
			end
		end
	else
		if self.timer > 0 then
			self.timer = self.timer - doorspeed*dt
			if self.timer <= 0 then
				self.timer = 0
			end
		end
	end
end

function door:draw()
	local ymod = 0
	local rot = math.pi/2
	if self.timer > 0.5 then
		ymod = (self.timer - 0.5) * 2
	else
		rot = self.timer * math.pi
	end
	
	if self.dir == "hor" then
		love.graphics.draw(doorpieceimg, math.floor((self.x+14/16-xscroll-ymod)*16*scale), (self.y-yscroll-4/16)*16*scale, math.pi*.5, scale, scale, 4, 0)
		love.graphics.draw(doorpieceimg, math.floor((self.x+18/16-xscroll+ymod)*16*scale), (self.y-yscroll-4/16)*16*scale, math.pi*1.5, scale, scale, 4, 0)
		love.graphics.draw(doorcenterimg, math.floor((self.x+16/16-xscroll-ymod)*16*scale), (self.y-yscroll-4/16)*16*scale, math.pi*.5-rot, scale, scale, 4, 2)
		love.graphics.draw(doorcenterimg, math.floor((self.x+16/16-xscroll+ymod)*16*scale), (self.y-yscroll-4/16)*16*scale, math.pi*1.5-rot, scale, scale, 4, 2)
	else
		love.graphics.draw(doorpieceimg, math.floor((self.x+0.25-xscroll)*16*scale), (self.y-yscroll+6/16-ymod)*16*scale, math.pi, scale, scale, 4, 0)
		love.graphics.draw(doorpieceimg, math.floor((self.x+0.25-xscroll)*16*scale), (self.y-yscroll+10/16+ymod)*16*scale, 0, scale, scale, 4, 0)
		love.graphics.draw(doorcenterimg, math.floor((self.x+0.25-xscroll)*16*scale), (self.y-yscroll+8/16-ymod)*16*scale, rot, scale, scale, 4, 2)
		love.graphics.draw(doorcenterimg, math.floor((self.x+0.25-xscroll)*16*scale), (self.y-yscroll+8/16+ymod)*16*scale, math.pi+rot, scale, scale, 4, 2)
	end
end

function door:pushstuff()
	local col = checkrect(self.x, self.y, self.width, self.height, "all")
	for i = 1, #col, 2 do
		local v = objects[col[i]][col[i+1]]
		if self.dir == "ver" then
			if v.speedx >= 0 then
				v.x = self.x - v.width
			else
				v.x = self.x + self.width
			end
		elseif self.dir == "hor" then
			if v.speedy >= 0 then
				v.y = self.y - v.height
			else
				v.y = self.y + self.height
			end
		end
	end
end

function door:input(t, input)
	if input == "open" then
		if t == "on" and self.input1state == "off" then
			self.targetopen = not self.targetopen
		elseif t == "off" and self.input1state == "on" then
			self.targetopen = not self.targetopen
		elseif t == "toggle" then
			self.targetopen = not self.targetopen
		end
		
		self.input1state = t
	end
end

function door:closeopen(open)
	local prev = self.open
	self.open = open
	
	if self.open then
		if self.timer == 1 then
			self.active = false
		end
	else
		self.active = true
		self:pushstuff()
	end
	
	if self.open ~= prev then
		updateranges()
	end
end
end end)()end;
do require("package").preload["entities.generatorcheeps"] = (function() local package;return function(...)-- <pack entities.generatorcheeps> --
generatorcheeps = class("generatorcheeps")

function generatorcheeps:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	cheepgentable = {"right", 0}
	
	self.checktable = {}
	table.insert(self.checktable, "player")
	
	--Unpack the goods
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	
	--Stuff to come sometime
	--[[if #self.r > 0 and self.r[1] ~= "link" then
		bulletgentable[1] = self.r[1]
		table.remove(self.r, 1)
	end
	
	--Wind Intensity
	if #self.r > 0 and self.r[1] ~= "link" then
		bulletgentable[2] = self.r[1]		
		table.remove(self.r, 1)
	end]]
	
	--Region
	if #self.r > 0 then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
end

function generatorcheeps:update(dt)
	local col = checkrect(self.regionX, self.regionY, self.regionwidth, self.regionheight, self.checktable)
	if not levelfinished and #col > 0 then
		flyingfishtimer = flyingfishtimer + dt
		while flyingfishtimer > flyingfishdelay do
			flyingfishtimer = flyingfishtimer - flyingfishdelay
			flyingfishdelay = math.random(6, 20)/10
			
			local x, y = math.random(math.floor(xscroll), math.floor(xscroll)+width), mapheight
			local temp = enemy:new(x, y, "flyingfish")
			table.insert(objects["enemy"], temp)
			
			temp.speedx = objects["player"][1].speedx + math.random(10)-5
			
			if temp.speedx == 0 then
				temp.speedx = 1
			end
			
			if temp.speedx > 0 then
				temp.animationdirection = "left"
			else
				temp.animationdirection = "right"
			end
		end
	elseif #col == 0 then
	flyingfishtimer = 0
	end
end

function generatorcheeps:draw()
	
end
end end)()end;
do require("package").preload["entities.generatorbullet"] = (function() local package;return function(...)-- <pack entities.generatorbullet> --
generatorbullet = class("generatorbullet")

function generatorbullet:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.bulletgentable = {left = false, right = false, up = false, down = false}
	
	self.checktable = {}
	table.insert(self.checktable, "player")
	
	--Unpack the goods
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	
	--Directions, Firing Type
	if #self.r > 0 and self.r[1] ~= "link" then
		self.bulletgentable["left"] = true
		table.remove(self.r, 1)
	end
	
	if #self.r > 0 and self.r[1] ~= "link" then
		self.bulletgentable["right"] = true
		table.remove(self.r, 1)
	end
	
	if #self.r > 0 and self.r[1] ~= "link" then
		self.bulletgentable["up"] = true
		table.remove(self.r, 1)
	end
	
	if #self.r > 0 and self.r[1] ~= "link" then
		self.bulletgentable["down"] = true
		table.remove(self.r, 1)
	end
	
	--Region
	if #self.r > 0 then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
end

function generatorbullet:update(dt)
	local col = checkrect(self.regionX, self.regionY, self.regionwidth, self.regionheight, self.checktable)
	if not levelfinished and #col > 0 then
		bulletbilltimer = bulletbilltimer + dt
		while bulletbilltimer > bulletbilldelay do
			bulletbilltimer = bulletbilltimer - bulletbilldelay
			bulletbilldelay = math.random(5, 40)/10
			
			local nearestplayer = 1
			
			while objects["player"][nearestplayer] and objects["player"][nearestplayer].dead do
				nearestplayer = nearestplayer + 1
			end
			
			if objects["player"][nearestplayer] then
				local nearestplayerx = objects["player"][nearestplayer].x
				for i = 2, players do
					local v = objects["player"][i]
					if v.x > nearestplayerx and not v.dead then
						nearestplayer = i
					end
				end
			end
			
				local randomfactor = math.random(1, 4)
				if randomfactor == 1 and self.bulletgentable["left"] == true then
					table.insert(objects["enemy"], enemy:new(objects["player"][nearestplayer].x+24, math.random(self.regionY, self.regionY+self.regionheight), "bulletbill"))
				elseif randomfactor == 2 and self.bulletgentable["right"] == true then
					table.insert(objects["enemy"], enemy:new(objects["player"][nearestplayer].x-24, math.random(self.regionY, self.regionY+self.regionheight), "bulletbill"))
				elseif randomfactor == 3 and self.bulletgentable["up"] == true then
					table.insert(objects["enemy"], enemy:new(math.random(self.regionX, self.regionX+self.regionwidth), objects["player"][nearestplayer].y+16, "bulletbillvert"))
				elseif randomfactor == 4 and self.bulletgentable["down"] == true then
					table.insert(objects["enemy"], enemy:new(math.random(self.regionX, self.regionX+self.regionwidth), objects["player"][nearestplayer].y-16, "bulletbillvert"))
				else 
				bulletbilldelay = bulletbilltimer
				end
			playsound("bulletbill") --allowed global
			end
	elseif #col == 0 then
		bulletbilltimer = 0
	end
end

function generatorbullet:draw()
	
end
end end)()end;
do require("package").preload["entities.gel"] = (function() local package;return function(...)-- <pack entities.gel> --
gel = class("gel")

function gel:init(x, y, id)
	self.id = id
	
	--PHYSICS STUFF
	self.x = x-14/16
	self.y = y-12/16
	self.speedy = 0
	self.speedx = 0
	self.width = 12/16
	self.height = 12/16
	self.moves = true
	self.active = true
	self.category = 8
	self.mask = {false, false, true, true, true, true, true, true, false, false, true}
	self.gravity = 50
	self.autodelete = true
	self.timer = 0
	
	--IMAGE STUFF
	self.drawable = true
	self.quad = gelquad[math.random(3)]
	self.offsetX = 8
	self.offsetY = 0
	self.quadcenterX = 8
	self.quadcenterY = 8
	self.rotation = 0 --for portals
	if self.id == 1 then
		self.graphic = gel1img
	elseif self.id == 2 then
		self.graphic = gel2img
	elseif self.id == 3 then
		self.graphic = gel3img
	elseif self.id == 4 then
		self.graphic = gel4img
	elseif self.id == 5 then
		self.graphic = gel5img
	elseif self.id == 6 then
		self.graphic = gel6img
	end
	
	self.destroy = false
end

function gel:update(dt)
	--Funnels and fuck
	if self.funnel and not self.infunnel then
		self:enteredfunnel(true)
	end
	
	if self.infunnel and not self.funnel then
		self:enteredfunnel(false)
	end
	
	self.funnel = false

	if self.speedy > gelmaxspeed then
		self.speedy = gelmaxspeed
	end
	
	self.rotation = 0
	
	self.timer = self.timer + dt
	if self.timer >= gellifetime then
		return true
	end
	
	return self.destroy
end

function gel:leftcollide(a, b)
	if self:globalcollide(a, b) then
		return false
	end
	self.destroy = true
	if a == "tile" then
		local x, y = b.cox, b.coy
		
		if (inmap(x+1, y) and tilequads[map[x+1][y][1]]:getproperty("collision", x+1, y)) or (inmap(x, y) and tilequads[map[x][y][1]]:getproperty("collision", x, y) == false) then
			return
		end
		
		--see if adjsajcjet tile is a better fit
		if math.floor(self.y+self.height/2)+1 ~= y then
			if inmap(x, math.floor(self.y+self.height/2)+1) and tilequads[map[x][math.floor(self.y+self.height/2)+1][1]]:getproperty("collision", x, math.floor(self.y+self.height/2)+1) then
				y = math.floor(self.y+self.height/2)+1
			end
		end
		
		map[x][y]["gels"]["right"] = self.id
	elseif a == "lightbridgebody" and b.dir == "ver" then
		b.gels.right = self.id
	end
end

function gel:rightcollide(a, b)
	if self:globalcollide(a, b) then
		return false
	end
	self.destroy = true
	if a == "tile" then
		local x, y = b.cox, b.coy
		
		if (inmap(x-1, y) and tilequads[map[x-1][y][1]]:getproperty("collision", x-1, y)) or (inmap(x, y) and tilequads[map[x][y][1]]:getproperty("collision", x, y) == false) then
			return
		end
		
		--see if adjsajcjet tile is a better fit
		if math.floor(self.y+self.height/2)+1 ~= y then
			if inmap(x, math.floor(self.y+self.height/2)+1) and tilequads[map[x][math.floor(self.y+self.height/2)+1][1]]:getproperty("collision", x, math.floor(self.y+self.height/2)+1) then
				y = math.floor(self.y+self.height/2)+1
			end
		end
		
		map[x][y]["gels"]["left"] = self.id
	elseif a == "lightbridgebody" and b.dir == "ver" then
		b.gels.left = self.id
	end
end

function gel:floorcollide(a, b)
	if self:globalcollide(a, b) then
		return false
	end
	self.destroy = true
	if a == "tile" then
		local x, y = b.cox, b.coy
		
		if (inmap(x, y-1) and tilequads[map[x][y-1][1]]:getproperty("collision", x, y-1)) or (inmap(x, y) and tilequads[map[x][y][1]]:getproperty("collision", x, y) == false) then
			return
		end
		
		--see if adjsajcjet tile is a better fit
		if math.floor(self.x+self.width/2)+1 ~= x then
			if inmap(x, y) and tilequads[map[x][y][1]]:getproperty("collision", x, y) then
				x = math.floor(self.x+self.width/2)+1
			end
		end
		
		if inmap(x, y) and tilequads[map[x][y][1]]:getproperty("collision", x, y) then
			if map[x][y]["gels"]["top"] == self.id then
				if self.speedx > 0 then
					for cox = x+1, x+self.speedx*0.2 do
						if inmap(cox, y-1) and tilequads[map[cox][y][1]]:getproperty("collision", cox, y) == true and tilequads[map[cox][y-1][1]]:getproperty("collision", cox, y-1) == false then
							if map[cox][y]["gels"]["top"] ~= self.id then
								map[cox][y]["gels"]["top"] = self.id
								break
							end
						else
							break
						end
					end
				elseif self.speedx < 0 then
					for cox = x-1, x+self.speedx*0.2, -1 do
						if inmap(cox, y-1) and tilequads[map[cox][y][1]]:getproperty("collision", cox, y) and tilequads[map[cox][y-1][1]]:getproperty("collision", cox, y-1) == false then
							if map[cox][y]["gels"]["top"] ~= self.id then
								map[cox][y]["gels"]["top"] = self.id
								break
							end
						else
							break
						end
					end
				end
			else
				map[x][y]["gels"]["top"] = self.id
			end
		end
	elseif a == "lightbridgebody" and b.dir == "hor" then
		b.gels.top = self.id
	end
end

function gel:ceilcollide(a, b)
	if self:globalcollide(a, b) then
		return false
	end
	self.destroy = true
	if a == "tile" then
		local x, y = b.cox, b.coy
		if not inmap(x, y+1) or tilequads[map[x][y+1][1]]:getproperty("collision", x, y+1) == false then
			local x, y = b.cox, b.coy
			
			map[x][y]["gels"]["bottom"] = self.id
		end
	elseif a == "lightbridgebody" and b.dir == "hor" then
		b.gels.bottom = self.id
	end
end

function gel:globalcollide(a, b)
	if a == "tile" then
		local x, y = b.cox, b.coy
		if tilequads[map[x][y][1]]:getproperty("invisible", x, y) or tilequads[map[x][y][1]]:getproperty("grate", x, y) then
			return true
		end
	end
end

function gel:enteredfunnel(inside)
	if inside then
		self.infunnel = true
	else
		self.infunnel = false
		self.gravity = 50
	end
end
end end)()end;
do require("package").preload["entities.tile"] = (function() local package;return function(...)-- <pack entities.tile> --
tile = class("tile")

function tile:init(x, y, slant)
	self.cox = x+1
	self.coy = y+1
	self.x = x
	self.y = y
	self.speedx = 0
	self.speedy = 0
	self.width = 1
	self.height = 1
	self.active = true
	self.moves = false
	self.category = 2
	self.mask = {true}
end
end end)()end;
do require("package").preload["entities.enemyspawner"] = (function() local package;return function(...)-- <pack entities.enemyspawner> --
enemyspawner = class("enemyspawner")

function enemyspawner:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.r = {unpack(r)}
	self.xspeed = 0
	self.yspeed = 0
	self.enemytospawn = "goomba"
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--ENEMY NAME
	if #self.r > 0 and self.r[1] ~= "link" then
		self.enemytospawn = self.r[1]
		table.remove(self.r, 1)
	end
	
	--Xspeed
	if #self.r > 0 then
		if string.sub(self.r[1], 1, 1) == "m" then
			self.xspeed = -tonumber(string.sub(self.r[1], 2))
		else
			self.xspeed = tonumber(self.r[1])
		end
		table.remove(self.r, 1)
	end
	
	--Yspeed
	if #self.r > 0 then
		if string.sub(self.r[1], 1, 1) == "m" then
			self.yspeed = -tonumber(string.sub(self.r[1], 2))
		else
			self.yspeed = tonumber(self.r[1])
		end
		table.remove(self.r, 1)
	end
end

function enemyspawner:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function enemyspawner:input(t, input)
	if t ~= "off" then
		if enemiesdata[self.enemytospawn] then
			local temp = enemy:new(self.cox, self.coy, self.enemytospawn, {map[self.cox][self.coy][1], self.enemytospawn})
			table.insert(objects["enemy"], temp)
			temp.speedx = self.xspeed
			temp.speedy = self.yspeed
		end
	end
end
end end)()end;
do require("package").preload["entities.portalent"] = (function() local package;return function(...)-- <pack entities.portalent> --
portalent = class("portalent")

function portalent:init(x, y, r)
	self.cox = x
	self.coy = y
	self.x = x
	self.y = y
	
	self.dir = "up"
	self.portal = 1
	self.id = 1
	self.power = false

	--Input list
	self.input1state = "off"
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--TYPE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.portal = self.r[1]
		table.remove(self.r, 1)
	end
	
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	--ID
	if #self.r > 0 then
		self.id = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		self.power = self.r[1] == "true"
		table.remove(self.r, 1)
	end
	
	if not portals[self.id] then
		portals[self.id] = portal:new(self.id)
	end
	
	if self.power then
		self:trigger()
	end
end

function portalent:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function portalent:update(dt)
	
end

function portalent:draw()
	
end

function portalent:input(t, input)
	if input == "power" then
		local oldpower = self.power
		if t == "on" and self.input1state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		
		if self.power and not oldpower then
			self:trigger()
		elseif not self.power and oldpower then
			self:rem()
		end
		
		self.input1state = t
	end
end

function portalent:trigger()
	portals[self.id]:createportal(self.portal, self.x, self.y, self.dir, -1)
end

function portalent:rem()
	if portals[self.id]["x" .. self.portal] == self.x and portals[self.id]["y" .. self.portal] == self.y and portals[self.id]["facing" .. self.portal] == self.dir then
		portals[self.id]:removeportal(self.portal)
	else
		print("Portal wasn't removed because it isn't at this position")
	end
end
end end)()end;
do require("package").preload["entities.regiontrigger"] = (function() local package;return function(...)-- <pack entities.regiontrigger> --
regiontrigger = class("regiontrigger")

function regiontrigger:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	
	self.checktable = "all"
	self.outtable = {}
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	self.checktable = {}
	
	--TRIGGER ON PLAYER?
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			table.insert(self.checktable, "player")
		end			
		table.remove(self.r, 1)
	end
	
	--TRIGGER ON ENEMY?
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			table.insert(self.checktable, "enemy")
		end			
		table.remove(self.r, 1)
	end
	
	--REGION
	if #self.r > 0 then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
	
	self.out = "off"
end

function regiontrigger:update(dt)
	local col = checkrect(self.regionX, self.regionY, self.regionwidth, self.regionheight, self.checktable)
	
	if self.out == "off" and #col > 0 then
		self.out = "on"
		for i = 1, #self.outtable do
			if self.outtable[i][1].input then
				self.outtable[i][1]:input(self.out, self.outtable[i][2])
			end
		end
	elseif self.out == "on" and #col == 0 then
		self.out = "off"
		for i = 1, #self.outtable do
			if self.outtable[i][1].input then
				self.outtable[i][1]:input(self.out, self.outtable[i][2])
			end
		end
	end
end

function regiontrigger:draw()
	
end

function regiontrigger:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end
end end)()end;
do require("package").preload["entities.scaffold"] = (function() local package;return function(...)-- <pack entities.scaffold> --
scaffold = class("scaffold")

function scaffold:init(x, y, r)
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--DIRECTION
	if #self.r > 0 then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 then
		self.power = self.r[1] == "false"
		table.remove(self.r, 1)
	end
	
	--SIZE
	if #self.r > 0 then
		self.size = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--Distance
	if #self.r > 0 then
		self.distance = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--SPEED
	if #self.r > 0 then
		self.speed = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--Time1
	if #self.r > 0 then
		self.time1 = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--Time2
	if #self.r > 0 then
		self.time2 = tonumber(self.r[1])
		table.remove(self.r, 1)
	end

	--PHYSICS STUFF
	if (self.size ~= math.floor(self.size)) then
		self.x = x-0.25
	else
		self.x = x-1
	end	
	self.y = y-15/16
	self.startx = self.x
	self.starty = self.y+15/16
	self.speedx = 0 --!
	self.speedy = 0
	self.width = self.size
	self.height = 8/16
	self.moves = false
	self.active = true
	self.category = 15
	self.mask = {true}
	self.gravity = 0
	
	--IMAGE STUFF
	self.drawable = false
	
	self.rotation = 0
	
	self.timer = 0
	self.state = "start"
	self.input1state = "off"
end

function scaffold:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function scaffold:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		self.input1state = t
	end
end

function scaffold:update(dt)
	if not self.power then
		return false
	end
	
	if self.state == "start" then
		self.timer = self.timer + dt
		if self.timer > self.time1 then
			if self.dir == "right" then
				self.speedx = self.speed
			elseif self.dir == "left" then
				self.speedx = -self.speed
			elseif self.dir == "down" then
				self.speedy = self.speed
			elseif self.dir == "up" then
				self.speedy = -self.speed
			end
			self.state = "movingforth"
			self.timer = 0
		end
	elseif self.state == "end" then
		self.timer = self.timer + dt
		if self.timer > self.time2 then
			if self.dir == "right" then
				self.speedx = -self.speed
			elseif self.dir == "left" then
				self.speedx = self.speed
			elseif self.dir == "down" then
				self.speedy = -self.speed
			elseif self.dir == "up" then
				self.speedy = self.speed
			end
			self.state = "movingback"
			self.timer = 0
		end
	elseif self.state == "movingforth" or self.state == "movingback" then
		--moving part!
		local checktable = {"player", "enemy", "box"}
		local nextx, nexty = self.x + self.speedx*dt, self.y + self.speedy*dt

		for i, v in pairs(checktable) do
			for j, w in pairs(objects[v]) do
				if inrange(w.x, self.x-w.width, self.x+self.width) and inrange(w.y + w.height, self.y - 0.1, self.y + 0.1) then
					local newx = w.x + self.speedx*dt
					local newy = nexty - w.height
					if #checkrect(newx, newy, w.width, w.height, {"exclude", w, self}, true) == 0 then
						w.x = newx
						w.y = newy
						
						blay = newy+w.height
					end
				end
			end
		end
		
		self.x = nextx
		self.y = nexty
		
		if self.dir == "right" or self.dir == "left" then
			--check if end or start
			if self.state == "movingforth" then
				if self.dir == "right" then
					if self.x > self.startx + self.distance then
						self.state = "end"
						self.x = self.startx + self.distance
					end
				else
					if self.x < self.startx - self.distance then
						self.state = "end"
						self.x = self.startx - self.distance
					end
				end
			else
				if self.dir == "left" then
					if self.x > self.startx then
						self.state = "start"
						self.x = self.startx
					end
				else
					if self.x < self.startx then
						self.state = "start"
						self.x = self.startx
					end
				end
			end			
		else
			--check if end or start
			if self.state == "movingforth" then
				if self.dir == "down" then
					if self.y > self.starty + self.distance then
						self.state = "end"
						self.y = self.starty + self.distance
					end
				else
					if self.y < self.starty - self.distance then
						self.state = "end"
						self.y = self.starty - self.distance
					end
				end
			else
				if self.dir == "left" then
					if self.y > self.starty then
						self.state = "start"
						self.y = self.starty
					end
				else
					if self.y < self.starty then
						self.state = "start"
						self.y = self.starty
					end
				end
			end		
		end
	end
	
	return false
end

function scaffold:draw()
	for i = 1, self.size do
		if self.dir ~= "justright" then
			love.graphics.draw(scaffoldimg, math.floor((self.x+i-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
		else
			love.graphics.draw(platformbonusimg, math.floor((self.x+i-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
		end
	end
	
	if math.ceil(self.size) ~= self.size then --draw 1 more on the rightest
		love.graphics.draw(scaffoldimg, math.floor((self.x+self.size-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
	end
end

function scaffold:rightcollide(a, b)
	return false
end

function scaffold:leftcollide(a, b)
	return false
end

function scaffold:ceilcollide(a, b)
	if self.dir == "justright" then
		self.speedx = platformbonusspeed
	end
	return false
end

function scaffold:floorcollide(a, b)
	return false
end

function scaffold:passivecollide(a, b)
	return false
end
end end)()end;
do require("package").preload["entities.old_box"] = (function() local package;return function(...)-- <pack entities.old_box> --
box = class("box")

function box:init(x, y)
	--PHYSICS STUFF
	self.cox = x
	self.coy = y
	self.x = x-14/16
	self.y = y-12/16
	self.speedy = 0
	self.speedx = 0
	self.width = 12/16
	self.height = 12/16
	self.static = false
	self.active = true
	self.category = 9
	self.parent = nil
	self.portaloverride = true

	self.mask = {	true,
					false, false, false, false, false,
					false, true, false, true, true,
					false, false, true, false, false,
					true, true, false, false, true,
					false, true, true, false, false,
					true, false, true, true, true}
					
	self.emancipatecheck = true

	self.userect = adduserect(self.x, self.y, 12/16, 12/16, self)
	
	--IMAGE STUFF
	self.drawable = true
	self.graphic = boximg
	self.quad = boxquad[1]
	self.offsetX = 6
	self.offsetY = 2
	self.quadcenterX = 6
	self.quadcenterY = 6
	
	self.rotation = 0 --for portals
	self.gravitydirection = math.pi/2
	
	self.falling = false
	self.destroying = false
	self.outtable = {}
	self.portaledframe = false
end

function box:update(dt)
	local friction = boxfrictionair
	if self.falling == false then
		friction = boxfriction
	end
	
	--Funnels and fuck
	if self.funnel and not self.infunnel then
		self:enteredfunnel(true)
	end
	
	if self.infunnel and not self.funnel then
		self:enteredfunnel(false)
	end
	
	self.funnel = false
	
	if not self.pushed then
		if self.speedx > 0 then
			self.speedx = self.speedx - friction*dt
			if self.speedx < 0 then
				self.speedx = 0
			end
		else
			self.speedx = self.speedx + friction*dt
			if self.speedx > 0 then
				self.speedx = 0
			end
		end
	else
		self.pushed = false
	end
	
	self.rotation = 0
	
	if self.parent then
		local oldx = self.x
		local oldy = self.y
		
		self.x = self.parent.x+math.sin(-self.parent.pointingangle)*0.3
		self.y = self.parent.y-math.cos(-self.parent.pointingangle)*0.3
		
		if self.portaledframe == false then
			for h, u in pairs(objects["emancipationgrill"]) do
				if u.active then
					if u.dir == "hor" then
						if inrange(self.x+6/16, u.startx-1, u.endx, true) and inrange(u.y-14/16, oldy, self.y, true) then
							self:emancipate(h)
						end
					else
						if inrange(self.y+6/16, u.starty-1, u.endy, true) and inrange(u.x-14/16, oldx, self.x, true) then
							self:emancipate(h)
						end
					end
				end
			end
		end
		
		self.rotation = self.parent.rotation
	end
	
	self.userect.x = self.x
	self.userect.y = self.y

	--check if offscreen
	if self.y > mapheight+2 then
		self:destroy()
	end
	
	self.portaledframe = false
	
	if self.destroying then
		return true
	else
		return false
	end
end

function box:globalcollide(a, b, c, d, dir)
	if a == "platform" or a == "seesawplatform" then
		if dir == "floor" then
			if self.jumping and self.speedy < -jumpforce + 0.1 then
				return true
			end
		else
			return true
		end
	end
end

function box:ceilcollide(a, b)
	if self:globalcollide(a, b, c, d, "ceil") then
		return false
	end
end

function box:leftcollide(a, b)
	if self:globalcollide(a, b, c, d, "left") then
		return false
	end

	if a == "button" then
		self.y = b.y - self.height
		self.x = b.x + b.width - 0.01
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "player" then
		self.pushed = true
		return false
	end
end

function box:rightcollide(a, b)
	if self:globalcollide(a, b, c, d, "right") then
		return false
	end
	
	if a == "button" then
		self.y = b.y - self.height
		self.x = b.x - self.width+0.01
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "player" then
		self.pushed = true
		return false
	end
end

function box:floorcollide(a, b)
	if self:globalcollide(a, b, c, d, "floor") then
		return false
	end
	
	if self.falling then
		self.falling = false
	end
	
	if a == "enemy" and b.killedbyboxes then
		b:stomp()
		addpoints(200, self.x, self.y)
		playsound("stomp", self.x, self.y, self.speedx, self.speedy)
		self.falling = true
		self.speedy = -10
		return false
	end
end

function box:passivecollide(a, b)
	if self:globalcollide(a, b, c, d, "passive") then
		return false
	end
	
	if a == "player" then
		if self.x+self.width > b.x+b.width then
			self.x = b.x+b.width
		else
			self.x = b.x-self.width
		end
	end
end

function box:startfall()
	self.falling = true
end

function box:emancipate()
	if not self.destroying then
		local speedx, speedy = self.speedx, self.speedy
		if self.parent then
			self.parent:cubeemancipate()
			speedx = speedx + self.parent.speedx
			speedy = speedy + self.parent.speedy
		end
		table.insert(objects["emancipateanimation"], emancipateanimation:new(self.x, self.y, self.width, self.height, self.graphic, self.quad, speedx, speedy, self.rotation, self.offsetX, self.offsetY, self.quadcenterX, self.quadcenterY))
		self:destroy()
	end
end

function box:destroy()
	self.userect.delete = true
	self.destroying = true
	
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input("toggle", self.outtable[i][2])
		end
	end
end

function box:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function box:used(id)
	self.parent = objects["player"][id]
	self.active = false
	objects["player"][id]:pickupbox(self)
end

function box:dropped()
	self.parent = nil
	self.active = true
end

function box:portaled()
	self.portaledframe = true
end

function box:enteredfunnel(inside)
	if inside then
		self.infunnel = true
	else
		self.infunnel = false
		self.gravity = nil
	end
end

function box:faithplate(dir)
	self.falling = true
end

function box:onbutton(s)
	if s then
		self.quad = boxquad[2]
	else
		self.quad = boxquad[1]
	end
end
end end)()end;
do require("package").preload["entities.andgate"] = (function() local package;return function(...)-- <pack entities.andgate> --
andgate = class("andgate")

function andgate:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.visible = false
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	self.outtable = {}
	self.inputstate = {}
	self.outputstate = "off"
end

function andgate:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
					self.inputstate[tonumber(self.r[2])] = "off"
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function andgate:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function andgate:update(dt)
	if self.initial then
		self.initial = false
	end
end

function andgate:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(andgateimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function andgate:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end

function andgate:input(t, input)
	if tonumber(input) then
		if t == "toggle" then
			if self.inputstate[tonumber(input)] == "on" then
				self.inputstate[tonumber(input)] = "off"
			else
				self.inputstate[tonumber(input)] = "on"
			end
		else
			self.inputstate[tonumber(input)] = t
		end
		
		local pass = "on"
		for i, v in ipairs(self.inputstate) do
			if v ~= "on" then
				pass = "off"
			end
		end
		
		if self.outputstate ~= pass then
			self:out(pass)
			self.outputstate = pass
		end
	end
end
end end)()end;
do require("package").preload["entities.platformspawner"] = (function() local package;return function(...)-- <pack entities.platformspawner> --
platformspawner = class("platformspawner")

function platformspawner:init(x, y, r)
	self.x = x
	self.y = y
	self.dir = "up"
	self.timer = 0
	self.size = 3
	self.speed = platformjustspeed
	self.spawndelay = platformspawndelay
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIRECTION
	if #self.r > 0 then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	--SIZE
	if #self.r > 0 then
		self.size = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--SPEED
	if #self.r > 0 then
		self.speed = self.r[1]
		table.remove(self.r, 1)
	end
	
	--SPAWNDELAY
	if #self.r > 0 then
		self.spawndelay = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
end

function platformspawner:update(dt)
	self.timer = self.timer + dt
	if self.timer > self.spawndelay then
		if self.dir == "up" then
			table.insert(objects["platform"], platform:new(self.x, self.y+1, {0, 0, self.size, 0, 0, 0, self.speed}, "justup"))
		else
			table.insert(objects["platform"], platform:new(self.x, self.y-0.5, {0, 0, self.size, 0, 0, 0, self.speed}, "justdown"))
		end
		
		self.timer = self.timer - self.spawndelay
	end
	
	if self.x < xscroll - .5 then
		return true
	end
end
end end)()end;
do require("package").preload["entities.laser"] = (function() local package;return function(...)-- <pack entities.laser> --
laser = class("laser")

function laser:init(x, y, r)
	self.cox = x
	self.coy = y
	
	self.blocked = false
	self.lasertable = {}
	self.outtable = {}
	
	self.framestart = 0
	
	self.power = true
	self.input1state = "off"
	
	self.dir = "right"
	
	--Input list
	self.input1state = "off"
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.power = false
		end
		table.remove(self.r, 1)
	end
end

function laser:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function laser:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		self:updaterange()
		
		self.input1state = t
	end
end

function laser:update(dt)
	if self.framestart < 2 then
		self.framestart = self.framestart + 1
		return
	end
	local x, y, width, height
	local col = false
	
	for i = 1, #self.lasertable, 5 do
		if self.lasertable[i] == "left" then
			
			x = self.lasertable[i+1]-1+self.lasertable[i+3]
			y = self.lasertable[i+2]-0.5625
			width = -self.lasertable[i+3]+1
			height = 2/16
		elseif self.lasertable[i] == "right" then
			
			x = self.lasertable[i+1]-1
			y = self.lasertable[i+2]-0.5625
			width = self.lasertable[i+3]+1
			height = 2/16
		elseif self.lasertable[i] == "up" then
			
			x = self.lasertable[i+1]-0.5625
			y = self.lasertable[i+2]+self.lasertable[i+4]-1
			width = 2/16
			height = -self.lasertable[i+4]+1
			
		elseif self.lasertable[i] == "down" then
			
			x = self.lasertable[i+1]-0.5625
			y = self.lasertable[i+2]-1
			width = 2/16
			height = self.lasertable[i+4]+1
		end
		
		local rectcol = checkrect(x, y, width, height, {"player", "box", "enemy"})
		
		if #rectcol > 0 then
			col = true
			self.blocked = true
		
			local obj
			if self.lasertable[i] == "right" or self.lasertable[i] == "down" then
				local smallestx = mapwidth+1
				local smallesti
			
				for j = 1, #rectcol, 2 do
					if objects[rectcol[j]][rectcol[j+1]].x < smallestx then
						smallestx = objects[rectcol[j]][rectcol[j+1]].x
						smallesti = j
					end
				end
				obj = objects[rectcol[smallesti]][rectcol[smallesti+1]]
			else
				local biggestx = -1
				local biggesti
			
				for j = 1, #rectcol, 2 do
					if objects[rectcol[j]][rectcol[j+1]].x > biggestx then
						biggestx = objects[rectcol[j]][rectcol[j+1]].x
						biggesti = j
					end
				end
				
				obj = objects[rectcol[biggesti]][rectcol[biggesti+1]]
			end
			
			local newtable = {}
			for k = 1, i*5 do
				table.insert(newtable, self.lasertable[k])
			end
			
			if self.lasertable[i] == "left" then
				if obj.laser then
					obj:laser("right")
				end
				
				newtable[i+3] = obj.x - newtable[i+1] + obj.width+1
			elseif self.lasertable[i] == "right" then
				if obj.laser then
					obj:laser("left")
				end
				
				newtable[i+3] = obj.x - newtable[i+1]
			elseif self.lasertable[i] == "up" then
				if obj.laser then
					obj:laser("down")
				end
				
				newtable[i+4] = obj.y - newtable[i+2]+1
			elseif self.lasertable[i] == "down" then
				if obj.laser then
					obj:laser("up")
				end
				
				
				newtable[i+4] = obj.y - newtable[i+2] + 1 - obj.height+1-1
			end
			
			self.lasertable = newtable
			
			self:updateoutputs()
			break
		end
	end
	
	self:updateoutputs()
	
	if col == false and self.blocked == true then
		self.blocked = false
		self:updaterange()
	end
end

function laser:updateoutputs()
	for i = 1, #self.lasertable, 5 do
		if self.lasertable[i] == "left" then
			for x = self.lasertable[i+1], math.ceil(self.lasertable[i+1]+self.lasertable[i+3])-1, -1 do
				local y = self.lasertable[i+2]
				self:checktile(x, y, "left")
			end
		elseif self.lasertable[i] == "right" then
			for x = self.lasertable[i+1], math.floor(self.lasertable[i+1]+self.lasertable[i+3])+1 do
				local y = self.lasertable[i+2]
				self:checktile(x, y, "right")
			end
		elseif self.lasertable[i] == "up" then
			for y = self.lasertable[i+2], self.lasertable[i+2]+self.lasertable[i+4]-1, -1 do
				local x = self.lasertable[i+1]
				self:checktile(x, y, "up")
			end
		elseif self.lasertable[i] == "down" then
			for y = self.lasertable[i+2], self.lasertable[i+2]+self.lasertable[i+4]+1 do
				local x = self.lasertable[i+1]
				self:checktile(x, y, "down")
			end
		end
	end
	
	for i, v in pairs(self.outtable) do
		v:clear()
	end
end

function laser:checktile(x, y, dir)
	--check if block is a detector
	for i, v in pairs(objects["laserdetector"]) do
		--if (dir == "left" and v.dir == "right") or (dir == "right" and v.dir == "left") or (dir == "up" and v.dir == "down") or (dir == "down" and v.dir == "up") then
			if x == v.cox and y == v.coy and (v.cox ~= self.r[4] or v.coy ~= self.r[5]) then
				table.insert(self.outtable, v)
				v:input("on")
			end
		--end
	end
end

function laser:draw()	
	for i = 1, #self.lasertable, 5 do
		if self.lasertable[i] == "left" then
			if self.lasertable[i+3] < 1 then
				love.graphics.setScissor(math.floor((self.lasertable[i+1]+self.lasertable[i+3]-xscroll-1)*16*scale), (self.lasertable[i+2]-yscroll-1.5)*16*scale, (-self.lasertable[i+3]+1)*16*scale, 16*scale)
				local b = 0
				for x = self.lasertable[i+1], math.floor(self.lasertable[i+1]+self.lasertable[i+3])-1, -1 do
					b = b + 1
					love.graphics.draw(laserimg, math.floor((x-xscroll-1)*16*scale), (self.lasertable[i+2]-yscroll-20/16)*16*scale, 0, scale, scale)
				end
			end
		elseif self.lasertable[i] == "right" then
			if self.lasertable[i+3] > -1 then
				love.graphics.setScissor(math.floor((self.lasertable[i+1]-xscroll-1)*16*scale), (self.lasertable[i+2]-yscroll-1.5)*16*scale, (self.lasertable[i+3]+1)*16*scale, 16*scale)
					local b = 0
				for x = self.lasertable[i+1], math.ceil(self.lasertable[i+1]+self.lasertable[i+3])+1 do
					b = b + 1
					love.graphics.draw(laserimg, math.floor((x-xscroll-1)*16*scale), (self.lasertable[i+2]-yscroll-20/16)*16*scale, 0, scale, scale)
				end
			end
		elseif self.lasertable[i] == "up" then
			for y = self.lasertable[i+2], self.lasertable[i+2]+self.lasertable[i+4], -1 do
				love.graphics.draw(laserimg, math.floor((self.lasertable[i+1]-xscroll-5/16)*16*scale), (y-yscroll-1)*16*scale, math.pi/2, scale, scale, 8, 1)
			end
		elseif self.lasertable[i] == "down" then
			for y = self.lasertable[i+2], self.lasertable[i+2]+self.lasertable[i+4] do
				love.graphics.draw(laserimg, math.floor((self.lasertable[i+1]-xscroll-5/16)*16*scale), (y-yscroll-1)*16*scale, math.pi/2, scale, scale, 8, 1)
			end
		end
		
		love.graphics.setScissor()
	end
	
	local rot = 0
	if self.dir == "up" then
		rot = math.pi*1.5
	elseif self.dir == "down" then
		rot = math.pi*0.5
	elseif self.dir == "left" then
		rot = math.pi
	end

	love.graphics.draw(lasersideimg, math.floor((self.cox-xscroll-.5)*16*scale), (self.coy-yscroll-1)*16*scale, rot, scale, scale, 8, 8)
end

function laser:updaterange()
	self.lasertable = {}
	if self.power == false then
		self:updateoutputs()
		return
	end
	
	local dir = self.dir
	local startx, starty = self.cox, self.coy
	local rangex, rangey = 0, 0
	local x, y = self.cox, self.coy
	
	local firstcheck = true
	local quit = false
	while x >= 1 and x <= mapwidth and y >= 1 and y <= mapheight and (tilequads[map[x][y][1]]:getproperty("collision", x, y) == false or tilequads[map[x][y][1]]:getproperty("grate", x, y)) and (x ~= startx or y ~= starty or dir ~= self.dir or firstcheck == true) and quit == false do
		firstcheck = false
		
		if dir == "right" then
			x = x + 1
			rangex = rangex + 1
		elseif dir == "left" then
			x = x - 1
			rangex = rangex - 1
		elseif dir == "up" then
			y = y - 1
			rangey = rangey - 1
		elseif dir == "down" then
			y = y + 1
			rangey = rangey + 1
		end
		
		--check if current block is a portal
		local opp = "left"
		if dir == "left" then
			opp = "right"
		elseif dir == "up" then
			opp = "down"
		elseif dir == "down" then
			opp = "up"
		end
		
		local portalx, portaly, portalfacing, infacing = getPortal(x, y, opp)
		
		if portalx ~= false and ((dir == "left" and infacing == "right") or (dir == "right" and infacing == "left") or (dir == "up" and infacing == "down") or (dir == "down" and infacing == "up")) then
			
			if dir == "right" then
				x = x - 1
				rangex = rangex - 1
			elseif dir == "left" then
				x = x + 1
				rangex = rangex + 1
			elseif dir == "up" then
				y = y + 1
				rangey = rangey + 1
			elseif dir == "down" then
				y = y - 1
				rangey = rangey - 1
			end
			
			table.insert(self.lasertable, dir)
			table.insert(self.lasertable, x-rangex)
			table.insert(self.lasertable, y-rangey)
			table.insert(self.lasertable, rangex)
			table.insert(self.lasertable, rangey)
			
			x, y = portalx, portaly
			dir = portalfacing
			
			rangex, rangey = 0, 0
			
			if dir == "right" then
				x = portalx + 1
			elseif dir == "left" then
				x = portalx - 1
				rangex = 0
			elseif dir == "up" then
				y = portaly - 1
			elseif dir == "down" then
				y = portaly + 1
			end
		end
		
		--doors
		for i, v in pairs(objects["door"]) do
			if v.active then
				if v.dir == "ver" then
					if x == v.cox and (y == v.coy or y == v.coy-1) then
						quit = true
					end
				elseif v.dir == "hor" then
					if y == v.coy and (x == v.cox or x == v.cox+1) then
						quit = true
					end
				end
			end
		end
	end
		
	if dir == "right" then
		x = x - 1
		rangex = rangex - 1
	elseif dir == "left" then
		x = x + 1
		rangex = rangex + 1
	elseif dir == "up" then
		y = y + 1
		rangey = rangey + 1
	elseif dir == "down" then
		y = y - 1
		rangey = rangey - 1
	end
	
	table.insert(self.lasertable, dir)
	table.insert(self.lasertable, x-rangex)
	table.insert(self.lasertable, y-rangey)
	table.insert(self.lasertable, rangex)
	table.insert(self.lasertable, rangey)
	
	self:update()
end
end end)()end;
do require("package").preload["entities.animatedtiletrigger"] = (function() local package;return function(...)-- <pack entities.animatedtiletrigger> --
animatedtiletrigger = class("animatedtiletrigger")

function animatedtiletrigger:init(x, y, r)
	self.x = x
	self.y = y
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	self.visible = true
	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(	self.r, 1)
	end
	
	--REGION
	if #self.r > 0 then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
end

function animatedtiletrigger:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function animatedtiletrigger:update()

end

function animatedtiletrigger:draw()	
	if self.visible then
		love.graphics.draw(animatedtiletriggerimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function animatedtiletrigger:input(t, input)
	for x = self.regionX+1, self.regionX + self.regionwidth do
		for y = self.regionY+1, self.regionY + self.regionheight do
			if animatedtimers[x][y] then
				animatedtimers[x][y]:input(t)
			end
		end
	end
end
end end)()end;
do require("package").preload["entities.castlefirefire"] = (function() local package;return function(...)-- <pack entities.castlefirefire> --
castlefirefire = class("castlefirefire")

function castlefirefire:init()
	--PHYSICS STUFF
	self.y = 0
	self.x = 0
	self.width = 8/16
	self.height = 8/16
	self.active = true
	self.moves = false
	self.category = 23
	
	self.kills = true
	
	self.mask = {	true,
					true, false, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true}
	
	--IMAGE STUFF
	self.drawable = true
	self.graphic = fireballimg
	self.quad = fireballquad[1]
	self.offsetX = 4
	self.offsetY = 4
	self.quadcenterX = 4
	self.quadcenterY = 4
end
end end)()end;
do require("package").preload["entities.noportal"] = (function() local package;return function(...)-- <pack entities.noportal> --
noportal = class("noportal")

function noportal:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	
	self.checktable = "all"
	self.outtable = {}
	self.input1state = "off"
	self.power = true
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	self.checktable = {}
	
	--TRIGGER ON PROJECTILE?
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			table.insert(self.checktable, "portalprojectile")
		end			
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		self.power = self.r[1] == "true"
		table.remove(self.r, 1)
	end
	
	--REGION
	if #self.r > 0 and self.r[1] ~= "link" then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
	
	self.out = "off"
end

function noportal:link()
	print("DEBUG: noportal was linked")
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function noportal:input(t, input)
	--print("contact")
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			--print("the first one")
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			--print("the second one")
			self.power = not self.power
		elseif t == "toggle" then
			--print("the last one")
			self.power = not self.power
		end
		
		self.input1state = t
	else
		--print("what")
	end
end

function noportal:update(dt)
	if self.power then
		local col = checkrect(self.regionX, self.regionY, self.regionwidth, self.regionheight, self.checktable)
		
		if self.out == "off" and #col > 0 then
			for i=1,#col,2 do
				objects[col[i]][col[i+1]].destroy = true
				--print("DEBUG: caught item", i, col[i], col[i+1])
				--v.delete = true
			end
			self.out = "on"
			for i = 1, #self.outtable do
				if self.outtable[i][1].input then
					self.outtable[i][1]:input(self.out, self.outtable[i][2])
				end
			end
		end
	end
	if self.out == "on" then
		self.out = "off"
		for i = 1, #self.outtable do
			if self.outtable[i][1].input then
				self.outtable[i][1]:input(self.out, self.outtable[i][2])
			end
		end
	end
end

function noportal:draw()
	
end

function noportal:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end
end end)()end;
do require("package").preload["entities.redcoin"] = (function() local package;return function(...)-- <pack entities.redcoin> --
redcoin = class("redcoin")

function redcoin:init(x, y, r)
	self.cox = x
	self.coy = y

	self.x = x-1
	self.y = y-1
	self.width = 1
	self.height = 1
	self.moves = false
	self.active = true
	self.category = 6
	self.mask = {true}
	self.drawable = true
	self.quad = 1
	self.rotation = 0
	self.timer = 0
	self.falling = false
	self.destroy = false
	self.r = {unpack(r)}

	table.remove(self.r, 1)
	table.remove(self.r, 1)
	if #self.r > 0 and self.r[1] ~= "link" then
		self.value = self.r[1]
		table.remove(self.r, 1)
	end
	
	if #self.r > 0 and self.r[1] ~= "link" then
		self.size = self.r[1]
		table.remove(self.r, 1)
	end
	
	if self.size == "tallthin" then
		self.height = 2
		self.y = self.y-1
	elseif self.size == "large" then
		self.width = 2
		self.height = 2
		self.x = self.x-1
		self.y = self.y-1
	end
	if gameplaytype ~= "oddjob" then -- Make it not exist outside gameplaytype.
	self.destroy = true
	end
end

function redcoin:update(dt)
	-- returning in the update method signals the object handler to destroy us
	--[[if redcoincollected[self.value] >= 1 then  -- The why do you have dupes checker.
	self.destroy = true
	return true
	end]]
	if self.destroy then
	return true
	end
end

function redcoin:collect(ply)
	-- ply is a reference to the player that collected us, we can use that later
	redcoincollected[self.value] = 1
	redcoincount = redcoincount + 1
	if redcoincount == oddjobquotas[1] then
		playsound("redcoin5", self.x, self.y)
	else
		playsound("redcoin1", self.x, self.y)
	end
	self.active = false
	self.drawable = false
	self.destroy = true
end

function redcoin:draw()
	if self.size == "tallthin" then
		love.graphics.draw(redcointallimg, redcointallquads[redcoinframe], math.floor((self.x-xscroll)*16*scale), ((self.y-yscroll)*16*scale)-8*scale, 0, scale, scale)
	elseif self.size == "large" then
		love.graphics.draw(redcoinbigimg, redcoinbigquads[redcoinframe], math.floor((self.x-xscroll)*16*scale), ((self.y-yscroll)*16*scale)-8*scale, 0, scale, scale)
	else
		love.graphics.draw(redcoinimg, redcoinquads[redcoinframe], math.floor((self.x-xscroll)*16*scale), ((self.y-yscroll)*16*scale)-8*scale, 0, scale, scale)
	end
end
end end)()end;
do require("package").preload["entities.squarewave"] = (function() local package;return function(...)-- <pack entities.squarewave> --
squarewave = class("squarewave")

function squarewave:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.r = r
	
	self.outtable = {}
	
	self.timer = 0
	self.time1 = 1
	self.time2 = 1
	self.visible = false
	self.initial = true
	
	--Input list
	self.input1state = "off"
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--TIME1
	if #self.r > 0 and self.r[1] ~= "link" then
		self.time1 = self.r[1]
		table.remove(self.r, 1)
	end
	--TIME2
	if #self.r > 0 and self.r[1] ~= "link" then
		self.time2 = self.r[1]
		table.remove(self.r, 1)
	end
	--START
	if #self.r > 0 and self.r[1] ~= "link" then
		self.timer = self.r[1]*(self.time1+self.time2)
		table.remove(self.r, 1)
	end
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
end

function squarewave:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function squarewave:update(dt)
	if self.initial then
		self.initial = false
		if self.timer > self.time1 then
			self:out("on")
		end
	end
	
	self.timer = self.timer + dt
	if self.timer - dt <= self.time1 and self.timer > self.time1 then
		self:out("on")
	end
	
	if self.timer - dt <= self.time2+self.time1 and self.timer > self.time2+self.time1 then
		self:out("off")
		self.timer = self.timer - self.time2-self.time1
	end
end

function squarewave:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(squarewaveimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function squarewave:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end
end end)()end;
do require("package").preload["entities.lightbridge"] = (function() local package;return function(...)-- <pack entities.lightbridge> --
lightbridge = class("lightbridge")

function lightbridge:init(x, y, r)
	self.cox = x
	self.coy = y
	self.dir = "right"
	self.r = {unpack(r)}
	
	self.childtable = {}
	
	self.power = true
	self.glowa = 1
	self.glowtimer = 0
	self.input1state = "off"
	self.children = 0
	
	self.dir = "right"
	
	--Input list
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.power = false
		end
		table.remove(self.r, 1)
	end
	
	self:updaterange()
end

function lightbridge:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function lightbridge:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		self:updaterange()
		
		self.input1state = t
	end
end

function lightbridge:update(dt)
	self.glowtimer = self.glowtimer + dt*2
	
end

function lightbridge:getglowa(offset)
	return math.sin(self.glowtimer-offset*0.5)*.25+.75
end

function lightbridge:draw()
	local rot = 0
	if self.dir == "up" then
		rot = math.pi*1.5
	elseif self.dir == "down" then
		rot = math.pi*0.5
	elseif self.dir == "left" then
		rot = math.pi
	end

	love.graphics.draw(lightbridgesideimg, math.floor((self.cox-xscroll-.5)*16*scale), (self.coy-yscroll-1)*16*scale, rot, scale, scale, 8, 8)
end

function lightbridge:updaterange()
	--save old gel values
	local gels = {}
	
	for i, v in pairs(self.childtable) do
		if v.gels.top then
			table.insert(gels, {x=v.cox, y=v.coy, dir="top", i=v.gels.top})
		elseif v.gels.left then
			table.insert(gels, {x=v.cox, y=v.coy, dir="left", i=v.gels.left})
		elseif v.gels.right then
			table.insert(gels, {x=v.cox, y=v.coy, dir="right", i=v.gels.right})
		elseif v.gels.bottom then
			table.insert(gels, {x=v.cox, y=v.coy, dir="bottom", i=v.gels.bottom})
		end
	end	
	
	for i, v in pairs(self.childtable) do
		v.destroy = true
	end
	self.childtable = {}
	
	if self.power == false then
		return
	end
	
	local dir = self.dir
	local startx, starty = self.cox, self.coy
	local x, y = self.cox, self.coy
	self.children = 0
	
	local firstcheck = true
	local quit = false
	while x >= 1 and x <= mapwidth and y >= 1 and y <= mapheight and (tilequads[map[x][y][1]]:getproperty("collision", x, y) == false or tilequads[map[x][y][1]]:getproperty("grate", x, y)) and (x ~= startx or y ~= starty or dir ~= self.dir or firstcheck == true) and quit == false do
		firstcheck = false
		
		self.children = self.children + 1
		if dir == "right" then
			x = x + 1
			table.insert(objects["lightbridgebody"], lightbridgebody:new(self, x-1, y, "hor", self.children))
		elseif dir == "left" then
			x = x - 1
			table.insert(objects["lightbridgebody"], lightbridgebody:new(self, x+1, y, "hor", self.children))
		elseif dir == "up" then
			y = y - 1
			table.insert(objects["lightbridgebody"], lightbridgebody:new(self, x, y+1, "ver", self.children))
		elseif dir == "down" then
			y = y + 1
			table.insert(objects["lightbridgebody"], lightbridgebody:new(self, x, y-1, "ver", self.children))
		end
		
		--check if current block is a portal
		local opp = "left"
		if dir == "left" then
			opp = "right"
		elseif dir == "up" then
			opp = "down"
		elseif dir == "down" then
			opp = "up"
		end
		
		local portalx, portaly, portalfacing, infacing = getPortal(x, y, opp)
		if portalx ~= false and ((dir == "left" and infacing == "right") or (dir == "right" and infacing == "left") or (dir == "up" and infacing == "down") or (dir == "down" and infacing == "up")) then
			x, y = portalx, portaly
			dir = portalfacing
			
			if dir == "right" then
				x = x + 1
			elseif dir == "left" then
				x = x - 1
			elseif dir == "up" then
				y = y - 1
			elseif dir == "down" then
				y = y + 1
			end
		end
		
		--doors
		for i, v in pairs(objects["door"]) do
			if v.active then
				if v.dir == "ver" then
					if x == v.cox and (y == v.coy or y == v.coy-1) then
						quit = true
					end
				elseif v.dir == "hor" then
					if y == v.coy and (x == v.cox or x == v.cox+1) then
						quit = true
					end
				end
			end
		end
	end
	
	--Restore gels! yay!
	--crosscheck childtable with gels to see any matching shit
	for j, w in pairs(self.childtable) do
		for i, v in pairs(gels) do
			if v.x == w.cox and v.y == w.coy then
				if v.dir == "left" or v.dir == "right" then
					if w.dir == "ver" then
						w.gels[v.dir] = v.i
					end
				else
					if w.dir == "hor" then
						w.gels[v.dir] = v.i
					end
				end
			end
		end
	end
end

function lightbridge:addChild(t)
	table.insert(self.childtable, t)
end
end end)()end;
do require("package").preload["entities.gamemode"] = (function() local package;return function(...)-- <pack entities.gamemode> --
gamemode = class('gamemode')

function gamemode:init(worlds)
	self.worlds = worlds --all the levels/worlds this is responsible for managing
	self.rules = {} --a basic set of rules to enforce every think frame
end

local magictimeoffset = 8 --I guess this is the expected length of the hurry up jingle

function gamemode:update(dt)
	for _, planet in pairs(self.worlds) do
		
		-- TIME
		if planet.timelimit > 0 and planet.time > 0  and planet:anyPlayersActiveAndAlive() then
			local pretime = planet.time
			planet.time = planet.time - planet.timescale*dt
			
			if planet.time > 0 and pretime >= planet.lowtime and planet.time < planet.lowtime then
				love.audio.stop()
				playsound("lowtime") --allowed global
				
				if pretime >= planet.lowtime-8 and planet.time < planet.lowtime-magictimeoffset then
					if planet:areAnyPlayersStarred() then
						music:play("starmusic.ogg")
					else
						playmusic()
					end
				end
			elseif planet.time <= 0 then
				planet.time = 0
				planet:killAllPlayers("time")
			end
		end
	end
end
end end)()end;
do require("package").preload["entities.weapon"] = (function() local package;return function(...)-- <pack entities.weapon> --
weapon = class('weapon')
weapon.static.isWeapon = true
function weapon:init(parent)
	self.parent = parent
	self.primaryAttackDelay = 0 --can go negative on sufficiently large dt
	self.primaryAttackTimer = 0
	self.primaryAmmo = nil --if nil, then it doesn't use any
	self.secondaryAttackDelay = 0
	self.secondaryAttackTimer = 0
	self.secondaryAmmo = nil
	table.insert(objects["weapon"], self)
end

function weapon:update(dt)
	if self.primaryAttackDelay and self.primaryAttackTimer and self.primaryAttackTimer > 0 then
		self.primaryAttackTimer = self.primaryAttackTimer - dt
	end
	
	if self.secondaryAttackDelay and self.secondaryAttackTimer and self.secondaryAttackTimer > 0 then
		self.secondaryAttackTimer = self.secondaryAttackTimer - dt
	end
end

function weapon:draw()
	-- we don't have a standard draw procedure just yet
end

function weapon:primaryFire()
	--@TODO: make a check to see if the player is currently wielding the weapon
	if self.primaryAttackDelay and self.primaryAttackTimer and self.primaryAttackTimer <= 0 then
		-- time permits
		self.primaryAttackTimer = self.primaryAttackDelay
		return true
	else
		return false
	end
end

function weapon:secondaryFire()
	if self.secondaryAttackDelay and self.secondaryAttackTimer and self.secondaryAttackTimer <= 0 then
		-- time permits
		self.secondaryAttackTimer = self.secondaryAttackDelay
		return true
	else
		return false
	end
end
end end)()end;
do require("package").preload["entities.pedestal"] = (function() local package;return function(...)-- <pack entities.pedestal> --
pedestal = class("pedestal")

function pedestal:init(x, y, r)
	self.cox = x
	self.coy = y
	self.x = x-12/16
	self.y = y-1
	
	self.progress = 0
	self.pickedup = false
	
	self.blue = false
	self.orange = false
	
	self.r = {unpack(r)}
	
	if #r >= 4 then
		self.blue = r[3] == "true"
		self.orange = r[4] == "true"
	end
end

function pedestal:update(dt)
	if not self.pickedup then
		local col = checkrect(self.x, self.y, 8/16, 8/16, {"player"})
		
		if #col > 0 then
			for i = 2, #col, 2 do
				print("!")
				if self.blue then
					if not objects["player"][col[i]].portalsavailable[1] then
						self.pickedup = true
						objects["player"][col[i]]:portalpickup(1)
					end
				end
				
				if self.orange then
					if not objects["player"][col[i]].portalsavailable[2] then
						self.pickedup = true
						objects["player"][col[i]]:portalpickup(2)
					end
				end
			
				if self.pickedup then
					break
				end
			end
		end
	elseif self.progress < pedestaltime then
		self.progress = math.min(pedestaltime, self.progress + dt)
	end
end

function pedestal:draw()
	love.graphics.setColor(255, 255, 255)
	if self.pickedup then
		local prog = self.progress / pedestaltime
		love.graphics.setScissor(math.floor((self.cox-1-xscroll)*16*scale), math.floor((self.coy-1.5-yscroll)*16*scale)+14*prog*scale, 16*scale, (14*(1-prog)+2)*scale)
	end
	love.graphics.draw(pedestalbaseimg, math.floor((self.cox-1-xscroll)*16*scale), math.floor((self.coy-1.5-yscroll)*16*scale), 0, scale, scale)
	love.graphics.setScissor()
	
	if not self.pickedup then
		love.graphics.draw(pedestalgunimg, math.floor((self.cox-1-xscroll)*16*scale), math.floor((self.coy-1.5-yscroll)*16*scale), 0, scale, scale)
	
		if self.blue or self.orange then
			if self.blue then
				love.graphics.setColor(objects["player"][1].portal1color)
			elseif self.orange then
				love.graphics.setColor(objects["player"][1].portal2color)
			end
			love.graphics.rectangle("fill", math.floor((self.cox-1-xscroll+7/16)*16*scale), math.floor((self.coy-1.5-yscroll+2/16)*16*scale), scale, scale)
		end
	end
end
end end)()end;
do require("package").preload["entities.notgate"] = (function() local package;return function(...)-- <pack entities.notgate> --
notgate = class("notgate")

function notgate:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.visible = false
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	self.outtable = {}
	self.input1state = "on"
	self.initial = true
end

function notgate:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function notgate:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function notgate:update(dt)
	if self.initial then
		self.initial = false
		self:input("off", "in")
	end
end

function notgate:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(notgateimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function notgate:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end

function notgate:input(t, input)
	if input == "in" then
		if t == "on" and self.input1state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		
		self.input1state = t
	
		local out = "on"
		if not self.power then
			out = "off"
		end
		
		self:out(out)
	end
end
end end)()end;
do require("package").preload["entities.cubedispenser"] = (function() local package;return function(...)-- <pack entities.cubedispenser> --
cubedispenser = class("cubedispenser")

function cubedispenser:init(x, y, r)
	--PHYSICS STUFF
	self.cox = x
	self.coy = y
	self.x = x-1
	self.y = y-1
	self.speedy = 0
	self.speedx = 0
	self.width = 2
	self.height = 2
	self.moves = false
	self.active = true
	self.category = 7
	self.mask = {true, false, false, false, false, false, false, false, true}
	
	self.timer = cubedispensertime
	self.t = "box"
	
	--Input list
	self.input1state = "off"
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DROP ON LOAD
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.timer = 0
		end
		table.remove(self.r, 1)
	end
	
	--DROP ON LOAD
	if #self.r > 0 and self.r[1] ~= "link" then
		self.spawnondestroy = self.r[1] == "true"
		table.remove(self.r, 1)
	end
	
	--TYPE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.t = self.r[1]
		
		table.remove(self.r, 1)
	end
	
	self.inputactive = false
	self.boxexists = false
	self.box = nil
end

function cubedispenser:input(t, input)
	if input == "drop" or input == "drop_enemy_triggered" then
		if (t == "on" and self.input1state == "off") or (t == "toggle" ) then
			if self.boxexists then
				self.boxexists = false
				if input == "drop" then
					self:removebox()
				end
			end
			
			self.timer = 0
		end
	end
end

function cubedispenser:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function cubedispenser:update(dt)
	if self.timer < cubedispensertime then
		self.timer = self.timer + dt
		
		if self.timer > 0.6 and self.boxexists == false then
			local temp
			if self.t == "box" then
				temp = box:new(self.cox+.5, self.coy)
				temp:addoutput(self, "drop")
				table.insert(objects["box"], temp)
			elseif table.contains(enemies, self.t) then
				temp = enemy:new(self.cox, self.coy+2-enemiesdata[self.t].height, self.t)
				
				if self.spawnondestroy then
					temp:addoutput(self, "drop_enemy_triggered")
				end
				
				temp.mask[7] = true
				table.insert(objects["enemy"], temp)
			end
			
			self.box = temp
			self.boxexists = true
		elseif self.timer > 1 then
			self.timer = 1
		end	
	end
	return false
end

function cubedispenser:draw()
	love.graphics.draw(cubedispenserimg, math.floor((self.cox-xscroll-1)*16*scale), (self.coy-yscroll-1.5)*16*scale, 0, scale, scale, 0, 0)
end

function cubedispenser:removebox()
	if self.box then
		self.box:emancipate()
	end
end
end end)()end;
do require("package").preload["entities.button"] = (function() local package;return function(...)-- <pack entities.button> --
button = class("button")

function button:init(x, y, r)
	self.cox = x
	self.coy = y
	
	--PHYSICS STUFF
	self.x = x-15/16
	self.y = y-3/16
	self.width = 30/16
	self.height = 3/16
	self.moves = false
	self.active = false
	self.category = 22
	self.dir = "down"
	self.objtable = {"player", "enemy", "box"}
	
	self.mask = {true}
	
	self.drawable = false
	
	--Input list
	self.input1state = "off"
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	self.out = false
	self.outtable = {}
	self.pressings = {}
end

function button:update(dt)
	local x, y, width, height
	if self.dir == "down" then
		x = self.x+5/16
		y = self.y-2/16
		width = 20/16
		height = 1
	elseif self.dir == "left" then
		x = self.x-12/16
		y = self.y-7/16
		width = 1
		height = 20/16
	elseif self.dir == "right" then
		x = self.x+10/16
		y = self.y-7/16
		width = 1
		height = 20/16
	elseif self.dir == "up" then
		x = self.x+5/16
		y = self.y-24/16
		width = 20/16
		height = 1
	end
	
	local colls = checkrect(x, y, width, height, self.objtable)
	
	for j = 1, #colls, 2 do
		local add = true
		for i, v in pairs(self.pressings) do
			if objects[colls[j]][colls[j+1]] == v then
				add = false
			end
		end
		
		if add then
			table.insert(self.pressings, objects[colls[j]][colls[j+1]])
			if objects[colls[j]][colls[j+1]].onbutton then
				objects[colls[j]][colls[j+1]]:onbutton(true)
			end
		end
	end
	
	
	local delete = {}
	
	for i, v in pairs(self.pressings) do
		local rem = true
		for j = 1, #colls, 2 do
			if objects[colls[j]][colls[j+1]] == v then
				rem = false
			end
		end
		
		if rem then
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		if self.pressings[v].onbutton then
			self.pressings[v]:onbutton(false)
		end
		table.remove(self.pressings, v)
	end
	
	if (#colls > 0) ~= self.out then
		self.out = not self.out
		for i = 1, #self.outtable do
			if self.outtable[i][1].input then
				if self.out then
					self.outtable[i][1]:input("on", self.outtable[i][2])
				else
					self.outtable[i][1]:input("off", self.outtable[i][2])
				end
			end
		end
	end
end

function button:draw()
	local quad = 1
	if self.out then
		quad = 2
	end

	if self.dir == "down" then	
		love.graphics.draw(buttonimg, buttonquad[quad], math.floor((self.x-1/16-xscroll)*16*scale), ((self.y-yscroll)*16-10)*scale, 0, scale, scale)
	elseif self.dir == "left" then
		love.graphics.draw(buttonimg, buttonquad[quad], math.floor((self.x+4/16-xscroll)*16*scale), ((self.y-yscroll)*16-21)*scale, math.pi/2, scale, scale)
	elseif self.dir == "right" then
		love.graphics.draw(buttonimg, buttonquad[quad], math.floor((self.x+10/16-xscroll)*16*scale), ((self.y-yscroll)*16+11)*scale, -math.pi/2, scale, scale)
	elseif self.dir == "up" then
		love.graphics.draw(buttonimg, buttonquad[quad], math.floor((self.x+31/16-xscroll)*16*scale), ((self.y-yscroll)*16-16)*scale, math.pi, scale, scale)
	end
end

function button:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end
end end)()end;
do require("package").preload["entities.pushbutton"] = (function() local package;return function(...)-- <pack entities.pushbutton> --
pushbutton = class("pushbutton")

function pushbutton:init(x, y, r)
	self.cox = x
	self.coy = y
	self.dir = "left"
	self.base = "down"
	
	self.out = false
	self.outtable = {}	
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	--BASE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.base = self.r[1]
		table.remove(self.r, 1)
	end

	self.userect = userect:new(x-11/16, y-11/16, 6/16, 6/16, self)
	
	self.timer = pushbuttontime
end

function pushbutton:update(dt)
	if self.timer < pushbuttontime then
		self.timer = self.timer + dt
		if self.timer >= pushbuttontime then
			self.pusheddown = false
			self.timer = pushbuttontime
		end
	end
end

function pushbutton:draw()
	local quad = 1
	if self.pusheddown then
		quad = 2
	end
	
	local horscale = scale
	if self.dir == "right" then
		horscale = -scale
	end
	
	local r = 0
	if self.base == "left" then
		r = math.pi/2
	elseif self.base == "up" then
		r = math.pi
	elseif self.base == "right" then
		r = math.pi*1.5
	end
	
	love.graphics.draw(pushbuttonimg, pushbuttonquad[quad], math.floor((self.cox-0.5-xscroll)*16*scale), (self.coy-yscroll-1)*16*scale, r, horscale, scale, 8, 8)
end

function pushbutton:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function pushbutton:used()
	if self.timer == pushbuttontime then
		self.pusheddown = true
		self.timer = 0
		for i = 1, #self.outtable do
			if self.outtable[i][1].input then
				self.outtable[i][1]:input("toggle", self.outtable[i][2])
			end
		end
	end
end
end end)()end;
do require("package").preload["entities.portalwall"] = (function() local package;return function(...)-- <pack entities.portalwall> --
portalwall = class("portalwall")

function portalwall:init(x, y, width, height)
	self.x = x
	self.y = y	
	self.width = width
	self.height = height
	self.moves = false
	self.active = true
	self.category = 12
	self.mask = {true}
end

function portalwall:draw()--debug
	love.graphics.setColor(255, 0, 0)
	love.graphics.setPointSize(5)
	if self.width ~= 0 or self.height ~= 0 then
		love.graphics.line((self.x-xscroll)*16*scale, (self.y-.5-yscroll)*16*scale, (self.x-xscroll)*16*scale+self.width*16*scale, (self.y-.5-yscroll)*16*scale+self.height*16*scale)
	else
		love.graphics.point((self.x-xscroll)*16*scale, (self.y-.5-yscroll)*16*scale)
	end
end
end end)()end;
do require("package").preload["entities.platform"] = (function() local package;return function(...)-- <pack entities.platform> --
platform = class("platform")

function platform:init(x, y, r, diroverride)
	self.size = 2
	self.dir = diroverride or "normal" --(normal, Justup, Justdown, justright(bonus stage), fall)
	self.speed = platformjustspeed
	self.xdistance = 0
	self.ydistance = 0
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--SIZE
	if #self.r > 0 then
		self.size = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--X Distance
	if #self.r > 0 then
		if string.sub(self.r[1], 1, 1) == "m" then
			self.xdistance = -tonumber(string.sub(self.r[1], 2))
		else
			self.xdistance = tonumber(self.r[1])
		end
		table.remove(self.r, 1)
	end
	
	
	--X Distance
	if #self.r > 0 then
		if string.sub(self.r[1], 1, 1) == "m" then
			self.ydistance = -tonumber(string.sub(self.r[1], 2))
		else
			self.ydistance = tonumber(self.r[1])
		end
		table.remove(self.r, 1)
	end
	
	--Time
	if #self.r > 0 then
		self.time = tonumber(self.r[1])
		table.remove(self.r, 1)
	end

	--PHYSICS STUFF
	if (self.size ~= math.floor(self.size)) then
		self.x = x-1.25
	else
		self.x = x-1
	end	
	self.y = y-15/16
	self.startx = self.x
	self.starty = self.y
	self.speedx = 0 --!
	self.speedy = 0
	self.width = self.size
	self.height = 8/16
	self.moves = false
	self.active = true
	self.category = 15
	self.mask = {true}
	self.gravity = 0
	
	--IMAGE STUFF
	self.drawable = false
	
	self.rotation = 0
	
	self.timer = 0
	
	if self.dir == "justup" then
		self.speedy = -self.speed
	elseif self.dir == "justdown" then
		self.speedy = self.speed
	end
end

function platform:func(i) --0-1 in please
	return (-math.cos(i*math.pi*2)+1)/2
end

function platform:update(dt)
	if dt > 0 then --Debug fix when dividing by dt
		if self.dir == "normal" then
			self.timer = self.timer + dt
			
			while self.timer > self.time do
				self.timer = self.timer - self.time
			end
			
			local newx = (self.startx) + self:func(self.timer/self.time)*self.xdistance
			local newy = (self.starty) + self:func(self.timer/self.time)*self.ydistance
			
			self.speedx = (newx-self.x)/dt
			self.speedy = (newy-self.y)/dt
			
		elseif self.dir == "justup" and self.y < -1 then
			return true
		elseif (self.dir == "justdown" or self.dir == "fall") and self.y > mapheight then
			return true
		end
	end
	
	local checktable = {"player", "enemy", "box"}
	
	local numberofobjects = 0
	
	--GET FALL SPEED
	
	if self.dir == "fall" then
		for i, v in pairs(checktable) do
			for j, w in pairs(objects[v]) do
				if inrange(w.x, self.x-w.width, self.x+self.width) and inrange(w.y + w.height, self.y - 0.1, self.y + 0.1) then
					numberofobjects = numberofobjects + 1
				end
			end
		end
		
		self.speedy = numberofobjects*4
	end
	
	local nextx, nexty = self.x + self.speedx*dt, self.y + self.speedy*dt
	
	for i, v in pairs(checktable) do
		for j, w in pairs(objects[v]) do
			if inrange(w.x, self.x-w.width, self.x+self.width) and inrange(w.y + w.height, self.y - 0.1, self.y + 0.1) then
				local newx = w.x + self.speedx*dt
				local newy = nexty - w.height
				if #checkrect(newx, newy, w.width, w.height, {"exclude", w, self}, true) == 0 then
					w.x = newx
					w.y = newy
					
					blay = newy+w.height
				end
				numberofobjects = numberofobjects + 1
			end
		end
	end
	
	self.x = nextx
	self.y = nexty
	
	return false
end

function platform:draw()
	for i = 1, self.size do
		if self.dir ~= "justright" then
			love.graphics.draw(platformimg, math.floor((self.x+i-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
		else
			love.graphics.draw(platformbonusimg, math.floor((self.x+i-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
		end
	end
	
	if math.ceil(self.size) ~= self.size then --draw 1 more on the rightest
		love.graphics.draw(platformimg, math.floor((self.x+self.size-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
	end
end

function platform:rightcollide(a, b)
	return false
end

function platform:leftcollide(a, b)
	return false
end

function platform:ceilcollide(a, b)
	if self.dir == "justright" then
		self.speedx = platformbonusspeed
	end
	return false
end

function platform:floorcollide(a, b)
	return false
end

function platform:passivecollide(a, b)
	return false
end
end end)()end;
do require("package").preload["entities.walltimer"] = (function() local package;return function(...)-- <pack entities.walltimer> --
walltimer = class("walltimer")

function walltimer:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	
	self.outtable = {}
	self.lighted = false
	self.time = 1
	self.quad = 1
	
	self.input1state = "off"
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)	
	--TIME
	if #self.r > 0 and self.r[1] ~= "link" then
		self.time = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	self.timer = self.time
end

function walltimer:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function walltimer:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function walltimer:update(dt)
	if self.lighted then
		self.quad = 2
	elseif self.timer == self.time then
		self.quad = 1
	else
		self.timer = self.timer + dt
		local div = self.time/10
		for i = 1, 9 do
			if i == math.floor(self.timer*(1/div)) then
				self.quad = i+1
			end
		end
		
		if self.timer >= self.time then
			self:out("off")
			self.timer = self.time
		end
	end
end

function walltimer:draw()
	love.graphics.setColor(255, 255, 255)
	
	love.graphics.draw(walltimerimg, walltimerquad[self.quad], math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
end

function walltimer:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end

function walltimer:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self:out("on")
			self.timer = self.time
			self.lighted = true
			self.quad = 2
		elseif t == "off" and self.input1state == "on" then
			self.lighted = false
			self.timer = 0
		elseif t == "toggle" then
			self.timer = 0
			self.quad = 2
			self.lighted = false
			self:out("on")
		end
		
		self.input1state = t
	end
end
end end)()end;
do require("package").preload["entities.panel"] = (function() local package;return function(...)-- <pack entities.panel> --
panel = class("panel")

function panel:init(x, y, t)
	self.cox = x
	self.coy = y
	
	self.dir = "right"
	self.out = false
	self.input1state = "off"
	
	--Input list
	self.t = {unpack(t)}
	table.remove(self.t, 1)
	table.remove(self.t, 1)
	--Dir
	if #self.t > 0 then
		self.dir = self.t[1]
		table.remove(self.t, 1)
	end
	--Start white
	if #self.t > 0 then
		self.out = self.t[1] == "true"
		table.remove(self.t, 1)
	end
	
	if self.dir == "up" then
		self.dir = "top"
	elseif self.dir == "down" then
		self.dir = "bottom"
	end
	
	if self.dir == "left" then
		self.r = 0
	elseif self.dir == "top" then
		self.r = math.pi/2
	elseif self.dir == "right" then
		self.r = math.pi
	elseif self.dir == "bottom" then
		self.r = math.pi*1.5
	end
	
	self:link()
	self:updatestuff()
end

function panel:link()
	while #self.t > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.t[3]) == v.cox and tonumber(self.t[4]) == v.coy then
					v:addoutput(self, self.t[2])
				end
			end
		end
		table.remove(self.t, 1)
		table.remove(self.t, 1)
		table.remove(self.t, 1)
		table.remove(self.t, 1)
	end
end

function panel:draw()
	local quad = 2
	if self.out then
		quad = 1
	end
	
	love.graphics.draw(panelimg, panelquad[quad], math.floor((self.cox-1-xscroll+.5)*16*scale), math.floor((self.coy-1-yscroll)*16*scale), self.r, scale, scale, 8, 8)
end

function panel:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.out = true
		elseif t == "off" and self.input1state == "on" then
			self.out = false
		elseif t == "toggle" then
			self.out = not self.out
		end
		
		self.input1state = t
		
		self:updatestuff()
	end
end
	
function panel:updatestuff()
	map[self.cox][self.coy]["portaloverride"][self.dir] = self.out
	
	if self.out == false and tilequads[map[self.cox][self.coy][1]]:getproperty("portalable", self.cox, self.coy) == false then
		checkportalremove(self.cox, self.coy)
	end
end
end end)()end;
do require("package").preload["entities.groundlight"] = (function() local package;return function(...)-- <pack entities.groundlight> --
groundlight = class("groundlight")

function groundlight:init(x, y, r)
	self.x = x
	self.y = y
	self.dir = 2
	
	--[[@NOTE: In the event everything goes horribly wrong, refer to this.
		1	=	ver
		2	=	hor
		3	=	upright
		4	=	rightdown
		5	=	downleft
		6	=	leftup
	]]
	
	self.timer = 0
	
	self.input1state = "off"
	
	self.lighted = false
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		self.lighted = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
end

function groundlight:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function groundlight:update(dt)
	if self.timer > 0 then
		self.timer = self.timer - dt
		if self.timer <= 0 then
			self.timer = 0
			self:input("off")
		end
	end
end

function groundlight:draw()
	if self.lighted then
		love.graphics.setColor(255, 122, 66, 255)
	else
		love.graphics.setColor(60, 188, 252, 255)
	end
	love.graphics.draw(groundlightimg, groundlightquad[self.dir], math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
end

function groundlight:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.lighted = not self.lighted
		elseif t == "off" and self.input1state == "on" then
			self.lighted = not self.lighted
		elseif t == "toggle" then
			self.lighted = not self.lighted
		end
		
		self.input1state = t
	end
end
end end)()end;
do require("package").preload["entities.damage"] = (function() local package;return function(...)-- <pack entities.damage> --
damage = class("damage")
--[[
	this class is a singleton that is used as a rule evaluator against objects
	
	there should only ever be one of each
]]


function damage:init()
	
end

end end)()end;
do require("package").preload["entities.leaf"] = (function() local package;return function(...)-- <pack entities.leaf> --
leaf = class("leaf")

function leaf:init(x, y)
	self.x = x
	self.y = y
	self.frame = math.random(1,2) --random leaf bro!
	
end

function leaf:update(dt)
	if windgentable[1] == "left" then
		self.x = self.x - .50
		elseif windgentable[1] == "right" then
		self.x = self.x + .50
	end
	if self.x > width or self.y > mapheight then
		self.destroy = true
		return true
	end
	return false
end

function leaf:draw()
	love.graphics.draw(leafimg, leafquad[spriteset][self.frame], math.floor((self.x-xscroll)*16*scale), math.floor((self.y-yscroll-.5)*16*scale), 0, scale, scale, 2, 2)
end
end end)()end;
do require("package").preload["entities.generators"] = (function() local package;return function(...)-- <pack entities.generators> --
generators = class("generators")

function generators:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.visible = false
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	if #self.r > 0 and self.r[1] ~= "link" then
		self.contents = self.r[1]
		table.remove(self.r, 1)
		else
	table.remove(self.r, 1)
	end
end

function generators:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function generators:input(t, input)
	if t ~= "off" then
		if self.contents == "bulletbill" then
			gensrunning["bulletbill"] = true
			return true
		elseif self.contents == "flyingcheeps" then
			gensrunning["flyingcheeps"] = true
			return true
		elseif self.contents == "bowserflames" then
			gensrunning["bowserflames"] = true
			return true
		elseif self.contents == "highwindright" then
			gensrunning["highwind"] = true
			return true
		end
	else
	gensrunning["bulletbill"] = false
	gensrunning["flyingcheeps"] = false
	gensrunning["bowserflames"] = false
	gensrunning["highwind"] = false
	return false
	end
end
end end)()end;
do require("package").preload["entities.generatorflames"] = (function() local package;return function(...)-- <pack entities.generatorflames> --
generatorflames = class("generatorflames")

function generatorflames:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	flamegentable = {"right", 0}
	
	self.checktable = {}
	table.insert(self.checktable, "player")
	
	--Unpack the goods
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	
	--Stuff to come sometime
	--[[if #self.r > 0 and self.r[1] ~= "link" then
		bulletgentable[1] = self.r[1]
		table.remove(self.r, 1)
	end
	
	--Wind Intensity
	if #self.r > 0 and self.r[1] ~= "link" then
		bulletgentable[2] = self.r[1]		
		table.remove(self.r, 1)
	end]]
	
	--Region
	if #self.r > 0 then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
end

function generatorflames:update(dt)
	local col = checkrect(self.regionX, self.regionY, self.regionwidth, self.regionheight, self.checktable)
	if not levelfinished and #col > 0 and (not objects["bowser"][1] or (objects["bowser"][1].backwards == false and objects["bowser"][1].shot == false and objects["bowser"][1].fall == false)) then
		firetimer = firetimer + dt
		while firetimer > firedelay do
			firetimer = firetimer - firedelay
			firedelay = math.random(4)
			local temp = enemy:new(xscroll + width, math.random(3)+7, "fire")
			table.insert(objects["enemy"], temp)
			
			
			if objects["bowser"][1] then --make bowser fire this
				temp.y = objects["bowser"][1].y+0.25
				temp.x = objects["bowser"][1].x-0.750
				
				--get goal Y
				temp.movement = "targety"
				temp.targetyspeed = 2
				temp.targety = objects["bowser"][1].starty-math.random(3)+2/16
			end
		end
	elseif #col == 0 then
	firetimer = 0
	end
end

function generatorflames:draw()
	
end
end end)()end;
do require("package").preload["entities.bowser"] = (function() local package;return function(...)-- <pack entities.bowser> --
bowser = class("bowser")

function bowser:init(x, y)
	-- one of the signatures said that bowser starts with (x, y-1/16) but that puts 'em in the floor
	--PHYSICS STUFF
	self.x = x+4
	self.y = y-27/16-1/16
	self.level = --[[i or]] marioworld
	-- removed for now for sanity rasins
	self.startx = x+12
	self.starty = y-1/16
	self.speedy = 0
	self.speedx = 0
	self.width = 30/16--v
	self.height = 28/16--v
	self.moves = true--v
	self.active = true--v
	self.emancipatecheck = true--v
	self.category = 16--v
	
	self.mask = {	true,
					false, false, false, false, true,
					false, true, false, true, false,
					false, false, true, true, false,
					true, true, false, false, true,
					false, true, true, false, false,
					true, false, true, true, true}--v
	
	self.gravity = bowsergravity--v
	
	--IMAGE STUFF
	self.drawable = true
	self.graphic = bowserimg
	self.quad = bowserquad[1][1]
	self.walkframe = 1
	self.offsetX = 14--v
	self.offsetY = -2--v
	self.quadcenterX = 16--v
	self.quadcenterY = 12--v
	
	self.rotation = 0 --for portals
	self.gravitydirection = math.pi/2
	self.jump = false
	
	self.animationtimer = 0
	self.animationdirection = "right"
	self.fireframe = 1
	self.timer = 0
	self.hammertimer = 0
	self.hammertime = 1 --Stop!
	self.hammers = false
	if self.level >= 6 then
		self.hammers = true
	end
	
	self.hp = bowserhealth
	
	self.shot = false
	self.fall = false
	
	self:newtargetx("right")
end

function bowser:update(dt)
	if self.shot then
		self.speedy = self.speedy + shotgravity*dt
		
		self.x = self.x+self.speedx*dt
		self.y = self.y+self.speedy*dt
		
		if self.speedy > bowserfallspeed then
			self.speedy = bowserfallspeed
		end
		
		return false
	else
		if self.speedy > bowserfallspeed then
			self.speedy = bowserfallspeed
		end

		self.rotation = unrotate(self.rotation, self.gravitydirection, dt)
		
		if not self.fall then
			self.animationtimer = self.animationtimer + dt
			while self.animationtimer > bowseranimationspeed do
				self.animationtimer = self.animationtimer - bowseranimationspeed
				if self.walkframe == 1 then
					self.walkframe = 2
				else
					self.walkframe = 1
				end
			end
			
			if self.x < self.targetx then
				self.speedx = bowserspeedforwards
				if self.x+self.speedx*dt >= self.targetx then
					self:newtargetx("left")
				end
			else
				self.speedx = -bowserspeedforwards
				if self.x+self.speedx*dt <= self.targetx then
					self:newtargetx("right")
				end
			end
			
			--stop, hammertime
			if self.hammers and self.backwards == false then
				self.hammertimer = self.hammertimer + dt
				while self.hammertimer > self.hammertime do
					table.insert(objects["enemy"], enemy:new(self.x+4/16, self.y+.5, "hammer", {}))
					self.hammertimer = self.hammertimer - self.hammertime
					
					--new delay
					self.hammertime = bowserhammertable[math.random(#bowserhammertable)]
				end
			end
		end
		
		if self.backwards == false and firestarted and firetimer > firedelay-0.5 then
			self.fireframe = 2
			self.speedx = 0
		else
			self.fireframe = 1
		end
		
		self.quad = bowserquad[self.fireframe][self.walkframe]
		
		--left of player override
		if not self.fall then
			if objects["player"][getclosestplayer(self.x+15/16)].x > self.x+15/16 and self.jump == false then
				self.animationdirection = "left"
				self.speedx = bowserspeedbackwards
				self.backwards = true
			else
				self.backwards = false
				self.animationdirection = "right"
				self.timer = self.timer + dt
				if self.timer > bowserjumpdelay and self.jump == false then
					self.speedy = -bowserjumpforce
					self.jump = true
					self.timer = self.timer - bowserjumpdelay
				end
			end
		end
	end
	
	return false
end

function bowser:draw()
	--just for the hammers
	if not self.fall and not self.backwards then
		if self.hammertimer > self.hammertime - bowserhammerdrawtime then
			love.graphics.draw(enemiesdata["hammer"].graphic, enemiesdata["hammer"].quad, math.floor((self.x-xscroll)*16*scale), (self.y-yscroll-.5-11/16)*16*scale, 0, scale, scale)
		end
	end
end

function bowser:newtargetx(dir)
	if dir == "right" then
		self.targetx = self.startx-1-math.random(2)
	else
		self.targetx = self.startx-7-math.random(2)
	end
end

function bowser:shotted(dir)
	self.hp = self.hp - 1
	if self.hp == 0 then
		self:firedeath()
	end
end

function bowser:firedeath()
	self.shot = true
	self.speedy = -shotjumpforce
	self.direction = dir or "right"
	self.active = false
	self.gravity = shotgravity
	self.speedx = 0
	
	playsound("shot", self.x, self.y, self.speedx, self.speedy)
	playsound("bowserfall", self.x, self.y, self.speedx, self.speedy)
	
	addpoints(firepoints["bowser"], self.x+self.width/2, self.y)
	
	--image
	if marioworld <= 7 then
		self.graphic = decoysimg
		self.quad = decoysquad[marioworld]
	end
end

function bowser:leftcollide(a, b)
	if a == "player" then
		return false
	end
end

function bowser:rightcollide(a, b)
	if a == "player" then
		return false
	end
end

function bowser:ceilcollide(a, b)
	if a == "player" then
		return false
	end
end

function bowser:startfall()

end

function bowser:floorcollide(a, b)
	if self.jump then
		self.jump = false
		self.timer = 0
	end
	if a == "player" then
		return false
	end
end

function bowser:startfall()
	self.jump = true
end

function bowser:emancipate(a)
	self:shotted()
end
end end)()end;
do require("package").preload["entities.userect"] = (function() local package;return function(...)-- <pack entities.userect> --
userect = class('userect')

function userect:init(x, y, width, height, parent)
	self.x = x
	self.y = y
	self.width = width
	self.height = height
	self.parent = parent
	self.destroy = false
	
	table.insert(objects["userect"], self)
end

function userect:update(dt)
	return self.destroy
end

function userect:draw()
	
end

function userect:setPos(x, y)
	self.x = x
	self.y = y
end

function userect:use(x, y, width, height, user)
	--x, y, width, height are presumably different from where ?
	if aabb(x, y, width, height, self.x, self.y, self.width, self.height) then
		self.parent:used(user)
	end
end


-- these are here so that I can keep track of how their original implementation worked
function legacy_userect(x, y, width, height)
	local outtable = {}
	
	local j
	
	for i, v in pairs(userects) do
		if aabb(x, y, width, height, v.x, v.y, v.width, v.height) then
			table.insert(outtable, v.callback)
			if not j then
				j = i
			end
		end
	end
	
	return outtable, j
end

function legacy_adduserect(x, y, width, height, callback)
	local t = {}
	t.x = x
	t.y = y
	t.width = width
	t.height = height
	t.callback = callback
	t.delete = false
	
	table.insert(userects, t)
	return t
end
end end)()end;
do require("package").preload["entities.seesawplatform"] = (function() local package;return function(...)-- <pack entities.seesawplatform> --
seesawplatform = class("seesawplatform")

function seesawplatform:init(x, y, size, callback, side)
	--PHYSICS STUFF
	self.size = size or 2
	self.startx = x-self.size	
	self.starty = y	
	self.x = x-self.size/2-0.5
	self.y = y-17/16
	self.speedx = 0 --!
	self.speedy = 0
	self.width = self.size
	self.height = 8/16
	self.moves = false
	self.active = true
	self.category = 15
	self.mask = {true}
	self.gravity = 0
	
	self.callback = callback
	self.side = side
	
	--IMAGE STUFF
	self.drawable = false
	
	self.rotation = 0
	
	self.speedy = 0
end

function seesawplatform:update(dt)
	local previousX = self.x
	local previousY = self.y
	
	local checktable = {}
	for i, v in pairs(enemies) do
		if objects[v] then
			table.insert(checktable, v)
		end
	end
	table.insert(checktable, "player")
	
	local numberofobjects = 0
	
	for i, v in pairs(checktable) do
		for j, w in pairs(objects[v]) do
			if not w.jumping and inrange(w.x, self.x-w.width, self.x+self.width) then
				if inrange(w.y, self.y - w.height - 0.1, self.y - w.height + 0.1) then
					numberofobjects = numberofobjects + 1
					w.y = self.y - w.height + self.speedy*dt
				end
			end
		end
	end
	
	self.y = self.y + self.speedy*dt
	
	--report back on number of objects
	if self.side == "left" then
		self.callback:callbackleft(numberofobjects)
	else
		self.callback:callbackright(numberofobjects)
	end
	
	if self.y > mapheight+1 then
		return true
	end
	
	return false
end

function seesawplatform:draw()
	for i = 1, self.size do
		if self.dir ~= "justright" then
			love.graphics.draw(platformimg, math.floor((self.x+i-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
		else
			love.graphics.draw(platformbonusimg, math.floor((self.x+i-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
		end
	end
	
	if math.ceil(self.size) ~= self.size then --draw 1 more on the rightest
		love.graphics.draw(platformimg, math.floor((self.x+self.size-1-xscroll)*16*scale), math.floor((self.y-yscroll-8/16)*16*scale), 0, scale, scale)
	end
end

function seesawplatform:rightcollide(a, b)
	return false
end

function seesawplatform:leftcollide(a, b)
	return false
end

function seesawplatform:ceilcollide(a, b)
	return false
end

function seesawplatform:floorcollide(a, b)
	return false
end
end end)()end;
do require("package").preload["entities.geldispenser"] = (function() local package;return function(...)-- <pack entities.geldispenser> --
geldispenser = class("geldispenser")

function geldispenser:init(x, y, r)
	--PHYSICS STUFF
	self.cox = x
	self.coy = y
	self.x = x-1
	self.y = y-1
	self.r = r
	self.speedy = 0
	self.speedx = 0
	self.width = 2
	self.height = 2
	self.moves = false
	self.active = true
	self.category = 7
	self.mask = {true, false, false, false, false, false}
	
	self.dir = "down"
	self.id = 1
	self.timer = 0
	self.input1state = "off"
	
	self.dropping = true
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--DIR
	if #self.r > 0 then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	--ID
	if #self.r > 0 then
		self.id = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.dropping = false
		end
		table.remove(self.r, 1)
	end
	
	self:link()
end

function geldispenser:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function geldispenser:update(dt)
	if self.dropping then
		self.timer = self.timer + dt
		
		while self.timer > geldispensespeed do
			self.timer = self.timer - geldispensespeed
			if self.dir == "down" then
				table.insert(objects["gel"], gel:new(self.x+1.5 + (math.random()-0.5)*1, self.y+12/16, self.id))
				objects["gel"][#objects["gel"]].speedy = 10
			elseif self.dir == "right" then
				table.insert(objects["gel"], gel:new(self.x+14/16, self.y+1.5 + (math.random()-0.5)*1, self.id))
				objects["gel"][#objects["gel"]].speedx = 20
				objects["gel"][#objects["gel"]].speedy = -4
			elseif self.dir == "left" then
				table.insert(objects["gel"], gel:new(self.x+30/16, self.y+1.5 + (math.random()-0.5)*1, self.id))
				objects["gel"][#objects["gel"]].speedx = -20
				objects["gel"][#objects["gel"]].speedy = -4
			elseif self.dir == "up" then
				table.insert(objects["gel"], gel:new(self.x+1.5 + (math.random()-0.5)*1, self.y+12/16, self.id))
				objects["gel"][#objects["gel"]].speedy = -30
			end
		end
	end
	
	return false
end

function geldispenser:draw()
	if self.dir == "down" then
		love.graphics.draw(geldispenserimg, math.floor((self.cox-xscroll-1)*16*scale), (self.coy-yscroll-1.5)*16*scale, 0, scale, scale, 0, 0)
	elseif self.dir == "right" then
		love.graphics.draw(geldispenserimg, math.floor((self.cox-xscroll-1)*16*scale), (self.coy-yscroll+.5)*16*scale, math.pi*1.5, scale, scale, 0, 0)
	elseif self.dir == "left" then
		love.graphics.draw(geldispenserimg, math.floor((self.cox-xscroll+1)*16*scale), (self.coy-yscroll-1.5)*16*scale, math.pi*0.5, scale, scale, 0, 0)
	elseif self.dir == "up" then
		love.graphics.draw(geldispenserimg, math.floor((self.cox-xscroll+1)*16*scale), (self.coy-yscroll+.5)*16*scale, math.pi, scale, scale, 0, 0)
	end
end

function geldispenser:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.dropping = not self.dropping
		elseif t == "off" and self.input1state == "on" then
			self.dropping = not self.dropping
		elseif t == "toggle" then
			self.dropping = not self.dropping
		end
		
		self.input1state = t
	end
end
end end)()end;
do require("package").preload["entities.portalparticle"] = (function() local package;return function(...)-- <pack entities.portalparticle> --
portalparticle = class("portalparticle")

function portalparticle:init(x, y, color, direction)
	self.x = x or 0
	self.y = y or 0
	self.timer = 0 
	self.color = color or {255, 255, 255, 0}
	self.direction = direction
	
	self.speedx, self.speedy = 0, 0
	if self.direction == "left" then
		self.speedx = -portalparticlespeed
	elseif self.direction == "right" then
		self.speedx = portalparticlespeed
	elseif self.direction == "up" then
		self.speedy = -portalparticlespeed
	elseif self.direction == "down" then
		self.speedy = portalparticlespeed
	end
end

function portalparticle:update(dt)
	self.timer = self.timer + dt
	self.x = self.x + self.speedx*dt
	self.y = self.y + self.speedy*dt
	
	self.speedx = self.speedx + math.random(-10, 10)/70
	self.speedy = self.speedy + math.random(-10, 10)/70
	
	if self.direction == "up" then
		if self.speedy > 0 then
			self.speedy = 0
		end
	end
	
	if self.timer > portalparticleduration then
		return true
	end
	
	return false
end

function portalparticle:draw()
	local r, g, b = unpack(self.color)
	local a = (1 - self.timer/portalparticleduration) * 255
	love.graphics.setColor(r, g, b, a)
	love.graphics.draw(portalparticleimg, math.floor((self.x-xscroll)*16*scale), math.floor((self.y-yscroll-.5)*16*scale), 0, scale, scale, .5, .5)
end
end end)()end;
do require("package").preload["entities.bulletbill"] = (function() local package;return function(...)-- <pack entities.bulletbill> --
bulletbill = class("bulletbill")

function bulletbill:init(x, y)
	self.x = x
	self.y = y
	self.id = id
	self:randomtime()
	self.timer = self.time-0.5
	self.autodelete = true
end

function bulletbill:update(dt)
	self.timer = self.timer + dt
	if self.timer > self.time and self.x > xscroll and self.x < xscroll+width+2 then
		if self:fire() then
			self.timer = 0
			self:randomtime()
			
			--remove on non solids
			if not tilequads[map[self.x][self.y][1]]:getproperty("collision", self.x, self.y) then
				return true
			else
				return false
			end
		end
	end
end

function bulletbill:fire()
	--count all bullet bills
	
	local count = 0
	for i, v in pairs(objects["enemy"]) do
		if v.t == "bulletbill" then
			count = count + 1
		end
	end
	
	if count >= maximumbulletbills then
		return false
	end
	
	--get nearest player
	local pl = 1
	for i = 2, players do
		if math.abs(objects["player"][i].x + 14/16 - self.x) < math.abs(objects["player"][pl].x + 14/16 - self.x) then
			pl = i
		end
	end
	
	if objects["player"][pl].x + 14/16 > self.x + bulletbillrange then
		table.insert(objects["enemy"], enemy:new(self.x, self.y, "bulletbill"))
		return true
	elseif objects["player"][pl].x + 14/16 < self.x - bulletbillrange then
		table.insert(objects["enemy"], enemy:new(self.x, self.y, "bulletbill"))
		return true
	end
end

function bulletbill:randomtime()
	local rand = math.random(bulletbilltimemin*10, bulletbilltimemax*10)/10
	self.time = rand
end

---------------------- 
--[[
bulletbill = class("bulletbill")
function bulletbill:init(x, y, dir)
	self.startx = x-14/16
	--PHYSICS STUFF
	self.x = self.startx
	self.y = y-14/16
	self.speedy = 0
	if dir == "left" then
		self.speedx = -bulletbillspeed
		self.customscissor = {self.x-18/16, self.y-2/16, 1, 1}
	else
		self.speedx = bulletbillspeed
		self.customscissor = {self.x+14/16, self.y-2/16, 1, 1}
	end
	self.width = 12/16
	self.height = 12/16
	self.moves = true
	self.active = true
	self.gravity = 0
	self.rotation = 0
	self.autodelete = true
	self.timer = 0
	
	--IMAGE STUFF
	self.drawable = true
	self.quad = bulletbillquad[spriteset]
	self.offsetX = 6
	self.offsetY = 2
	self.quadcenterX = 8
	self.quadcenterY = 8
	self.graphic = bulletbillimg
	
	self.category = 11
	self.animationdirection = dir
	
	self.mask = {	true, 
					true, false, false, false, true,
					true, true, true, true, true,
					true, false, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true,
					true, true, true, true, true}
					
	self.shot = false
	
	playsound("bulletbill")
end

function bulletbill:update(dt)
	if self.x < self.startx - 1 or self.x > self.startx + 1 then
		self.customscissor = nil
	end
	
	if self.shot then
		self.speedy = self.speedy + shotgravity*dt
		
		self.x = self.x+self.speedx*dt
		self.y = self.y+self.speedy*dt
		
		--check if goomba offscreen
		if self.y > 18 then
			return true
		else
			return false
		end
	else
		self.timer = self.timer + dt
		if self.timer >= bulletbilllifetime then
			return true
		end
	
		if self.rotation ~= 0 then
			if math.abs(math.abs(self.rotation)-math.pi/2) < 0.1 then
				self.rotation = -math.pi/2
			else
				self.rotation = 0
			end
		end
		
		if self.speedx < 0 then
			self.animationdirection = "left"
		elseif self.speedx > 0 then
			self.animationdirection = "right"
		elseif self.speedy < 0 then
			self.animationdirection = "right"
		elseif self.speedy > 0 then
			self.animationdirection = "left"
		end
	end
end

function bulletbill:stomp(dir) --fireball, star, turtle
	self.shot = true
	self.speedy = 0
	self.direction = dir or "right"
	self.active = false
	self.gravity = shotgravity
	if self.direction == "left" then
		self.speedx = -shotspeedx
	else
		self.speedx = shotspeedx
	end
end

function bulletbill:shotted(dir)
	self:stomp(dir)
end

function bulletbill:rightcollide(a, b)
	self:globalcollide(a, b)
	return false
end

function bulletbill:leftcollide(a, b)
	self:globalcollide(a, b)
	return false
end

function bulletbill:ceilcollide(a, b)
	self:globalcollide(a, b)
	if a == "player" or a == "box" then
		self:stomp()
	end
	return false
end

function bulletbill:floorcollide(a, b)
	self:globalcollide(a, b)
	return false
end

function bulletbill:globalcollide(a, b)
	if self.killstuff then
		if a == "goomba" or a == "koopa" then
			b:shotted("left")
			return true
		end
	else
		return true
	end
end

function bulletbill:portaled()
	self.killstuff = true
end--]]
end end)()end;
do require("package").preload["entities.checkpoint"] = (function() local package;return function(...)-- <pack entities.checkpoint> --
checkpoint = class("checkpoint")

function checkpoint:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	
	self.r = {unpack(r)}
	
	self.all = true
	self.p = {false, false, false, false}
	self.rest = false
	self.visible = false
	
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--Check all
	if #self.r > 0 and self.r[1] ~= "link" then
		self.all = self.r[1] == "true"
		table.remove(self.r, 1)
	end
	
	--p1-4
	for i = 1, 4 do
		if #self.r > 0 and self.r[1] ~= "link" then
			self.p[i] = self.r[1] == "true"
			table.remove(self.r, 1)
		end
	end
	
	--rest
	if #self.r > 0 and self.r[1] ~= "link" then
		self.rest = self.r[1] == "true"
		table.remove(self.r, 1)
	end
	
	--visible
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = self.r[1] == "true"
		table.remove(self.r, 1)
	end
	
	--REGION
	if #self.r > 0 then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
	
	self.input1state = "off"
end

function checkpoint:update()
	local col = checkrect(self.regionX, self.regionY, self.regionwidth, self.regionheight, {"player"})
	
	if #col > 0 then
		self:trigger()
	end
end

function checkpoint:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function checkpoint:input(t, input)
	if input == "trigger" then
		if t == "on" and self.input1state == "off" then
			self:trigger()
		elseif t == "toggle" then
			self:trigger()
		end
		
		self.input1state = t
	end
end

function checkpoint:trigger()
	local modtable = {}
	if self.all then
		table.insert(modtable, 1)
		table.insert(modtable, 2)
		table.insert(modtable, 3)
		table.insert(modtable, 4)
		table.insert(modtable, 5)
	else
		for i = 1, 4 do
			if self.p[i] then
				table.insert(modtable, i)
			end
		end
		
		if self.rest then
			table.insert(modtable, 5)
		end
	end
	
	for i, v in pairs(modtable) do
		checkpointx[v] = self.x
		checkpointy[v] = self.y
	end
	
	checkpointsub = mariosublevel
end
end end)()end;
do require("package").preload["entities.wallindicator"] = (function() local package;return function(...)-- <pack entities.wallindicator> --
wallindicator = class("wallindicator")

function wallindicator:init(x, y, r)
	self.x = x
	self.y = y
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	self.lighted = false
	
	--default off
	if #self.r > 0 and self.r[1] ~= "link" then
		self.lighted = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	self.input1state = "off"
end

function wallindicator:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function wallindicator:update()

end

function wallindicator:draw()
	love.graphics.setColor(255, 255, 255)
	local quad = 1
	if self.lighted then
		quad = 2
	end
	
	love.graphics.draw(wallindicatorimg, wallindicatorquad[quad], math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
end

function wallindicator:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.lighted = not self.lighted
		elseif t == "off" and self.input1state == "on" then
			self.lighted = not self.lighted
		elseif t == "toggle" then
			self.lighted = not self.lighted
		end
		
		self.input1state = t
	end
end
end end)()end;
do require("package").preload["entities.lightbridgebody"] = (function() local package;return function(...)-- <pack entities.lightbridgebody> --
lightbridgebody = class("lightbridgebody")

function lightbridgebody:init(parent, x, y, dir, i)
	parent:addChild(self)
	self.i = i
	self.cox = x
	self.coy = y
	self.dir = dir
	self.parent = parent

	--PHYSICS STUFF
	if dir == "hor" then
		self.x = x-1
		self.y = y-9/16
		self.width = 1
		self.height = 1/8
	else
		self.x = x-9/16
		self.y = y-1
		self.width= 1/8
		self.height = 1
	end
	self.moves = false
	self.active = true
	self.category = 28
	
	self.mask = {true}
	
	self.gels = {}
	
	self:pushstuff()
end

function lightbridgebody:pushstuff()
	local col = checkrect(self.x, self.y, self.width, self.height, {"box", "player"})
	for i = 1, #col, 2 do
		local v = objects[col[i]][col[i+1]]
		if self.dir == "ver" then
			if v.speedx >= 0 then
				if #checkrect(self.x + self.width, v.y, v.width, v.height, {"exclude", v}, true) > 0 then
					v.x = self.x - v.width
				else
					v.x = self.x + self.width
				end
			else
				if #checkrect(self.x - v.width, v.y, v.width, v.height, {"exclude", v}, true) > 0 then
					v.x = self.x + self.width
				else
					v.x = self.x - v.width
				end
			end
		elseif self.dir == "hor" then
			if v.speedy <= 0 then
				if #checkrect(v.x, self.y - v.height, v.width, v.height, {"exclude", v}, true) > 0 then
					v.y = self.y + self.height
				else
					v.y = self.y - v.height
				end
			else
				if #checkrect(v.x, self.y + self.height, v.width, v.height, {"exclude", v}, true) > 0 then
					v.y = self.y - v.height
				else
					v.y = self.y + self.height
				end
			end
		end
	end
end

function lightbridgebody:update(dt)
	if self.destroy then
		return true
	else
		return false
	end
end

function lightbridgebody:draw()
	love.graphics.setColor(255, 255, 255)
	
	local glowa = self.parent:getglowa(self.i)
	
	if self.dir == "hor" then
		love.graphics.draw(lightbridgeimg, math.floor((self.cox-xscroll-1)*16*scale), (self.coy-yscroll-1.5)*16*scale, 0, scale, scale)
		love.graphics.setColor(255, 255, 255, glowa*255)
		love.graphics.draw(lightbridgeglowimg, math.floor((self.cox-xscroll-1)*16*scale), (self.coy-yscroll-1.5)*16*scale, 0, scale, scale)
	else
		love.graphics.draw(lightbridgeimg, math.floor((self.cox-xscroll-1/16)*16*scale), (self.coy-yscroll-1)*16*scale, math.pi/2, scale, scale, 8, 1)
		love.graphics.setColor(255, 255, 255, glowa*255)
		love.graphics.draw(lightbridgeglowimg, math.floor((self.cox-xscroll-1/16)*16*scale), (self.coy-yscroll-1)*16*scale, math.pi/2, scale, scale, 8, 1)
	end
	
	love.graphics.setColor(255, 255, 255)
	
	--gel
	for i = 1, 4 do
		local dir = "top"
		local r = 0
		if i == 2 then
			dir = "right"
			r = math.pi/2
		elseif i == 3 then
			dir = "bottom"
			r = math.pi
		elseif i == 4 then
			dir = "left"
			r = math.pi*1.5
		end
		
		for i = 1, numgeltypes do
			if self.gels[dir] == i then
				if i == 1 then
					img = gel1groundimg
				elseif i == 2 then
					img = gel2groundimg
				elseif i == 3 then
					img = gel3groundimg
				elseif i == 4 then
					img = gel4groundimg
				elseif i == 5 then
					img = gel5groundimg
				elseif i == 6 then
					img = gel6groundimg
				end
				
				love.graphics.draw(img, math.floor((self.cox-.5-xscroll)*16*scale), math.floor((self.coy-1-yscroll)*16*scale), r, scale, scale, 8, 2)
			end
		end
	end
end
end end)()end;
do require("package").preload["entities.axe"] = (function() local package;return function(...)-- <pack entities.axe> --
axe = class("axe")

function axe:init(x, y, r)
	self.cox = x
	self.coy = y

	self.x = x-1
	self.y = y-1
	self.speedx = 0
	self.speedy = 0
	self.moves = false
	self.active = true
	self.width = 1
	self.height = 1
	self.category = 6
	self.mask = {true}
	self.drawable = true
	self.quad = 1
	self.rotation = 0
	self.timer = 0
	self.falling = false
	self.destroy = false
	self.r = {unpack(r)}

	table.remove(self.r, 1)
	table.remove(self.r, 1)
	if #self.r > 0 and self.r[1] ~= "link" then
		self.value = self.r[1]
		table.remove(self.r, 1)
	end
	
	if #self.r > 0 and self.r[1] ~= "link" then
		self.size = self.r[1]
		table.remove(self.r, 1)
	end
	
	self.out = false
	self.outtable = {}
end

function axe:update(dt)
	-- returning in the update method signals the object handler to destroy us
	--[[if redcoincollected[self.value] >= 1 then  -- The why do you have dupes checker.
	self.destroy = true
	return true
	end]]
	
	-- probably some redundancy here \o/
	if self.out then
		for i = 1, #self.outtable do
			if self.outtable[i][1].input then
				self.outtable[i][1]:input("on", self.outtable[i][2])
			else
				self.outtable[i][1]:input("off", self.outtable[i][2])
			end
		end
	end
	
	if self.destroy then
		return true
	end
end

function axe:collect(ply)
	-- ply is a reference to the player that collected us, we can use that later
	self.out = true
	self.active = false
	self.drawable = false
	
	if levelfinished then
		return
	end
	ply.ducking = false
	for i = 1, players do
		objects["player"][i]:removeportals()
	end
	
	for i, v in pairs(objects["platform"]) do
		objects["platform"][i] = nil
	end

	ply.raccoontimer = 0
	ply.animation = "axe"
	ply.invincible = false
	ply.drawable = true
	ply.animationx = self.x
	ply.animationy = self.y
	ply.animationbridgex = self.x
	ply.controlsenabled = false
	ply.animationtimer = 0
	ply.speedx = 0
	ply.speedy = 0
	ply.gravity = 0
	ply.active = false
	ply.infunnel = false
	levelfinished = true
	levelfinishtype = "castle"
	levelfinishedmisc = 0
	levelfinishedmisc2 = 1
	if marioworld == 8 then
		levelfinishedmisc2 = 2
	end
	bridgedisappear = false
	ply.animationtimer2 = castleanimationbridgedisappeardelay
	bowserfall = false
	
	objects["screenboundary"]["axe"] = nil
	
	if objects["bowser"][1] and not objects["bowser"][1].shot then
		local v = objects["bowser"][1]
		v.speedx = 0
		v.speedy = 0
		v.active = false
		v.gravity = 0
		v.category = 1
	else
		ply.animationtimer = castleanimationmariomove
		ply.active = true
		ply.gravity = mariogravity
		ply.animationstate = "running"
		ply.speedx = 4.27
		ply.pointingangle = -math.pi/2
		ply.animationdirection = "right"
	end
	
	--self.destroy = true
end

function axe:draw()
	if self.drawable then
		love.graphics.draw(axeimg, axequads[coinframe], math.floor((self.cox-1-xscroll)*16*scale), (self.coy-1.5-yscroll)*16*scale, 0, scale, scale)
	end
end

function axe:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end
end end)()end;
do require("package").preload["entities.firework"] = (function() local package;return function(...)-- <pack entities.firework> --
firework = class("firework")

function firework:init(x, yoffset, ply)
	self.x = x+(math.random(9)-5)
	self.y = math.random(5)+3+yoffset
	self.timer = 0
	ply.score = ply.score + 200
end

function firework:update(dt)
	self.timer = self.timer + dt
	
	if self.timer >= fireworksoundtime and self.timer-dt < fireworksoundtime then
		playsound("boom", self.x, self.y)
	end
	
	if self.timer > fireworkdelay then
		return true
	end
	
	return self.destroy
end

function firework:draw()
	local framelength = fireworkdelay/3
	local frame = 1
	if self.timer > framelength*1.1 then
		frame = 2
	end
	if self.timer > framelength*1.25 then
		frame = 3
	end
	if self.timer > framelength*1.5 then
		frame = 4
	end
	love.graphics.draw(fireworkimg, fireworkquads[frame], math.floor((self.x-xscroll)*16*scale), (self.y-yscroll-0.5)*16*scale, 0, scale, scale, 16, 16)
	if self.timer > framelength*1.7 then
		self.destroy=true
		return true
	end
end
end end)()end;
do require("package").preload["entities.old_fireball"] = (function() local package;return function(...)-- <pack entities.old_fireball> --
fireball = class("fireball")

function fireball:init(x, y, dir, v)
	--PHYSICS STUFF
	self.y = y+4/16
	self.speedy = 0
	if dir == "right" then
		self.speedx = fireballspeed
		self.x = x+6/16
	else
		self.speedx = -fireballspeed
		self.x = x
	end
	self.width = 8/16
	self.height = 8/16
	self.active = true
	self.static = false
	self.category = 13
	
	self.mask = {	true,
					false, true, false, false, true,
					false, true, false, true, false,
					false, true, false, true, false,
					true, true, false, false, false,
					false, true, false, false, true,
					false, false, false, false, true}
					
	self.destroy = false
	self.destroysoon = false
	--self.gravity = 40
	
	--IMAGE STUFF
	self.drawable = true
	self.graphic = fireballimg
	self.quad = fireballquad[1]
	self.offsetX = 4
	self.offsetY = 4
	self.quadcenterX = 4
	self.quadcenterY = 4
	
	self.fireballthrower = v
	
	self.rotation = 0 --for portals
	self.gravitydirection = math.pi/2
	self.timer = 0
	self.quadi = 1
	
	self.emancipatecheck = true
	playsound("fireball", self.x, self.y, self.speedx, self.speedy)
end

function fireball:update(dt)
	--rotate back to 0 (portals)
	self.rotation = 0
	
	--animate
	self.timer = self.timer + dt
	if self.destroysoon == false then
		while self.timer > staranimationdelay do
			self.quadi = self.quadi + 1
			if self.quadi == 5 then
				self.quadi = 1
			end
			self.quad = fireballquad[self.quadi]
			self.timer = self.timer - staranimationdelay
		end
	else
		while self.timer > staranimationdelay do
			self.quadi = self.quadi + 1
			if self.quadi == 8 then
				self.destroy = true
				self.quadi = 7
			end
			
			self.quad = fireballquad[self.quadi]
			self.timer = self.timer - staranimationdelay
		end
	end
	
	if self.x < xscroll-1 or self.x > xscroll+width+1 or self.y > mapheight and self.active then
		self.fireballthrower:fireballcallback()
		self.destroy = true
	end
	
	if self.destroy then
		return true
	else
		return false
	end
end

function fireball:leftcollide(a, b)
	self.x = self.x-.5
	self:hitstuff(a, b)
	
	self.speedx = fireballspeed
	return false
end

function fireball:rightcollide(a, b)
	self:hitstuff(a, b)
	
	self.speedx = -fireballspeed
	return false
end

function fireball:floorcollide(a, b)
	if a ~= "tile" and a ~= "portalwall" then
		self:hitstuff(a, b)
	end
	
	self.speedy = -fireballjumpforce
	return false
end

function fireball:ceilcollide(a, b)
	self:hitstuff(a, b)
end

function fireball:passivecollide(a, b)
	self:ceilcollide(a, b)
	return false
end

function fireball:hitstuff(a, b)
	if a == "tile" or a == "bulletbill" or a == "portalwall" or a == "spring" then
		self:explode()
		playsound("blockhit", self.x, self.y)
		
	elseif a == "enemy" or a == "bowser" then
		if b:shotted("right", false, false, true) ~= false then
			if a ~= "bowser" then
				addpoints(b.firepoints or 200, self.x, self.y)
			end
		end
		self:explode()
	end
end

function fireball:explode()
	if self.active then
		self.fireballthrower:fireballcallback()
		
		self.destroysoon = true
		self.quadi = 5
		self.quad = fireballquad[self.quadi]
		self.active = false
	end
end

function fireball:emancipate()
	if not self.kill then
		table.insert(objects["emancipateanimation"], emancipateanimation:new(self.x, self.y, self.width, self.height, self.graphic, self.quad, self.speedx, self.speedy, self.rotation, self.offsetX, self.offsetY, self.quadcenterX, self.quadcenterY))
		self.kill = true
		self.drawable = false
	end
end
end end)()end;
do require("package").preload["entities.emancipationgrill"] = (function() local package;return function(...)-- <pack entities.emancipationgrill> --
emancipationgrill = class("emancipationgrill")

function emancipationgrill:init(x, y, r)
	self.cox = x
	self.coy = y
	self.r = {unpack(r)}
	self.dir = "ver"
	self.power = true
	self.inputstate = "off"
	
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--Input list
	--DIR
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.power = false
		end
		table.remove(self.r, 1)
	end
	
	self.destroy = false
	if getTile(self.cox, self.coy) == true then
		self.destroy = true
	end
	
	for i, v in pairs(objects["emancipationgrill"]) do
		local a, b = v:getTileInvolved(self.cox, self.coy)
		if a and b == self.dir then
			self.destroy = true
		end
	end
	
	self.particles = {}
	self.particles.i = {}
	self.particles.dir = {}
	self.particles.speed = {}
	self.particles.mod = {}
	
	self.involvedtiles = {}
	
	--find start and end
	if self.dir == "hor" then
		--self.height = 1
		local curx = self.cox
		while curx >= 1 and getTile(curx, self.coy) == false do
			self.involvedtiles[curx] = self.coy
			curx = curx - 1
		end
		self.startx = curx + 1
		
		local curx = self.cox
		while curx <= mapwidth and getTile(curx, self.coy) == false do
			self.involvedtiles[curx] = self.coy
			curx = curx + 1
		end
		self.endx = curx - 1
		
		self.range = math.floor(((self.endx - self.startx + 1 + emanceimgwidth/16)*16)*scale)
		--self.width = self.endx - self.startx + 1
		--print("grill is", self.width, "wide")
	else
		--self.width = 1
		local cury = self.coy
		while cury >= 1 and getTile(self.cox, cury) == false do
			self.involvedtiles[cury] = self.cox
			cury = cury - 1
		end
		self.starty = cury + 1
		
		local cury = self.coy
		while cury <= mapheight and getTile(self.cox, cury) == false do
			self.involvedtiles[cury] = self.cox
			cury = cury + 1
		end
		self.endy = cury - 1
		
		self.range = math.floor(((self.endy - self.starty + 1 + emanceimgwidth/16)*16)*scale)
		--self.height = self.endy - self.starty + 1
		--print("grill is", self.height, "tall")
	end
	
	for i = 1, self.range/16/scale do
		table.insert(self.particles.i, math.random())
		table.insert(self.particles.speed, (1-emanceparticlespeedmod)+math.random()*emanceparticlespeedmod*2)
		if math.random(2) == 1 then
			table.insert(self.particles.dir, 1)
		else
			table.insert(self.particles.dir, -1)
		end
		table.insert(self.particles.mod, math.random(4)-2)
	end
end

function emancipationgrill:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function emancipationgrill:update(dt)
	if self.destroy then
		return true
	end

	for i, v in pairs(self.particles.i) do
		self.particles.i[i] = self.particles.i[i] + emanceparticlespeed/(self.range/16/scale)*dt*self.particles.speed[i]
		while self.particles.i[i] > 1 do
			self.particles.i[i] = self.particles.i[i]-1
			self.particles.speed[i] = (1-emanceparticlespeedmod)+math.random()*emanceparticlespeedmod*2
			if math.random(2) == 1 then
				self.particles.dir[i] = 1
			else
				self.particles.dir[i] = -1
			end
			self.particles.mod[i] = math.random(4)-2
		end
	end
end

function emancipationgrill:draw()
	if self.destroy == false then
		if self.dir == "hor" then
			parstartleft = math.floor((self.startx-1-xscroll)*16*scale)
			parstartright = math.floor((self.endx-1-xscroll)*16*scale)
			if self.power then
				love.graphics.setScissor(parstartleft, ((self.coy-yscroll-1)*16-2)*scale, self.range - emanceimgwidth*scale, scale*4)
				
				love.graphics.setColor(unpack(emancelinecolor))
				love.graphics.rectangle("fill", math.floor((self.startx-1-xscroll)*16*scale), ((self.coy-yscroll-1)*16-2)*scale, self.range, scale*4)
				love.graphics.setColor(255, 255, 255)
				
				for i, v in pairs(self.particles.i) do
					local y = ((self.coy-1-yscroll)*16-self.particles.mod[i])*scale
					if self.particles.dir[i] == 1 then
						local x = parstartleft+self.range*v
						love.graphics.draw(emanceparticleimg, math.floor(x), y, math.pi/2, scale, scale)
					else
						local x = parstartright-self.range*v
						love.graphics.draw(emanceparticleimg, math.floor(x), y, -math.pi/2, scale, scale, 1)
					end
				end
				
				love.graphics.setScissor()
			end
			
			--Sidethings
			love.graphics.draw(emancesideimg, parstartleft, ((self.coy-1-yscroll)*16-4)*scale, 0, scale, scale)
			love.graphics.draw(emancesideimg, parstartright+16*scale, ((self.coy-1-yscroll)*16+4)*scale, math.pi, scale, scale)
		else --ver
			parstartup = math.floor((self.starty-yscroll-1)*16*scale)
			parstartdown = math.floor((self.endy-yscroll-1)*16*scale)
			if self.power then
				love.graphics.setScissor(math.floor(((self.cox-1-xscroll)*16+6)*scale), parstartup-8*scale, scale*4, self.range - emanceimgwidth*scale)
				
				love.graphics.setColor(unpack(emancelinecolor))
				love.graphics.rectangle("fill", math.floor(((self.cox-1-xscroll)*16+6)*scale), parstartup-8*scale, scale*4, self.range - emanceimgwidth*scale)
				love.graphics.setColor(255, 255, 255)
				
				for i, v in pairs(self.particles.i) do
					local x = ((self.cox-1-xscroll)*16-self.particles.mod[i]+9)*scale
					if self.particles.dir[i] == 1 then
						local y = parstartup-yscroll+self.range*v
						love.graphics.draw(emanceparticleimg, math.floor(x), y, math.pi, scale, scale)
					else
						local y = parstartdown-yscroll-self.range*v
						love.graphics.draw(emanceparticleimg, math.floor(x), y, 0, scale, scale, 1)
					end
				end
				
				love.graphics.setScissor()
			end
			
			--Sidethings
			love.graphics.draw(emancesideimg, math.floor(((self.cox-xscroll)*16-4)*scale), parstartup-8*scale, math.pi/2, scale, scale)
			love.graphics.draw(emancesideimg, math.floor(((self.cox-xscroll)*16-12)*scale), parstartdown+8*scale, -math.pi/2, scale, scale)
		end
	end
end

function emancipationgrill:getTileInvolved(x, y)
	if self.power then
		if self.dir == "hor" then
			if self.involvedtiles[x] == y then
				return true, "hor"
			else
				return false, "hor"
			end
		else
			if self.involvedtiles[y] == x then
				return true, "ver"
			else
				return false, "ver"
			end
		end
	else
		return false
	end
end

function emancipationgrill:input(t, input)
	if input == "power" then
		if t == "on" and self.inputstate == "off" then
			self.power = not self.power
		elseif t == "off" and self.inputstate == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		
		self.inputstate = t
	end
end
end end)()end;
do require("package").preload["entities.spring"] = (function() local package;return function(...)-- <pack entities.spring> --
spring = class("spring")

function spring:init(x, y, r)
	self.cox = x
	self.coy = y
	
	--PHYSICS STUFF
	self.x = x-1
	self.y = y-32/16
	self.width = 16/16
	self.height = 32/16
	self.moves = false
	self.active = true
	
	self.drawable = false
	self.type = "regular"
	
	self.timer = springtime
	
	self.r = {unpack(r)}
	--r == the map data at map[x][y]
	table.remove(self.r, 1) --r[1] == tile index, can be used to look up properties in tilequads{}
	table.remove(self.r, 1) --r[2] == entity index, can be used to look up generic base entity in entitylist{}
	-- all indexes of r after this point are those that you defined by the rightclick menu.
	--SPRINGTYPE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.type = self.r[1]
		table.remove(self.r, 1)
	end
	
	self.category = 19
	
	self.mask = {true}
	
	self.frame = 1
end

function spring:update(dt)
	if self.timer < springtime then
		self.timer = self.timer + dt
		if self.timer > springtime then
			self.timer = springtime
		end
		self.frame = math.ceil(self.timer/(springtime/3)+0.001)+1
		if self.frame > 3 then
			self.frame = 6-self.frame
		end
	end
end

function spring:draw()
	if self.type == "regular" then
		love.graphics.draw(springimg, springquads[spriteset][self.frame], math.floor((self.x-xscroll)*16*scale), ((self.y-yscroll)*16-8)*scale, 0, scale, scale)
	elseif self.type == "high" then
		love.graphics.draw(springhighimg, springquads[spriteset][self.frame], math.floor((self.x-xscroll)*16*scale), ((self.y-yscroll)*16-8)*scale, 0, scale, scale)
	else
		love.graphics.draw(springimg, springquads[spriteset][self.frame], math.floor((self.x-xscroll)*16*scale), ((self.y-yscroll)*16-8)*scale, 0, scale, scale)
	end
end

function spring:hit()
	self.timer = 0
	playsound("spring", self.x, self.y)
end
end end)()end;
do require("package").preload["entities.seesaw"] = (function() local package;return function(...)-- <pack entities.seesaw> --
seesaw = class("seesaw")

--settings for the types
seesawtype = {}
seesawtype[1] = {7,4,6,3}
seesawtype[2] = {4,2,6,3}
seesawtype[3] = {7,3,6,3}
seesawtype[4] = {8,3,7,3}
seesawtype[5] = {5,3,7,3}
seesawtype[6] = {6,3,7,3}
seesawtype[7] = {4,3,7,1.5}
seesawtype[8] = {3,3,7,1.5}
seesawtype[9] = {3,4,7,1.5}


function seesaw:init(x, y, r)
	self.x = x
	self.y = y
	
	if t == nil then
		t = 1
	end
	
	self.range = seesawtype[t][1]
	self.dist1 = seesawtype[t][2]
	self.dist2 = seesawtype[t][3]
	self.width = seesawtype[t][4]
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--RANGE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.range = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	--DIST1
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dist1 = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	--DIST2
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dist2 = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	--WIDTH
	if #self.r > 0 and self.r[1] ~= "link" then
		self.width = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	self.lcount = 0
	self.rcount = 0
	self.falloff = false
	
	self.leftplatform = seesawplatform:new(self.x, self.y+self.dist1, self.width, self, "left")
	self.rightplatform = seesawplatform:new(self.x+self.range, self.y+self.dist2, self.width, self, "right")
	
	table.insert(objects["seesawplatform"], self.leftplatform)
	table.insert(objects["seesawplatform"], self.rightplatform)
end

function seesaw:update(dt)
	if self.falloff then
		self.leftplatform.speedy = self.leftplatform.speedy + seesawgravity*dt
		self.rightplatform.speedy = self.rightplatform.speedy + seesawgravity*dt
	else
		local speed = self.lcount - self.rcount
		
		self.leftplatform.speedy = self.leftplatform.speedy + speed*seesawspeed*dt
		self.rightplatform.speedy = self.rightplatform.speedy - speed*seesawspeed*dt
		
		if self.leftplatform.speedy > 0 and speed <= 0 then
			self.leftplatform.speedy = self.leftplatform.speedy - seesawfriction*dt
			if speed == 0 and self.leftplatform.speedy < 0 then
				self.leftplatform.speedy = 0
			end
		elseif self.leftplatform.speedy < 0 and speed >= 0 then
			self.leftplatform.speedy = self.leftplatform.speedy + seesawfriction*dt
		end
	
		if self.rightplatform.speedy > 0 and speed >= 0 then
			self.rightplatform.speedy = self.rightplatform.speedy - seesawfriction*dt
			if speed == 0 and self.rightplatform.speedy < 0 then
				self.leftplatform.speedy = 0
			end
		elseif self.rightplatform.speedy < 0 and speed <= 0 then
			self.rightplatform.speedy = self.rightplatform.speedy + seesawfriction*dt
		end
		
		--check if falloff
		if self.leftplatform.y-self.y <= 0 then
			if self.rcount ~= 0 then
				self:fallingoff("right")
			else
				self.leftplatform.y = self.y
				self.rightplatform.y = self.y+self.dist1+self.dist2-2-2/16
			end
		end
		
		if self.rightplatform.y-self.y <= 0 then
			if self.lcount ~= 0 then
				self:fallingoff("left")
			else
				self.rightplatform.y = self.y
				self.leftplatform.y = self.y+self.dist1+self.dist2-2-2/16
			end
		end
	end
end

function seesaw:fallingoff(side)
	self.leftplatform.speedy = 0
	self.rightplatform.speedy = 0
	
	self.falloffside = side
	self.falloff = true
end

function seesaw:draw()
	--left
	love.graphics.draw(seesawimg, seesawquad[1], math.floor((self.x-1-xscroll)*16*scale), (self.y-yscroll-1.5)*16*scale, 0, scale, scale)
	
	if self.falloff == false and self.leftplatform.y-self.y >= 0 then
		love.graphics.setScissor((self.x-1-xscroll)*16*scale, (self.y-yscroll-0.5)*16*scale, 16*scale, math.floor((self.leftplatform.y-self.y)*16*scale))
		for i = 1, math.ceil(self.leftplatform.y-self.y) do
			love.graphics.draw(seesawimg, seesawquad[3], math.floor((self.x-1-xscroll)*16*scale), (self.y-yscroll+i-1.5)*16*scale, 0, scale, scale)
		end
		love.graphics.setScissor()
	else
		if self.falloffside == "left" then
			for i = 1, self.dist1+self.dist2-2 do
				love.graphics.draw(seesawimg, seesawquad[3], math.floor((self.x-1-xscroll)*16*scale), (self.y-yscroll+i-1.5)*16*scale, 0, scale, scale)
			end
		end
	end
		
	
	--middle
	for i = 1, self.range-1 do
		love.graphics.draw(seesawimg, seesawquad[4], math.floor((self.x-1+i-xscroll)*16*scale), (self.y-yscroll-1.5)*16*scale, 0, scale, scale)
	end
		
	--right
	love.graphics.draw(seesawimg, seesawquad[2], math.floor((self.x-1+self.range-xscroll)*16*scale), (self.y-yscroll-1.5)*16*scale, 0, scale, scale)
	
	if self.falloff == false and self.rightplatform.y-self.y >= 0 then
		love.graphics.setScissor((self.x-1+self.range-xscroll)*16*scale, (self.y-yscroll-0.5)*16*scale, 16*scale, math.floor((self.rightplatform.y-self.y)*16*scale))
		for i = 1, math.ceil(self.rightplatform.y-self.y) do
			love.graphics.draw(seesawimg, seesawquad[3], math.floor((self.x+self.range-1-xscroll)*16*scale), (self.y-yscroll+i-1.5)*16*scale, 0, scale, scale)
		end
		love.graphics.setScissor()
	else
		if self.falloffside == "right" then
			for i = 1, self.dist1+self.dist2-2 do
				love.graphics.draw(seesawimg, seesawquad[3], math.floor((self.x+self.range-1-xscroll)*16*scale), (self.y-yscroll+i-1.5)*16*scale, 0, scale, scale)
			end
		end
	end
end

function seesaw:callbackleft(i)
	self.lcount = i
end

function seesaw:callbackright(i)
	self.rcount = i
end
end end)()end;
do require("package").preload["entities.generatorwind"] = (function() local package;return function(...)-- <pack entities.generatorwind> --
generatorwind = class("generatorwind")

function generatorwind:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	windgentable = {"right", 0}
	
	self.checktable = {}
	table.insert(self.checktable, "player")
	
	--Unpack the goods
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	
	--Wind Direction
	if #self.r > 0 and self.r[1] ~= "link" then
		windgentable[1] = self.r[1]
		table.remove(self.r, 1)
	end
	
	--Wind Intensity
	if #self.r > 0 and self.r[1] ~= "link" then
		windgentable[2] = self.r[1]		
		table.remove(self.r, 1)
	end
	
	--Region
	if #self.r > 0 then
		local s = self.r[1]:split(":")
		self.regionX, self.regionY, self.regionwidth, self.regionheight = s[2], s[3], tonumber(s[4]), tonumber(s[5])
		if string.sub(self.regionX, 1, 1) == "m" then
			self.regionX = -tonumber(string.sub(self.regionX, 2))
		end
		if string.sub(self.regionY, 1, 1) == "m" then
			self.regionY = -tonumber(string.sub(self.regionY, 2))
		end
		
		self.regionX = tonumber(self.regionX) + self.x - 1
		self.regionY = tonumber(self.regionY) + self.y - 1
		table.remove(self.r, 1)
	end
end

function generatorwind:update(dt)
	local col = checkrect(self.regionX, self.regionY, self.regionwidth, self.regionheight, self.checktable)
	if not levelfinished and #col > 0 then
		--[[if windsound:isStopped() then
			playsound(windsound)
		end]]
		local player1 = objects["player"][1]
		if player1.animationdirection == "left" and player1.animationstate ~= "idle" then
			if not player1.spring and not player1.springhigh then
				if windgentable[1] == "left" then
					player1.speedx = player1.speedx - ((windgentable[2]/100)/2)
					elseif windgentable[1] == "right" then
					player1.speedx = player1.speedx + (windgentable[2]/100)
				end
			else
				
			end
		elseif player1.animationstate ~= "idle" then
			if not player1.spring and not player1.springhigh then
				if windgentable[1] == "left" then
					player1.speedx = player1.speedx - (windgentable[2]/100)
					elseif windgentable[1] == "right" then
					player1.speedx = player1.speedx + ((windgentable[2]/100)/2)
				end
			else
				
			end
		elseif player1.animationstate == "idle" then
			if windgentable[2] == "left" then
				player1.speedx = player1.speedx - 1
				elseif windgentable[1] == "right" then
				player1.speedx = player1.speedx + 1
			end
		end
		-- Make high wind leaves appear
		windtimer = windtimer + dt
		while windtimer > 0.05 do
			windtimer = windtimer - 0.05
			if windgentable[1] == "right" then
			table.insert(objects["leaf"], leaf:new(xscroll, math.random(1, mapheight)))
			elseif windgentable[1] == "left" then
			table.insert(objects["leaf"], leaf:new(xscroll+25, math.random(1, mapheight)))
			end
		end
	elseif #col == 0 then
	windtimer = 0
	end
end

function generatorwind:draw()
	
end
end end)()end;
do require("package").preload["entities.funnel"] = (function() local package;return function(...)-- <pack entities.funnel> --
funnel = class("funnel")

function funnel:init(x, y, r)
	self.cox = x
	self.coy = y
	self.dir = "right"
	self.r = {unpack(r)}
	self.reverse = 1
	self.power = true
	self.firstupdate = true
	self.input1state = "off"
	self.input2state = "off"
	self.quad = 1
	
	self.timer = 0
	self.timer2 = 0
	
	self.objtable = {"player", "enemy", "box", "gel"}
	
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	self.speed = funnelspeed
	
	--Input list
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		self.dir = self.r[1]
		table.remove(self.r, 1)
	end
	
	--SPEED
	if #self.r > 0 and self.r[1] ~= "link" and tonumber(self.r[1]) then
		self.speed = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--DIRECTION
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.reverse = -1
		end
		table.remove(self.r, 1)
	end
	
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		if self.r[1] == "true" then
			self.power = false
		end
		table.remove(self.r, 1)
	end
	self:updaterange()
	
	self.animationtime = 3/self.speed-1/16
end

function funnel:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function funnel:update(dt)	
	if self.power then
		self.timer = self.timer + dt
		if self.timer > self.animationtime then
			self.timer = math.mod(self.timer, self.animationtime)
		end
		
		self.timer2 = self.timer2 + dt
		while self.timer2 > excursionbaseanimationtime do
			self.timer2 = self.timer2 - excursionbaseanimationtime
			if self.reverse == 1 then
				self.quad = self.quad + 1
				if self.quad > 8 then
					self.quad = 1
				end
			else
				self.quad = self.quad - 1
				if self.quad < 1 then
					self.quad = 8
				end
			end		
		end

		local x, y, width, height
		
		for i, v in pairs(self.funneltable) do
			if v.dir == "right" then
				x = v.x-1
				y = v.y-1
				width = v.rangex
				height = 2
			elseif v.dir == "left" then
				x = v.x+v.rangex
				y = v.y-1
				width = -v.rangex
				height = 2
			elseif v.dir == "up" then
				x = v.x-1
				y = v.y+v.rangey
				width = 2
				height = -v.rangey
			else
				x = v.x-1
				y = v.y-1
				width = 2
				height = v.rangey
			end
			
			if v.dir == "right" or v.dir == "left" then
				if v.timer < math.abs(v.rangex) then
					v.timer = v.timer + dt*funnelbuildupspeed
					if v.timer > math.abs(v.rangex) then
						v.timer = math.abs(v.rangex)
					end
				end
			else
				if v.timer < math.abs(v.rangey) then
					v.timer = v.timer + dt*funnelbuildupspeed
					if v.timer > math.abs(v.rangey) then
						v.timer = math.abs(v.rangey)
					end
				end
			end
			
			local rectcol = checkrect(x, y, width, height, self.objtable)
			
			for i = 1, #rectcol, 2 do
				local w = objects[rectcol[i]][rectcol[i+1]]
				w.speedx = 0
				w.speedy = 0
				if not w.funneloffset then
					--these numbers are magic, I'm sorry
					if rectcol[i] ~= "gel" then
						w.funneloffset = 0
					else
						w.funneloffset = math.random()*5-2.5
					end
				end
				
				-- update the lifetime of gels
				if rectcol[i]=="gel" then
					w.timer = 0
				end
				
				if v.dir == "right" then
					w.speedx = self.speed*self.reverse
					
					local diff = (w.y+w.height/2)-y-1
					w.speedy = -diff*funnelforce-w.funneloffset+(math.sin(self.cox-w.x)*0.5)
					
					if rectcol[i] == "player" then
						if w.binds.control.playerDown then
							w.speedy = funnelmovespeed
						elseif w.binds.control.playerUp then
							w.speedy = w.speedy-funnelmovespeed
						end
					end
					
				elseif v.dir == "left" then
					w.speedx = -self.speed*self.reverse
					
					local diff = (w.y+w.height/2)-y-1
					w.speedy = -diff*funnelforce-w.funneloffset+(math.sin(self.cox-w.x)*0.5)
					
					if rectcol[i] == "player" then
						if w.binds.control.playerDown then
							w.speedy = funnelmovespeed
						elseif w.binds.control.playerUp then
							w.speedy = w.speedy-funnelmovespeed
						end
					end
					
				elseif v.dir == "up" then
					w.speedy = -self.speed*self.reverse
					
					local diff = (w.x+w.width/2)-x-1
					w.speedx = -diff*funnelforce-w.funneloffset+(math.sin(self.coy-w.y)*0.5)
					
					if rectcol[i] == "player" then
						if w.binds.control.playerLeft then
							w.speedx = -funnelmovespeed
						elseif w.binds.control.playerRight then
							w.speedx = funnelmovespeed
						end
					end
					
				else
					w.speedy = self.speed*self.reverse
					
					local diff = (w.x+w.width/2)-x-1
					w.speedx = -diff*funnelforce-w.funneloffset+(math.sin(self.coy-w.y)*0.5)
					
					if rectcol[i] == "player" then
						if w.binds.control.playerLeft then
							w.speedx = -funnelmovespeed
						elseif w.binds.control.playerRight then
							w.speedx = funnelmovespeed
						end
					end
				end
				
				w.funnel = true
				
				w.gravity = 0
				w.gravitydirection = math.pi/2
			end
		end
	end
end

function funnel:draw()
	love.graphics.setColor(255, 255, 255)
	
	if self.power then
		local img
		if self.reverse == 1 then
			img = excursionfunnelimg
			endimg = excursionfunnelendimg
		else
			img = excursionfunnel2img
			endimg = excursionfunnel2endimg
		end
		
		for i, v in pairs(self.funneltable) do
			if v.dir == "right" then
				local progress = v.timer/v.rangex
				if self.reverse == 1 then
					love.graphics.setScissor((v.x-xscroll-1)*16*scale, (v.y-yscroll-1.5)*16*scale, v.rangex*progress*16*scale, 2*16*scale)
				else
					love.graphics.setScissor((v.x-xscroll-1+(v.rangex*(1-progress)))*16*scale, (v.y-yscroll-1.5)*16*scale, v.rangex*progress*16*scale, 2*16*scale)
				end
				
				local x
				for j = 0, math.ceil(v.rangex/3)+1 do
					x = math.floor((v.x-xscroll-1+(j-1)*3+self.timer/self.animationtime*3*self.reverse)*16*scale)
					
					love.graphics.draw(img, x, math.floor((v.y-yscroll-1.5)*16*scale), 0, scale, scale)
				end
				
				love.graphics.draw(endimg, math.floor((v.x-xscroll+v.rangex-1.5)*16*scale), math.floor((v.y-yscroll-1)*16*scale), 0, scale, scale, 8, 8)
				
				love.graphics.setScissor()
			elseif v.dir == "left" then
				local progress = v.timer/-v.rangex
				if self.reverse == 1 then
					love.graphics.setScissor((v.x+v.rangex-xscroll-v.rangex*(1-progress))*16*scale, (v.y-yscroll-1.5)*16*scale, -v.rangex*progress*16*scale, 2*16*scale)
				else
					love.graphics.setScissor((v.x+v.rangex-xscroll)*16*scale, (v.y-yscroll-1.5)*16*scale, -v.rangex*progress*16*scale, 2*16*scale)
				end
				
				for j = 0, math.ceil(-v.rangex/3)+1 do
					local x = math.floor((v.x+v.rangex-xscroll+(j-1)*3-self.timer/self.animationtime*3*self.reverse)*16*scale)
					
					love.graphics.draw(img, x, math.floor((v.y-yscroll-1.5)*16*scale), 0, scale, scale)
				end
				
				love.graphics.draw(endimg, math.floor((v.x-xscroll+v.rangex+.5)*16*scale), math.floor((v.y-yscroll)*16*scale), math.pi, scale, scale, 8, 8)
				
				love.graphics.setScissor()
			elseif v.dir == "up" then
				local progress = v.timer/-v.rangey
				if self.reverse == 1 then
					love.graphics.setScissor((v.x-xscroll-1)*16*scale, (v.y+v.rangey-yscroll-.5-v.rangey*(1-progress))*16*scale, 2*16*scale, -v.rangey*progress*16*scale)
				else
					love.graphics.setScissor((v.x-xscroll-1)*16*scale, (v.y+v.rangey-yscroll-.5)*16*scale, 2*16*scale, -v.rangey*progress*16*scale)
				end
				
				for j = 0, math.ceil(-v.rangey/3)+1 do
					local y = math.floor((v.y+v.rangey-yscroll-.5+(j-1)*3-self.timer/self.animationtime*3*self.reverse)*16*scale)
					
					love.graphics.draw(img, math.floor((v.x-xscroll+1)*16*scale), y, math.pi/2, scale, scale)
				end
				
				love.graphics.draw(endimg, math.floor((v.x-xscroll-.5)*16*scale), math.floor((v.y-yscroll+v.rangey)*16*scale), -math.pi/2, scale, scale, 8, 8)
				
				love.graphics.setScissor()
			else
				local progress = v.timer/v.rangey
				if self.reverse == 1 then
					love.graphics.setScissor((v.x-xscroll-1)*16*scale, (v.y-yscroll-1.5)*16*scale, 2*16*scale, v.rangey*progress*16*scale)
				else
					love.graphics.setScissor((v.x-xscroll-1)*16*scale, (v.y-yscroll-1.5+v.rangey*(1-progress))*16*scale, 2*16*scale, v.rangey*progress*16*scale)
				end
				
				for j = 0, math.ceil(v.rangey/3)+1 do
					local y = math.floor((v.y-yscroll-1.5+(j-1)*3+self.timer/self.animationtime*3*self.reverse)*16*scale)
					
					love.graphics.draw(img, math.floor((v.x-xscroll+1)*16*scale), y, math.pi/2, scale, scale)
				end
				
				love.graphics.draw(endimg, math.floor((v.x-xscroll+.5)*16*scale), math.floor((v.y-yscroll+v.rangey-2)*16*scale), math.pi/2, scale, scale, 8, 8)
				
				love.graphics.setScissor()
			end
		end
	end
	
	love.graphics.setColor(255, 255, 255)
	if self.dir == "right" then
		love.graphics.draw(excursionbaseimg, excursionquad[self.quad], math.floor((self.cox-xscroll-1)*16*scale), math.floor((self.coy-yscroll-1.5)*16*scale), 0, scale, scale)
	elseif self.dir == "left" then
		love.graphics.draw(excursionbaseimg, excursionquad[self.quad], math.floor((self.cox-xscroll)*16*scale), math.floor((self.coy-yscroll+.5)*16*scale), math.pi, scale, scale)
	elseif self.dir == "up" then
		love.graphics.draw(excursionbaseimg, excursionquad[self.quad], math.floor((self.cox-xscroll-1)*16*scale), math.floor((self.coy-yscroll-.5)*16*scale), -math.pi/2, scale, scale)
	elseif self.dir == "down" then
		love.graphics.draw(excursionbaseimg, excursionquad[self.quad], math.floor((self.cox-xscroll+1)*16*scale), math.floor((self.coy-yscroll-1.5)*16*scale), math.pi/2, scale, scale)
	end
end

function funnel:updaterange()
	self.funneltable = {}
	
	local dir = self.dir
	local startx, starty = self.cox, self.coy
	local rangex, rangey = 0, 0
	local x, y = self.cox, self.coy
	
	local firstcheck = true
	local quit = false
	local collision = false
	
	while x >= 1 and x <= mapwidth and y >= 1 and y <= mapheight and not collision and (x ~= startx or y ~= starty or dir ~= self.dir or firstcheck == true) and quit == false do
		firstcheck = false
		
		if dir == "right" then
			x = x + 1
			rangex = rangex + 1
		elseif dir == "left" then
			x = x - 1
			rangex = rangex - 1
		elseif dir == "up" then
			y = y - 1
			rangey = rangey - 1
		elseif dir == "down" then
			y = y + 1
			rangey = rangey + 1
		end
		
		--check if current block is a portal
		local opp = "left"
		if dir == "left" then
			opp = "right"
		elseif dir == "up" then
			opp = "down"
		elseif dir == "down" then
			opp = "up"
		end
		
		local portalx, portaly, portalfacing, infacing, portalrealx, portalrealy, portal2realx, portal2realy = getPortal(x, y, opp)
		
		if portalx ~= false and ((dir == "left" and infacing == "right") or (dir == "right" and infacing == "left") or (dir == "up" and infacing == "down") or (dir == "down" and infacing == "up")) then
			--check if complete entry
			local pass = true
			if dir == "right" then
				if y ~= portal2realy-1 then
					pass = false
				end
			elseif dir == "left" then
				if y ~= portal2realy then
					pass = false
				end
			elseif dir == "up" then
				if x ~= portal2realx-1 then
					pass = false
				end
			elseif dir == "down" then
				if x ~= portal2realx then
					pass = false
				end
			end
			
			if pass then
				local dummy = {dir=dir, x=x-rangex, y=y-rangey, rangex=rangex, rangey=rangey, timer=0}
				
				table.insert(self.funneltable, dummy)
				
				x, y = portalrealx, portalrealy
			
				dir = portalfacing
				
				if dir == "down" then
					x = x-1
				elseif dir == "left" then
					y = y-1
				end
				
				rangex, rangey = 0, 0
				
				if dir == "right" then
					x = portalx + 1
				elseif dir == "left" then
					x = portalx - 1
					rangex = 0
				elseif dir == "up" then
					y = portaly - 1
				elseif dir == "down" then
					y = portaly + 1
				end
			end
		end
		
		--doors
		for i, v in pairs(objects["door"]) do
			if v.active then
				local secondx, secondy = x, y
				if dir == "right" then
					secondy = secondy + 1
				elseif dir == "left" then
					secondy = secondy + 1
				elseif dir == "up" then
					secondx = secondx + 1
				elseif dir == "down" then
					secondx = secondx + 1
				end
				if v.dir == "ver" then
					if (x == v.cox or secondx == v.cox) and ((y == v.coy or y == v.coy-1) or (secondy == v.coy or secondy == v.coy-1)) then
						quit = true
					end
				elseif v.dir == "hor" then
					if (y == v.coy or secondy == v.coy) and ((x == v.cox or x == v.cox+1) or (secondx == v.cox or secondx == v.cox+1)) then
						quit = true
					end
				end
			end
		end
		
		--get collision for next while
		if dir == "up" or dir == "down" then
			if not inmap(x+1, y) or (tilequads[map[x][y][1]]:getproperty("collision", x, y) and tilequads[map[x][y][1]]:getproperty("grate", x, y) == false) or
			(tilequads[map[x+1][y][1]]:getproperty("collision", x+1, y) and tilequads[map[x+1][y][1]]:getproperty("grate", x+1, y) == false) then
				collision = true
			end
		else
			if not inmap(x, y+1) or (tilequads[map[x][y][1]]:getproperty("collision", x, y) and tilequads[map[x][y][1]]:getproperty("grate", x, y) == false) or
			(tilequads[map[x][y+1][1]]:getproperty("collision", x, y+1) and tilequads[map[x][y+1][1]]:getproperty("grate", x, y+1) == false) then
				collision = true
			end
		end
	end
	
	if rangex ~= 0 or rangey ~= 0 then
		local dummy = {dir=dir, x=x-rangex, y=y-rangey, rangex=rangex, rangey=rangey, timer=0}
		
		table.insert(self.funneltable, dummy)
		
		if not self.lastblock or (self.lastblock[1] == x+rangex and self.lastblock[2] == y+rangey) then
			for i, v in pairs(self.funneltable) do
				v.timer = math.abs(v.rangex)+math.abs(v.rangey)
			end
		end	
		
		self.lastblock = {x+rangex, y+rangey}
	end
end

function funnel:input(t, input)
	if input == "reverse" then
		if t == "on" and self.input1state == "off" then
			self.reverse = -self.reverse
		elseif t == "off" and self.input1state == "on" then
			self.reverse = -self.reverse
		elseif t == "toggle" then
			self.reverse = -self.reverse
		end
		
		self.input1state = t
		
		for i, v in pairs(self.funneltable) do
			v.timer = 0
		end
	elseif input == "power" then
		if t == "on" and self.input2state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input2state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		
		self.input2state = t
	end
end
end end)()end;
do require("package").preload["entities.emancipateanimation"] = (function() local package;return function(...)-- <pack entities.emancipateanimation> --
emancipateanimation = class("emancipateanimation")

function emancipateanimation:init(x, y, width, height, img, quad, speedx, speedy, rotation, offsetX, offsetY, quadcenterX, quadcenterY)
	
	-- this would be static but it's not, call the cops
	self.effectdelay = 0.10
	self.effecttime = 0.4
	self.effectanimtime = 0.6
	self.effectfadeouttime = 0.2
	
	self.x = x
	self.y = y
	self.width = width
	self.height = height
	self.img = img
	self.quad = quad
	self.speedx = speedx
	self.speedy = speedy
	self.rotation = rotation
	self.offsetX = offsetX
	self.offsetY = offsetY
	self.quadcenterX = quadcenterX
	self.quadcenterY = quadcenterY
	self.emancemaxspeed = 3
	self.emanceaccel = 20
	
	self.speedx = math.max(-self.emancemaxspeed, math.min(self.emancemaxspeed, self.speedx))
	
	self.speedy = math.max(-self.emancemaxspeed, math.min(self.emancemaxspeed, self.speedy))
	
	self.rotationspeed = (math.random()-.5)*8
	self.timer = 0
	self.timer2 = 0
end

function emancipateanimation:update(dt)
	self.speedx = self.speedx + (math.random()-.5)*dt*self.emanceaccel
	self.speedy = self.speedy + (math.random()-.5)*dt*self.emanceaccel

	self.x = self.x + self.speedx*dt
	self.y = self.y + self.speedy*dt
	
	self.rotation = self.rotation + self.rotationspeed*dt
	
	if self.timer < self.effecttime-self.effectfadeouttime then
		self.timer2 = self.timer2 + dt
		while self.timer2 > self.effectdelay do
			emancipationfizzle:new(self.x+math.random()*self.width, self.y+math.random()*self.height, self.speedx, self.speedy)
			self.timer2 = self.timer2 - self.effectdelay
		end
	end
	
	self.timer = self.timer + dt
	if self.timer > self.effectanimtime then
		return true
	else
		return false
	end
end

function emancipateanimation:draw()
	local black = 1-self.timer/self.effectanimtime
	local a = math.min(1, 1-(self.timer-(self.effectanimtime-self.effectfadeouttime))/self.effectfadeouttime)

	love.graphics.setColor(255*black, 255*black, 255*black, 255*a)
	if self.quad then
		love.graphics.draw(self.img, self.quad, math.floor(((self.x-xscroll)*16+self.offsetX)*scale), math.floor(((self.y-yscroll)*16-self.offsetY)*scale), self.rotation, scale, scale, self.quadcenterX, self.quadcenterY)
	else
		love.graphics.draw(self.img, math.floor(((self.x-xscroll)*16+self.offsetX)*scale), math.floor(((self.y-yscroll)*16-self.offsetY)*scale), self.rotation, scale, scale, self.quadcenterX, self.quadcenterY)
	end
end
end end)()end;
do require("package").preload["entities.delayer"] = (function() local package;return function(...)-- <pack entities.delayer> --
delayer = class("delayer")

function delayer:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	
	self.outtable = {}
	self.delay = 1
	self.visible = true
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	--TIME
	if #self.r > 0 and self.r[1] ~= "link" then
		self.delay = tonumber(self.r[1]) or 1
		table.remove(self.r, 1)
	end
	
	self.timers = {}
end

function delayer:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function delayer:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function delayer:update(dt)
	local delete = {}
	
	for i = 1, #self.timers do
		local v = self.timers[i]
		v.timeleft = v.timeleft - dt
		if v.timeleft <= 0 then
			self:out(v.t)
		
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		table.remove(self.timers, v) --remove
	end
end

function delayer:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(delayerimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function delayer:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end

function delayer:input(t, input)
	table.insert(self.timers, {t=t, timeleft=self.delay})
end
end end)()end;
do require("package").preload["entities.animationtarget"] = (function() local package;return function(...)-- <pack entities.animationtarget> --
animationtarget = class("animationtarget")

function animationtarget:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	self.outtable = {}
	self.id = ""
	
	--IDENTIFIER
	if #self.r > 0 and self.r[1] ~= "link" then
		self.id = tostring(self.r[1])
		table.remove(self.r, 1)
	end
end

function animationtarget:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function animationtarget:addoutput(a, t)
	print("added output")
	table.insert(self.outtable, {a, t})
end

function animationtarget:out(t)
	for i = 1, #self.outtable do
		print("telling our dad")
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end
end end)()end;
do require("package").preload["entities.sfxentity"] = (function() local package;return function(...)-- <pack entities.sfxentity> --
sfxentity = class("sfxentity")

function sfxentity:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.visible = false
	self.r = {unpack(r)}
	self.single = true
	self.triggered = false
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	--Single Trigger
	if #self.r > 0 and self.r[1] ~= "link" then
		self.single = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	--SFX SOURCE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.sfxname = self.r[1]
		table.remove(self.r, 1)
	end
	
	self.outtable = {}
end

function sfxentity:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					print("trying to touch", v)
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function sfxentity:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(sfxentityimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function sfxentity:input(t, input)
	if t ~= "off" then
		if not self.triggered or not self.single then
			self.triggered = true
			if self.sfxname ~= "none.ogg" then
				playsound(self.sfxname, self.x, self.y)
			end
		end
	end
end

function sfxentity:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end
end end)()end;
do require("package").preload["entities.ceilblocker"] = (function() local package;return function(...)-- <pack entities.ceilblocker> --
ceilblocker = class("ceilblocker")

function ceilblocker:init(x)
	self.x = x-1
	self.y = -1000
	self.height = 1000
	self.width = 1
	self.moves = false
	self.active = true
end
end end)()end;
do require("package").preload["entities.musicentity"] = (function() local package;return function(...)-- <pack entities.musicentity> --
musicentity = class("musicentity")

function musicentity:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.visible = false
	self.r = {unpack(r)}
	self.single = true
	self.triggered = false
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	--Single Trigger
	if #self.r > 0 and self.r[1] ~= "link" then
		self.single = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	--MUSIC SOURCE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.musicname = self.r[1]
		table.remove(self.r, 1)
	end
end

function musicentity:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function musicentity:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(musicentityimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function musicentity:input(t, input)
	if t ~= "off" then
		if not self.triggered or not self.single then
			self.triggered = true
			stopmusic()
			if self.musicname ~= "none.ogg" then
				musicname = self.musicname
				playmusic()
			end
		end
	end
end
end end)()end;
do require("package").preload["entities.actionblock"] = (function() local package;return function(...)-- <pack entities.actionblock> --
actionblock = class("actionblock")

function actionblock:init(x, y)
	self.cox = x
	self.coy = y
	self.x = x-1
	self.y = y-1
	self.speedx = 0
	self.speedy = 0
	self.width = 1
	self.height = 1
	self.active = true
	self.moves = false
	self.category = 2
	self.mask = {true}
	
	self.state = "off"
	self.outtable = {}
	self.timer = blockbouncetime
end

function actionblock:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function actionblock:update(dt)
	if self.timer < blockbouncetime then
		self.timer = math.min(blockbouncetime, self.timer + dt)
	end
end

function actionblock:draw()
	local bounceyoffset = 0
	if self.timer < blockbouncetime then
		if self.timer < blockbouncetime/2 then
			bounceyoffset = self.timer / (blockbouncetime/2) * blockbounceheight
		else
			bounceyoffset = (2 - self.timer / (blockbouncetime/2)) * blockbounceheight
		end
	end
	
	local q = 1
	if self.state == "on" then
		q = 2
	end
	love.graphics.draw(actionblockimg, wallindicatorquad[q], math.floor((self.x-xscroll)*16*scale), math.floor((self.y-.5-yscroll-bounceyoffset)*16*scale), 0, scale, scale)
end

function actionblock:floorcollide(a, b, c, d)
	if self.state == "off" then
		self.state = "on"
	else
		self.state = "off"
	end
	if self.timer == blockbouncetime then
		self.timer = 0
	end
	
	self:out(self.state)
end

function actionblock:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end
end end)()end;
do require("package").preload["entities.orgate"] = (function() local package;return function(...)-- <pack entities.orgate> --
orgate = class("orgate")

function orgate:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.visible = false
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	self.outtable = {}
	self.inputstate = {}
	self.outputstate = "off"
end

function orgate:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
					self.inputstate[tonumber(self.r[2])] = "off"
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function orgate:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function orgate:update(dt)
	if self.initial then
		self.initial = false
	end
end

function orgate:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(orgateimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function orgate:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end

function orgate:input(t, input)
	if tonumber(input) then
		if t == "toggle" then
			if self.inputstate[tonumber(input)] == "on" then
				self.inputstate[tonumber(input)] = "off"
			else
				self.inputstate[tonumber(input)] = "on"
			end
		else
			self.inputstate[tonumber(input)] = t
		end
		
		local pass = "off"
		for i, v in ipairs(self.inputstate) do
			if v == "on" then
				pass = "on"
			end
		end
		
		if self.outputstate ~= pass then
			self:out(pass)
			self.outputstate = pass
		end
	end
end
end end)()end;
do require("package").preload["entities.animationtrigger"] = (function() local package;return function(...)-- <pack entities.animationtrigger> --
animationtrigger = class("animationtrigger")

function animationtrigger:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	
	--Input list
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--IDENTIFIER
	if #self.r > 0 and self.r[1] ~= "link" then
		self.id = tostring(self.r[1])
		table.remove(self.r, 1)
	end
end

function animationtrigger:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function animationtrigger:input(t, input)
	if input == "in" then
		if t == "on" or t == "toggle" then
			if not animationtriggerfuncs[self.id] then
				return
			end
			
			for i = 1, #animationtriggerfuncs[self.id] do
				animationtriggerfuncs[self.id][i]:trigger()
			end
		end
	end
end
end end)()end;
do require("package").preload["entities.textentity"] = (function() local package;return function(...)-- <pack entities.textentity> --
textentity = class("textentity")

function textentity:init(x, y, r)
	self.x = x
	self.y = y
	self.power = true
	self.text = ""
	
	self.red = 1
	self.green = 1
	self.blue = 1
	self.offsetx = 0
	self.offsety = .5
	
	--Input list
	self.input1state = "off"
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	--TEXT
	if #self.r > 0 and self.r[1] ~= "link" then
		self.text = self.r[1]
		table.remove(self.r, 1)
	end
	--POWER
	if #self.r > 0 and self.r[1] ~= "link" then
		self.power = not (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	--Red
	if #self.r > 0 and self.r[1] ~= "link" then
		self.red = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	--Green
	if #self.r > 0 and self.r[1] ~= "link" then
		self.green = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	--Blue
	if #self.r > 0 and self.r[1] ~= "link" then
		self.blue = tonumber(self.r[1])
		table.remove(self.r, 1)
	end
	
	--Offset X
	if #self.r > 0 and self.r[1] ~= "link" then
		self.offsetx = tonumber(self.r[1]) or 0
		table.remove(self.r, 1)
	end
	--Offset Y
	if #self.r > 0 and self.r[1] ~= "link" then
		self.offsety = tonumber(self.r[1]) or 0
		table.remove(self.r, 1)
	end
end

function textentity:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function textentity:input(t, input)
	if input == "power" then
		if t == "on" and self.input1state == "off" then
			self.power = not self.power
		elseif t == "off" and self.input1state == "on" then
			self.power = not self.power
		elseif t == "toggle" then
			self.power = not self.power
		end
		
		self.input1state = t
	end
end

function textentity:update(dt)
	
end

function textentity:draw()
	if self.power then
		love.graphics.setColor(self.red, self.green, self.blue)
		properprint(self.text, math.floor((self.x-xscroll-1-(1/16)+(self.offsetx/16))*16*scale), math.floor((self.y-yscroll-1-(8/16)+(self.offsety/16))*16*scale))
		--properprint("thank you " .. characters[mariocharacter[1]].name .. "!", math.floor(((mapwidth-12-xscroll)*16-1)*scale), (lastaxe.coy-4.5-yscroll)*16*scale)
		--properprint("but our princess is in", math.floor(((mapwidth-13.5-xscroll)*16-1)*scale), (lastaxe.coy-2.5-yscroll)*16*scale) --say what
		--properprint("another castle!", math.floor(((mapwidth-13.5-xscroll)*16-1)*scale), (lastaxe.coy-1.5-yscroll)*16*scale) --bummer.
		-- I don't know *why* I have to off-by-one the X and Y but that's the way I found it.
	end
end
end end)()end;
do require("package").preload["entities.rsflipflop"] = (function() local package;return function(...)-- <pack entities.rsflipflop> --
rsflipflop = class("rsflipflop")

function rsflipflop:init(x, y, r)
	self.x = x
	self.y = y
	self.cox = x
	self.coy = y
	self.visible = false
	self.r = {unpack(r)}
	table.remove(self.r, 1)
	table.remove(self.r, 1)
	
	--VISIBLE
	if #self.r > 0 and self.r[1] ~= "link" then
		self.visible = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	
	self.outtable = {}
	self.output = false
end

function rsflipflop:link()
	while #self.r > 3 do
		for j, w in pairs(outputs) do
			for i, v in pairs(objects[w]) do
				if tonumber(self.r[3]) == v.cox and tonumber(self.r[4]) == v.coy then
					v:addoutput(self, self.r[2])
				end
			end
		end
		
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
		table.remove(self.r, 1)
	end
end

function rsflipflop:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function rsflipflop:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(rsflipflopimg, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end

function rsflipflop:out(t)
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input(t, self.outtable[i][2])
		end
	end
end

function rsflipflop:input(t, input)
	if input == "set" then
		if (t == "on" or t == "toggle") and not self.output then
			self.output = true
			self:out("on")
		end
	elseif input == "reset" then
		if (t == "on" or t == "toggle") and self.output then
			self.output = false
			self:out("off")
		end
	end
end
end end)()end;
do require("package").preload["entities.enemy"] = (function() local package;return function(...)-- <pack entities.enemy> --
enemy = class("enemy")

function enemy:init(x, y, t, a)
	if not enemiesdata[t] then
		return nil
	end
	
	self.t = t
	if a then
		self.a = {unpack(a)}
	else
		self.a = {}
	end
	
	--Some standard values..
	self.rotation = 0
	self.active = true
	self.moves = true
	self.mask = {}
	self.gravitydirection = math.pi/2
	
	--self.combo = 1
	--why is this here? I dunno
	
	self.falling = false
	
	self.shot = false
	self.outtable = {}
	
	self.speedx = 0
	self.speedy = 0
	
	-- this is here so when things like koopa shells kill things, the player responsible gets points
	self.doesdamagetype = "touch"
	self.lastinfluence = nil --nil means "world", otherwise, it's an object reference
	
	self.health = 1
	
	--Get our enemy's properties from the property table
	for i, v in pairs(enemiesdata[self.t]) do
		self[i] = v
	end
	
	--Gameplaytype exclusivity
	if self.gamemodeexclusive then
		if gameplaytype ~= self.exclusivegamemode then
			self.active = false
			self.drawable = false
			self.destroy = true
		end
	end
	
	if self.customtimer then
		self.customtimertimer = 0
		self.currentcustomtimerstage = 1
	end

	--Decide on a random movement if it's random..
	if self.movementrandoms then
		self.movement = self.movementrandoms[math.random(#self.movementrandoms)]
	end
	
	self.x = x-.5-self.width/2+(self.spawnoffsetx or 0)
	self.y = y-self.height+(self.spawnoffsety or 0)
	
	if self.animationtype == "mirror" then
		self.animationtimer = 0
		self.animationdirection = "left"
	elseif self.animationtype == "frames" then
		self.quadi = self.animationstart
		self.quad = self.quadgroup[self.quadi]
		self.animationtimer = 0
	end
	
	if self.stompanimation then
		self.deathtimer = 0
	end
	
	if self.shellanimal then
		self.upsidedown = false
		self.resettimer = 0
		self.wiggletimer = 0
		self.wiggleleft = true
	end
	
	if self.kirbyenemy then
		self.upsidedown = false
		self.resettimer = 0
		self.wiggletimer = 0
		self.wiggleleft = true
	end
	
	if self.customscissor then
		self.customscissor = {unpack(self.customscissor)}
		self.customscissor[1] = self.customscissor[1] + x - 1
		self.customscissor[2] = self.customscissor[2] + y - 1
	end
	
	if self.starttowardsplayerhorizontal then --Prize for best property name
		local closestplayer = 1
		self.animationdirection = "right"
		local closestdist = math.huge
		for i = 1, #objects["player"] do
			local v = objects["player"][i]
			local dist = math.sqrt((v.x-self.x)^2+(v.y-self.y)^2)
			if dist < closestdist then
				closestdist = dist
				closestplayer = i
			end
		end
			
		if objects["player"][closestplayer] then
			if objects["player"][closestplayer].x < self.x then
				self.speedx = -math.abs(self.speedx)
				self.animationdirection = "right"
			else
				self.speedx = math.abs(self.speedx)
				self.animationdirection = "left"
			end
		end
	end
	
	self.spawnallow = true
	self.spawnedenemies = {}
	if self.movement == "piston" then
		self.pistontimer = self.pistonretracttime
		self.pistonstate = "retracting"
		
		if self.spawnonlyonextended then
			self.spawnallow = false
		end
	elseif self.movement == "flytime" then
		self.flyingtimer = 0
		self.startx = self.x
		self.starty = self.y
	elseif self.movement == "squid" then
		self.squidstate = "idle"
	end
	
	if self.speedxtowardsplayer then
		local closestplayer = 1
		local closestdist = math.sqrt((objects["player"][1].x-self.x)^2+(objects["player"][1].y-self.y)^2)
		for i = 2, players do
			local v = objects["player"][i]
			local dist = math.sqrt((v.x-self.x)^2+(v.y-self.y)^2)
			if dist < closestdist then
				closestdist = dist
				closestplayer = i
			end
		end
		
		if objects["player"][closestplayer].x + objects["player"][closestplayer].width/2 > self.x + self.width/2 then
			self:leftcollide("", {}, "", {})
			self.speedx = math.abs(self.speedx)
		else
			self:rightcollide("", {}, "", {})
			self.speedx = -math.abs(self.speedx)
		end
	end
	
	if self.lifetime and self.lifetime > 0 then
		self.lifetimer = self.lifetime
	end
	
	if self.jumps or self.jumpsalt then
		self.jumptimer = 0
	end
	
	self.firstmovement = self.movement
	self.firstanimationtype = self.animationtype
	self.startoffsetY = self.offsetY
	self.startquadcenterY = self.quadcenterY
	self.startoffsetY = self.offsetY
	self.startx = self.x
	self.starty = self.y
	self.startgravity = self.gravity
	
	if self.spawnsenemy then
		self.spawnenemytimer = 0
		self.spawnenemydelay = self.spawnenemydelays[math.random(#self.spawnenemydelays)]
	end
	
	self.throwanimationstate = 0
	
	if self.chasetime then
		self.chasetimer = 0
	end
	
	--enemy collide transform trigger
	if self.transforms then
		if string.sub(self.transformtrigger, 0, 11)  == "collidewith" then
			self.transformtriggerenemycollide = string.sub(self.transformtrigger, 12, string.len(self.transformtrigger))
		end
	end
	
	if self.spawnsound then
		playsound(self.spawnsound, self.x, self.y, self.speedx, self.speedy)
	end
	
	self.outtable = {}
end

function enemy:update(dt)
	--Funnels and fuck
	if self.funnel and not self.infunnel then
		self:enteredfunnel(true)
	end
	
	if self.infunnel and not self.funnel then
		self:enteredfunnel(false)
	end
	
	self.funnel = false
	if self.lifetimer then
		self.lifetimer = self.lifetimer - dt
		if self.lifetimer <= 0 then
			if self.transforms and self.transformtrigger == "lifetime" then
				self:transform(self.transformsinto)
			end
			self:output()
			self.dead = true
			
			return true
		end
	end
	
	if self.kill then
		self:output()
		self.dead = true
		
		return true
	end
	
	if self.stompanimation and self.dead then
		self.deathtimer = self.deathtimer + dt
		if self.deathtimer > 0.5 then
			self:output()
			
			return true
		else
			return false
		end
	end
	
	if not self.doesntunrotate then
		self.rotation = unrotate(self.rotation, self.gravitydirection, dt)
	end
	
	if self.shot then
		self.speedy = self.speedy + shotgravity*dt
		
		self.x = self.x+self.speedx*dt
		self.y = self.y+self.speedy*dt
		
		return false
	end
	
	if self.animationtype == "mirror" then
		self.animationtimer = self.animationtimer + dt
		while self.animationtimer > self.animationspeed do
			self.animationtimer = self.animationtimer - self.animationspeed
			if self.animationdirection == "left" then
				self.animationdirection = "right"
			else
				self.animationdirection = "left"
			end
		end
	elseif self.animationtype == "frames" then
		self.animationtimer = self.animationtimer + dt
		while self.animationtimer > self.animationspeed do
			self.animationtimer = self.animationtimer - self.animationspeed
			self.quadi = self.quadi + 1
			if self.quadi > self.animationstart + self.animationframes - 1 then
				self.quadi = self.quadi - self.animationframes
			end
			self.quad = self.quadgroup[self.quadi]
		end
		
		if self.speedx > 0 then
			self.animationdirection = "left"
		else
			self.animationdirection = "right"
		end
	end
	
	if self.spawnsenemy then
		self.spawnenemytimer = self.spawnenemytimer + dt
		while self.spawnenemytimer >= self.spawnenemydelay and self.spawnallow and (not self.spawnmax or self:getspawnedenemies() < self.spawnmax) do
			if self.spawnsenemyrandoms then
				self.spawnsenemy = self.spawnsenemyrandoms[math.random(#self.spawnsenemyrandoms)]
			end
			self:spawnenemy(self.spawnsenemy)
			self.spawnenemytimer = 0
			self.spawnenemydelay = self.spawnenemydelays[math.random(#self.spawnenemydelays)]
			self.throwanimationstate = 0
			if self.animationtype == "frames" then
				self.quad = self.quadgroup[self.quadi + self.throwanimationstate]
			end
		end
		
		if self.throwpreparetime and self.spawnenemytimer >= (self.spawnenemydelay - self.throwpreparetime) then
			self.throwanimationstate = self.throwquadoffset
			if self.animationtype == "frames" then
				self.quad = self.quadgroup[self.quadi + self.throwanimationstate]
			end
		end
	end	
	
	if self.movement == "truffleshuffle" then
		if self.speedx > 0 then
			if self.speedx > self.truffleshufflespeed then
				self.speedx = self.speedx - self.truffleshuffleacceleration*dt*2
				if self.speedx < self.truffleshufflespeed then
					self.speedx = self.truffleshufflespeed
				end
			elseif self.speedx < self.truffleshufflespeed then
				self.speedx = self.speedx + self.truffleshuffleacceleration*dt*2
				if self.speedx > self.truffleshufflespeed then
					self.speedx = self.truffleshufflespeed
				end
			end
		else
			if self.speedx < -self.truffleshufflespeed then
				self.speedx = self.speedx + self.truffleshuffleacceleration*dt*2
				if self.speedx > -self.truffleshufflespeed then
					self.speedx = -self.truffleshufflespeed
				end
			elseif self.speedx > -self.truffleshufflespeed then
				self.speedx = self.speedx - self.truffleshuffleacceleration*dt*2
				if self.speedx < -self.truffleshufflespeed then
					self.speedx = -self.truffleshufflespeed
				end
			end
		end
		
		if self.turnaroundoncliff and self.falling == false then
			--check if nothing below
			local x = math.floor(self.x + self.width/2+1)
			local y = math.floor(self.y + self.height+1.5)
			if inmap(x, y) and tilequads[map[x][y][1]]:getproperty("collision", x, y) == false and ((inmap(x+.5, y) and tilequads[map[math.ceil(x+.5)][y][1]]:getproperty("collision", math.ceil(x+.5), y)) or (inmap(x-.5, y) and tilequads[map[math.floor(x-.5)][y][1]]:getproperty("collision", math.floor(x-.5), y))) then
				if self.speedx < 0 then
					self.x = x-self.width/2
				else
					self.x = x-1-self.width/2
				end
				self.speedx = -self.speedx
			end
		end
		
	elseif self.movement == "shell" then
		if self.small then
			if self.wakesup then
				if math.abs(self.speedx) < 0.0001 then
					self.resettimer = self.resettimer + dt
					if self.resettimer > self.resettime then
						self.offsetY = self.startoffsetY
						self.quadcenterY = self.startquadcenterY
						self.quad = self.quadgroup[self.animationstart]
						self.small = false
						self.speedx = -self.truffleshufflespeed
						self.resettimer = 0
						self.upsidedown = false
						self.kickedupsidedown = false
						self.movement = self.firstmovement
						self.animationtype = self.firstanimationtype
						if self.resetspiny then
							self.stompable = false
						end
						if self.chasemarioonwakeup then
							local px = objects["player"][getclosestplayer(self.x)].x
							if px > self.x then
								self.speedx = -self.speedx
							end
						end
					elseif self.resettimer > self.resettime-self.wiggletime then
						self.wiggletimer = self.wiggletimer + dt
						while self.wiggletimer > self.wiggledelay do
							self.wiggletimer = self.wiggletimer - self.wiggledelay
							if self.wiggleleft then
								self.x = self.x + 1/16
							else
								self.x = self.x - 1/16
							end
							self.wiggleleft = not self.wiggleleft
						end
					end
				else
					self.resettimer = 0
				end
			end
		end
		
	elseif self.movement == "follow" then
		local nearestplayer = 1
			while objects["player"][nearestplayer] and objects["player"][nearestplayer].dead do
				nearestplayer = nearestplayer + 1
			end
		
			if objects["player"][nearestplayer] then
				local nearestplayerx = objects["player"][nearestplayer].x
				for i = 2, players do
					local v = objects["player"][i]
					if v.x > nearestplayerx and not v.dead then
						nearestplayer = i
					end
				end
			
			nearestplayerx = nearestplayerx + objects["player"][nearestplayer].speedx*self.distancetime
			
			local distance = math.abs(self.x - nearestplayerx)
			--check if too far in wrong direction
			if (not self.direction or self.direction == "left") and self.x < nearestplayerx-self.followspace then
				self.direction = "right"
				self.animationdirection = "right"
			elseif self.direction == "right" and self.x > nearestplayerx+self.followspace then
				self.direction = "left"
				self.animationdirection = "left"
			end
			
			if self.direction == "right" then
				if self.nofollowspeedup then
					self.speedx = self.followspeed or 2
				else
					self.speedx = math.max((self.followspeed or 2), round((distance-3)*2))
				end
			else
				self.speedx = -(self.followspeed or 2)
			end
		end
		--BOOFOLLOW
		--BOOFOLLOW
	elseif self.movement == "boofollow" then
		local nearestplayer = 1
		local boohide = false
		local b = objects["player"][nearestplayer] 
		
		while objects["player"][nearestplayer] and objects["player"][nearestplayer].dead do
			nearestplayer = nearestplayer + 1
		end
		
		if objects["player"][nearestplayer] then
			local nearestplayerx = objects["player"][nearestplayer].x
			local nearestplayery = objects["player"][nearestplayer].y
			for i = 2, players do
				local v = objects["player"][i]
				if v.x > nearestplayerx and not v.dead then
					nearestplayer = i
				end
			end
		
		nearestplayerx = nearestplayerx + objects["player"][nearestplayer].speedx*self.distancetime
		nearestplayery = nearestplayery + objects["player"][nearestplayer].speedy*self.distancetime
		
		local distance = math.abs(self.x - nearestplayerx)
		--check if too far in wrong direction
		if (not self.direction or self.direction == "left") and self.x < nearestplayerx-self.followspace then
			self.direction = "right"
			self.animationdirection = "right"
		elseif self.direction == "right" and self.x > nearestplayerx+self.followspace then
			self.direction = "left"
			self.animationdirection = "left"
		end
		
		if self.direction == "right" and boohide == false then
			if self.nofollowspeedup then
				self.speedx = self.followspeed or 2
			else
				self.speedx = math.max((self.followspeed or 2), round((distance-3)*2))
			end
		else
			self.speedx = -(self.followspeed or 2)
		end
		--Boo Hide Boode
		if b.angleframe == 1 or 2 then
			boohide = true
			
			
		elseif b.angleframe == 3 or 4 then
			boohide = false
			
		end
		
		-- Moving Up and Down left
		if self.direction == "left" and (self.y > nearestplayery-self.followspace) and lookedat == false then
			self.speedy = -(self.followspeed or 2)
		elseif self.direction == "left" and (self.y < nearestplayery-self.followspace) and lookedat == false then
			self.speedy = (self.followspeed or 2)
		end
		--Moving Up and Down right
		if self.direction == "right" and (self.y > nearestplayery-self.followspace) and lookedat == false then
				self.speedy = -(self.followspeed or 2)
		elseif self.direction == "right" and (self.y < nearestplayery-self.followspace) and lookedat == false then
			self.speedy = (self.followspeed or 2)
		end
		--Boo Hide True Things
		if lookedat == true then
			self.speedx = 0
			self.speedy = 0
		end
	end
	elseif self.movement == "piston" then
		self.pistontimer = self.pistontimer + dt
		
		if self.pistonstate == "extending" then		
			--move X
			if self.x > self.startx + self.pistondistx then
				self.x = self.x - self.pistonspeedx*dt
				if self.x < self.startx + self.pistondistx then
					self.x = self.startx + self.pistondistx
				end
			elseif self.x < self.startx + self.pistondistx then
				self.x = self.x + self.pistonspeedx*dt
				if self.x > self.startx + self.pistondistx then
					self.x = self.startx + self.pistondistx
				end
			end
			
			--move Y
			if self.y > self.starty + self.pistondisty then
				self.y = self.y - self.pistonspeedy*dt
				if self.y < self.starty + self.pistondisty then
					self.y = self.starty + self.pistondisty
				end
			elseif self.y < self.starty + self.pistondisty then
				self.y = self.y + self.pistonspeedy*dt
				if self.y > self.starty + self.pistondisty then
					self.y = self.starty + self.pistondisty
				end
			end
			
			if self.x == self.startx + self.pistondistx and self.y == self.starty + self.pistondisty and not self.spawnallow then
				self.spawnallow = true
				self.spawnenemytimer = self.spawnenemydelay
			end
			
			if self.pistontimer > self.pistonextendtime then
				self.pistontimer = 0
				self.spawnallow = false
				self.pistonstate = "retracting"
			end
			
			
		else --retracting			
			--move X
			if self.x > self.startx then
				self.x = self.x - self.pistonspeedx*dt
				if self.x < self.startx then
					self.x = self.startx
				end
			elseif self.x < self.startx then
				self.x = self.x + self.pistonspeedx*dt
				if self.x > self.startx then
					self.x = self.startx
				end
			end
			
			--move Y
			if self.y > self.starty then
				self.y = self.y - self.pistonspeedy*dt
				if self.y < self.starty then
					self.y = self.starty
				end
			elseif self.y < self.starty then
				self.y = self.y + self.pistonspeedy*dt
				if self.y > self.starty then
					self.y = self.starty
				end
			end
			
			if self.inactiveonretracted and self.x == self.startx and self.y == self.starty then
				self.active = false
			end
			
			if self.pistontimer > self.pistonretracttime then
				local playernear = false
				for i = 1, players do
					local v = objects["player"][i]
					if inrange(v.x+v.width/2, self.x+self.width/2-(self.dontpistondist or 3), self.x+self.width/2+(self.dontpistondist or 3)) then
						playernear = true
					end
				end
				
				if not self.dontpistonnearplayer or not playernear then
					self.pistontimer = 0
					self.pistonstate = "extending"
					self.active = true
				end
			end
		end
	elseif self.movement == "wiggle" then
		if self.speedx < 0 then
			if self.x < self.startx-self.wiggledistance then
				self.speedx = self.wigglespeed or 1
			end
		elseif self.speedx > 0 then
			if self.x > self.startx then
				self.speedx = -self.wigglespeed or 1
			end
		else
			self.speedx = self.wigglespeed or 1
		end
		
	elseif self.movement == "verticalwiggle" then
		if self.speedy < 0 then
			if self.y < self.starty-self.verticalwiggledistance then
				self.speedy = self.verticalwigglespeed or 1
			end
		elseif self.speedy > 0 then
			if self.y > self.starty then
				self.speedy = -self.verticalwigglespeed or 1
			end
		else
			self.speedy = self.verticalwigglespeed or 1
		end
		
	elseif self.movement == "rocket" then
		if self.y > self.starty+(self.rocketdistance or 15) and self.speedy > 0 then
			self.y = self.starty+(self.rocketdistance or 15)
			
			self.speedy = -math.sqrt(2*(self.gravity or yacceleration)*(self.rocketdistance or 15))
		end
		
		if self.speedy < 0 then
			self.upsidedown = false
		else
			self.upsidedown = true
		end
		
	elseif self.movement == "squid" then
		local closestplayer = 1
		local closestdist = math.sqrt((objects["player"][1].x-self.x)^2+(objects["player"][1].y-self.y)^2)
		for i = 2, players do
			local v = objects["player"][i]
			local dist = math.sqrt((v.x-self.x)^2+(v.y-self.y)^2)
			if dist < closestdist then
				closestdist = dist
				closestplayer = i
			end
		end
		
		if self.squidstate == "idle" then
			self.speedy = self.squidfallspeed
			
			--get if change state to upward
			if (self.y+self.speedy*dt) + self.height + 0.0625 >= (objects["player"][closestplayer].y - (24/16 - objects["player"][closestplayer].height)) then
				self.squidstate = "upward"
				self.upx = self.x
				self.speedx = 0
				self.speedy = 0
				
				if self.animationtype == "squid" then
					self.quad = self.quadgroup[2]
				end
				
				--get if to change direction
				if true then--math.random(2) == 1 then
					if self.direction == "right" then
						if self.x > objects["player"][closestplayer].x then
							self.direction = "left"
						end
					else
						if self.x < objects["player"][closestplayer].x then
							self.direction = "right"
						end
					end
				end
			end
			
		elseif self.squidstate == "upward" then
			if self.direction == "right" then
				self.speedx = self.speedx + self.squidacceleration*dt
				if self.speedx > self.squidxspeed then
					self.speedx = self.squidxspeed
				end
			else
				self.speedx = self.speedx - self.squidacceleration*dt
				if self.speedx < -self.squidxspeed then
					self.speedx = -self.squidxspeed
				end
			end
			
			self.speedy = self.speedy - self.squidacceleration*dt
			
			if self.speedy < -self.squidupspeed then
				self.speedy = -self.squidupspeed
			end
			
			if math.abs(self.x - self.upx) >= (self.squidhordistance or 2) then
				self.squidstate = "downward"
				self.downy = self.y
				self.speedx = 0
			end
			
		elseif self.squidstate == "downward" then
			self.speedy = self.squidfallspeed
			if self.y > self.downy + self.squiddowndistance then
				self.squidstate = "idle"
			end
			
			if self.animationtype == "squid" then
				self.quad = self.quadgroup[1]
			end
		end
		
	elseif self.movement == "targety" then
		if self.y > self.targety then
			self.y = self.y - self.targetyspeed*dt
			if self.y < self.targety then
				self.y = self.targety
			end
		elseif self.y < self.targety then
			self.y = self.y + self.targetyspeed*dt
			if self.y > self.targety then
				self.y = self.targety
			end
		end
	elseif self.movement == "flytime" then
		self.flyingtimer = self.flyingtimer + dt
		
		while self.flyingtimer > (self.flyingtime or 7) do
			self.flyingtimer = self.flyingtimer - (self.flyingtime or 7)
		end
		
		local newy = self:func(self.flyingtimer/(self.flyingtime or 7))*(self.flyingdisy or 0) + self.starty
		self.y = newy
		local newx = self:func(self.flyingtimer/(self.flyingtime or 7))*(self.flyingdisx or 0) + self.startx
		self.x = newx
	end
	
	if self.jumps then
		self.jumptimer = self.jumptimer + dt
		if self.jumptimer > self.jumptime then
			self.jumptimer = self.jumptimer - self.jumptime
			--decide whether up or down
			local dir
			if self.y > 12 then
				dir = "up"
			elseif self.y < 6 then
				dir = "down"
			else
				if math.random(2) == 1 then
					dir = "up"
				else
					dir = "down"
				end
			end
			
			if dir == "up" then
				self.speedy = -self.jumpforce
				self.mask[2] = true
				self.jumping = "up"
			else
				self.speedy = -self.jumpforcedown
				self.mask[2] = true
				self.jumping = "down"
				self.jumpingy = self.y
			end
		end
		
		if self.jumping then
			if self.jumping == "up" then
				if self.speedy > 0 then
					self.jumping = false
					self.mask[2] = false
				end
			elseif self.jumping == "down" then
				if self.y > self.jumpingy + self.height+1.1 then
					self.jumping = false
					self.mask[2] = false
				end
			end
		end
	end
	--Jumpsalt for Not hammer brothers jumping type
		if self.jumpsalt then
		self.jumptimer = self.jumptimer + dt
		if self.jumptimer > self.jumptime then
			self.jumptimer = self.jumptimer - self.jumptime
			--decide whether up or up
			local dir
			if self.y > 12 then
				dir = "up"
			elseif self.y < 6 then
				dir = "up"
			else
				if math.random(2) == 1 then
					dir = "up"
				else
					dir = "up"
				end
			end
			
			if dir == "up" then
				self.speedy = -self.jumpforce
				self.mask[2] = true
				self.jumping = "up"
			else
				self.speedy = -self.jumpforcedown
				self.mask[2] = true
				self.jumping = "down"
				self.jumpingy = self.y
			end
		end
		
		if self.jumping then
			if self.jumping == "up" then
				if self.speedy > 0 then
					self.jumping = false
					self.mask[2] = false
				end
			elseif self.jumping == "down" then
				if self.y > self.jumpingy + self.height+1.1 then
					self.jumping = false
					self.mask[2] = false
				end
			end
		end
	end
	
	if self.facesplayer then
		local closestplayer = 1
		local closestdist = math.sqrt((objects["player"][1].x-self.x)^2+(objects["player"][1].y-self.y)^2)
		for i = 2, players do
			local v = objects["player"][i]
			local dist = math.sqrt((v.x-self.x)^2+(v.y-self.y)^2)
			if dist < closestdist then
				closestdist = dist
				closestplayer = i
			end
		end
		
		if objects["player"][closestplayer].x + objects["player"][closestplayer].width/2 > self.x + self.width/2 then
			self.animationdirection = "left"
		else
			self.animationdirection = "right"
		end
	end
	
	if self.chasetime then
		if self.chasetimer > self.chasetime then
			local closestplayer = 1
			local closestdist = math.sqrt((objects["player"][1].x-self.x)^2+(objects["player"][1].y-self.y)^2)
			for i = 2, players do
				local v = objects["player"][i]
				local dist = math.sqrt((v.x-self.x)^2+(v.y-self.y)^2)
				if dist < closestdist then
					closestdist = dist
					closestplayer = i
				end
			end
			
			if objects["player"][closestplayer].x + objects["player"][closestplayer].width/2 < self.x + self.width/2 then
				self.speedx = -(self.chasespeed or 1.5)
			else
				self.chasetimer = 0
				self.startx = self.x
			end
		else
			self.chasetimer = self.chasetimer + dt
		end
	end
	
	--Check if player is near
	if self.transforms and (self.transformtrigger == "playernear" or self.transformtrigger == "playernotnear") then
		if type(self.playerneardist) == "number" then
			for i = 1, players do
				local v = objects["player"][i]
				if inrange(v.x+v.width/2, self.x+self.width/2-(self.playerneardist or 3), self.x+self.width/2+(self.playerneardist or 3)) then
					if self.transformtrigger == "playernear" then
						self:transform(self.transformsinto)
						return
					end
				elseif self.transformtrigger == "playernotnear" then
					self:transform(self.transformsinto)
					
				end
			end
		elseif type(self.playerneardist) == "table" and #self.playerneardist == 4 then
			local col = checkrect(self.x+self.playerneardist[1], self.y+self.playerneardist[2], self.x+self.playerneardist[1]+self.playerneardist[3], self.y+self.playerneardist[2]+self.playerneardist[4], {"player"})
			if #col > 0 then
				if self.transformtrigger == "playernear" then
					self:transform(self.transformsinto)
					return
				end
			elseif self.transformtrigger == "playernotnear" then
				self:transform(self.transformsinto)
				return
			end
		end
	end
	
	--Check if player if facing the enemy
	if self.staticifseen or self.staticifnotseen or (self.transforms and (self.transformtrigger == "seen" or self.transformtrigger == "notseen"))then
		local lookedat = false
		for i = 1, players do
			local v = objects["player"][i]
			if v.x+(self.width/2) > self.x+(self.width/2) then
				if v.portalsavailable[1] or v.portalsavailable[2] then
					if v.pointingangle > 0 then
						lookedat = true
					end
				else
					if v.animationdirection == "left" then
						lookedat = true
					end
				end
			else
				if v.portalsavailable[1] or v.portalsavailable[2] then
					if v.pointingangle < 0 then
						lookedat = true
					end
				else
					if v.animationdirection == "right" then
						lookedat = true
					end
				end
			end
		end
		if (self.transforms and self.transformtrigger == "notseen") or self.staticifnotseen then
			lookedat = not lookedat
		end
		if lookedat then
			if self.staticifseen or self.staticifnotseen then
				self.static = true
			else
				self:transform(self.transformsinto)
				return
			end
		else
			if self.staticifseen or self.staticifnotseen then
				self.static = false
			end
		end
	end
	
	if self.rotatetowardsplayer then
		for i = 1, players do
			local v = objects["player"][i]
			if not v.dead then
				self.rotation = (-math.atan2((v.x+v.width/2)-(self.x+self.width/2), (v.y+v.height/2)-(self.y+self.height/2-3/16)))-math.pi/2
			end
		end
	end
	
	if self.customtimer then
		self.customtimertimer = self.customtimertimer + dt
		while self.customtimertimer > self.customtimer[self.currentcustomtimerstage][1] do
			self.customtimertimer = self.customtimertimer - self.customtimer[self.currentcustomtimerstage][1]
			if self.customtimer[self.currentcustomtimerstage][2] and self.customtimer[self.currentcustomtimerstage][3] then
				self:customtimeraction(self.customtimer[self.currentcustomtimerstage][2], self.customtimer[self.currentcustomtimerstage][3])
			elseif self.customtimer[self.currentcustomtimerstage][2] then
				self:customtimeraction(self.customtimer[self.currentcustomtimerstage][2])
			end
			self.currentcustomtimerstage = self.currentcustomtimerstage + 1
			if self.currentcustomtimerstage > #self.customtimer then
				self.currentcustomtimerstage = 1
			end
		end
	end
end

function enemy:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function enemy:hurt(attacker, damagetype, damagetaken, ex)
	-- damagetype isn't used (yet) but it will help
	-- returns true if this would kill the enemy, false otherwise
	if self:evaluate_damagetype(damagetype) then
		self.health = self.health - damagetaken
		local waslethal = self.health <= 0
		local printtbl = {"DEBUG: enemy hurt by ", attacker, "doing", damagetype, "for", damagetaken, "damage"}
		if waslethal then
			printtbl[#printtbl]="damage -- so hard it died"
		end
		for k,v in pairs(printtbl) do
			print(k, v)
		end
		--print(unpack(printtbl))
		killfeed.new(attacker, damagetype, self, damagetaken)
		return waslethal
	else
		print("DEBUG: enemy WAS NOT HURT by ", attacker, "doing", damagetype, "for", damagetaken, "damage")
	end
end

function enemy:murder(attacker, reason)
	--@TODO: killfeed stuff here
	
end

function enemy:evaluate_damagetype(dtype)
	-- return true if we could potentially be hurt
	-- only focus on the conditions that result in death, generic no-death return at end
	if dtype == "fireball" then
		return not self.resistsfire
	elseif dtype == "star" then
		return not self.resistsstar
	elseif dtype == "stomp" then
		-- if we can be stomped but aren't in a shell, this hurts us
		return self.stompable and not self.shellanimal 
	elseif dtype == "shell" then
		-- there's no form of immunity for the shell
		return true
	elseif dtype == "bump" then
		return not self.notkilledfromblocksbelow
	else
		print("WARNING: Tried to evaluate unknown damagetype ",dtype, "run as 'suicide'.")
		return true
	end
	
	return false --nothing that we care about
end

function enemy:setinfluence(influencer)
	self.lastinfluence = influencer
end

function enemy:do_damage(damagetype, attacker, ...)
	--print("DEBUG: do_damage called with", damagetype, attacker, ...)
	if self["damage_"..damagetype] then
		self["damage_"..damagetype](self, attacker, ...)
	else
		print("CRITICAL: Tried to process unknown damage callback -- ",damagetype)
	end
end

-- these are all damage type evaluators
function enemy:damage_stomp(attacker)
	local soundtoplay
	if self.stompable then
		-- stuff to do regardless of hurt
		if self.kirbyenemy then
			soundtoplay = "kirbyenemy"
		elseif self.shellanimal then
			soundtoplay = "stomp"
			if self.small then
				soundtoplay = "shot"
			end
		end
		playsound(soundtoplay, self.x, self.y, self.speedx, self.speedy)
		
		if self.transforms and self.transformtrigger == "stomp" then
			--@WARNING: we're not determining if we're dying here, so the transform trigger is premature
			self:transform(self.transformsinto)
			return
		end
		
		if self.givecoinwhenstomped then
			attacker:getcoin(1)
		end
		
		if self:hurt(attacker, "stomp", 1) then
			if self.transforms and self.transformtrigger == "death" then
				self:transform(self.transformsinto)
				return
			end
			
			self.active = false
			if self.stompanimation then
				self.quad = self.quadgroup[self.stompedframe]
				if self.fallswhenstomped then
					self.shot = true
					self.gravity = shotgravity
				else
					self.dead = true
				end
			else
				self.shot = true
				self.gravity = shotgravity
			end
		else
			-- non-lethal, do shell stuff
			if not self.small then
				print("DEBUG: case 1")
				self.quadcenterY = 19
				self.offsetY = 0
				self.quad = self.quadgroup[self.smallquad]
				self.small = true
				self.movement = self.smallmovement
				self.speedx = 0
				self.animationtype = "none"
				playsound("stomp", self.x, self.y, self.speedx, self.speedy)
			elseif self.speedx == 0 then
				print("DEBUG: case 2")
				playsound("shot", self.x, self.y, self.speedx, self.speedy)
				attacker:getscore(500, self.x, self.y) --koopa got kicked or something
				if self.x > attacker.x then
					self.speedx = self.smallspeed
					self.x = attacker.x+12/16+self.smallspeed*gdt
					if b then
						self.size = b.size
					else
						self.size = 1
					end
					self.killsenemies = true
					self:setinfluence(attacker)
				else
					self.speedx = -self.smallspeed
					self.x = attacker.x-self.width-self.smallspeed*gdt
					if attacker then
						--@WARNING: I don't understand this branch but I'm just rolling with it.
						self.size = attacker.size
					else
						self.size = 1
					end
					self.killsenemies = true
					self:setinfluence(attacker)
				end
			else
				print("DEBUG: case 3")
				playsound("shot", self.x, self.y, self.speedx, self.speedy)
				self.speedx = 0
				self.combo = 1
			end
		end
	end
end

function enemy:damage_shell(attacker, dir)
	if self.givecoinwhenshot then
		attacker:getcoin(1)
	end
	
	if self.transforms and self.transformtrigger == "shell" then
		self:transform(self.transformsinto)
		return false
	end
	
	playsound("shot", self.x, self.y, self.speedx, self.speedy)
	
	if self:hurt(attacker, "shell", 1) then
		if self.transforms and self.transformtrigger == "death" then
			self:transform(self.transformsinto)
			return false
		end
		self.speedy = -(self.shotjumpforce or shotjumpforce)
		self.direction = dir or "right"
		self.gravity = shotgravity
		
		if self.direction == "left" then
			self.speedx = -(self.shotspeedx or shotspeedx)
		else
			self.speedx = self.shotspeedx or shotspeedx
		end
		
		if self.shellanimal then
			self.small = true
			self.quad = self.quadgroup[self.smallquad]
		end
		
		self.shot = true
		self.active = false
		
		if self.doesntflyawayonfireball then
			self.kill = true
			self.drawable = false
		end
		return true
	end
end

function enemy:damage_physics(attacker, dir)
	if self:hurt(attacker, "physics", 1) then
		attacker:getscore(self.firepoints or
						score_enum.generic_firepoints or
						enemy_score_enum.fireball[self.t],
					self.x, self.y)
		self:neo_shotted(attacker, "physics", dir)
	end
end
function enemy:damage_fireball(attacker, dir)
	if self:hurt(attacker, "fireball", 1) then
		attacker:getscore(self.firepoints or
						score_enum.generic_firepoints or
						enemy_score_enum.fireball[self.t],
					self.x, self.y)
		self:neo_shotted(attacker, "fireball", dir)
	end
end
function enemy:damage_star(attacker, dir)
	if self:hurt(attacker, "star", 1) then
		attacker:getscore(self.firepoints or
						score_enum.generic_firepoints or
						enemy_score_enum.fireball[self.t],
					self.x, self.y)
		self:neo_shotted(attacker, "star", dir)
	end
end
function enemy:damage_bump(attacker, dir)
	if self:hurt(attacker, "bump", 1) then
		attacker:getscore(score_enum.underside_bump, self.x, self.y)
		self:neo_shotted(attacker, "bump", dir, true)
	end
end
function enemy:damage_suicide(attacker)
	if self:hurt(attacker, "suicide", 1) then
		-- no, giving score to a suicide doesn't make sense, but I don't want to write another generic kill handler
		attacker:getscore(enemy_score_enum.fireball[self.t], self.x, self.y)
		self:neo_shotted(attacker, "suicide")
	end
end
--w:do_damage("bump", self, dir, true)

function enemy:neo_shotted(attacker, damagetype, dir, below, high)
	if self.givecoinwhenshot then
		attacker:getcoin(1)
	end
	
	if self.transforms and self.transformtrigger == damagetype then
		self:transform(self.transformsinto)
		return
	end --self.transformtrigger == "death"
	
	playsound("shot", self.x, self.y, self.speedx, self.speedy)
	
	self.speedy = -(self.shotjumpforce or shotjumpforce)
	if high then
		self.speedy = self.speedy*2
	end
	self.direction = dir or "right"
	self.gravity = shotgravity
	
	if self.direction == "left" then
		self.speedx = -(self.shotspeedx or shotspeedx)
	else
		self.speedx = self.shotspeedx or shotspeedx
	end
	
	if self.shellanimal then
		self.small = true
		self.quad = self.quadgroup[self.smallquad]
		if below then
			-- bumping and the like
			self.upsidedown = true
			self.kickedupsidedown = true
			self.stompable = true
			self.offsetY = 4
			self.movement = self.smallmovement
			self.animationtype = "none"
		else
			self.shot = true
			self.active = false
		end
	else
		self.shot = true
		self.active = false
	end
	
	if self.doesntflyawayonfireball and damagetype == "fireball" then
		self.kill = true
		self.drawable = false
	end
	
	return true
end

function enemy:legacy_shotted(dir, below, high, fireball, star)
	-- this shouldn't be called, it's just here to look pretty
	if fireball and self.resistsfire then
		return false
	end
	
	if star and self.resistsstar then
		return false
	end
	
	if self.shothealth then
		if self.shothealth > 1 then
			self.shothealth = self.shothealth - 1
			return
		end
	elseif self.health and not self.shothealth then
		if self.health > 1 then
			self.health = self.health - 1
			return
		end
	end
	
	if self.givecoinwhenshot then
		collectcoin(nil, nil, 1)
	end
	
	if self.transforms and (self.transformtrigger == "shot" or self.transformtrigger == "death") then
		self:transform(self.transformsinto)
		return
	end
	
	playsound("shot", self.x, self.y, self.speedx, self.speedy)
	
	self.speedy = -(self.shotjumpforce or shotjumpforce)
	if high then
		self.speedy = self.speedy*2
	end
	self.direction = dir or "right"
	self.gravity = shotgravity
	
	if self.direction == "left" then
		self.speedx = -(self.shotspeedx or shotspeedx)
	else
		self.speedx = self.shotspeedx or shotspeedx
	end
	
	if self.shellanimal then
		self.small = true
		self.quad = self.quadgroup[self.smallquad]
		if below then
			self.upsidedown = true
			self.kickedupsidedown = true
			self.offsetY = 4
			self.movement = self.smallmovement
			self.animationtype = "none"
		else
			self.shot = true
			self.active = false
		end
	else
		self.shot = true
		self.active = false
	end
	
	if self.doesntflyawayonfireball then
		self.kill = true
		self.drawable = false
	end
	
	return true
end

function enemy:customtimeraction(action, arg)
	if action == "bounce" then
		if self.speedy == 0 then
			self.speedy = -(arg or 10)
		end
	elseif action == "playsound" then
		playsound(arg, self.x, self.y, self.speedx, self.speedy)
	elseif string.sub(action, 0, 7) == "reverse" then
		local parameter = string.sub(action, 8, string.len(action))
		if not self[parameter] then return end
		if type(self[parameter]) ~= "number" then return end
		self[parameter] = -self[parameter]
	elseif string.sub(action, 0, 3) == "add" then
		local parameter = string.sub(action, 8, string.len(action))
		if not self[parameter] or not arg or tonumber(arg) == nil then return end
		if type(self[parameter]) ~= "number" then return end
		self[parameter] = self[parameter] + arg
	elseif string.sub(action, 0, 8) == "multiply" then
		local parameter = string.sub(action, 8, string.len(action))
		if not self[parameter] or not arg or tonumber(arg) == nil then return end
		if type(self[parameter]) ~= "number" then return end
		self[parameter] = self[parameter] * arg
	elseif action == "setframe" then
		self.quad = self.quadgroup[arg]
	elseif string.sub(action, 0, 3) == "set" then
		if not arg then --if arg is nil set it to false
			self[string.sub(action, 4, string.len(action))] = false
		else
			self[string.sub(action, 4, string.len(action))] = arg
		end
	end
end

function enemy:func(i) -- 0-1 in please
	return (-math.cos(i*math.pi*2)+1)/2
end

function enemy:globalcollide(a, b, c, d, dir)
	if a == "tile" then
		if not self.resistsspikes then
			dir = twistdirection(self.gravitydirection, dir)
			if dir == "ceil" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikesbottom", b.cox, b.coy) then
				self:shotted()
				return false
			elseif dir == "right" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikesleft", b.cox, b.coy) then
				self:shotted()
				return false
			elseif dir == "left" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikesright", b.cox, b.coy) then
				self:shotted()
				return false
			elseif dir == "floor" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikestop", b.cox, b.coy) then
				self:shotted()
				return false
			end
		end
	end

	if a == "platform" or a == "seesawplatform" then
		if dir == "floor" then
			if self.jumping and self.speedy < -jumpforce + 0.1 then
				return true
			end
		else
			return true
		end
	end
	
	if a == "player" and self.removeonmariocontact then
		self.kill = true
		self.drawable = false
		return true
	end

	if a == "player" then
		return true
	end
	
	if self.killsenemies and a == "enemy" then
		return true
	end
	
	if a == "fireball" and self.resistsfire then
		return true
	end
	
	if b.killsenemies then
		local dir = "right"
		if b.speedx < 0 then
			dir = "left"
		end
		
		if b.lastinfluence then
			if b.doesdamagetype then
				--print("DEBUG: hurt points =", firepoints[self.t])
				self:do_damage(b.doesdamagetype, b.lastinfluence, dir)
				b.lastinfluence:getcombo(1, "shell", self.x, self.y, true)
			else
				print("WARNING: Something tried to kill something else without a definite damagetype.")
			end
		else
			print("WARNING: Something attempted to kill something else without being influenced by a player.")
		end
		return true
	end
	
	if self.transforms and (self.transformtrigger == "globalcollide" or self.transformtrigger == "collide") then
		if self.transformtriggerenemycollide then
			if a == "enemy" and b.t == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		elseif self.transformtriggerobjectcollide then
			if a == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		else
			self:transform(self.transformsinto)
		end
		return true
	end
	
	if self.breaksblocks then
		if self.breakblockside == "global" and a == "tile" then
			hitblock(b.cox, b.coy, self, true)
		end
	end
	
	if self.nocollidestops or b.nocollidestops then
		return true
	end
end

function enemy:leftcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "left") then
		return false
	end
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
	
	if self.transforms and self.transformtrigger == "leftcollide" then
		if self.transformtriggerenemycollide then
			if a == "enemy" and b.t == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		elseif self.transformtriggerobjectcollide then
			if a == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		else
			self:transform(self.transformsinto)
		end
		return
	end
	
	if self.reflects then
		self.speedx = -self.speedx
	end
	
	if self.breaksblocks then
		if (self.breakblockside == "sides" or self.breakblockside == "left") and a == "tile" then
			hitblock(b.cox, b.coy, self, true)
		end
	end
	
	if self.movement == "truffleshuffle" then
		self.speedx = self.truffleshufflespeed
		if not self.dontmirror then
			self.animationdirection = "left"
		end
		return false
	elseif self.small then
		if a ~= "enemy" then
			self.speedx = self.smallspeed
			
			if a == "tile" then
				hitblock(b.cox, b.coy, self, true)
			else
				playsound("blockhit", self.x, self.y, self.speedx, self.speedy)
			end
			return false
		end
	end
end

function enemy:rightcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "right") then
		return false
	end
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
	
	if self.transforms and self.transformtrigger == "rightcollide" then
		if self.transformtriggerenemycollide then
			if a == "enemy" and b.t == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		elseif self.transformtriggerobjectcollide then
			if a == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		else
			self:transform(self.transformsinto)
		end
		return
	end
	
	if self.reflects then
		self.speedx = -self.speedx
	end
	
	if self.breaksblocks then
		if (self.breakblockside == "sides" or self.breakblockside == "right") and a == "tile" then
			hitblock(b.cox, b.coy, self, true)
		end
	end
	
	if self.movement == "truffleshuffle" then
		self.speedx = -self.truffleshufflespeed
		if not self.dontmirror then
			self.animationdirection = "right"
		end
		return false
	elseif self.small then
		if a ~= "enemy" then
			self.speedx = -self.smallspeed
			
			if a == "tile" then
				hitblock(b.cox, b.coy, self, true)
			else
				playsound("blockhit", self.x, self.y, self.speedx, self.speedy)
			end
			return false
		end
	end
end

function enemy:ceilcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "ceil") then
		return false
	end
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
	
	if self.transforms and self.transformtrigger == "ceilcollide" then
		if self.transformtriggerenemycollide then
			if a == "enemy" and b.t == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		elseif self.transformtriggerobjectcollide then
			if a == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		else
			self:transform(self.transformsinto)
		end
		return
	end
	
	if self.reflects then
		self.speedy = -self.speedy
	end
	
	if self.breaksblocks then
		if self.breakblockside == "ceil" and a == "tile" then
			hitblock(b.cox, b.coy, self, true)
		end
	end
end

function enemy:floorcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "floor") then
		return false
	end
	
	if self.transforms and self.transformtrigger == "floorcollide" then
		if self.transformtriggerenemycollide then
			if a == "enemy" and b.t == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		elseif self.transformtriggerobjectcollide then
			if a == self.transformtriggerenemycollide then
				self:transform(self.transformsinto)
			end
		else
			self:transform(self.transformsinto)
		end
		return
	end
	
	if self.reflects then
		self.speedy = -self.speedy
	end
	
	if self.bounces then
		self.speedy = -(self.bounceforce or 10)
	end
	
	if self.kickedupsidedown then
		self.speedx = 0
		self.kickedupsidedown = false
	end
	
	self.falling = false
end

function enemy:passivecollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "passive") then
		return false
	end
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
end

function enemy:startfall()
	self.falling = true
end

function enemy:legacy_stomp(x, b)
	if self.stompable then
		if self.stomphealth then
			if self.stomphealth > 1 then
				self.stomphealth = self.stomphealth - 1
				return
			end
		elseif self.health and not self.stomphealth then
			if self.health > 1 then
				self.health = self.health - 1
				return
			end
		end
	
		if self.transforms and (self.transformtrigger == "stomp" or self.transformtrigger == "death") then
			self:transform(self.transformsinto)
			return
		end
		
		if self.givecoinwhenstomped then
			collectcoin(nil, nil, 1)
		end
		
		if self.shellanimal then
			if not self.small then
				self.quadcenterY = 19
				self.offsetY = 0
				self.quad = self.quadgroup[self.smallquad]
				self.small = true
				self.movement = self.smallmovement
				self.speedx = 0
				self.animationtype = "none"
			elseif self.speedx == 0 then
				if self.x > x then
					self.speedx = self.smallspeed
					self.x = x+12/16+self.smallspeed*gdt
					if b then
						self.size = b.size
					else
						self.size = 1
					end
					self.killsenemies = true
				else
					self.speedx = -self.smallspeed
					self.x = x-self.width-self.smallspeed*gdt
					if b then
						self.size = b.size
					else
						self.size = 1
					end
					self.killsenemies = true
				end
			else
				self.speedx = 0
				self.combo = 1
			end
		else
			self.active = false
			if self.stompanimation then
				self.quad = self.quadgroup[self.stompedframe]
				if self.fallswhenstomped then
					self.shot = true
					self.gravity = shotgravity
				else
					self.dead = true
				end
			else
				self.shot = true
				self.gravity = shotgravity
			end
		end
	end
end

function enemy:autodeleted()
	self.dead = true
	self:output()
end

function enemy:output()
	for i = 1, #self.outtable do
		if self.outtable[i][1].input then
			self.outtable[i][1]:input("toggle", self.outtable[i][2])
		end
	end
end

function enemy:addoutput(a, t)
	table.insert(self.outtable, {a, t})
end

function enemy:portaled(theportal, entereddir, exitdir)
	if self.killsenemiesafterportal then
		--@NOTE: This is only in here because we didn't add an option or ruleset for changing influencers.
		if theportal.parent then
			--the portal belonged to someone, reset our influence
			self:setinfluence(theportal.parent)
		end
		self.killsenemies = true
	end
end

function enemy:spawnenemy(t)
	local speedx, speedy = 0, 0
	if self.spawnenemyspeedx then
		speedx = self.spawnenemyspeedx
	end
	if self.spawnenemyspeedy then
		speedy = self.spawnenemyspeedy
	end
	if self.spawnmomentum then
		if objects["player"][1].x < self.x then
			speedx = self.speedx + math.random(-6,2)
		else
			speedx = self.speedx + math.random(-2,6)
		end
	end
	
	if (self.spawnenemyspeedxrandomstart and self.spawnenemyspeedxrandomend) then
		speedx = math.random()*(self.spawnenemyspeedxrandomend-self.spawnenemyspeedxrandomstart) + self.spawnenemyspeedxrandomstart
	end
	
	if (self.spawnenemyspeedyrandomstart and self.spawnenemyspeedyrandomend) then
		speedy = math.random()*(self.spawnenemyspeedyrandomend-self.spawnenemyspeedyrandomstart) + self.spawnenemyspeedyrandomstart
	end
	
	local closestplayer = 1
	local closestdist = math.sqrt((objects["player"][1].x-self.x)^2+(objects["player"][1].y-self.y)^2)
	for i = 2, players do
		local v = objects["player"][i]
		local dist = math.sqrt((v.x-self.x)^2+(v.y-self.y)^2)
		if dist < closestdist then
			closestdist = dist
			closestplayer = i
		end
	end

	if self.spawnenemytowardsplayer then
		
		local a = -math.atan2(objects["player"][closestplayer].x-self.x, objects["player"][closestplayer].y-self.y)+math.pi/2
		
		speedx = math.cos(a)*self.spawnenemyspeed
		speedy = math.sin(a)*self.spawnenemyspeed
	end
	
	if self.spawnenemyspeedxtowardsplayer then
		if objects["player"][closestplayer].x + objects["player"][closestplayer].width/2 > self.x + self.width/2 then
			speedx = math.abs(speedx)
		else
			speedx = -math.abs(speedx)
		end
	end
	
	local xoffset = self.spawnenemyoffsetx or 0
	local yoffset = self.spawnenemyoffsety or 0
	
	local temp = enemy:new(self.x+self.width/2+.5+xoffset, self.y+self.height+yoffset, t, {})
	table.insert(objects["enemy"], temp)
	
	temp.speedx = speedx
	temp.speedy = speedy
	
	if temp.movement == "truffleshuffle" and temp.speedx > 0 then
		temp.animationdirection = "left"
	end
	
	table.insert(self.spawnedenemies, temp)
	temp.spawner = self
end

function enemy:transform(t)
	local xoffset = self.transformsoffsetx or 0
	local yoffset = self.transformsoffsety or 0
	if self.transformsintorandoms then
		self.transformsinto = self.transformsintorandoms[math.random(#self.transformsintorandoms)]
	end

	local temp = enemy:new(self.x+self.width/2+.5+xoffset, self.y+self.height+yoffset, t, {})
	
	if self.transformpassedparameters then
		for i = 1, #self.transformpassedparameters do
			if self.transformpassedparameters[i] ~= nil then
				temp[self.transformpassedparameters[i]] = self[self.transformpassedparameters[i]]
			end
		end
	end
	
	table.insert(objects["enemy"], temp)
	
	if self.spawner then
		table.insert(self.spawner.spawnedenemies, temp)
	end
	
	self.kill = true
end

function enemy:emancipate()
	if not self.kill then
		table.insert(objects["emancipateanimation"], emancipateanimation:new(self.x, self.y, self.width, self.height, self.graphic, self.quad, self.speedx, self.speedy, self.rotation, self.offsetX, self.offsetY, self.quadcenterX, self.quadcenterY))
		self.kill = true
		self.drawable = false
	end
end

function enemy:laser(guns, pewpew)
	if not self.laserresistant then
		self:shotted()
	end
end

function enemy:enteredfunnel(inside)
	if inside then
		self.infunnel = true
	else
		self.infunnel = false
		self.gravity = self.startgravity
	end
end

function enemy:getspawnedenemies()
	local count = 0
	for i, v in pairs(self.spawnedenemies) do
		if not v.dead then
			count = count + 1
		end
	end
	
	return count
end
end end)()end;
do require("package").preload["entities.portalprojectileparticle"] = (function() local package;return function(...)-- <pack entities.portalprojectileparticle> --
portalprojectileparticle = class("portalprojectileparticle")

function portalprojectileparticle:init(x, y, color, r, g, b)
	self.x = x
	self.y = y
	self.color = color
	
	
	self.speedx = math.random(-10, 10)/70
	self.speedy = math.random(-10, 10)/70
	
	self.alpha = 150
	
	self.timer = 0
end

function portalprojectileparticle:update(dt)
	self.timer = self.timer + dt
	
	self.speedx = self.speedx + math.random(-10, 10)/70
	self.speedy = self.speedy + math.random(-10, 10)/70
	
	self.x = self.x + self.speedx*dt
	self.y = self.y + self.speedy*dt
	
	self.alpha = self.alpha - dt*300
	if self.alpha < 0 then
		self.alpha = 0
		return true
	end
end

function portalprojectileparticle:draw()
	local r, g, b = unpack(self.color)
	love.graphics.setColor(r, g, b, self.alpha)
	
	love.graphics.draw(portalprojectileparticleimg, math.floor((self.x-xscroll)*16*scale), math.floor((self.y-yscroll-.5)*16*scale), 0, scale, scale, 2, 2)
end
end end)()end;
do require("package").preload["entities.smokepuff"] = (function() local package;return function(...)-- <pack entities.smokepuff> --
smokepuff = class("smokepuff")

function smokepuff:init(x, y)
	self.x = x
	self.y = y
	self.timer = 0
end

function smokepuff:update(dt)
	self.timer = self.timer + dt
	
	if self.timer > smokepuffdelay then
		return true
	end
	
	if self.destroy then
	return true
	end
end

function smokepuff:draw()
	local framelength = smokepuffdelay/3
	local frame = 1
	if self.timer > framelength*1.1 then
		frame = 2
	end
	if self.timer > framelength*1.25 then
		frame = 3
	end
	if self.timer > framelength*1.5 then
		frame = 4
	end
	love.graphics.draw(smokepuffimg, smokepuffquads[frame], math.floor((self.x-xscroll)*16*scale),((self.y-yscroll)*16*scale)-8*scale, 0, scale, scale)
	if self.timer > framelength*1.7 then
		self.destroy=true
		return true
	end
end
end end)()end;
do require("package").preload["entities.pswitch"] = (function() local package;return function(...)-- <pack entities.pswitch> --
pswitch = class("pswitch")

function pswitch:init(x, y, r)
	self.cox = x
	self.coy = y
	
	self.x = x-1
	self.y = y-1
	self.width = 1
	self.height = 1
	self.frame = 1
	self.speedy = 0
	self.speedx = 0
	self.moves = false
	self.active = true
	self.destroy = false
	self.inuse = false
	self.liveone = false
	self.color = 1
	
	self.quadcenterX = 8
	self.quadcenterY = 8
	self.gravitydirection = math.pi/2
	
	self.falling = false
	self.rotation = 0
	self.drawable = false
	self.type = "blue"
	self.reusable = false
	self.carryable = false
	
	self.r = {unpack(r)}
	--r == the map data at map[x][y]
	table.remove(self.r, 1) --r[1] == tile index, can be used to look up properties in tilequads{}
	table.remove(self.r, 1) --r[2] == entity index, can be used to look up generic base entity in entitylist{}
	-- all indexes of r after this point are those that you defined by the rightclick menu.
	-- P-Switch Type
	if #self.r > 0 and self.r[1] ~= "link" then
		self.type = self.r[1]
		table.remove(self.r, 1)
	end
	-- Reusability
	if #self.r > 0 and self.r[1] ~= "link" then
		self.reusable = (self.r[1] == "true")
		table.remove(self.r, 1)
	end
	-- Carryable, Changes graphic
	if #self.r > 0 and self.r[1] ~= "link" then
		self.carryable = (self.r[1] == "true")
		table.remove(self.r, 1)
	end

	self.category = 19
	
	self.mask = {true}
	
	if self.carryable == true then
		self.frame = 3
	end
	
	if self.type == "blue" then
	self.color = 1
	elseif self.type == "grey" then
	self.color = 2
	end
	
end

function pswitch:update(dt)
	if self.destroy == true then
		return true
	end
	if pswitchactive["blue"] == true then -- Timers
		pswitchtimers["blue"] = pswitchtimers["blue"] + dt
		--print("Blue P-Switch is Active: '"..pswitchtimers["blue"].."' seconds.")
	end
	if pswitchactive["grey"] == true then
		pswitchtimers["grey"] = pswitchtimers["grey"] + dt
		--print("Grey P-Switch is Active: '"..pswitchtimers["grey"].."' seconds.")
	end
	
	if pswitchtimers["blue"] >= pswitchtime and self.inuse == true then -- Out of Time
		self.inuse = false
		pswitchtimers["blue"] = 0
		pswitchactive["blue"] = false
		
		if self.carryable == false then
			self.frame = 1
			print("Pop up the P-Switch.")
		elseif self.carryable == true then
			self.frame = 3
			print("Pop up the carryable P-Switch.")
		end
		
		print("Time up on Blue P-Switches.")
	end
	if pswitchtimers["grey"] >= pswitchtime and self.inuse == true then
		self.inuse = false
		pswitchtimers["grey"] = 0
		pswitchactive["grey"] = false
		
		if self.carryable == false then
			self.frame = 1
			print("Pop up the P-Switch.")
		elseif self.carryable == true then
			self.frame = 3
			print("Pop up the carryable P-Switch.")
		end
		
		print("Time up on Grey P-Switches.")
	end

	if pswitchactive["blue"] == false and pswitchactive["grey"] == false and switchtimeout == true then
		switchtimeout = false
		self:dead()
		print("Destroy that obnoxious music.")
	end
end

function pswitch:draw()
		love.graphics.draw(pswitchimg, pswitchquads[self.color][self.frame], math.floor((self.x-xscroll)*16*scale),((self.y-yscroll)*16*scale)-8*scale, 0, scale, scale)
end

function pswitch:hit()
	if self.inuse == false then
		if self.type == "blue" then -- Set Timer for the type.
			pswitchactive["blue"] = true
			pswitchtimers["blue"] = 0
		elseif self.type == "grey" then
			pswitchactive["grey"] = true
			pswitchtimers["grey"] = 0
		end
		
		if self.reusable == true then -- Check for Reusability.
			self.inuse = true
			print("P-Switch is flattened: It's reusable.")
		elseif self.reusable == false then
			self.destroy = true
			table.insert(objects["smokepuff"], smokepuff:new(self.x, self.y))
			print("P-Switch is destroy: No Reuse.")
		end
		
		
		if self.carryable == true and self.inuse == true then -- Graphical Guff.
			self.frame = 4
			print("P-Switch is carryable.")
		elseif self.carryable == false and self.inuse == true then
			self.frame = 2
			print("P-Switch is attached to the ground.")
		end

		switchtimeout = true
		playsound("switch", self.x, self.y)
		pswitch:alive() -- Obnoxiously overwrite the music every time someone hits one.
	end
end

function pswitch:alive()
	stopmusic()
	music:play("switchmusic.ogg")
end

function pswitch:dead()
	playmusic()
	music:stop("switchmusic.ogg")
end
end end)()end;
do require("package").preload["animatedtimer"] = (function() local package;return function(...)-- <pack animatedtimer> --
animatedtimer = class("animatedtimer")
animatedtimerlist = {}

function animatedtimer:init(x, y, tileno)
	self.x = x
	self.y = y 
	self.quadi = 1
	self.timer = 0
	self.quadobj = tilequads[tileno]
	self.delays = self.quadobj.delays
	self.frametimes = {}
	self.length = 0
	for i = 1, #self.delays do
		self.length = self.length + self.delays[i]
		self.frametimes[i] = self.length
	end
	self.dir = 0
	
	table.insert(animatedtimerlist, self)
end

function animatedtimer:update(dt)
	local oldi = self:geti()
	self.timer = self.timer + dt*self.dir
	
	if self.timer > self.length then
		self.timer = self.length
		self.dir = 0
	elseif self.timer < 0 then
		self.timer = 0
		self.dir = 0
	end
	local newi = self:geti()
	
	if oldi ~= newi then
		local oldcol = self.quadobj.properties[oldi].collision
		local oldportalable = self.quadobj.properties[oldi].portalable
		
		local props = self.quadobj.properties[newi]
		
		if oldcol ~= props.collision then
			if props.collision then
				objects["tile"][self.x .. "-" .. self.y] = tile:new(self.x-1, self.y-1)
			else
				objects["tile"][self.x .. "-" .. self.y] = nil
				checkportalremove(self.x, self.y)
			end
		end
		
		if oldportalable ~= props.portalable then
			if not props.portalable then
				checkportalremove(self.x, self.y)
			end
		end
	end
end

function animatedtimer:input(t)
	if t == "on" then
		self.dir = 1
	elseif t == "off" then
		self.dir = -1
	elseif t == "toggle" then
		self.dir = -self.dir
		
		if self.dir == 0 then
			if self.timer == 0 then
				self.dir = 1
			else
				self.dir = -1
			end
		end
	end
end

function animatedtimer:geti()
	for i = 2, #self.frametimes do
		if self.timer > self.frametimes[i-1] and self.timer <= self.frametimes[i] then
			return i
		end
	end
	
	return 1
end
end end)()end;
do require("package").preload["enemies"] = (function() local package;return function(...)-- <pack enemies> --
function enemies_load()
	defaultvalues = {quadcount=1, quadno=1}

	enemiesdata = {}
	enemies = {}
	
	--ENEMIIIIEEES
	loaddelayed = {}
	
	local fl = love.filesystem.getDirectoryItems("enemies/")
	local fl2 = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/enemies/")
	
	local realfl = {}
	
	for i = 1, #fl do
		table.insert(realfl, "enemies/" .. fl[i]) --STANDARD ENEMIES
	end
	
	for i = 1, #fl2 do
		table.insert(realfl, "mappacks/" .. mappack .. "/enemies/" .. fl2[i]) --MAPPACK ENEMIES
	end
	
	for i = 1, #realfl do
		if string.sub(realfl[i], -4) == "json" then
			loadenemy(realfl[i])
		end
	end
end

function loadenemy(filename)
	local ss = filename:split("/")
	local folder = ""
	for i = 1, #ss-1 do
		folder = folder .. ss[i] .. "/"
	end
	
	local s = string.sub(ss[#ss], 1, -6):lower()
	
	--CHECK FOR - , ; * AND WHATEVER ELSE WOULD BREAK MAPS
	local skip = false
	local badlist = {",", ";", "-", "*"} --badlist sounds like a movie
	for i = 1, #badlist do
		if s:find(badlist[i]) then
			skip = true
		end
	end
	
	if not skip then --bad letter
		local data = love.filesystem.read(filename)
		data = data:gsub("\r", "")
		
		if string.sub(data, 1, 4) == "base" then
			local split = data:split("\n")
			local base = string.sub(split[1], 6)
			if enemiesdata[base] then
				local newdata = ""
				for i = 2, #split do
					newdata = newdata .. split[i]
					if i ~= #split then
						newdata = newdata .. "\n"
					end
				end
				
				enemiesdata[s] = usebase(enemiesdata[base])
				
				local temp = JSON:decode(newdata)
				
				for i, v in pairs(temp) do
					enemiesdata[s][i] = v
				end
			else
				--Put enemy for later loading because base hasn't been loaded yet
				if not success then
					if not loaddelayed[base] then
						loaddelayed[base] = {}
					end
					table.insert(loaddelayed[base], filename)
					print("ENEMIES: Didn't have base " .. base .. " for " .. s ..", loading later.")
				end
				return
			end
		else
			enemiesdata[s] = JSON:decode(data)
		end
		
		--CASE INSENSITVE THING
		for i, v in pairs(enemiesdata[s]) do
			local a = i:lower()
			if a == "offsetx" then
				enemiesdata[s]["offsetX"] = v
			elseif a == "offsety" then
				enemiesdata[s]["offsetY"] = v
			elseif a == "quadcenterx" then
				enemiesdata[s]["quadcenterX"] = v
			elseif a == "quadcentery" then
				enemiesdata[s]["quadcenterY"] = v
			else
				if type(v) == "string" then
					enemiesdata[s][a] = v:lower()
				else
					enemiesdata[s][a] = v
				end
			end
		end
		
		for i, v in pairs(defaultvalues) do
			if enemiesdata[s][i] == nil then
				enemiesdata[s][i] = v
			end
		end
		
		--Load graphics if it exists
		for i,j in pairs(enemygraphicsearchdirs) do
			j = j % {mappack=mappack,file=s..".png",graphicspack=graphicspack}
			if love.filesystem.exists(j) then
				enemiesdata[s].graphic = love.graphics.newImage(j)
				break
			end
		end
		if enemiesdata[s].graphic == nil then
			-- presumably, our graphics are derived from something else
			print("ENEMIES: "..s.." had no matching png and wasn't BASEd on anything!")
			enemiesdata[s].graphic = love.graphics.newImage("graphics/DEFAULT/nographic.png")
		end
		
		--Set up quads if given
		if enemiesdata[s].graphic and enemiesdata[s].quadcount then
			local imgwidth, imgheight = enemiesdata[s].graphic:getWidth(), enemiesdata[s].graphic:getHeight()
			local quadwidth = imgwidth/enemiesdata[s].quadcount
			local quadheight = imgheight/4
			
			if math.floor(quadwidth) == quadwidth and math.floor(quadheight) == quadheight then
				if enemiesdata[s].nospritesets then
					quadheight = quadheight*4
				end
				
				enemiesdata[s].quadbase = {}
				
				for y = 1, 4 do
					enemiesdata[s].quadbase[y] = {}
					for x = 1, enemiesdata[s].quadcount do
						local realy = (y-1)*quadheight
						if enemiesdata[s].nospritesets then
							realy = 0
						end
						enemiesdata[s].quadbase[y][x] = love.graphics.newQuad((x-1)*quadwidth, realy, quadwidth, quadheight, imgwidth, imgheight)
					end
				end
			end
		end
		
		--check if graphic for enemy exists
		if enemiesdata[s].quadbase and enemiesdata[s].graphic then
			enemiesdata[s].drawable = true
			enemiesdata[s].quadgroup = enemiesdata[s].quadbase[spriteset]
			if enemiesdata[s].animationtype == "frames" then
				enemiesdata[s].quad = enemiesdata[s].quadbase[spriteset][enemiesdata[s].animationstart]
			else
				enemiesdata[s].quad = enemiesdata[s].quadbase[spriteset][enemiesdata[s].quadno]
			end
		end
		
		table.insert(enemies, s)
		
		
		if loaddelayed[s] and #loaddelayed[s] > 0 then
			for j = #loaddelayed[s], 1, -1 do
				loadenemy(loaddelayed[s][j]) --RECURSIVE PROGRAMMING AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH
				table.remove(loaddelayed, j)
			end
		end
	else
		--Bad.
	end
end

function usebase(t)
	local r = {}
	
	for i, v in pairs(t) do
		r[i] = v
	end
	
	return r
end
end end)()end;
do require("package").preload["hatconfigs"] = (function() local package;return function(...)-- <pack hatconfigs> --
local i
hat = {}

i = 1
hat[i] = {}
hat[i].x = 7
hat[i].y = 2
hat[i].height = 2
hat[i].graphic = love.graphics.newImage("standardhats/standard.png")

i = 2
hat[i] = {}
hat[i].x = 5
hat[i].y = -3
hat[i].height = 4
hat[i].graphic = love.graphics.newImage("standardhats/tyrolean.png")

i = 3
hat[i] = {}
hat[i].x = 5
hat[i].y = -1
hat[i].height = 4
hat[i].graphic = love.graphics.newImage("standardhats/towering1.png")

i = 4
hat[i] = {}
hat[i].x = 5
hat[i].y = -6
hat[i].height = 8
hat[i].graphic = love.graphics.newImage("standardhats/towering2.png")

i = 5
hat[i] = {}
hat[i].x = 5
hat[i].y = 1
hat[i].height = 2
hat[i].graphic = love.graphics.newImage("standardhats/towering3.png")

i = 6
hat[i] = {}
hat[i].x = 5
hat[i].y = -7
hat[i].height = 10
hat[i].graphic = love.graphics.newImage("standardhats/drseuss.png")

i = 7
hat[i] = {}
hat[i].x = 4
hat[i].y = -7
hat[i].height = 8
hat[i].graphic = love.graphics.newImage("standardhats/bird.png")

i = 8
hat[i] = {}
hat[i].x = 4
hat[i].y = -1
hat[i].height = 3
hat[i].graphic = love.graphics.newImage("standardhats/banana.png")

i = 9
hat[i] = {}
hat[i].x = 7
hat[i].y = -2
hat[i].height = 3
hat[i].graphic = love.graphics.newImage("standardhats/beanie.png")

i = 10
hat[i] = {}
hat[i].x = 7
hat[i].y = -5
hat[i].height = 8
hat[i].graphic = love.graphics.newImage("standardhats/toilet.png")

i = 11
hat[i] = {}
hat[i].x = 5
hat[i].y = -4
hat[i].height = 5
hat[i].graphic = love.graphics.newImage("standardhats/indian.png")

i = 12
hat[i] = {}
hat[i].x = 6
hat[i].y = -1
hat[i].height = 3
hat[i].graphic = love.graphics.newImage("standardhats/officerhat.png")

i = 13
hat[i] = {}
hat[i].x = 5
hat[i].y = -3
hat[i].height = 6
hat[i].graphic = love.graphics.newImage("standardhats/crown.png")

i = 14
hat[i] = {}
hat[i].x = 5
hat[i].y = -5
hat[i].height = 9
hat[i].graphic = love.graphics.newImage("standardhats/tophat.png")

i = 15
hat[i] = {}
hat[i].x = 6
hat[i].y = 1
hat[i].height = 2
hat[i].graphic = love.graphics.newImage("standardhats/batter.png")

i = 16
hat[i] = {}
hat[i].x = 6
hat[i].y = 0
hat[i].height = 2
hat[i].graphic = love.graphics.newImage("standardhats/bonk.png")

i = 17
hat[i] = {}
hat[i].x = 6
hat[i].y = 0
hat[i].height = 3
hat[i].graphic = love.graphics.newImage("standardhats/bakerboy.png")

i = 18
hat[i] = {}
hat[i].x = 5
hat[i].y = 1
hat[i].height = 2
hat[i].graphic = love.graphics.newImage("standardhats/troublemaker.png")

i = 19
hat[i] = {}
hat[i].x = 7
hat[i].y = 1
hat[i].height = 3
hat[i].graphic = love.graphics.newImage("standardhats/whoopee.png")

i = 20
hat[i] = {}
hat[i].x = 6
hat[i].y = -1
hat[i].height = 4
hat[i].graphic = love.graphics.newImage("standardhats/milkman.png")

i = 21
hat[i] = {}
hat[i].x = 6
hat[i].y = 1
hat[i].height = 2
hat[i].graphic = love.graphics.newImage("standardhats/bombingrun.png")

i = 22
hat[i] = {}
hat[i].x = 4
hat[i].y = 3
hat[i].height = 0
hat[i].graphic = love.graphics.newImage("standardhats/bonkboy.png")

i = 23
hat[i] = {}
hat[i].x = 6
hat[i].y = 0
hat[i].height = 3
hat[i].graphic = love.graphics.newImage("standardhats/flippedtrilby.png")

i = 24
hat[i] = {}
hat[i].x = 7
hat[i].y = 0
hat[i].height = 3
hat[i].graphic = love.graphics.newImage("standardhats/superfan.png")

i = 25
hat[i] = {}
hat[i].x = 6
hat[i].y = -2
hat[i].height = 4
hat[i].graphic = love.graphics.newImage("standardhats/familiarfez.png")

i = 26
hat[i] = {}
hat[i].x = 3
hat[i].y = 0
hat[i].height = 4
hat[i].graphic = love.graphics.newImage("standardhats/santahat.png")

i = 27
hat[i] = {}
hat[i].x = 6
hat[i].y = 0
hat[i].height = 2
hat[i].graphic = love.graphics.newImage("standardhats/sailor.png")

i = 28
hat[i] = {}
hat[i].x = 3
hat[i].y = -3
hat[i].height = 5
hat[i].graphic = love.graphics.newImage("standardhats/koopa.png")


table.insert(hat, {x = 5, y = -5, height = 5, graphic = love.graphics.newImage("standardhats/blooper.png")})

--30:
table.insert(hat, {x = 7, y = 1, height = 2, graphic = love.graphics.newImage("standardhats/shyguy.png")})

table.insert(hat, {x = 6, y = 4, height = 4, graphic = love.graphics.newImage("standardhats/goodnewseverybody.png")})

table.insert(hat, {x = 5, y = 1, height = 4, graphic = love.graphics.newImage("standardhats/jetset.png")})

table.insert(hat, {x = 6, y = 0, height = 2, graphic = love.graphics.newImage("standardhats/jotaro.png")})

table.insert(hat, {x = 7, y = -2, height = 4, graphic = love.graphics.newImage("standardhats/dio.png")})

table.insert(hat, {x = 5, y = -2, height = 14, graphic = love.graphics.newImage("standardhats/flabber.png")})

table.insert(hat, {x = 5, y = -2, height = 14, graphic = love.graphics.newImage("standardhats/he.png")})

table.insert(hat, {x = 5, y = 0, height = 14, graphic = love.graphics.newImage("standardhats/mario3coon.png")})

table.insert(hat, {x = 2, y = -7, height = 14, graphic = love.graphics.newImage("standardhats/hothead.png")})

table.insert(hat, {x = 2, y = -6, height = 14, graphic = love.graphics.newImage("standardhats/praisethesun.png")})

table.insert(hat, {x = 2, y = -6, height = 14, graphic = love.graphics.newImage("standardhats/flycap.png")})

table.insert(hat, {x = 5, y = -3, height = 14, graphic = love.graphics.newImage("standardhats/konamim.png")})

table.insert(hat, {x = 2, y = -5, height = 14, graphic = love.graphics.newImage("standardhats/bighead.png")})
end end)()end;
do require("package").preload["animationguiline"] = (function() local package;return function(...)-- <pack animationguiline> --
animationguiline = class("animationguiline")

animationlist = {}
local toenter = {}

--TRIGGERS:

table.insert(toenter, {name = "mapload",
	t = {
		t="trigger",
		nicename="on map load",
		entries={
			 
		}
	}
})

table.insert(toenter, {name = "animationtrigger",
	t = {
		t="trigger",
		nicename="animation trigger",
		entries={
			{
				t="text",
				value="with id",
			},
			
			{
				t="input",
				default="myanim",
			},
		}
	}
})

table.insert(toenter, {name = "timepassed",
	t = {
		t="trigger",
		nicename="after seconds:",
		entries={
			{
				t="numinput",
				default="1"
			},
		}
	}
})

table.insert(toenter, {name = "playerxgreater",
	t = {
		t="trigger",
		nicename="player's x position >",
		entries={
			{
				t="numinput"
			},
		}
	}
})

table.insert(toenter, {name = "playerxless",
	t = {
		t="trigger",
		nicename="player's x position <",
		entries={
			{
				t="numinput"
			},
		}
	}
})

table.insert(toenter, {name = "playerygreater",
	t = {
		t="trigger",
		nicename="player's y position >",
		entries={
			{
				t="numinput"
			},
		}
	}
})

table.insert(toenter, {name = "playeryless",
	t = {
		t="trigger",
		nicename="player's y position <",
		entries={
			{
				t="numinput"
			},
		}
	}
})



--CONDITIONS:

table.insert(toenter, {name = "noprevsublevel", 
	t = {
		t="condition",
		nicename="map started here",
		entries={
			
		}
	}
})

table.insert(toenter, {name = "worldequals", 
	t = {
		t="condition",
		nicename="world is number",
		entries={
			{
				t="worldselection",
			}
		}
	}
})

table.insert(toenter, {name = "levelequals", 
	t = {
		t="condition",
		nicename="level is number",
		entries={
			{
				t="levelselection",
			}
		}
	}
})

table.insert(toenter, {name = "sublevelequals",
	t= {
		t="condition",
		nicename="sublevel is number",
		entries={
			{
				t="sublevelselection",
			}
		}
	}
})

table.insert(toenter, {name = "requirecoins",
	t= {
		t="condition",
		nicename="require coins",
		entries={
			{
				t="numinput",
			}
		}
	}
})

--ACTIONS:

table.insert(toenter, {name = "disablecontrols", 
	t = {
		t="action",
		nicename="disable controls",
		entries={
			{
				t="text",
				value="of"
			},
			
			{
				t="playerselection",
			},
		}
	}
})

table.insert(toenter, {name = "enablecontrols", 
	t = {
		t="action",
		nicename="enable controls",
		entries={
			{
				t="text",
				value="of"
			},
			
			{
				t="playerselection",
			},
		}
	}
})

table.insert(toenter, {name = "sleep", 
	t = {
		t="action",
		nicename="sleep/wait",
		entries={
			{
				t="numinput",
				default="1",
			},
			
			{
				t="text",
				value="seconds",
			},
		}
	}
})

table.insert(toenter, {name = "animationtarget", 
	t = {
		t="action",
		nicename="trigger animation target",
		entries={
			{
				t="text",
				value="with id",
			},
			{
				t="input",
				default="mytarget",
			},
		}
	}
})

table.insert(toenter, {name = "setcamerax", 
	t = {
		t="action",
		nicename="set camera to x:",
		entries={
			{
				t="numinput",
			},
		}
	}
})

table.insert(toenter, {name = "setcameray", 
	t = {
		t="action",
		nicename="set camera to y:",
		entries={		
			{
				t="numinput",
			},
		}
	}
})

table.insert(toenter, {name = "pancameratox", 
	t = {
		t="action",
		nicename="pan camera to x:",
		entries={
			{
				t="numinput",
			},
			
			{
				t="text",
				value="over",
			},
			
			{
				t="numinput",
			},
			
			{
				t="text",
				value="seconds",
			}
		}
	}
})

table.insert(toenter, {name = "pancameratoy", 
	t = {
		t="action",
		nicename="pan camera to y:",
		entries={
			{
				t="numinput",
			},
			
			{
				t="text",
				value="over",
			},
			
			{
				t="numinput",
			},
			
			{
				t="text",
				value="seconds",
			}
		}
	}
})

table.insert(toenter, {name = "disablescroll", 
	t = {
		t="action",
		nicename="disable scrolling",
		entries={
		
		}
	}
})

table.insert(toenter, {name = "enablescroll", 
	t = {
		t="action",
		nicename="enable scrolling",
		entries={
		
		}
	}
})

table.insert(toenter, {name = "setx", 
	t = {
		t="action",
		nicename="move player to x:",
		entries={
			{
				t="playerselection"
			},
			
			{
				t="text",
				value="to x=",
			},
			
			{
				t="numinput"
			}
		}
	}
})

table.insert(toenter, {name = "sety", 
	t = {
		t="action",
		nicename="move player to y:",
		entries={
			{
				t="playerselection"
			},
			
			{
				t="text",
				value="to y=",
			},
			
			{
				t="numinput"
			}
		}
	}
})

table.insert(toenter, {name = "playerwalk", 
	t = {
		t="action",
		nicename="animate to walk:",
		entries={
			{
				t="playerselection",
			},
			
			{
				t="text",
				value="towards"
			},
			
			{
				t="directionselection",
			}
		}
	}
})

table.insert(toenter, {name = "playeranimationstop", 
	t = {
		t="action",
		nicename="stop playeranimations:",
		entries={
			{
				t="playerselection",
			}
		}
	}
})

table.insert(toenter, {name = "disableanimation", 
	t = {
		t="action",
		nicename="disable this animation",
		entries={
			
		}
	}
})

table.insert(toenter, {name = "enableanimation", 
	t = {
		t="action",
		nicename="enable this anim",
		entries={
			
		}
	}
})

table.insert(toenter, {name = "playerjump", 
	t = {
		t="action",
		nicename="make jump:",
		entries={
			{
				t="playerselection",
			}
		}
	}
})

table.insert(toenter, {name = "playerstopjump", 
	t = {
		t="action",
		nicename="stop jumping:",
		entries={
			{
				t="playerselection",
			}
		}
	}
})

table.insert(toenter, {name = "dialogbox", 
	t = {
		t="action",
		nicename="create dialog",
		entries={
			{
				t="text",
				value="with text"
			},
			
			{
				t="input",
				length=192
			},
			
			{
				t="text",
				value="and speaker"
			},
			
			{
				t="input"
			},
		}
	}
})

table.insert(toenter, {name = "removedialogbox", 
	t = {
		t="action",
		nicename="destroy dialogs",
		entries={
			
		}
	}
})

table.insert(toenter, {name = "playmusic", 
	t = {
		t="action",
		nicename="play music",
		entries={
			{
				t="musicselection"
			}
		}
	}
})

table.insert(toenter, {name = "screenshake", 
	t = {
		t="action",
		nicename="shake the screen",
		entries={
			{
				t="text",
				value="with"
			},
			
			{
				t="numinput",
			},
			
			{
				t="text",
				value="force",
			}
		}
	}
})

table.insert(toenter, {name = "addcoins", 
	t = {
		t="action",
		nicename="add coins",
		entries={
			{
				t="playerselection",
			},
			{
				t="numinput",
				default="1"
			},
			{
				t="text",
				value="coins"
			}
		}
	}
})

table.insert(toenter, {name = "addpoints", 
	t = {
		t="action",
		nicename="add points",
		entries={
			{
				t="playerselection",
			},
			{
				t="numinput",
				default="1"
			},
			
			{
				t="text",
				value="points"
			}
		}
	}
})

table.insert(toenter, {name = "changebackgroundcolor", 
	t = {
		t="action",
		nicename="change background color",
		entries={
			{
				t="text",
				value="to r"
			},
			
			{
				t="numinput",
				default="255"
			},
			
			{
				t="text",
				value="g"
			},
			
			{
				t="numinput",
				default="255"
			},
			
			{
				t="text",
				value="b"
			},
			
			{
				t="numinput",
				default="255"
			},
		}
	}
})

table.insert(toenter, {name = "killplayer", 
	t = {
		t="action",
		nicename="kill player:",
		entries={
			{
				t="playerselection",
			}
		}
	}
})

table.insert(toenter, {name = "changetime", 
	t = {
		t="action",
		nicename="change time left",
		entries={
			{
				t="text",
				value="to"
			},
		
			{
				t="numinput",
				default="400"
			}
		}
	}
})

table.insert(toenter, {name = "loadlevel", 
	t = {
		t="action",
		nicename="load level:",
		entries={
			{
				t="text",
				value="world"
			},
		
			{
				t="numinput",
				default="1"
			},
			
			{
				t="text",
				value="level"
			},
		
			{
				t="numinput",
				default="1"
			},
			
			{
				t="text",
				value="sublevel"
			},
		
			{
				t="numinput",
				default="0"
			}
		}
	}
})

table.insert(toenter, {name = "disableplayeraim", 
	t = {
		t="action",
		nicename="disable aiming",
		entries={
			{
				t="text",
				value="of"
			},
			
			{
				t="playerselection",
			},
		}
	}
})

table.insert(toenter, {name = "enableplayeraim", 
	t = {
		t="action",
		nicename="enable aiming",
		entries={
			{
				t="text",
				value="of"
			},
			
			{
				t="playerselection",
			},
		}
	}
})

table.insert(toenter, {name = "closeportals", 
	t = {
		t="action",
		nicename="close portals",
		entries={
			{
				t="text",
				value="of"
			},
			
			{
				t="playerselection",
			},
		}
	}
})

table.insert(toenter, {name = "makeplayerlook", 
	t = {
		t="action",
		nicename="make player aim to deg",
		entries={
			{
				t="playerselection",
			},
			
			{
				t="text",
				value="to"
			},
			
			{
				t="numinput",
			},
			
			{
				t="text",
				value="degrees"
			},
		}
	}
})

table.insert(toenter, {name = "makeplayerfireportal", 
	t = {
		t="action",
		nicename="make fire portal:",
		entries={
			{
				t="text",
				value="player"
			},
			
			{
				t="playerselection",
			},
			
			{
				t="text",
				value="portal #"
			},
			
			{
				t="numinput",
				default="1"
			},
		}
	}
})

table.insert(toenter, {name = "disableportalgun", 
	t = {
		t="action",
		nicename="disable portal gun of",
		entries={
			{
				t="playerselection",
			},
		}
	}
})

table.insert(toenter, {name = "enableportalgun", 
	t = {
		t="action",
		nicename="enable portal gun of",
		entries={
			{
				t="playerselection",
			},
		}
	}
})

--SORT ALPHABETICALLY (I didn't even know you could greater/less compare strings.)
table.sort(toenter, function(a, b) return a.t.nicename < b.t.nicename end)

local typelist = {"trigger", "condition", "action"}

local animationstrings = {}

for i = 1, #typelist do
	animationstrings[typelist[i] ] = {}
end

for i, v in pairs(toenter) do
	animationlist[v.name] = v.t
	table.insert(animationstrings[v.t.t], v.t.nicename)
end

function animationguiline:init(tabl, t2, parent)
	self.t = tabl
	self.type = t2
	self.parent = parent
	
	local x = 0
	self.elements = {}
	self.elements[1] = {}
	local start = 1
	for i = 1, #animationstrings[self.type] do
		if animationlist[self.t[1]] and animationlist[self.t[1]].nicename == animationstrings[self.type][i] then
			start = i
		end
	end
	local firstwidth = 22--#animationstrings[self.type][start]
	
	self.deletebutton = guielement:new("button", 0, 0, "x", function() self:delete() end, nil, nil, nil, 8, 0.1)
	self.deletebutton.textcolor = {200, 0, 0}
	
	self.downbutton = guielement:new("button", 0, 0, "_dir6", function() self:movedown() end, nil, nil, nil, 8, 0.1)
	self.downbutton.textcolor = {255, 255, 255}
	
	self.upbutton = guielement:new("button", 0, 0, "_dir4", function() self:moveup() end, nil, nil, nil, 8, 0.1)
	self.upbutton.textcolor = {255, 255, 255}
	
	self.elements[1].gui = guielement:new("dropdown", 0, 0, firstwidth, function(val) self:changemainthing(val) end, start, unpack(animationstrings[self.type]))
	self.elements[1].width = 14+firstwidth*8
	
	if not self.t[1] then
		for i, v in pairs(animationlist) do
			if v.nicename == animationstrings[self.type][1] then
				self.t[1] = i
				break
			end
		end
	end
	
	local tid = 1
	if animationlist[self.t[1] ] then
		for i, v in ipairs(animationlist[self.t[1] ].entries) do
			local temp = {}
			
			if v.t == "text" then
				temp.t = "text"
				temp.value = v.value
				temp.width = #v.value*8
			else
				tid = tid + 1
				
				local dropdown = false
				local dropwidth
				local args
				
				if v.t == "input" then
					local width = 15
					local maxwidth = v.length or 30
					temp.gui = guielement:new("input", 0, 0, width, nil, self.t[tid] or v.default or "", maxwidth, nil, nil, 0)
					temp.width = 4+width*8
					
				elseif v.t == "numinput" then
					local width = 5
					local maxwidth = 10
					temp.gui = guielement:new("input", 0, 0, width, nil, self.t[tid] or v.default or "0", maxwidth, nil, true, 0)
					temp.width = 4+width*8
					
				elseif v.t == "playerselection" then
					dropdown = true
					dropwidth = 8
					args = {"everyone", "player 1", "player 2", "player 3", "player 4"}
					
				elseif v.t == "worldselection" then
					dropdown = true
					dropwidth = 1
					args = {"1", "2", "3", "4", "5", "6", "7", "8"}
					
				elseif v.t == "levelselection" then
					dropdown = true
					dropwidth = 1
					args = {"1", "2", "3", "4"}
					
				elseif v.t == "sublevelselection" then
					dropdown = true
					dropwidth = 4
					args = {"main", "1", "2", "3", "4", "5"}
					
				elseif v.t == "directionselection" then
					dropdown = true
					dropwidth = 5
					args = {"right", "left"}
					
				elseif v.t == "musicselection" then
					dropdown = true
					dropwidth = 15
					args = {unpack(musiclist)}
					
				end
				
				if dropdown then
					local j = #self.elements+1
					local starti = 1
					for j, k in pairs(args) do
						if self.t[tid] == k then
							starti = j
						end
					end
					
					temp.gui = guielement:new("dropdown", 0, 0, dropwidth, function(val) self:submenuchange(val, j) end, starti, unpack(args))
					temp.width = dropwidth*8+14
				end
			end
			
			table.insert(self.elements, temp)
		end
	end
end

function animationguiline:update(dt)
	for i = 1, #self.elements do
		if self.elements[i].gui then
			self.elements[i].gui:update(dt)
		end
	end
	self.downbutton:update(dt)
	self.upbutton:update(dt)
end

function animationguiline:draw(x, y)
	love.graphics.setColor(0, 0, 0)
	love.graphics.rectangle("fill", x*scale, y*scale, (width*16-x)*scale, 11*scale)
	love.graphics.setColor(255, 255, 255)
	
	local xadd = 0
	self.deletebutton.x = x+xadd
	self.deletebutton.y = y
	self.deletebutton:draw()
	xadd = xadd + 10
	
	self.downbutton.x = x+xadd
	self.downbutton.y = y
	self.downbutton:draw()
	xadd = xadd + 10
	
	self.upbutton.x = x+xadd
	self.upbutton.y = y
	self.upbutton:draw()
	xadd = xadd + 12
	
	for i = 1, #self.elements do
		if self.elements[i].t == "text" then
			love.graphics.setColor(255, 255, 255)
			properprint(self.elements[i].value, (x+xadd-1)*scale, (y+2)*scale)
			xadd = xadd + self.elements[i].width
		else
			if not self.elements[i].gui.extended then
				self.elements[i].gui.x = x+xadd
				self.elements[i].gui.y = y
			end
			xadd = xadd + self.elements[i].width
		end
	end
end

function animationguiline:click(x, y, button)
	if self.deletebutton:click(x, y, button) then
		return true
	end
	
	if self.downbutton:click(x, y, button) then
		return true
	end
	
	if self.upbutton:click(x, y, button) then
		return true
	end
	
	local rettrue
	
	local i = 1
	while i <= #self.elements do
		if self.elements[i].gui then
			if self.elements[i].gui:click(x, y, button) then
				rettrue = true
			end
		end
		i = i + 1
	end
	
	return rettrue
end

function animationguiline:unclick(x, y, button)
	self.downbutton:unclick(x, y, button)
	self.upbutton:unclick(x, y, button)
end

function animationguiline:delete()
	self.parent:deleteline(self.type, self)
end

function animationguiline:moveup()
	self.parent:moveupline(self.type, self)
end

function animationguiline:movedown()
	self.parent:movedownline(self.type, self)
end

function animationguiline:keypressed(key)
	for i = 1, #self.elements do
		if self.elements[i].gui then
			self.elements[i].gui:keypress(key)
		end
	end
end

function animationguiline:changemainthing(value)
	local name
	for i, v in pairs(animationlist) do
		if v.nicename == animationstrings[self.type][value] then
			name = i
		end
	end
	self:init({name}, self.type, self.parent)
end

function animationguiline:submenuchange(value, id)
	self.elements[id].gui.var = value
end

function animationguiline:haspriority()
	for i, v in pairs(self.elements) do
		if v.gui then
			if v.gui.priority then
				return true
			end
		end
	end
	
	return false
end
end end)()end;
do require("package").preload["entitylistitem"] = (function() local package;return function(...)-- <pack entitylistitem> --
entitylistitem = class("entitylistitem")

function entitylistitem:init(t, i)
	self.x = x
	self.y = y
	self.t = t
	self.i = i 
	self.startx = 5
	self.starty = 38
	self.offy = 0
end

function entitylistitem:gethighlight(x, y)
	x = x/scale-self.startx
	y = y/scale-self.starty+self.offy/scale
	
	return x >= self.x and x < self.x+16 and y >= self.y and y < self.y+16
end

function entitylistitem:calibrate(startx, starty, offy)
	self.startx = startx
	self.starty = starty
	self.offy = offy
end
end end)()end;
do require("package").preload["_client"] = (function() local package;return function(...)-- <pack _client> --
function client_load()
	CLIENT = true
	print("===CLIENT===")
	message( "Attempting Connection to " .. ip .. ":" .. port .. ".." )
	client_createclient(ip, port)
	updatetimer = 0
	players = 2
	client_controls()
	netplay = true
end

function client_controls()
	mouseowner = 2
	
	controls = {}
	
	local i = 2
	controls[i] = {}
	controls[i]["right"] = {"d"}
	controls[i]["left"] = {"a"}
	controls[i]["down"] = {"s"}
	controls[i]["run"] = {"lshift"}
	controls[i]["jump"] = {" "}
	controls[i]["aimX"] = {} --mouse aiming, so no need
	controls[i]["aimY"] = {}
	controls[i]["portal1"] = {}
	controls[i]["portal2"] = {}
	controls[i]["reload"] = {"r"}
	controls[i]["use"] = {"e"}
	
	local i = 1 --unbind Player 1
	controls[i] = {}
	controls[i]["right"] = {""}
	controls[i]["left"] = {""}
	controls[i]["down"] = {""}
	controls[i]["run"] = {""}
	controls[i]["jump"] = {""}
	controls[i]["aimX"] = {}
	controls[i]["aimY"] = {}
	controls[i]["portal1"] = {}
	controls[i]["portal2"] = {}
	controls[i]["reload"] = {""}
	controls[i]["use"] = {""}
end

function client_createclient(ip, port)
	pingtime = love.timer.getTime()
	CLIENT = true
	MyClient = lube.client("udp")
	MyClient:setCallback(umsg.recv)
	MyClient:setHandshake("bj")
	MyClient:connect(ip, port)
	MyClient:setPing(true, 5, "PING")
	
	--umsg.hook( "string", function)
	umsg.hook( "client_connectconfirm", client_connectconfirm)
	umsg.hook( "client_playerlistget", client_playerlistget)
	umsg.hook( "client_start", client_start)
	umsg.hook( "client_synctest", client_synctest)
	umsg.hook( "shootportal", client_shootportal)
end

function client_update(dt)
	MyClient:update(dt)
	
	updatetimer = updatetimer + dt
	if updatetimer > updatedelay then
		if objects then
			local s = "ndummy~1"
			for i, v in pairs(objects["player"][2]) do
				if type(v) == "table" then
				
				elseif type(v) == "number" then
					s = s .. "~n" .. i .. "~" .. tostring(v)
				
				elseif type(v) == "string" then
					s = s .. "~s" .. i .. "~" .. tostring(v)
				
				elseif type(v) == "boolean" then
					s = s .. "~b" .. i .. "~" .. tostring(v)
				else
					s = s .. "~" .. i .. "~" .. tostring(v)
				end
			end
			local um = usermessage:new("server_synctest", s)
			um:send()
		end
		
		updatetimer = 0
	end
end

function client_shootportal(args)
	args = args:split("~")
	shootportal(1, tonumber(args[1]), tonumber(args[2]), tonumber(args[3]), tonumber(args[4]))
end

function client_synctest(input)
	if objects then
		des = deserialize(input)
		for i = 1, #des, 2 do
			local t = string.sub(des[i], 1, 1)
			local varname = string.sub(des[i], 2, string.len(des[i]))
			local varvalue = des[i+1]
			if t == "b" then
				if varvalue == "true" then
					objects["player"][1][varname] = true
				else
					objects["player"][1][varname] = false
				end
			elseif t == "s" then
				objects["player"][1][varname] = varvalue
			elseif t == "n" then
				objects["player"][1][varname] = tonumber(varvalue)
			end
		end
	end
end

function client_connectconfirm(s)
	currenttime = love.timer.getTime()
 	message("Successfully Connected! (" .. math.floor((currenttime - pingtime)*1000) .. "ms)")
	message("MotD: " .. s)
	message("Sending nickname..")
	
	local um = usermessage:new( "nickname", localnick)	
	um:send()
	
	message("Entering Lobby..")
	message("Requesting playerlist..")
	message("---------------------------")
	
	local um = usermessage:new( "playerlistrequest" )
	um:send()
end

function client_playerlistget(s)
	playerlist = s:split("~")
	message("Playerlist received:")
	for i = 1, #playerlist do
		message(i .. ": " .. playerlist[i])
	end
	message("---------------------------")
end

function client_start(s)
	message("Starting the game!")
	game_load()
end

function client_quit()
	MyClient:disconnect()
	
end
end end)()end;
do require("package").preload["tools.notool"] = (function() local package;return function(...)-- <pack tools.notool> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	
end
end end)()end;
do require("package").preload["tools.entitydraw"] = (function() local package;return function(...)-- <pack tools.entitydraw> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x, y = getMousePos()
	local tilex,tiley = getMouseTile(x, y-8*scale)
	self.status="("..tilex..","..tiley..")"
	
	if editortool.update(self,dt) then
		-- begin of tap
		lightdrawX, lightdrawY = getMouseTile(x, y+8*scale)
		lightdrawtable = {{x=lightdrawX, y=lightdrawY}}
		-- paint
		paintLight()
	end
end

function thisclass:draw()
	editortool.draw(self)
end
end end)()end;
do require("package").preload["tools.paintdraw"] = (function() local package;return function(...)-- <pack tools.paintdraw> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init(drawtile)
	editortool.init(self, classname)
	self.dragdraw = false
	self.dragging = true
	self.drawtile = drawtile or 0
end

function thisclass:operate(x,y)
	placetile(x,y)
end

function thisclass:change(...)
	local arg={...}
	self.drawtile = arg[1] or 0
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x, y = getMousePos()
	local tilex,tiley = getMouseTile(x, y-8*scale)
	self.status="("..tilex..","..tiley..")"
	
	if editortool.update(self,dt) and not rightclickm then
		-- paint everywhere for as long as the mouse is down
		if inmap(tilex,tiley) then
			self:operate(x,y)
		end
	end
end

function thisclass:draw()
	editortool.draw(self)
	
	if not rightclickactive and not rightclickm and not regiondragging then
		local x, y = getMouseTile(mouse.getX(), mouse.getY()-8*scale)
		--local posstr = x..",|"..y
		--local xcenteroffset = (2/16) --((string.len(posstr)*4)/16)
		-- the above is the closest I got to centered when using the format "(x,y)"
		--properprintbackground(posstr, math.floor((x-xscroll-1-(3/16)+xcenteroffset)*16*scale), math.floor(((y-yscroll+(2/16))*16+8)*scale), true)
		if inmap(x, y+1) then
			love.graphics.setColor(255, 255, 255, 200)
			-- we do this because if we open the enemies tab and don't do anything we end up with a beetle
			-- deep down, isn't that all we *really* want out of life?
			if editentities == false and type(currenttile)=="number" then
				local quad = tilequads[currenttile]:quad()
				if currenttile > 10000 then
					quad = tilequads[currenttile]:quad()
				end
				love.graphics.draw(tilequads[currenttile].image, quad, math.floor((x-xscroll-1)*16*scale), math.floor(((y-yscroll-1)*16+8)*scale), 0, scale, scale)
			elseif editenemies == false then
				love.graphics.draw(entityquads[currenttile].image, entityquads[currenttile].quad, math.floor((x-xscroll-1)*16*scale), math.floor(((y-yscroll-1)*16+8)*scale), 0, scale, scale)
			else
				local v = enemiesdata[currenttile]
				local xoff, yoff = (((v.spawnoffsetx or 0)+v.width/2-.5)*16 - v.offsetX + v.quadcenterX)*scale, (((v.spawnoffsety or 0)-v.height+1)*16-v.offsetY - v.quadcenterY)*scale
				love.graphics.draw(v.graphic, v.quad, math.floor((x-xscroll-1)*16*scale+xoff), math.floor(((y-yscroll)*16)*scale+yoff), 0, scale, scale)
			end
		end
	end
end
end end)()end;
do require("package").preload["tools.dropper"] = (function() local package;return function(...)-- <pack tools.dropper> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	
end

function thisclass:canFire()
	local value = controls.tap.editorDropper and self.active and not editormenuopen and not testlevel
	print("dropper canfire", value)
	return value
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x, y = getMousePos()
	local tilex,tiley = getMouseTile(x, y+(8*scale))
	self.status="("..tilex..","..tiley..")"
	
	if self:canFire() then
		if inmap(tilex, tiley) then
			editentities = false
			editenemies = false
			switch_tileset("all")
			currenttile = map[tilex][tiley][1]
			changeTool("paintdraw", currenttile)
		end
	end
end

function thisclass:draw()
	editortool.draw(self)
end
end end)()end;
do require("package").preload["tools.region"] = (function() local package;return function(...)-- <pack tools.region> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	self.dragdraw = false
	self.editing = false
end

function thisclass:cancel()
	editortool.cancel(self)
	
	self.startx=0
	self.starty=0
	self.startt=false
	self.regioning=false
	self.regiondragging = nil
	rightclickactive = false
end

function thisclass:change(...)
	local arg={...}
	print("inside region changer:")
	table.print(arg)
	self.startx = arg[1] or 0
	self.starty = arg[2] or 0
	self.startt = arg[3] or false
	self.regioning = arg[4] or false
	
	editorignoretap = true
	editorignorerelease = true
	--get width n shit
	local j
	
	for i = 3, #map[self.startx][self.starty] do
		local s = tostring(map[self.startx][self.starty][i]):split(":")
		if s[1] == self.startt then
			j = i
			break
		end
	end
	
	if j then
		local s = map[self.startx][self.starty][j]:split(":")
		
		local rx, ry = s[2], s[3]
		
		if string.sub(rx, 1, 1) == "m" then
			rx = -tonumber(string.sub(rx, 2))
		end
		if string.sub(ry, 1, 1) == "m" then
			ry = -tonumber(string.sub(ry, 2))
		end
		self.regiondragging = regiondrag:new(self.startx+rx, self.starty+ry, s[4], s[5])
	else
		print("Error! Unknown t :(")
	end
end

function thisclass:canFire()
	--print("click", tostring(controls.tap.editorSelect), "active", tostring(self.active), "noignore", tostring(not editorignoretap), "nomenuopen", tostring(not editormenuopen), "notest", tostring(not testlevel))
	return controls.tap.editorSelect and self.active and not editormenuopen and not testlevel
end

function thisclass:canUnfire()
	return controls.release.editorSelect and self.active and not editormenuopen and not testlevel
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x, y = getMousePos()
	local tilex,tiley = getMouseTile(x, y+8*scale)
	self.status="("..tilex..","..tiley..")|("..x..","..y..")"
	
	if controls.tap.editorSelect then
		print("checks", controls.tap.editorSelect, editorignoretap, self.active, not editormenuopen, not testlevel, self.regiondragging)
	end
	if controls.release.editorSelect then
		print("unchecks", controls.release.editorSelect, editorignoretap, self.active, not editormenuopen, not testlevel, self.regiondragging)
	end
	if self:canFire() and self.regiondragging and self.regiondragging:checkGrab(x, y) then
		print("do first")
		--previousTool()
		local t = self.startt
		local x, y = self.startx, self.starty
		
		local j
		
		for i = 3, #map[x][y] do
			local s = tostring(map[x][y][i]):split(":")
			if s[1] == t then
				j = i
				break
			end
		end
		
		local rx, ry = self.regiondragging.x-x+1, self.regiondragging.y-y+1
		
		if rx < 0 then
			rx = "m" .. -rx
		end
		
		if ry < 0 then
			ry = "m" .. -ry
		end
		
		map[x][y][j] = t .. ":" .. rx .. ":" .. ry .. ":" .. self.regiondragging.width .. ":" .. self.regiondragging.height
		
		--self.regioning = false
		--self.regiondragging = nil
		rightclickactive = false
		
		--[[if self.regiondragging:checkGrab(x, y) then
			print("doodleburg")
		end]]
		
	elseif self:canUnfire() and self.regiondragging then
		print("do other")
		self.regiondragging:releaseGrab()
	elseif self.regiondragging and self.regiondragging:update(dt) and self.regiondragging:checkGrab(x, y) then
		self.regiondragging = nil
	end
end

function thisclass:draw()
	editortool.draw(self)
	
	if self.regiondragging then
		self.regiondragging:draw()
	end
end
end end)()end;
do require("package").preload["tools.linker"] = (function() local package;return function(...)-- <pack tools.linker> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	self.dragdraw = false
	self.linking = false
	
	self.startx = 0
	self.starty = 0
	self.startt = {}
end

function thisclass:cancel()
	editortool.cancel(self)
	
	self.startx=0
	self.starty=0
	self.startt=false
	self.linking=false
end

function thisclass:change(...)
	local arg={...}
	print("inside linker changer:")
	table.print(arg)
	self.startx = arg[1] or 0
	self.starty = arg[2] or 0
	self.startt = arg[3] or false
	self.linking = arg[4] or false
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x, y = getMousePos()
	local tilex,tiley = getMouseTile(x, y+8*scale)
	self.status="("..tilex..","..tiley..")"
	
	if self:canFire() and not self.linking then
		print("beginlink")
		--changeTool("linker")
		--editorignoretap = true
		--[[rightclickactive = true
		rightclickoldX = x
		rightclickoldY = y
		linktoolt = t
		rightclicka = 1
		closerightclickmenu()
		self.linking = true]]
	elseif self:canFire() and self.linking then 
		print("endlink")
		local startx, starty = self.startx, self.starty
		print("start", startx, starty)
		-- I don't know why it has to be like this, but it does.
		local endx, endy = getMouseTile(x, y+8*scale)
		print("end", endx, endy)
		
		local edittable = {{x=startx, y=starty}}
		
		--@NOTE: I don't actually think this belongs here.
		--if selectionwidth then
		--	local selectionlist = selectiongettiles(selectionx, selectiony, selectionwidth, selectionheight)
			
		--	for i = 1, #selectionlist do
		--		local v = selectionlist[i]
				-- @WARNING: This code is probably broken because I removed the groundlighttable and made it an "r" value.
		--		if (map[v.x][v.y][2] == map[startx][starty][2] or (entitylist[map[v.x][v.y][2]] and table.contains("groundlight", entitylist[map[v.x][v.y][2]].t) and table.contains("groundlight", entitylist[map[startx][starty][2]].t))) and (v.x ~= startx or v.y ~= starty) then
		--			table.insert(edittable, {x=v.x, y=v.y})
		--		end
		--	end
		--end
		
		
		for i = 1, #edittable do
			local x, y = edittable[i].x, edittable[i].y
			if x ~= endx or y ~= endy then
				print("actually doing something")
				local r = map[endx][endy]
				print("here's what r has for us:")
				table.print(r)
				print("conditions check:", #r > 1, table.contains(outputsi, r[2]))
				
				--LIST OF NUMBERS THAT ARE ACCEPTED AS INPUTS (buttons, laserdetectors)
				if #r > 1 and table.contains( outputsi, r[2] ) then
					print("where did this r come from")
					--@NOTE: If we want to change the format of linkable entities, we do it here!
					r = map[x][y]
					
					local i = 1
					while (r[i] ~= "link" or r[i+1] ~= self.startt) and i <= #r do
						i = i + 1
					end
					
					map[x][y][i] = "link"
					map[x][y][i+1] = self.startt
					map[x][y][i+2] = endx
					map[x][y][i+3] = endy
					linktoolfadeouttime = linktoolfadeouttimeslow
				else
					print("didn't do the important thing, sorry")
				end
			end
		end
		self:cancel()
		
		previousTool()
	end
end

function thisclass:draw()
	editortool.draw(self)
	
	if self.linking then
		local tx, ty
		local x1, y1
		local x2, y2
		
		if rightclickm then
			print("did first")
			tx = rightclickm.tx
			ty = rightclickm.ty
			x1, y1 = math.floor((tx-xscroll-.5)*16*scale), math.floor((ty-yscroll-1)*16*scale)
		-- i have no idea what this does, but it WILL break things
		else
			tx = self.startx
			ty = self.starty
			x1, y1 = math.floor((tx-xscroll-.5)*16*scale), math.floor((ty-yscroll-1)*16*scale)
		end
		
		-- draw all the existing links
		local drawtable = {}
		
		for i = 1, #map[tx][ty] do
			if map[tx][ty][i] == "link" then
				x2, y2 = math.floor((map[tx][ty][i+2]-xscroll-.5)*16*scale), math.floor((map[tx][ty][i+3]-yscroll-1)*16*scale)
				
				local t = map[tx][ty][i+1]
				table.insert(drawtable, {x1, y1, x2, y2, t})
			end
		end
		
		table.sort(drawtable, function(a,b) return math.abs(a[3]-a[1])>math.abs(b[3]-b[1]) end)
		
		for i = 1, #drawtable do
			local x1, y1, x2, y2, t = unpack(drawtable[i])
			love.graphics.setColor(127, 127, 255*(i/#drawtable), 255*rightclicka)
			
			if math.mod(i, 2) == 0 then
				drawlinkline2(x1, y1, x2, y2)
			else
				drawlinkline(x1, y1, x2, y2)
			end
			
			properprintbackground(t, math.floor(x2-string.len(t)*4*scale), y2+10*scale, true, {0, 0, 0, 255*rightclicka})
		end
		
		-- draw the current line that we're dragging around
		if self.startt then
			local x1, y1 = math.floor((self.startx-xscroll-.5)*16*scale), math.floor((self.starty-yscroll-1)*16*scale)
			local x2, y2 = getMousePos()
			
			love.graphics.setColor(255, 172, 47, 255)
			
			drawlinkline(x1, y1, x2, y2)
			
			love.graphics.setColor(200, 140, 30, 255)
			
			love.graphics.draw(linktoolpointerimg, x2-math.ceil(scale/2), y2, 0, scale, scale, 3, 3)
			
			properprintbackground(self.startt, math.floor(x2+4*scale), y2-4*scale, true)
		end
	end
end
end end)()end;
do require("package").preload["tools.selection"] = (function() local package;return function(...)-- <pack tools.selection> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	self.dragdraw = false
	self.selecting = false
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x,y = getMouseTile(mouse.getX(), mouse.getY()-8*scale)
	self.status="("..x..","..y..")"
	
	if self:canFire() then
		selectionstart()
	elseif self:canUnfire() then
		selectionend()
	end
end

function thisclass:draw()
	editortool.draw(self)
	
	if selectiondragging or selectionwidth then
		local x, y, width, height
		
		x, y = selectionx, selectiony
		if selectiondragging then
			width, height = mousex-selectionx, mousey-selectiony
		else
			width, height = selectionwidth, selectionheight
		end
		
		if width < 0 then
			x = x + width
			width = -width
		end
		if height < 0 then
			y = y + height
			height = -height
		end
		
		if selectiondragging then
			drawrectangle(x/scale, y/scale, width/scale, height/scale)
		end
		
		local selectionlist = selectiongettiles(x, y, width, height)
		
		love.graphics.setColor(255, 255, 255, 100)
		for i = 1, #selectionlist do
			local v = selectionlist[i]
			if map[v.x][v.y][2] and entitylist[map[v.x][v.y][2]] and rightclickmenues[entitylist[map[v.x][v.y][2]].t] then
				love.graphics.rectangle("fill", (v.x-xscroll-1)*16*scale, (v.y-yscroll-1.5)*16*scale, 16*scale, 16*scale)
			end
		end
	end
end

function thisclass:clear()
	local x, y = round(selectionx/scale), round(selectiony/scale)
	local width, height = round(selectionwidth/scale), round(selectionheight/scale)
	
	local selectionlist = selectiongettiles(selectionx, selectiony, selectionwidth, selectionheight)
	
	for i = 1, #selectionlist do
		for j = 2, #map[selectionlist[i].x][selectionlist[i].y] do
			map[selectionlist[i].x][selectionlist[i].y][j] = nil
		end
	end
end
end end)()end;
do require("package").preload["tools.playermover"] = (function() local package;return function(...)-- <pack tools.playermover> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x, y = getMousePos()
	local tilex,tiley = getMouseTile(x, y-8*scale)
	self.status="("..tilex..","..tiley..")"
	
	if self:canFire() then
		if objects["player"][1] and not objects["player"][1].vine then
			objects["player"][1].x = x-1+2/16
			objects["player"][1].y = y-objects["player"][1].height
			objects["player"][1].vine = false
		end
	end
	
	if editortool.update(self,dt) then
		-- begin of tap
		lightdrawX, lightdrawY = getMouseTile(x, y+8*scale)
		lightdrawtable = {{x=lightdrawX, y=lightdrawY}}
		-- paint
		paintLight()
	end
end

function thisclass:draw()
	editortool.draw(self)
end
end end)()end;
do require("package").preload["tools.lightdraw"] = (function() local package;return function(...)-- <pack tools.lightdraw> --
local classname=debug.getinfo(1,'S').source:split("/")[2]:sub(0,-5)
_G[classname] = class(classname, editortool)
local thisclass = _G[classname]

function thisclass:init()
	editortool.init(self, classname)
	
end

function thisclass:update(dt)
	-- we can always show our status, probably
	local x, y = getMousePos()
	local tilex,tiley = getMouseTile(x, y-8*scale)
	self.status="("..tilex..","..tiley..")"
	
	if editortool.update(self,dt) then
		-- begin of tap
		lightdrawX, lightdrawY = getMouseTile(x, y+8*scale)
		lightdrawtable = {{x=lightdrawX, y=lightdrawY}}
		-- paint
		paintLight()
	end
end

function thisclass:draw()
	editortool.draw(self)
end
end end)()end;
do require("package").preload["editortool"] = (function() local package;return function(...)-- <pack editortool> --
editortool = class('editortool')

function editortool:init(name)
	self.status = ""
	self.name = name
	self.active = false
	
	self.allowdrag = true
	self.dragging = false
	
	-- this draws the little dashed lines around where the current tile is
	self.showtilehighlight = true
end

-- change parameters
function editortool:change(...)
	local arg={...}
	print("change called with:")
	print(Tserial.pack(arg, true, true))
	--for k,v in pairs(arg) do print(k, "=", v) end
end

-- revert the states set by attempting to begin the operation
function editortool:cancel()
	
end

function editortool:operate()
	-- this function is meant to paramaterize inputs for an undo history and insert it
end

function editortool:revertOperation()
	-- this is the invert of operate, which is meant to undo what just happened in the undo stack
end

function editortool:update(dt)
	if self.active and controls.editorPaint and not testlevel and not editormenuopen then
		if controls.tap.editorSelect and editorignoretap then
			-- not entirely sure this belongs here but it'll help us sort out the paint tool for now
			return false
		elseif controls.release.editorSelect and editorignorerelease then
			return false
		else
			return true
		end
	end
end

function editortool:canFire()
	if self.allowdrag and not self.dragging then
		self.dragging = true
	end
	--print("click", tostring(controls.tap.editorSelect), "active", tostring(self.active), "noignore", tostring(not editorignoretap), "nomenuopen", tostring(not editormenuopen), "notest", tostring(not testlevel))
	return controls.tap.editorSelect and self.active and not editormenuopen and not testlevel
end

function editortool:canUnfire()
	if self.allowdrag and self.dragging then
		self.dragging = false
	end
	--print("unclick", tostring(controls.release.editorSelect), "active", tostring(self.active), "noignore", tostring(not editorignorerelease), "nomenuopen", tostring(not editormenuopen), "notest", tostring(not testlevel))
	return controls.release.editorSelect and self.active and not editormenuopen and not testlevel
end

function editortool:canPaint()
	return controls.editorPaint and not testlevel and not editormenuopen
end

function editortool:draw()
	if self.showtilehighlight then
		local x, y = getMouseTile(mouse.getX(), mouse.getY()-8*scale)
		love.graphics.draw(cursorareaimg, cursorareaquads[redcoinframe], math.floor((x-xscroll-1-(1/16))*16*scale), math.floor(((y-yscroll-1-(1/16))*16+8)*scale), 0, scale, scale)
	end
end
end end)()end;
do require("package").preload["oldfuncs"] = (function() local package;return function(...)-- <pack oldfuncs> --
function server_syncping()
	for i, v in pairs(server_peerlist) do
		for j, k in pairs(server_peerlist) do
			if v.mostrecentping and k.ip and k.port then
				server_udp:sendto("pingupdate;" .. i .. ";" .. v.mostrecentping, k.ip, k.port)
			end
		end
	end
end
function server_syncconfig()
	for i, v in pairs(server_peerlist) do
		for j, k in pairs(server_peerlist) do
			if j ~= i then
				if v.hattable then
					server_sendto("hats", {tbl=v.hattable}, k.ip, k.port)
				end
				if v.colortable then
					server_sendto("color", {tbl=v.colortable}, k.ip, k.port)
				end
				if v.nick then
					server_sendto("nick", {nick=v.nick,id=i}, k.ip, k.port)
				end

				if v.portalcolors then
					server_sendto("portalcolor", {tbl=v.portalcolors}, k.ip, k.port)
				end
			end
		end
	end

	server_sendto("globalmappacks",
		{tbl=server_globalmappacklist},
		server_peerlist[1].ip,
		server_peerlist[1].port)

	for x = 2, #server_peerlist do
		server_sendto("changemappack", {mappack=server_mappack}, server_peerlist[x].ip, server_peerlist[x].port)
	end

	for x = 2, #server_peerlist do
		server_sendto("changemax", {max=lobby_maxplayers}, server_peerlist[x].ip, server_peerlist[x].port)
	end
end





-- callbacks
function server_pingback(datatable, clientnumber)
	if server_peerlist[clientnumber].personalpingtimer and not server_startedgame then
		server_peerlist[clientnumber].countingping = false
		server_peerlist[clientnumber].mostrecentping = round(server_peerlist[clientnumber].personalpingtimer*1000)
	end
end

function server_clientquit(datatable, clientnumber)
	print(clientnumber)
	if server_peerlist[clientnumber].nick then
		print("client " .. server_peerlist[clientnumber].nick  .. " is quitting")
	else
		print("client " .. clientnumber .. " is quitting")
	end
	for x = 1, #server_peerlist do
		server_udp:sendto("clientnumber;" .. x, server_peerlist[x].ip, server_peerlist[x].port)
		server_udp:sendto("removepeer;" .. clientnumber, server_peerlist[x].ip, server_peerlist[x].port)
	end
	local playertoremove = clientnumber
	table.remove(server_peerlist, clientnumber)
	resyncconfig = true

	if server_startedgame and #server_peerlist < 2 then
		network_quit()
		notice.new("all players left", notice.red, 6)
	end
end

function server_hats(datatable, clientnumber)
	print("received " .. clientnumber .. "'s hats")
	server_peerlist[clientnumber].hattable = {}
	for x = 3, #datatable do 
		table.insert(server_peerlist[tonumber(datatable[2])].hattable, datatable[x])
	end
end

function server_color(datatable, clientnumber)
	print("received " .. clientnumber .. "'s colors")
	server_peerlist[clientnumber].colortable = {{datatable[3], datatable[4], datatable[5]}, {datatable[6], datatable[7], datatable[8]}, {datatable[9], datatable[10], datatable[11]} }
end

function server_portalcolor(datatable, clientnumber)
	print("server got " .. clientnumber .. "'s portal colors")
	server_peerlist[clientnumber].portalcolors = {}
	server_peerlist[clientnumber].portalcolors[1] = {datatable[3], datatable[4], datatable[5]}
	server_peerlist[clientnumber].portalcolors[2] = {datatable[6], datatable[7], datatable[8]}
end

function server_mappacklist(datatable, clientnumber)
	server_peerlist[clientnumber].mappacktable = {}
	for x = 3, #datatable do
		table.insert(server_peerlist[clientnumber].mappacktable, {mappack=datatable[x]})
	end

	for x = 1, #server_peerlist do
		if server_peerlist[x].mappacktable then
			for y = 1, #server_peerlist[x].mappacktable do
				server_peerlist[x].mappacktable[y].matchedwith = 1
			end
		end
	end



	local v = server_peerlist[1]
	print("there are " .. #server_peerlist .. " peers")
	if #server_peerlist > 1 then
		server_globalmappacklist = {}
		for j, k in pairs(server_peerlist) do
			if j ~= 1 then
				for x = 1, #v.mappacktable do
					if k.mappacktable then
						for y = 1, #k.mappacktable do
							if v.mappacktable[x].mappack == k.mappacktable[y].mappack then
								v.mappacktable[x].matchedwith = v.mappacktable[x].matchedwith + 1
							end
						end
					end
				end
			end
		end
	else
		server_globalmappacklist = mappackname
		server_mappack = mappackname[lobby_mappackselectionnumber]
	end


	for x = 1, #v.mappacktable do
		if v.mappacktable[x].matchedwith == #server_peerlist then
			print(v.mappacktable[x].matchedwith, v.mappacktable[x].mappack)
			table.insert(server_globalmappacklist, v.mappacktable[x].mappack)
		end
	end
end

function server_move(datatable, clientnumber)
	--[[server_peerlist[clientnumber].x = datatable[3]
	server_peerlist[clientnumber].y = datatable[4]
	server_peerlist[clientnumber].speedx = datatable[5]
	server_peerlist[clientnumber].speedy = datatable[6]
	server_peerlist[clientnumber].currentdt = datatable[7]--]]
	local sendstring = "synccoords;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6] .. ";" .. datatable[7]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_portal(datatable, clientnumber)
	--[[server_peerlist[clientnumber].portali = datatable[3]
	server_peerlist[clientnumber].portalcox = datatable[4]
	server_peerlist[clientnumber].portalcoy = datatable[5]
	server_peerlist[clientnumber].portalside = datatable[6]
	server_peerlist[clientnumber].portaltendency = datatable[7]
	server_peerlist[clientnumber].portalx = datatable[8]
	server_peerlist[clientnumber].portaly = datatable[9]
	server_peerlist[clientnumber].portalnewx = datatable[10]
	server_peerlist[clientnumber].portalnewy = datatable[11]
	server_peerlist[clientnumber].placenewportal = true--]]

	local sendstring = "portal;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6] .. ";" .. datatable[7] .. ";" .. datatable[8] .. ";" .. datatable[9] .. ";" .. datatable[10] .. ";" .. datatable[11]
	server_sendtootherpeers(sendstring, clientnumber)


end

function server_shoot(datatable, clientnumber)
	--[[server_peerlist[clientnumber].shooti = datatable[3]
	server_peerlist[clientnumber].shootx = datatable[4]
	server_peerlist[clientnumber].shooty = datatable[5]
	server_peerlist[clientnumber].shootdirection = datatable[6]
	server_peerlist[clientnumber].shootnewportal = true--]]
	local sendstring = "shoot;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_hitblock(datatable, clientnumber)
--[[
	server_peerlist[clientnumber].hitblockx = datatable[3]
	server_peerlist[clientnumber].hitblocky = datatable[4]

	server_peerlist[clientnumber].hitnewblock = true--]]
	local sendstring = "hitblock;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_death(datatable, clientnumber)

	--[[server_peerlist[clientnumber].diedhow = datatable[3]
	server_peerlist[clientnumber].justdied = true--]]

	local sendstring = "death;" .. clientnumber .. ";" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_powerup(datatable, clientnumber)
	--[[server_peerlist[clientnumber].newmushroomx = datatable[3]
	server_peerlist[clientnumber].newmushroomy = datatable[4]
	--Nil for mushroom or flower, star for star
	server_peerlist[clientnumber].powerupname = datatable[5]
	server_peerlist[clientnumber].mariogrow = true--]]

	local sendstring = "powerup;" .. clientnumber .. ";" .. datatable[3].. ";" .. datatable[4]
	if datatable[5] then
		sendstring = sendstring .. ";" .. datatable[5]
	end

	server_sendtootherpeers(sendstring, clientnumber)

end

function server_1up(datatable, clientnumber)
	--[[server_peerlist[clientnumber].newmariolives = {}
	for x = 1, #server_peerlist do
		--print("yep " .. x)
		server_peerlist[clientnumber].newmariolives[x] = datatable[x+2]
	end
			--print(data)
	server_peerlist[clientnumber].newoneupx = datatable[#server_peerlist+3]
	server_peerlist[clientnumber].newoneupy = datatable[#server_peerlist+4]
	server_peerlist[clientnumber].synclives = true--]]

	local sendstring = "lives;"
	for x = 1, #server_peerlist do
		sendstring = sendstring .. datatable[x+2] .. ";"
	end
	sendstring = sendstring .. datatable[#server_peerlist+3] .. ";" .. datatable[#server_peerlist+4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_poisonmushed(datatable, clientnumber)
	local sendstring = "poisonmushed;" .. clientnumber .. ";" .. datatable[3].. ";" .. datatable[4]
	if datatable[5] then
		sendstring = sendstring .. ";" .. datatable[5]
	end
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_pointingangle(datatable, clientnumber)
	server_peerlist[clientnumber].pointingangle = datatable[3]
	if datatable[4] == "now" then
		server_peerlist[clientnumber].immediatelysyncangle = true
	end
end

function server_goombakill(datatable, clientnumber)
	--[[
	server_peerlist[clientnumber].newgoombakill = true
	server_peerlist[clientnumber].newgoombax = datatable[3]
	server_peerlist[clientnumber].newgoombay = datatable[4]
	server_peerlist[clientnumber].goombakilltype = datatable[5]--]]

	local sendstring = "goombakill;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_jump(datatable, clientnumber)
	--server_peerlist[clientnumber].newjump = true

	local sendstring = "jump;" .. clientnumber
	server_sendtootherpeers(sendstring, clientnumber)

end

function server_reload(datatable, clientnumber)
	--server_peerlist[clientnumber].newreload = true
	local sendstring = "reloadportals;" .. clientnumber
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_fireball(datatable, clientnumber)
	--[[server_peerlist[clientnumber].newfire = true
	server_peerlist[clientnumber].newfireballx = datatable[3]
	server_peerlist[clientnumber].newfirebally = datatable[4]
	server_peerlist[clientnumber].newfireballdir = datatable[5]--]]

	local sendstring = "fireball;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_koopastomp(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].koopastomps, {x=datatable[3], y=datatable[4], hitx=datatable[5]})

	local sendstring = "koopastomp;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4]
	if datatable[5] then
		sendstring = sendstring .. ";" .. datatable[5]
	end
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_spawnenemy(datatable, clientnumber)
	--[[if not server_peerlist[clientnumber].enemiestospawn then
		server_peerlist[clientnumber].enemiestospawn = {}
	end
	--print(data)
	table.insert(server_peerlist[clientnumber].enemiestospawn, {x=datatable[3], y=datatable[4]})--]]
	local sendstring = "spawnenemy;" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
	--print(server_peerlist[clientnumber].enemiestospawn[#server_peerlist[clientnumber].enemiestospawn].x, server_peerlist[clientnumber].enemiestospawn[#server_peerlist[clientnumber].enemiestospawn].y)
end

function server_duck(datatable, clientnumber)
	--[[server_peerlist[clientnumber].syncduck = true
	server_peerlist[clientnumber].duckstate = datatable[3]--]]

	local sendstring = "duck;" .. clientnumber .. ";" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_pipe(datatable, clientnumber)
	--[[server_peerlist[clientnumber].pipex = datatable[3]
	server_peerlist[clientnumber].pipey = datatable[4]
	server_peerlist[clientnumber].pipedir = datatable[5]
	server_peerlist[clientnumber].pipei = datatable[6]
	server_peerlist[clientnumber].newpipe = true--]]

	local sendstring = "pipe;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_goombasync(datatable, clientnumber)
	--[[if not server_peerlist[clientnumber].goombas then
		server_peerlist[clientnumber].goombas = {}
	end
	table.insert(server_peerlist[clientnumber].goombas, {x=datatable[3], y=datatable[4], speedx=datatable[5], tablelocation=datatable[6]})
	if finishedlevel then
		server_peerlist[clientnumber].goombas = {}
	end
--]]
	if not finishedlevel then
		local sendstring = "goombasync;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
		server_sendtootherpeers(sendstring, clientnumber)
	end
end

function server_chat(datatable, clientnumber)
	--[[if not server_peerlist[clientnumber].chatmessages then
		server_peerlist[clientnumber].chatmessages = {}
	end
	table.insert(server_peerlist[clientnumber].chatmessages, datatable[3])--]]

	local sendstring = "chat;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_finish(datatable, clientnumber)	
	--server_peerlist[clientnumber].grabbedflag = true
	finishedlevel = true
	--[[server_peerlist[clientnumber].mariotime = datatable[3]
	server_peerlist[clientnumber].finishleveltype = datatable[4]--]]

	local sendstring = "finish;" .. clientnumber .. ";" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)

end

function server_firespawn(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].spawnedfires, {x=datatable[3], y=datatable[4], targety=datatable[5]})
	local sendstring = "firespawn;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5]
end

function server_bowsersync(datatable, clientnumber)
	--[[server_peerlist[clientnumber].syncbowser = true
	server_peerlist[clientnumber].bowserx = datatable[3]
	server_peerlist[clientnumber].bowsery = datatable[4]
	server_peerlist[clientnumber].bowsertargetx = datatable[5]
	server_peerlist[clientnumber].bowserspeedy = datatable[6]--]]
	local sendstring = "bowsersync;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_bowserjump(datatable, clientnumber)
	--[[server_peerlist[clientnumber].bowserjump = true
	server_peerlist[clientnumber].bowserspeedy = datatable[3]--]]

	local sendstring = "bowserjump;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_cfiresync(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].castlefires, {angle=datatable[3], i=datatable[4]})
	local sendstring = "cfiresync;" .. datatable[3] .. ":" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_pformsync(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].platforms, {timer=datatable[3], i=datatable[4], name=datatable[5]})
	--server_peerlist[clientnumber].platforms[#server_peerlist[clientnumber].platforms].name = datatable[5] or "timer"
	local sendstring = "pformsync;" ..datatable[3] .. ";" .. datatable[4] .. ";" .. (datatable[5] or "timer")
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_createpform(datatable, clientnumber)
--	table.insert(server_peerlist[clientnumber].platforms, {x=datatable[3], y=datatable[4], dir=datatable[5], size=datatable[6]})
	local sendstring = "createpform;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_squidstate(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].squidstates, {i = datatable[3], state=datatable[4], dir=datatable[5], target=datatable[6]})
	local sendstring = "squidstate;" .. datatable[3] .. ";" .. datatable[4]
	if datatable[5] then
		sendstring = sendstring .. ";" .. datatable[5]
	end
	if datatable[6] then
		sendstring = sendstring .. ";" .. datatable[6]
	end
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_squidsync(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].squids, {x=datatable[3], y=datatable[4], player=datatable[5], i=datatable[6]})
	local sendstring = "squidsync;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_fishspawn(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].fishspawns, {x=datatable[3], speedx=datatable[4]})
	local sendstring = "fishspawn;" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_upfireup(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].upfiresyncs, {object=datatable[3]})
	local sendstring = "upfireup;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_hammer(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].hammers, {x=datatable[3], y=datatable[4], dir=datatable[5]})
	local sendstring = "hammer;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_brojump(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].brojumps, {dir=datatable[3], objectnumber=datatable[4]})
	local sendstring = "brojump;" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_objectshotted(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].shottedobjects, {x=datatable[3], y=datatable[4], dir=datatable[5], name=datatable[6]})
	local sendstring = "objectshotted;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_koopasync(datatable, clientnumber)
	--[[table.insert(server_peerlist[clientnumber].koopasyncs, {x=datatable[3], y=datatable[4], speedx=datatable[5], size=datatable[6], i=datatable[7]})
	if finishedlevel then
		server_peerlist[clientnumber].koopasyncs = {}
	end--]]
	if not finishedlevel then
		local sendstring = "koopasync;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6] .. ";" .. datatable[7]
		server_sendtootherpeers(sendstring, clientnumber)
	end
end

function server_seesaw(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].seesaws, {y=datatable[3], i=datatable[4]})
	local sendstring = "seesaw;" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_spikethrow(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].spikethrows, {x=datatable[3], y=datatable[4]})
	local sendstring = "spikespawn;" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_spiketurn(datatable, clientnumber)
	--[[server_peerlist[clientnumber].newspiketurn = true
	server_peerlist[clientnumber].newspiketurnobject = datatable[3]--]]
	local sendstring = "spiketurn;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_mazevar(datatable, clientnumber)
	--[[server_peerlist[clientnumber].newmazevar = true
	server_peerlist[clientnumber].newmazevarnumber = datatable[3]--]]
	local sendstring = "mazevar;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_bullet(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].bullets, {x=datatable[3], y=datatable[4], dir=datatable[5]})
	local sendstring = "bulletspawn;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_plantout(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].plants, {id=datatable[3]})
	local sendstring = "plantout;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_redplantout(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].plants, {id=datatable[3]})
	local sendstring = "redplantout;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_reddownplantout(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].plants, {id=datatable[3]})
	local sendstring = "reddownplantout;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_downplantout(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].plants, {id=datatable[3]})
	local sendstring = "downplantout;" .. datatable[3]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_inflives(datatable)
	server_inflivesvalue = (datatable[3] == "1")
	for i, v in pairs(server_peerlist) do
		if i ~= 1 then
			server_udp:sendto("inflives;" .. datatable[3], v.ip, v.port)
		end
	end
end

function server_sharingportals(datatable)
	server_sharingportalsvalue = (datatable[3] == "1")
	for i, v in pairs(server_peerlist) do
		if i ~= 1 then
			server_udp:sendto("sharetheportals;" .. datatable[3], v.ip, v.port)
		end
	end
end

function server_infinitetimefunction(datatable)
	server_infinitetime = (datatable[3] == "1")
	for i, v in pairs(server_peerlist) do
		if i ~= 1 then
			server_udp:sendto("setinfinitetime;" .. datatable[3], v.ip, v.port)
		end
	end
end

function server_checkboxvaluechange(datatable, clientnumber)
	if not server_peerlist[clientnumber].checkboxvalues then
		server_peerlist[clientnumber].checkboxvalues = {}
	end
	server_peerlist[clientnumber].checkboxvalues[datatable[4]] = datatable[3]

	for i, v in pairs(server_peerlist) do
		if i ~= 1 then
			server_udp:sendto("synccheckboxvalue;" .. datatable[3] .. ";" .. datatable[4], v.ip, v.port)
		end
	end
end

function server_use(datatable, clientnumber)
	--server_peerlist[clientnumber].newuse = true
	local sendstring = "use;" .. clientnumber
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_boxsync(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].boxes, {x=datatable[3], y=datatable[4], id=datatable[5], parentnumber=datatable[6]})
	local sendstring = "boxsync;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5]
	if datatable[6] then
		sendstring = sendstring .. ";" .. datatable[6]
	end
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_coin(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].coins, {x=datatable[3], y=datatable[4]})
	local sendstring = "coins;" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_mushroomsync(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].mushrooms, {x=datatable[3], y=datatable[4], speedx=datatable[5], id=datatable[6]})
	local sendstring = "mushroomsync;" .. datatable[3] .. ";" .. datatable[4] .. ";" .. datatable[5] .. ";" .. datatable[6]
	server_sendtootherpeers(sendstring, clientnumber)
end

function server_cheepver(datatable, clientnumber)
	--table.insert(server_peerlist[clientnumber].cheepvertable, {move=datatable[3], id=datatable[4]})
	local sendstring = "cheepver;" .. datatable[3] .. ";" .. datatable[4]
	server_sendtootherpeers(sendstring, clientnumber)
end

function sendcoords(v, k, i)
	if v.x and v.y and v.speedx and v.speedy and v.currentdt then
		server_udp:sendto("synccoords;" .. i .. ";" .. v.x .. ";" .. v.y .. ";" .. v.speedx .. ";" .. v.speedy .. ";" .. v.currentdt, k.ip, k.port)
	end
end

function server_endgame()
	for x = 2, #server_peerlist do
		server_udp:sendto("endgame", server_peerlist[x].ip, server_peerlist[x].port)
	end
	resynctimer = 0
end

function server_sendtootherpeers(string, clientnumber)--10/10 most useful function
	if clientnumber ~= 1 then
		local split = string:split(";")
		if _G["network_" .. split[1]] then
			_G["network_" .. split[1]](split)
		end
	end
	for x = 2, #server_peerlist do 
		if x ~= clientnumber then
			server_udp:sendto(string, server_peerlist[x].ip, server_peerlist[x].port)
		end
	end
end



function network_pingcheck(datatable)
	udp:send("pingback;" .. networkclientnumber)
end
function network_quit(datatable)


	onlinemp = false
	if not clientisnetworkhost then
		udp:send("clientquit;" .. networkclientnumber)
	else
		server_shutserver()
	end


	if clientisnetworkhost then
		magicdns_remove()
	end


	gamestate = "menu"
	players = 1
	menu_load()
	guielements = {}

	if datatable then
		notice.new("host shut server", notice.red, 6)
	end

	udp:close()


end

function network_generallobbysyncs(datatable)

	if datatable[1] == "connected" then
		networksynccedconfig = false
		local nick = guielements.nickentry.value
		lobby_load(nick)
		print("connected")

	elseif datatable[1] == "startgame" then
		connectionstate = "starting game..."
		players = tonumber(datatable[2])
		game_load()

	elseif datatable[1] == "clientnumber" then
		networkclientnumber = tonumber(datatable[2])
		print("my client number is " .. networkclientnumber)


	elseif datatable[1] == "chat" then
		if not objects then
			network_chat(datatable)
		end


	elseif datatable[1] == "nick" then
		if not lobby_playerlist[convertclienttoplayer(tonumber(datatable[2]))] then
			lobby_playerlist[convertclienttoplayer(tonumber(datatable[2]))] = {}
		end
		lobby_playerlist[convertclienttoplayer(tonumber(datatable[2]))].nick = datatable[3]


	elseif datatable[1] == "pingupdate" then
		if not lobby_playerlist[convertclienttoplayer(tonumber(datatable[2]))] then
			lobby_playerlist[convertclienttoplayer(tonumber(datatable[2]))] = {}
		end
		lobby_playerlist[convertclienttoplayer(tonumber(datatable[2]))].ping = datatable[3]


	elseif datatable[1] == "pingcheck" then
		network_pingcheck()
	elseif datatable[1] == "inflives" then
		network_inflives(datatable)
	elseif datatable[1] == "sharetheportals" then
		lobby_changesharedportalsvalue(datatable)
	elseif datatable[1] == "setinfinitetime" then
		lobby_setinfinitetime(datatable)
	elseif datatable[1] == "synccheckboxvalue" then
		lobby_synccheckboxvalue(datatable)
	elseif datatable[1] == "globalmappacks" then
		lobby_globalmappacks(datatable)
	elseif datatable[1] == "changemappack" then
		lobby_changemappack(datatable)
	elseif datatable[1] == "changemax" then
		lobby_changemaxplayers(datatable)
	elseif datatable[1] == "removepeer" then
		table.remove(lobby_playerlist, tonumber(datatable[2]))
		--[[players = players - 1
		table.remove(objects["player"], tonumber(datatable[2]))--]]
	elseif datatable[1] == "quit" then
		network_quit(datatable)
	end
end

function network_synccoords(datatable)
	if objects then
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))].x = tonumber(datatable[3])
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))].y = tonumber(datatable[4])
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))].speedx = tonumber(datatable[5])
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))].speedy = tonumber(datatable[6])
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))].currentdt = tonumber(datatable[7])
		local currentdt = tonumber(datatable[7])
	end


	--[[if not clientisnetworkhost then
		for i, v in pairs(objects["goomba"]) do
			v.currentdt = currentdt
		end
		for i, v in pairs(objects["koopa"]) do
			v.currentdt = currentdt
		end
	end--]]
end

function network_portal(datatable)
	createportal(convertclienttoplayer(tonumber(datatable[2])), tonumber(datatable[3]), tonumber(datatable[4]), tonumber(datatable[5]), datatable[6], tonumber(datatable[7]), tonumber(datatable[8]), tonumber(datatable[9]), tonumber(datatable[10]), tonumber(datatable[11]), true)
end

function network_shoot(datatable)
	shootportal(convertclienttoplayer(tonumber(datatable[2])), tonumber(datatable[3]), tonumber(datatable[4]), tonumber(datatable[5]), tonumber(datatable[6]), true)
end

function network_hitblock(datatable)
	hitblock(tonumber(datatable[3]), tonumber(datatable[4]), objects["player"][convertclienttoplayer(tonumber(datatable[2]))], true)
end

function network_death(datatable)
	objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:die(datatable[3], true)
end

function network_powerup(datatable)
	local x, y = math.floor(datatable[3]), math.floor(datatable[4])
	if datatable[5] then
		--star
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:star(nil, true)
		if #objects["star"] == 1 then
			objects["star"][1].destroy = true
		end

		local triggered
		for i, v in pairs(objects["star"]) do
			if math.floor(v.x) == x and math.floor(v.y) == y then
				v.destroy = true
				triggered = true
			end
		end
	

		if not triggered then
			for i, v in pairs(objects["player"]) do
				if i ~= 1 then
					for j, k in pairs(objects["mushroom"]) do
						if aabb(v.x-1/2, v.y, v.width+1, v.height, k.x, k.y, k.width, k.height) then
							k.destroy = true
						end
					end
				end
			end
		end

	else
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:grow()
		local triggered
		if #objects["mushroom"] == 1 and #objects["flower"] == 0 then
			objects["mushroom"][1].destroy = true
			objects["mushroom"][1].drawable = false
			triggered = true
		end
		if #objects["flower"] == 1 and #objects["mushroom"] == 0 then
			objects["flower"][1].destroy = true
			objects["flower"][1].drawable = false
			triggered = true
		end
		if not triggered then
			for i, v in pairs(objects["mushroom"]) do
				if math.floor(v.x) == x and math.floor(v.y) == y then
					v.destroy = true
					v.drawable = false
					triggered = true
				end
			end
		end

		if not triggered then
			for i, v in pairs(objects["player"]) do
				if i ~= 1 then
					for j, k in pairs(objects["mushroom"]) do
						if aabb(v.x-1/2, v.y, v.width+1, v.height, k.x, k.y, k.width, k.height) then
							k.destroy = true
							k.drawable = false
							triggered = true
						end
					end
				end
			end
		end

		if not triggered then
			for i, v in pairs(objects["flower"]) do
				if math.floor(v.x) == x and math.floor(v.y) == y then
					v.destroy = true
					v.drawable = false
					triggered = true
				end
			end
		end

		if not triggered then
			for i, v in pairs(objects["player"]) do
				if i ~= 1 then
					for j, k in pairs(objects["flower"]) do
						if aabb(v.x-4/16, v.y, v.width+1/2, v.height, k.x, k.y, k.width, k.height) then
							k.destroy = true
							k.drawable = false
							triggered = true
						end
					end
				end
			end
		end
	end
end

function network_poisonmushed(datatable)
	if #objects["poisonmush"] == 1 then
		objects["poisonmush"][1].destroy = true
		triggered = true
	end

	for i, v in pairs(objects["poisonmush"]) do
		--print(math.floor(v.x), x, math.floor(v.y), y)
		if math.floor(v.x) == x or math.floor(v.y) == y then
			v.destroy = true
		end
	end
	
end

function network_lives(datatable)
	for x = 1, players do
		mariolives[x] = tonumber(datatable[x+1])
	end
	local x, y = tonumber(datatable[players+2]), tonumber(datatable[players+3])

	local triggered

	if #objects["oneup"] == 1 then
		objects["oneup"][1].destroy = true
		triggered = true
	end

	for i, v in pairs(objects["oneup"]) do
		--print(math.floor(v.x), x, math.floor(v.y), y)
		if math.floor(v.x) == x or math.floor(v.y) == y then
			v.destroy = true
		end
	end

	if not triggered then
		for i, v in pairs(objects["player"]) do
			if i ~= 1 then
				for j, k in pairs(objects["oneup"]) do
					if aabb(v.x-4/16, v.y, v.width+1/2, v.height, k.x, k.y, k.width, k.height) then
						v.destroy = true
					end
				end
			end
		end
	end

	table.insert(scrollingscores, scrollingscore:new("1up", x, y))
	playsound(oneupsound)
	respawnplayers()
end

function network_otherpointingangle(datatable)
	objects["player"][convertclienttoplayer(tonumber(datatable[2]))].pointingangle = tonumber(datatable[3])
end

function network_goombakill(datatable)
	local x, y = math.floor(datatable[3]), math.floor(datatable[4])
	local triggered

	local goombaobject
	for i, v in pairs(objects["goomba"]) do
		if math.floor(v.x) == x and math.floor(v.y) == y then
			goombaobject = v
			triggered = true
		end
	end

	if not triggered then
		for i, v in pairs(objects["player"]) do
			if i ~= 1 then
				for j, k in pairs(objects["goomba"]) do
					if aabb(v.x-4/16, v.y-1, v.width+1/2, v.height+2, k.x, k.y, k.width, k.height) then
						goombaobject = k
						triggered = true
					end
				end
			end
		end
	end

	if triggered then
		if datatable[5] == "stomp" then
			objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:stompenemy("goomba", goombaobject, true)
		else
			goombaobject:shotted(nil, true)
		end
	end
end

function network_jump(datatable)
	objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:jump(true)
end

function network_reloadportals(datatable)
	objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:removeportals()
end

function network_fireball(datatable)
	objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:fire(datatable[3], datatable[4], datatable[5], objects["player"][convertclienttoplayer(tonumber(datatable[2]))])
end

function network_koopastomp(datatable)
	local x, y = math.floor(datatable[3]), math.floor(datatable[4])
	local triggered

	local koopaobject
	for i, v in pairs(objects["koopa"]) do
		if math.floor(v.x) == x and math.floor(v.y) == y then
			koopaobject = v
			triggered = true
		end
	end

	local distances = {}
	local sqrt = math.sqrt

	if not triggered then
		local v = objects["player"][convertclienttoplayer(tonumber(datatable[2]))]
		for j, k in pairs(objects["koopa"]) do
			local distancecalculation = sqrt((k.x-v.x)^2 +(k.y-v.y)^2)
			table.insert(distances, {distance=distancecalculation, id=j})
			if aabb(v.x-1/2, v.y-1, v.width+1, v.height+2, k.x, k.y, k.width, k.height) then
				koopaobject = k
				triggered = true
			end
		end
	end

	if not triggered then
		local farthestdistance = 1
		for x = 2, #distances do
			if distances[x].distance > distances[farthestdistance].distance then
				farthestdistance = x
			end
		end
		koopaobject = objects["koopa"][farthestdistance]
		if koopaobject then
			triggered = true
		end
	end



	if triggered then
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:stompenemy("koopa", koopaobject, true)
	end
end

function network_spawnenemy(datatable)
	spawnenemy(tonumber(datatable[2]), tonumber(datatable[3]), true)
end

function network_duck(datatable)
	objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:duck(datatable[3] == "true")
end

function network_pipe(datatable)
	local location = tonumber(datatable[6])
	if not location then
		location = datatable[6]
	end

	objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:pipe(tonumber(datatable[3]), tonumber(datatable[4]), datatable[5], location)
end

function network_goombasync(datatable)
	local i = tonumber(datatable[5])
	if objects["goomba"][i] then
	 	objects["goomba"][i].x = tonumber(datatable[2])
		objects["goomba"][i].y = tonumber(datatable[3])
		objects["goomba"][i].speedx = tonumber(datatable[4])
	else
		objects["goomba"][i] = goomba:new(tonumber(datatable[2]), tonumber(datatable[3]), "goomba")
		objects["goomba"][i].speedx = tonumber(datatable[4])
	end
end

function network_mushroomsync(datatable)
	local i = objects["mushroom"][tonumber(datatable[5])]
	if i then
		i.x = tonumber(datatable[2])
		i.y = tonumber(datatable[3])
		i.speedx = tonumber(datatable[4])
	end
end

function network_koopasync(datatable)
	local i = tonumber(datatable[6])
	if objects["koopa"][i] then
	 	objects["koopa"][i].x = tonumber(datatable[2])
		objects["koopa"][i].y = tonumber(datatable[3])
		objects["koopa"][i].speedx = tonumber(datatable[4])
		if datatable[5] == "2" then
			objects["koopa"][i].flying = true
			objects["koopa"][i].small = false
		elseif datatable[5] == "1" then
			objects["koopa"][i].flying = false
			objects["koopa"][i].small = false
		else
			objects["koopa"][i].small = true
			objects["koopa"][i].flying = false
		end
	end
end


function network_chat(datatable)
	chatmessagegradient = 180
	local chatdata = datatable[2]:split(":")
	table.insert(chatlog, 1, {id=chatdata[1], message=chatdata[2]})
end

function network_finish(datatable)
	mariotime = tonumber(datatable[3])
	if datatable[4] == "flag" then
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:flag(true)
	else
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:axe(true)
	end
end

function network_firespawn(datatable)
	local newfire = fire:new(tonumber(datatable[2]), tonumber(datatable[3])) 
	newfire.x = tonumber(datatable[2])
	newfire.y = tonumber(datatable[3])
	newfire.targety = tonumber(datatable[4])
	table.insert(objects["fire"], newfire)
end

function network_bowsersync(datatable)
	if objects["bowser"][1] then
		objects["bowser"][1].x = tonumber(datatable[2])
		objects["bowser"][1].y = tonumber(datatable[3])
		objects["bowser"][1].targetx = tonumber(datatable[4])
		objects["bowser"][1].speedy = tonumber(datatable[5])
	end
end

function network_bowserjump(datatable)
	if objects["bowser"][1] then
		objects["bowser"][1].speedy = tonumber(datatable[2])
		objects["bowser"][1].jump = true
	end
end

function network_cfiresync(datatable)
	if objects["castlefire"][tonumber(datatable[3])] then
		objects["castlefire"][tonumber(datatable[3])].angle = tonumber(datatable[2])
	end
end

function network_pformsync(datatable)
	--print(datatable[4])
	if objects["platform"][tonumber(datatable[3])] then
		if datatable[4] ~= "fall" then
			objects["platform"][tonumber(datatable[3])].timer = tonumber(datatable[2])
		else
			objects["platform"][tonumber(datatable[3])].y = tonumber(datatable[2])
		end
	end
end

function network_createpform(datatable)
	table.insert(objects["platform"], platform:new(tonumber(datatable[2]), tonumber(datatable[3]), datatable[4], tonumber(datatable[5])))
end

function network_squidstate(datatable)
	local object = objects["squid"][tonumber(datatable[2])]
	if object then
		object.state = datatable[3]
		if datatable[3] == "upward" then
			object.upx = tonumber(datatable[5])
			object.direction = datatable[4]
		elseif datatable[3] == "downward" then
			object.quad = squidquad[2]
			object.downy = tonumber(datatable[5])
			object.direction = datatable[4]
			object.speedx = 0
		elseif datatable[3] == "idle" then
			object.quad = squidquad[1]
		end
	end

end

function network_squidsync(datatable)
	if objects["squid"][tonumber(datatable[5])] then
		objects["squid"][tonumber(datatable[5])].x = tonumber(datatable[2])
		objects["squid"][tonumber(datatable[5])].y = tonumber(datatable[3])
		objects["squid"][tonumber(datatable[5])].closestplayer = tonumber(datatable[4])
	end
end

function network_fishspawn(datatable)
	local fish = flyingfish:new()
	fish.x = tonumber(datatable[2])
	fish.speedx = tonumber(datatable[3])
	table.insert(objects["flyingfish"], fish)
end

function network_upfireup(datatable)
	if objects["upfire"][tonumber(datatable[2])] then
		objects["upfire"][tonumber(datatable[2])].y = objects["upfire"][tonumber(datatable[2])].coy + upfirestarty
		objects["upfire"][tonumber(datatable[2])].speedy = -upfireforce
	end
end

function network_hammer(datatable)
	table.insert(objects["hammer"], hammer:new(tonumber(datatable[2]), tonumber(datatable[3]), datatable[4]))
end

function network_brojump(datatable)
	local broobject = objects["hammerbro"][tonumber(datatable[3])]
	if broobject then
		if datatable[2] == "up" then
			broobject.speedy = -hammerbrojumpforce
			broobject.mask[2] = true
			broobject.jumping = "up"
		else
			broobject.speedy = -hammerbrojumpforcedown
			broobject.mask[2] = true
			broobject.jumping = "down"
			broobject.jumpingy = broobject.y
		end
	end
end

function network_objectshotted(datatable)
	local x, y = tonumber(datatable[2]), tonumber(datatable[3])
	local triggered

	local object
	for i, v in pairs(objects[datatable[5]]) do
		if math.floor(v.x) == x and math.floor(v.y) == y then
			object = v
			triggered = true
			break
		end
	end

	if not triggered and objects[name] then
		for j, k in pairs(objects[name]) do
			if aabb(x-4/16, y-1, 1.5, 4, k.x, k.y, k.width, k.height) then
				object = k
				triggered = true
				break
			end
		end
	end

	if triggered then
		object:shotted(datatable[4], true)
	end

end

function network_seesaw(datatable)
	if objects["seesawplatform"][tonumber(datatable[3])] and not lastplayeronplatform then
		objects["seesawplatform"][tonumber(datatable[3])].y = tonumber(datatable[2])
	end
end

function network_spikespawn(datatable)
	table.insert(objects["goomba"], goomba:new(tonumber(datatable[2]), tonumber(datatable[3]), "spikeyfall"))
end

function network_spiketurn(datatable)
	if objects["goomba"][tonumber(datatable[2])] then
		objects["goomba"][tonumber(datatable[2])].speedx = goombaspeed
		objects["goomba"][tonumber(datatable[2])].animationdirection = "left"
	end
end

function network_mazevar(datatable)
	for x = 1, players do
		objects["player"][x].mazevar = tonumber(datatable[2])
	end
end

function network_bulletspawn(datatable)
	table.insert(objects["bulletbill"], bulletbill:new(tonumber(datatable[2]), tonumber(datatable[3]), datatable[4]))
end

function network_plantout(datatable)
	if objects["plant"][tonumber(datatable[2])] then
		objects["plant"][tonumber(datatable[2])].timer2 = 0
	end
end

function network_redplantout(datatable)
	if objects["redplant"][tonumber(datatable[2])] then
		objects["redplant"][tonumber(datatable[2])].timer2 = 0
	end
end

function network_reddownplantout(datatable)
	if objects["reddownplant"][tonumber(datatable[2])] then
		objects["reddownplant"][tonumber(datatable[2])].timer2 = 0
	end
end

function network_downplantout(datatable)
	if objects["downplant"][tonumber(datatable[2])] then
		objects["downplant"][tonumber(datatable[2])].timer2 = 0
	end
end

function network_use(datatable)
	if objects["player"][convertclienttoplayer(tonumber(datatable[2]))] then
		objects["player"][convertclienttoplayer(tonumber(datatable[2]))]:use()
	end
end

function network_inflives(datatable)
	infinitelives = (datatable[2] == "1")
	if guielements.livescheckbox then
		guielements.livescheckbox.var = infinitelives
	end
end

function network_boxsync(datatable)
	if objects["box"][tonumber(datatable[4])] then
		objects["box"][tonumber(datatable[4])].x = tonumber(datatable[2])
		objects["box"][tonumber(datatable[4])].y = tonumber(datatable[3])
		if datatable[5] then
			objects["box"][tonumber(datatable[4])]:used(convertclienttoplayer(tonumber(datatable[5])))
		end
	else
		objects["box"][tonumber(datatable[4])] = box:new(tonumber(datatable[2]), tonumber(datatable[3]))
		objects["box"][tonumber(datatable[4])].x = tonumber(datatable[2])
		objects["box"][tonumber(datatable[4])].y = tonumber(datatable[3])
		if datatable[5] then
			objects["box"][tonumber(datatable[4])]:used(convertclienttoplayer(tonumber(datatable[5])))
		end
	end
end


function network_coins(datatable)
	local x, y = tonumber(datatable[2]), tonumber(datatable[3])
	if inmap(x, y) and tilequads[map[x][y][1]].coin then
		collectcoin(x, y)
	end 
end

function network_cheepver(datatable)
	local v = objects["cheep"][tonumber(datatable[3])]
	if v then
		if datatable[2] == "1" then
			v.verticalmoving = true
		end
	end
end




function network_sendchat(data)
	client_send("chat", {message=data.newstring})
	table.insert(chatlog, 1, {id=data.id, message=data.message})
end



end end)()end;
do require("package").preload["baseentity"] = (function() local package;return function(...)-- <pack baseentity> --
baseentity = class('baseentity')
baseentity.mixedins = {}
-- these variables are only available to "baseentity", not its children

--[[@NOTE FOR WHEN I WAKEUP:
	instead of dynamically hooking the update/draw we can use a class table of conditions
	called "mixedins" that conditions based on the presence of a mixin
]]

--[[
	RESERVED SPECIAL PROPERTIES FOR MIDDLECLASS:
	name,
	class,
	super,
	static,
	included,
	__mixins,
	init,
	__instanceDict,
]]

--[[
	SIGNIFICANT STATICS:
	since these will never change, we make use of this data per-class,
	
	DEFINED IN EACH CLASS:
	image_sigs
]]

--[[
	SPECIAL CLASSES MADE USE OF BY MIXINS:
	CanEmancipate:	emancipateanimation->emancipationfizzle
	CanCarry:		userect
]]

function baseentity:init(x, y, z, r, parent)
	local mix = self.class.__mixins
	self.parent = parent --(or nil)
	
	if r then
		self.r = {}
		for k,v in ipairs(r) do
			if k > 2 then
				--1 = ???
				--2 = entity lookup id
				table.insert(self.r, v)
			end
		end
	end
	
	if mix[HasGraphics] then
		self:setGraphic(self.class.name, true)
		self:setCo(x, y, z)
		if self.class.UNI_SIZE then
			local size = self.class.UNI_SIZE
			self:setOffset(size[1]/2, (16-size[2])*.5, size[3]/2)
			self:setQuadCenter(size[1]/2, size[2]/2, size[3]/2)
		else
			self:setOffset(self.class.GRAPHIC_OFFSET)
			self:setQuadCenter(self.class.GRAPHIC_QUADCENTER)
		end
	end
	
	if mix[HasPhysics] then
		local size = self.class.UNI_SIZE or self.class.PHYS_SIZE
		if self.class.UNI_SIZE then
			self:setSize(size[1]/16, size[2]/16, size[3]/16)
		else
			self:setSize(size[1], size[2], size[3])
		end
		local posoff = {-1, -1, 0}
		if self.class.MAPPABLE_CENTERX then
			local multi = math.ceil(self.width)*16
			--[[
				this is to correct for objects larger than 16 units,
				finding the nearest multiple of 16 to apply against
			]]
			posoff[1] = posoff[1] + (multi%self.width)/2
		end
		if self.class.MAPPABLE_FLUSHY then
			posoff[2] = posoff[2] + (math.ceil(self.height)-self.height)
		end
		self:setPosition(x+posoff[1], y+posoff[2], z+posoff[3])
	end
	
	if mix[CanCarry] then
		self.userect = userect:new(self.x, self.y, self.width, self.height, self)
	end
	
	if mix[Base] then
		local size = self.class.BASE_SIZE
		--self:setSize(size[1], size[2], size[3])
		self:setPosition(x, y, z)
		--self:setCo(x, y, z)
	end
	
	if mix[CanInfluence] then
		self:setInfluence(parent)
	end
	
	
	-- if it has a an orientation, you should use this to set it. should be a direction enum key.
	self.dir = "right"
	
	-- TIME TRACKING
	--self.timer = 0
	-- the once timer gets to this, we clear and do timercallback
	--self.timermax = 1
	
	-- should we destroy ourselves in the next update
	self.destroy = false
	-- self-manage our copy in the right tables
	if mix[IsMappable] then
		-- use the existence of the name attribute to map a variable to self
		for k,v in pairs(self.class.EDITOR_RCM) do
			if v.name then
				self:getBasicInput(v.name)
			end
		end
	else
		-- mapped entities are already inserted
		table.insert(objects[self.class.name], self)
	end
end

--[[function baseentity:timercallback()
	-- this gets called whenever the internal timer gets this big
	-- usually this is just for animation
	self:setQuad(self.quadi)
	self.quadi = self.quadi + 1
end]]

function baseentity:update(dt)
	--[[this came from fireball, not sure if it's global:
		rotate back to 0 (portals)
	]]
	local mix = self.class.__mixins
	if mix[CanPortal] then
		self.rotation = 0
	end
	
	--[[self.timer = self.timer + dt
	
	if self.timer > self.timermax then
		self.timer = self.timer % self.timermax
		self:timercallback()
	end]]
	
	if self.x < xscroll-1 or self.x > xscroll+width+1 or self.y > mapheight and self.active then
		self:offscreencallback()
	end
	
	--MIXIN CASES
	if mix[HasPhysics] then
		if self.falling then
			self.friction = 0 --self.base_friction*self.base_friction_air_multiplier
		else
			self.friction = self.base_friction
		end
	end
	
	if mix[CanFunnel] then
		if self.funnel and not self.infunnel then
			self:funnelcallback(true)
		elseif not self.funnel and self.infunnel then
			self:funnelcallback(false)
		end
		--[[
			this is the default, but iirc I thought funnel managed
			this bool on objects it handles/releases
		]]
		self.funnel = false 
	end
	
	-- handle carried objects, arguably, this should be in the player's update method
	if mix[CanCarry] then
		if self.carrier then
			local oldx = self.x
			local oldy = self.y
			
			self.x = self.carrier.x+math.sin(-self.carrier.pointingangle)*0.3+(self.carrier.speedx*dt)
			self.y = self.carrier.y-math.cos(-self.carrier.pointingangle)*0.3+(self.carrier.speedy*dt)
			if self.portaledframe == false then
				--@WARNING: this code is basically checkforemances in physics.lua \o/
				for h, u in pairs(objects["emancipationgrill"]) do
					if u.active then
						if u.dir == "hor" then
							if inrange(self.x+6/16, u.startx-1, u.endx, true) and inrange(u.y-14/16, oldy, self.y, true) then
								print("trying to emancipate self because carrier")
								self:emancipate(h)
							end
						else
							if inrange(self.y+6/16, u.starty-1, u.endy, true) and inrange(u.x-14/16, oldx, self.x, true) then
								print("trying to emancipate self because carrier")
								self:emancipate(h)
							end
						end
					end
				end
			end
			
			self.rotation = self.carrier.rotation
		end
		self.userect:setPos(self.x+self.speedx*dt, self.y+self.speedy*dt)
		self.portaledframe = false
	end
	
	
	--MIXIN
	if mix[HasSounds] then
		for k,v in pairs(self.activesounds) do
			if v.moves then
				v.source:setPosition(self.x, self.y, self.z)
			end
			if v.use_velocity then
				v.source:setVelocity(self.speedx, self.speedy, self.speedz)
			end
		end
		
		-- run a filtered deletion on sounds that are completed
		--@NOTE: Consider converting this to the more general filter library.
		if #self.activesounds > 0 then
			table.fdelete(self.activesounds, self.filters.delete_sounds)
		end
	end
	
	
	if self.destroy then
		--prepare for the cold embrace of death
		self:remove()
	end
	
	-- let us know we're going to die
	return self.destroy
end

function baseentity:remove()
	-- in the event that an entity utilizes special resources that must be released
	if timer.Exists(self) then
		timer.Destroy(self)
	end
	self.destroy = true --but we can also use it to delete ourselves if we weren't going to
end


-- WONDERFUL COLLECTION OF CALLBACKS
function baseentity:offscreencallback()
	-- do something if we're no longer visible, usually it's disappear
	self:remove()
end

--[[ no special draw instructions, the engine supplies it if we lack it
function baseentity:draw()
	if self.visible then
		love.graphics.setColor(255, 255, 255)
		love.graphics.draw(self.graphic, self.quad, math.floor((self.x-1-xscroll)*16*scale), ((self.y-yscroll-1)*16-8)*scale, 0, scale, scale)
	end
end]]
end end)()end;
do require("package").preload["entitytooltip"] = (function() local package;return function(...)-- <pack entitytooltip> --
entitytooltip = class("entitytooltip")

local theight = 64
local twidth = 64
local descwidth = 0
twidth = twidth + descwidth*8 

function entitytooltip:init(ent)
	self.ent = ent
end

function entitytooltip:update(dt)
	self.x = math.min(mouse.getX(), width*16*scale-(twidth+4)*scale)
	self.y = math.max(0, mouse.getY()-(theight+4)*scale-(8*scale))
end

function entitytooltip:draw(a)
	if tooltipimages[self.ent.i] and a>0 then
		love.graphics.setColor(255, 255, 255, a)
		properprintbackground(self.ent.t, self.x, self.y, true)
		love.graphics.setColor(0, 0, 0, a)
		drawrectangle(self.x/scale, self.y/scale+8, (twidth+4), (theight+4))
		love.graphics.setColor(255, 255, 255, a)
		drawrectangle(self.x/scale+1, self.y/scale+9, 66, theight+2)
		
		local r, g, b = love.graphics.getBackgroundColor()
		love.graphics.setColor(r, g, b, a)
		love.graphics.rectangle("fill", self.x+2*scale, self.y+10*scale, 64*scale, 64*scale)
		love.graphics.setColor(255, 255, 255, a)
		love.graphics.draw(tooltipimages[self.ent.i], self.x+2*scale, self.y+10*scale, 0, scale, scale)
	end
end
end end)()end;
do require("package").preload["conf"] = (function() local package;return function(...)-- <pack conf> --
function love.conf(t)
	t.title = "Marin0SE"
	t.author = "Maurice"
	t.identity = "Marin0SE"
	t.modules.physics = false
	t.release = false
	t.window = false
	t.console = true
end
end end)()end;
do require("package").preload["weapons.portalgun"] = (function() local package;return function(...)-- <pack weapons.portalgun> --
portalgun = class('portalgun', weapon)
function portalgun:init(parent)
	weapon.init(self,parent)
end

function portalgun:update(dt)
	weapon.update(self,dt)
	-- nothin'
end

function portalgun:draw()
	weapon.draw(self)
	
	-- @TODO: We could probably internalize a lot of these properties.
	local ply = self.parent
	if ply and ply.controlsenabled and ply.activeweapon == self and not ply.vine and table.contains(ply.portalsavailable, true) then
		local sourcex, sourcey = ply.x+6/16, ply.y+6/16
		local cox, coy, side, tend, x, y = traceline(sourcex, sourcey, ply.pointingangle)
		local portalpossible = true
		if cox == false or getportalposition(1, cox, coy, side, tend) == false then
			portalpossible = false
		end
		
		-- DRAW THE DOTS
		love.graphics.setColor(255, 255, 255, 255)
		local dist = math.sqrt(((x-xscroll)*16*scale - (sourcex-xscroll)*16*scale)^2 + ((y-.5-yscroll)*16*scale - (sourcey-.5-yscroll)*16*scale)^2)/16/scale
		for i = 1, dist/portaldotsdistance+1 do
			if((i-1+portaldotstimer/portaldotstime)/(dist/portaldotsdistance)) < 1 then
				local xplus = ((x-xscroll)*16*scale - (sourcex-xscroll)*16*scale)*((i-1+portaldotstimer/portaldotstime)/(dist/portaldotsdistance))
				local yplus = ((y-.5-yscroll)*16*scale - (sourcey-.5-yscroll)*16*scale)*((i-1+portaldotstimer/portaldotstime)/(dist/portaldotsdistance))
				
				local dotx = (sourcex-xscroll)*16*scale + xplus
				local doty = (sourcey-.5-yscroll)*16*scale + yplus
				
				local radius = math.sqrt(xplus^2 + yplus^2)/scale
				
				local alpha = 255
				if radius < portaldotsouter then
					alpha = (radius-portaldotsinner) * (255/(portaldotsouter-portaldotsinner))
					if alpha < 0 then
						alpha = 0
					end
				end
				
				
				if portalpossible == false then
					love.graphics.setColor(255, 0, 0, alpha)
				else
					love.graphics.setColor(0, 255, 0, alpha)
				end
				
				love.graphics.draw(portaldotimg, math.floor(dotx-0.25*scale), math.floor(doty-0.25*scale), 0, scale, scale)
			end
		end
		
		-- DRAW CROSSHAIR
		love.graphics.setColor(255, 255, 255, 255)
		if cox ~= false then
			if portalpossible == false then
				love.graphics.setColor(255, 0, 0)
			else
				love.graphics.setColor(0, 255, 0)
			end
			
			local rotation = 0
			if side == "right" then
				rotation = math.pi/2
			elseif side == "down" then
				rotation = math.pi
			elseif side == "left" then
				rotation = math.pi/2*3
			end
			love.graphics.draw(portalcrosshairimg, math.floor((x-xscroll)*16*scale), math.floor((y-.5-yscroll)*16*scale), rotation, scale, scale, 4, 8)
		end
	end
end

function portalgun:shootPortal(i)
	shootportal(self.parent.playernumber, i, self.parent.x+6/16, self.parent.y+6/16, self.parent.pointingangle, false)
end

function portalgun:primaryFire()
	if self.parent and weapon.primaryFire(self) then
		self:shootPortal(1)
	else
		print("DEBUG: Tried to shoot portal1 with orphaned weapon?!")
	end
end

function portalgun:secondaryFire()
	if self.parent and weapon.secondaryFire(self) then
		self:shootPortal(2)
	else
		print("DEBUG: Tried to shoot portal with orphaned weapon?!")
	end
end
end end)()end;
do require("package").preload["weapons.gelcannon"] = (function() local package;return function(...)-- <pack weapons.gelcannon> --
gelcannon = class('gelcannon', weapon)
--gelcannon.static.name = 'gelcannon'
function gelcannon:init(parent)
	weapon.init(self,parent)
	self.primaryAttackDelay = gelcannondelay
	self.secondaryAttackDelay = gelcannondelay
	--gelcannonspeed = 30
end

function gelcannon:update(dt)
	weapon.update(self,dt)
	-- nothin'
end

function gelcannon:shootGel(i)
	local newgel = gel:new(self.parent.x+self.parent.width/2+8/16, self.parent.y+self.parent.height/2+6/16, i)
	newgel.speedx = math.cos(-self.parent.pointingangle-math.pi/2)*gelcannonspeed
	newgel.speedy = math.sin(-self.parent.pointingangle-math.pi/2)*gelcannonspeed
	
	table.insert(objects["gel"], newgel)
end

function gelcannon:primaryFire()
	if self.parent and weapon.primaryFire(self) then
		self:shootGel(1)
	else
		print("DEBUG: Tried to shoot gel1 with orphaned weapon?!")
	end
end

function gelcannon:secondaryFire()
	if self.parent and weapon.secondaryFire(self) then
		self:shootGel(2)
	else
		print("DEBUG: Tried to shoot gel2 with orphaned weapon?!")
	end
end
end end)()end;
do require("package").preload["netplay"] = (function() local package;return function(...)-- <pack netplay> --
local alternatesynctimer = -5
networkynccedconfig = false
networkupdatelimit = .05
bypassdupecheck = false
seesawisync = {}

client_sendhistory = {}
client_recvhistory = {}

function client_send(cmd, pl)
	local digest = Tserial.pack({cmd=cmd,pl=pl},true)
	if client_sendhistory[cmd]~=digest or bypassdupecheck then
		client_sendhistory[cmd] = digest
		print("[LUBE|client] Issuing server command '"..cmd.."'!")
		print("CLIENT-DEBUG: "..digest)
		client:send(digest)
	--else
		--print("CLIENT-WARNING-SENDDUPE")
	end
end

function network_load(ip, port)
	ip = ip or "localhost"
	port = port or 27020
	marioworld = 1
	mariolevel = 1
	
	print("[LUBE|client] connecting...")
	client = lube.udpClient()
	client.callbacks.recv = client_recv
	local suc, err = client:connect(ip, tonumber(port))
	if suc then
		game.isClient = true
		--[[ Upon connection, probe the server to get a unique ID. ]]
		print("[LUBE|client] probing server")
		client_send("connect", {nick=guielements.nickentry.value,mappacks=mappacklist})
	else
		print("[LUBE|client] connection failed")
		print("[LUBE|client] failure code: "..tostring(err))
		notice.new("server not found ", notice.red, 5)
	end
	

	networktimeouttimer = 0
	networkwarningssent = 0

	love.filesystem.write("savenick.txt", "return { nick=\"" .. guielements.nickentry.value .. "\"}")

	network_removeplayertimeouttables = {}
	for x = 1, math.max(players, 4) do
		network_removeplayertimeouttables[x] = 0
	end
end
function client_recv(rdata)
	local data = Tserial.unpack(rdata, true)
	if client_recvhistory[data.cmd]~=rdata or bypassdupecheck then
		client_recvhistory[data.cmd] = rdata
		--print("[LUBE|client] Running server->client command '"..data.cmd.."'!")
		--print("DEBUG: "..Tserial.pack(data,true))
		assert(_G["client_callback_"..data.cmd]~=nil, "Received invalid server->client command '"..data.cmd.."'!")
		_G["client_callback_" .. data.cmd](data.pl)
	--else
		--print("CLIENT-WARNING-RECVDUPE")
	end
	
end
function network_update(dt)
	client:update(dt)
	if objects then
		networkupdatetimer = networkupdatetimer + dt
		if networkupdatetimer > networkupdatelimit then 
			networkupdatetimer = networkupdatetimer - networkupdatelimit
			client_send("coordsupdate", {
				--[[@WARNING: 
					We don't want to trust the player to be who they say they are, so
					give the server a function to map a clientid to a playerid.
				]]
				x=objects["player"][1].x,
				y=objects["player"][1].y,
				speedx=objects["player"][1].speedx,
				speedy=objects["player"][1].speedy,
				pointingangle=objects["player"][1].pointingangle,
				--dt=love.timer.getDelta()
			})
		end
	end
end
function network_update2(dt)
	local chan, data = client_receive()
	if objects then
		networktimeouttimer = networktimeouttimer + dt
		for x = 2, math.max(players, 4) do
			network_removeplayertimeouttables[x] = network_removeplayertimeouttables[x]+dt
		end
	end
	while chan and data do
		print("CLIENT: Responding to message '"..chan.."'...")
		if chan == "rejected" then
			if data.reason == "full" then
				notice.new("server is full", notice.red, 5)
			else
				notice.new(data.reason, notice.red, 5)
			end
			onlinemp = false
			udp:close()
			--@TODO: Wrap this.
			return
		elseif chan == "endgame" then
			gamefinished = true
			love.audio.stop()
			gamestate = "lobby"
			objects = nil
			loadbackground("1-1.txt")
			lobby_maxplayers = 4
			local showmagicdns = lobby_showmagicdns
			lobby_load(LOBBY_HOSTNICK)
			guielements.showmagicdnsbutton.var = showmagicdns
			lobby_showmagicdns = showmagicdns
			networksynccedconfig = false
			return
		end

		if not objects then

			network_generallobbysyncs(data)
			return
		end

		--@TODO: Still don't know what this does.
		--[[if datatable[2] and tonumber(datatable[2]) then
			network_removeplayertimeouttables[convertclienttoplayer(tonumber(datatable[2]))] = 0
		end]]

		_G["client_" .. chan](data)
		if networktimeouttimer > 10 then
			notice.new("connection re-established", notice.red, 5)
		end
		networktimeouttimer = 0

		chan, data = client_receive()
	end

	if not objects then
		return
	end
	
	

	enemyupdatetimer = enemyupdatetimer + dt
	if enemyupdatetimer > 1 and clientisnetworkhost then
		enemyupdatetimer = 0
		-- not sure if this is even used?!
	end

	if alternatesynctimer >= 0 then
		alternatesynctimer = alternatesynctimer + dt
	end

	if alternatesynctimer > 1 then
		alternatesynctimer = 0
		if clientisnetworkhost then
			for k, v in pairs(objects["enemy"]) do
				local synctable = {
					id=v.a[1],
					t=v.t,
					x=v.x,
					y=v.y,
					speedx=v.speedx,
					speedy=v.speedy,
				}
				if v.t == "squid" then
					-- I don't know why we do this, we just do.
					synctable.closestplayer = (v.closestplayer%2)+1
				elseif v.t == "bowser" then
					targetx = v.targetx
				elseif v.t == "koopa" then
					flying = v.flying
					small = v.small
				end
				client_send("enemysync", synctable)
			end
			
			local oddsyncs = {"castlefire", "platform", "upfire", "box", "mushroom", "seesawplatform"}
			for _, p in pairs(oddsyncs) do
				local objs = getobjectsonscreen(p)
				for k,v in pairs(objs) do
					local oddsynctable = {
						name=p,
						id=i,
						x=v.x,
						y=v.y,
						speedx=v.speedx,
						speedy=v.speedy,
					}
					if p=="castlefire" then
						oddsynctable.angle = v.angle
					elseif p=="platform" then
						oddsynctable.timer = v.timer
					elseif p=="box" and v.parent then
						oddsynctable.parent = v.parent.playernumber
					end
					client_send("oddsync", {name=p, id=i, angle=v.angle})
				end
			end
		elseif lastplayeronplatform then
			--oddsync seesaw
		end
 	end

	if networktimeouttimer > 20 then
		network_quit()
		notice.new("timed out", notice.red, 6)
	end

	if networktimeouttimer > 10+networkwarningssent and networktimeouttimer < 20 then
		networkwarningssent = networkwarningssent + 1
		notice.new("connection problem ... disconnecting in " .. 10-networkwarningssent, notice.red, 2)
	end

	for x = 2, players do
		if network_removeplayertimeouttables[x] > 15 then
			table.remove(objects["player"], x)
			players = players - 1
		end
	end
end

function getobjectsonscreen(objectstring)
	local objectstosend = {}

	for i, v in pairs(objects[objectstring]) do
		for x = 2, players do
			local k = objects["player"][x]
			if v.x > k.x - width * .75 and v.x < k.x + width then
				table.insert(objectstosend, i)
				break
			end
		end
	end

	return objectstosend
end


function getifmainmario(b)
	for i, v in pairs(objects["player"]) do
		if v == b and i ~= 1 then
			return false
		end
	end
	return true
end

function convertclienttoplayer(clientnumber)
	--print(clientnumber, networkclientnumber)
	if clientnumber < networkclientnumber then 
		return clientnumber+1
	elseif clientnumber == networkclientnumber then
		return 1
	elseif clientnumber > networkclientnumber then
		return clientnumber
	end
end
-- GREAT BIG LIST OF CALLBACKS
function client_callback_connected(pl)
	networksynccedconfig = false
	local nick = guielements.nickentry.value
	lobby_load(nick)
	networkclientnumber = pl.yourpid
	print("connected, my client number is " .. networkclientnumber)
end
function client_callback_rejected(pl)
	notice.new(pl.reason, notice.red, 5)
	onlinemp = false
	client:close()
end
function client_callback_startgame(pl)
	connectionstate = "starting game..."
	players = pl.numplayers
	game_load()
end
function client_callback_synccoords(pl)
	local pid = pl.playerid
	local tid = pl.target
	--if pl.playerid == nil then
		-- this means we were called synccoords as a direct response to someone's move command
	--end
	if tid == networkclientnumber then
		print("WARNING: we tried to update ourselves from network")
		return false
	end
	pl.target = nil
	pl.playerid = nil
	--print("pid="..tostring(pid)..", tid="..tostring(tid)..", ncn="..tostring(networkclientnumber))
	--@DEV: If everything goes wrong, it's because of the above line.
	for k,v in pairs(pl) do
		objects["player"][convertclienttoplayer(tid)][k] = v
	end
end
function client_callback_synccontrol(pl)
	local pid = pl.playerid
	local tid = pl.target
	--if pl.playerid == nil then
		-- this means we were called synccoords as a direct response to someone's move command
	--end
	--print("XDEBUG: "..Tserial.pack(pl,true))
	--print("WE ARE: "..tostring(networkclientnumber).."TID: "..tostring(tid).."CID: "..tostring(convertclienttoplayer(tid)))
	if tid == networkclientnumber then
		print("WARNING: we tried to update ourselves from network")
		return false
	end
	--[[pl.target = nil
	pl.playerid = nil]]
	print("pid="..tostring(pid)..", tid="..tostring(tid)..", ncn="..tostring(networkclientnumber))
	if pl.direction == "press" then
		objects["player"][convertclienttoplayer(tid)]:controlPress(pl.control, true)
	elseif pl.direction == "release" then
		objects["player"][convertclienttoplayer(tid)]:controlRelease(pl.control, true)
	end
end
end end)()end;
do require("package").preload["animation"] = (function() local package;return function(...)-- <pack animation> --
animation = class("animation")

--[[ TRIGGERS:
mapload								when the map is loaded
timepassed:time						when <time> ms have passed
playerxgreater:x					when a player's x is greater than x
playerxless:x						when a player's x is less than x
playerygreater:x					when a player's y is greater than y
playeryless:x						when a player's y is less than y
animationtrigger:i					when animationtrigger with ID i is triggered
--]] 

--[[ CONDITIONS:
noprevsublevel						doesn't if the level was changed from another sublevel (Mario goes through pipe, lands in 1-1_1, prevsublevel was _0, no trigger.)
worldequals:i						only triggers if current world is i
levelequals:i						only triggers if current level is i
sublevelequals:i					only triggers if current sublevel is i
requirecoins:i						requires i coins to trigger (will not remove coins)
--]]

--[[ ACTIONS:
disablecontrols[:player]			disables player input and hides the portal line
enablecontrols[:player]				enables player input and shows portal line
sleep:time							waits for <time> secs
setcamerax:x						sets the camera xscroll to <x>
setcameray:y						sets the camera yscroll to <y>
pancameratox:x:time					pans the camera horizontally over <time> secs to <x>
pancameratoy:y:time					pans the camera vertically over <time> secs to <y>
disablescroll						disables autoscroll
enablescroll						enables autoscroll
setx[:player]:x						sets the x-position of player(s)
sety[:player]:y						sets the y-position of player(s)
playerwalk[:player]:direction		makes players walk into the given <direction>
playeranimationstop[:player]		stops whatever animation the player is in
disableanimation					disables this animation from triggering
enableanimation						enables this animation to trigger
playerjump[:player]					makes players jump (as high as possible)
playerstopjump[:player]				makes players abort the jump (for small jumps)
dialogbox:text[:speaker]			creates a dialogbox with <text> and <speaker>
removedialogbox						removes the dialogbox
playmusic:i							plays music <i>
screenshake:power					makes the screen shake with <power>
addcoins:coins						adds <coins> coins
addpoints:points					adds <points> points
changebackgroundcolor:r:g:b			changes background color ro rgb
killplayer[:player]					kills player(s)
changetime:time						changes the time left to <time>
loadlevel:world:level:sublevel		starts level <world>-<level>_<sublevel>
disableplayeraim:player				disables mouse or joystick aiming for <player>
enableplayeraim:player				enables mouse or joystick aiming for <player>
closeportals[:player]				closes portals for <player>
makeplayerlook:player:angle			makes players aim in direction of <angle>, starting at right and going CCW, should probably be used in connection with "disableplayeraim" because it's just once
makeplayerfireportal:player:i		makes a player shoot one of their portal
enableportalgun:player				enable portal gun of player
disableportalgun:player				disable portal gun of player
--]]

function animation:init(path, name)
	self.filepath = path
	self.name = name
	self.raw = love.filesystem.read(self.filepath)
	
	self:decode(self.raw)
	
	self.firstupdate = true
	self.running = false
	self.sleep = 0
	self.enabled = true
end

function animation:decode(s)
	self.triggers = {}
	self.conditions = {}
	self.actions = {}
	
	local animationjson = JSON:decode(s)

	for i, v in pairs(animationjson.triggers) do
		self:addtrigger(v)
	end
	
	for i, v in pairs(animationjson.conditions) do
		self:addcondition(v)
	end
	
	for i, v in pairs(animationjson.actions) do
		self:addaction(v)
	end
end

function animation:addtrigger(v)
	table.insert(self.triggers, {unpack(v)})
	if v[1] == "mapload" then
		
	elseif v[1] == "timepassed" then
		self.timer = 0
	elseif v[1] == "playerx" then
	
	elseif v[1] == "animationtrigger" then
		if not animationtriggerfuncs[v[2] ] then
			animationtriggerfuncs[v[2] ] = {}
		end
		table.insert(animationtriggerfuncs[v[2] ], self)
	end
end

function animation:addcondition(v)
	table.insert(self.conditions, {unpack(v)})
end

function animation:addaction(v)
	table.insert(self.actions, {unpack(v)})
end

function animation:update(dt)
	--check my triggers for triggering, yo
	for i, v in pairs(self.triggers) do
		if v[1] == "mapload" then
			if self.firstupdate then
				self:trigger()
			end
		elseif v[1] == "timepassed" then
			self.timer = self.timer + dt
			if self.timer >= tonumber(v[2]) and self.timer - dt < tonumber(v[2]) then
				self:trigger()
			end
		elseif v[1] == "playerxgreater" then
			local trig = false
			for i = 1, players do
				if objects["player"][i].x+objects["player"][i].width/2 > tonumber(v[2]) then
					trig = true
				end
			end
			
			if trig then
				self:trigger()
			end
		elseif v[1] == "playerxless" then
			local trig = false
			for i = 1, players do
				if objects["player"][i].x+objects["player"][i].width/2 < tonumber(v[2]) then
					trig = true
				end
			end
			
			if trig then
				self:trigger()
			end
			
		elseif v[1] == "playerygreater" then
			local trig = false
			for i = 1, players do
				if objects["player"][i].y+objects["player"][i].height/2 > tonumber(v[2]) then
					trig = true
				end
			end
			
			if trig then
				self:trigger()
			end
		elseif v[1] == "playeryless" then
			local trig = false
			for i = 1, players do
				if objects["player"][i].y+objects["player"][i].height/2 < tonumber(v[2]) then
					trig = true
				end
			end
			
			if trig then
				self:trigger()
			end
		end
	end
	
	self.firstupdate = false
	
	if self.running then
		if self.sleep > 0 then
			self.sleep = math.max(0, self.sleep - dt)
		end
		
		while self.sleep == 0 and self.currentaction <= #self.actions do
			local v = self.actions[self.currentaction]
			if v[1] == "disablecontrols" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][1].controlsenabled = false
					end
				else
					local p = objects["player"][tonumber(string.sub(v[2], -1))]
					if p then
						p.controlsenabled = false
					end
				end
			elseif v[1] == "enablecontrols" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][1].controlsenabled = true
					end
				else
					local p = objects["player"][tonumber(string.sub(v[2], -1))]
					if p then
						p.controlsenabled = true
					end
				end
			elseif v[1] == "sleep" then
				self.sleep = tonumber(v[2])
			elseif v[1] == "animationtarget" then
				print(" we do animaiton ", #objects["animationtarget"], v[1], v[2])
				for h,j in pairs(objects["animationtarget"]) do
					if j.id == v[2] then
						j:out("on")
					end
				end
			elseif v[1] == "setcamerax" then
				xscroll = tonumber(v[2])
			elseif v[1] == "pancameratox" then
				autoscroll = false
				cameraxpan(tonumber(v[2]), tonumber(v[3]))
			elseif v[1] == "pancameratoy" then
				autoscroll = false
				cameraypan(tonumber(v[2]), tonumber(v[3]))
			elseif v[1] == "disablescroll" then
				autoscroll = false
			elseif v[1] == "enablescroll" then
				autoscroll = true
			elseif v[1] == "setx" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i].x = tonumber(v[3])
					end
				else
					if objects["player"][tonumber(string.sub(v[3], -1))] then
						objects["player"][tonumber(string.sub(v[3], -1))].x = tonumber(v[4])
					end
				end
			elseif v[1] == "sety" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i].y = tonumber(v[3])
					end
				else
					if objects["player"][tonumber(string.sub(v[3], -1))] then
						objects["player"][tonumber(string.sub(v[3], -1))].y = tonumber(v[4])
					end
				end
			elseif v[1] == "playerwalk" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:animationwalk(v[3])
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:animationwalk(v[3])
					end
				end
			elseif v[1] == "playeranimationstop" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:stopanimation()
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:stopanimation()
					end
				end
			elseif v[1] == "disableanimation" then
				self.enabled = false
			elseif v[1] == "enableanimation" then
				self.enabled = true
			elseif v[1] == "playerjump" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:jump(true)
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:jump(true)
					end
				end
			elseif v[1] == "playerstopjump" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:stopjump(true)
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:stopjump()
					end
				end
			elseif v[1] == "dialogbox" then
				createdialogbox(v[2], v[3])
			elseif v[1] == "removedialogbox" then
				dialogboxes = {}
			
			elseif v[1] == "playmusic" then
				love.audio.stop()
				if v[2] then
					if musicname then
						music:stop(musicname)
					end
					musicname = v[2]
					playmusic()
				end
			elseif v[1] == "screenshake" then
				earthquake = tonumber(v[2]) or 1
			elseif v[1] == "addcoins" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:getcoin(tonumber(v[3]) or 1)
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:getcoin(tonumber(v[3]) or 1)
					end
				end
			elseif v[1] == "addpoints" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:getscore(tonumber(v[3]) or 1)
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:getscore(tonumber(v[3]) or 1)
					end
				end
			elseif v[1] == "changebackgroundcolor" then
				love.graphics.setBackgroundColor(tonumber(v[2]) or 255, tonumber(v[3]) or 255, tonumber(v[4]) or 255)
			elseif v[1] == "killplayer" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:die("script")
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:die("script")
					end
				end
			elseif v[1] == "changetime" then
				mariotime = (tonumber(v[2]) or 400)
			elseif v[1] == "loadlevel" then
				love.audio.stop()
				
				marioworld = tonumber(v[2]) or marioworld
				mariolevel = tonumber(v[3]) or mariolevel
				mariosublevel = tonumber(v[4]) or mariosublevel
				levelscreen_load("next")
				
			elseif v[1] == "disableplayeraim" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i].disableaiming = true
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))].disableaiming = true
					end
				end
			elseif v[1] == "enableplayeraim" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i].disableaiming = false
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))].disableaiming = false
					end
				end
			
			elseif v[1] == "closeportals" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i]:removeportals()
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))]:removeportals()
					end
				end
				
			elseif v[1] == "makeplayerlook" then
				local ang = math.mod(math.mod(tonumber(v[3]), 360)+360, 360)
				
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i].pointingangle = math.rad(ang)-math.pi/2
					end
				else
					if objects["player"][tonumber(string.sub(v[2], -1))] then
						objects["player"][tonumber(string.sub(v[2], -1))].pointingangle = math.rad(ang)-math.pi/2
					end
				end
			
			elseif v[1] == "makeplayerfireportal" then
				if tonumber(v[3]) == 1 or tonumber(v[3]) == 2 then
					if v[2] == "everyone" then
						for i = 1, players do
							local sourcex = objects["player"][i].x+6/16
							local sourcey = objects["player"][i].y+6/16
							local direction = objects["player"][i].pointingangle
							
							shootportal(i, 1, sourcex, sourcey, direction)
						end
					else
						local i = tonumber(string.sub(v[2], -1))
						
						if objects["player"][i] then
							local sourcex = objects["player"][i].x+6/16
							local sourcey = objects["player"][i].y+6/16
							local direction = objects["player"][i].pointingangle
							
							shootportal(i, 1, sourcex, sourcey, direction)
						end
					end
				end
				
			elseif v[1] == "disableportalgun" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i].portalgundisabled = true
					end
				else
					local i = tonumber(string.sub(v[2], -1))
					if objects["player"][i] then
						objects["player"][i].portalgundisabled = true
					end
				end
				
			elseif v[1] == "enableportalgun" then
				if v[2] == "everyone" then
					for i = 1, players do
						objects["player"][i].portalgundisabled = false
					end
				else
					local i = tonumber(string.sub(v[2], -1))
					if objects["player"][i] then
						objects["player"][i].portalgundisabled = false
					end
				end
			end
			
			self.currentaction = self.currentaction + 1
		end
		
		if self.currentaction > #self.actions then
			self.running = false
		end
	end
end

function animation:trigger()
	if self.enabled then
		--check conditions
		local pass = true
		
		for i, v in pairs(self.conditions) do
			if v[1] == "noprevsublevel" then
				if prevsublevel then
					pass = false
					break
				end
			elseif v[1] == "sublevelequals" then
				print(mariosublevel)
				if (v[2] == "main" and (tonumber(mariosublevel) ~= 0)) or (v[2] ~= "main" and tonumber(v[2]) ~= tonumber(mariosublevel)) then
					pass = false
					break
				end
			elseif v[1] == "levelequals" then
				if tonumber(v[2]) ~= tonumber(mariolevel) then
					pass = false
					break
				end
			elseif v[1] == "worldequals" then
				if tonumber(v[2]) ~= tonumber(marioworld) then
					pass = false
					break
				end
			elseif v[1] == "requirecoins" then
				if mariocoincount < tonumber(v[2]) then
					pass = false
					break
				end
			end
		end
		
		if pass then
			self.running = true
			self.currentaction = 1
			self.sleep = 0
		end
	end
end

function animation:draw()
	
end
end end)()end;
do require("package").preload["gui"] = (function() local package;return function(...)-- <pack gui> --
guielement = class("guielement")

function guielement:init(...)
	local arg = {...}
	self.active = true
	self.priority = false
	if arg[1] == "checkbox" then --checkbox(x, y, func, start)
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.func = arg[4]
		if not arg[5] or arg[5] == false then
			self.var = false
		else
			self.var = true
		end
		self.text = arg[6]
	elseif arg[1] == "dropdown" then --dropdown(x, y, width (in chars), func, start, {entries})
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.starty = self.y
		self.width = arg[4]
		self.func = arg[5]
		self.var = arg[6] or 1
		self.entries = {}
		for i = 7, #arg do
			table.insert(self.entries, arg[i])
		end
		self.extended = false
		self.cutoff = true
	elseif arg[1] == "rightclick" then --rightclick(x, y, width (in chars), func, start, {entries})
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.width = arg[4]
		self.func = arg[5]
		self.var = arg[6] or nil
		self.entries = {}
		for i = 7, #arg do
			table.insert(self.entries, arg[i])
		end
		self.priority = true
		
		if self.y > 112 then
			self.direction = "up"
		else
			self.direction = "down"
		end
	elseif arg[1] == "button" then --button(x, y, text, func, space, arguments (in a table), height, width, autorepeat)
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.text = arg[4]
		self.func = arg[5]
		self.space = arg[6] or 0
		if type(arg[7]) ~= "table" then
			self.arguments = {}
		else
			self.arguments = arg[7]
		end
		
		if type(self.text) == "string" then
			self.height = (arg[8] or 1)*10
			self.width = arg[9] or string.len(self.text)*8
		elseif type(self.text) == "userdata" then
			self.width = self.text:getWidth()-1
			self.height = self.text:getHeight()+1
		end
		self.autorepeat = arg[10] or false
		
		self.repeatwait = 0.3
		self.repeatdelay = arg[10] or 0.05
		if arg[10] == true then
			self.repeatdelay = 0.05
		end
		self.releasefunc = arg[11]
		
		self.repeatwaittimer = self.repeatwait
		self.repeatdelaytimer = self.repeatdelay
		
		self.bordercolorhigh = {255, 255, 255}
		self.bordercolor = {127, 127, 127}
		
		self.fillcolor = {0, 0, 0}
		self.textcolor = {255, 255, 255}
		
	elseif arg[1] == "scrollbar" then --scrollbar(x, y, range, width, height, default, dir, display, min, max, step, mousewheel)
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.range = arg[4]
		self.width = arg[5]
		self.height = arg[6]
		self.value = tonumber(arg[7]) or 0
		self.dir = arg[8] or "ver"
		self.displaynumber = arg[9] or false
		self.min = tonumber(arg[10]) or 0
		self.max = tonumber(arg[11]) or 1
		self.step = tonumber(arg[12]) or 0.01
		self.usemousewheel = arg[13] or false
		
		self.internvalue = (self.value-self.min)/(self.max-self.min)
		
		if self.dir == "ver" then
			self.yrange = self.range - self.height
		else
			self.xrange = self.range - self.width
		end	
		
		self.backgroundcolor = {127, 127, 127}
		self.bordercolorhigh = {255, 255, 255}
		self.bordercolor = {127, 127, 127}
		
		self.fillcolor = {0, 0, 0}
	elseif arg[1] == "input" then --input(x, y, width, enterfunc, start, maxlength, height, numerical, spacing)
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.width = arg[4]
		self.func = arg[5] or (function() self.inputting = false end)
		self.value = arg[6] or ""
		self.maxlength = arg[7] or 0
		self.height = arg[8] or 1
		self.numerical = arg[9] or false
		self.spacing = arg[10] or 1
		
		self.timer = 0
		self.cursorblink = true
		self.inputting = false
		self.cursorpos = string.len(self.value)+1
		self.offset = 0
		if self.height == 1 then
			if self.cursorpos > math.ceil(self.width) then
				if self.cursorpos == math.ceil(self.width)+1 or #self.value ~= self.width then
					self.offset = self.cursorpos-math.ceil(self.width)-1
				else
					self.offset = self.cursorpos-math.ceil(self.width)
				end
			end
		end
		
		self.bordercolorhigh = {255, 255, 255}
		self.bordercolor = {127, 127, 127}
		
		self.fillcolor = {0, 0, 0}
		self.textcolor = {255, 255, 255}
	elseif arg[1] == "text" then --(x, y, s, color)
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.value = arg[4] or ""
		self.color = arg[5] or {255, 255, 255}
		self.height = 10 --@MAGIC: Font height + 1px padding on top and bottom
		self.width = string.len(self.value)*8 --@MAGIC: Font expected width of 8px per character
	elseif arg[1] == "submenu" then
		self.type = arg[1]
		self.x = arg[2]
		self.y = arg[3]
		self.width = arg[4]
		self.width2 = arg[5]
		self.entries = arg[6]
		self.value = arg[7] or 1
		
		self.suby = self.y
		self.subx = self.x
		
		if self.y+(#self.entries*10) > height*16 then
			if (#self.entries)*10 > height*16 then
				self.missingy = (#self.entries)*10 - height*16
				self.suby = 0
			else
				self.suby = height*16-(#self.entries)*10
			end
		end
		
		if self.missingy then
			self.subx = self.subx + 11
		end
		
		if self.subx+12+self.width*8+self.width2*8 > width*16 then
			self.subx = self.x - (self.width+1)*8 - self.width2*8 - 3
		end
		
		self.extended = false
	end
end

function guielement:update(dt)
	if self.active then
		if self.type == "scrollbar" then
			if self.dragging then
				if self.dir == "ver" then
					local y = (mouse.getY()-self.draggingy) - self.y*scale
					local actualyrange = self.yrange*scale
					
					self.internvalue = y / actualyrange
					self.internvalue = math.min(math.max(self.internvalue, 0), 1) --clamp
				else
					local x = (mouse.getX()-self.draggingx) - self.x*scale
					local actualxrange = self.xrange*scale
					
					self.internvalue = x / actualxrange
					self.internvalue = math.min(math.max(self.internvalue, 0), 1) --clamp
				end
				
				--Apply the step
				self.value = round((self.min + (self.max-self.min)*self.internvalue)/self.step)*self.step
			end
		elseif self.type == "input" then
			self.timer = self.timer + dt
			while self.timer > blinktime do
				self.cursorblink = not self.cursorblink
				self.timer = self.timer - blinktime
			end
		elseif self.type == "button" then
			if self.autorepeat then
				if self.holding then
					if self.repeatwaittimer <= 0 then
						self.repeatdelaytimer = self.repeatdelaytimer - dt
						while self.repeatdelaytimer <= 0 do
							if self.func then
								self.func(unpack(self.arguments))
							end
							self.repeatdelaytimer = self.repeatdelaytimer + self.repeatdelay
						end
					else
						self.repeatwaittimer = self.repeatwaittimer - dt
					end
				else
					self.repeatwaittimer = self.repeatwait
					self.repeatdelaytimer = self.repeatdelay
				end
			end
		elseif self.type == "dropdown" then
			if self.scrollbar then
				self.scrollbar:update(dt)
				
				self.y = -self.missingy*self.scrollbar.value
			end
		elseif self.type == "submenu" then
			if self.scrollbar then
				self.scrollbar:update(dt)
				
				self.suby = -self.missingy*self.scrollbar.value
			end
		end
	end
end

function guielement:draw(a, offx, offy)
	local drawx = self.x + (offx or 0)
	local drawy = self.y + (offy or 0)
	
	love.graphics.setColor(255, 255, 255, a)
	if self.type == "checkbox" then
		local quad = 1
		if self.var == true then
			quad = 2
		end
		local high = 1
		if self:inhighlight(mouse.getPosition()) then
			high = 2
		end
		
		love.graphics.draw(checkboximg, checkboxquad[high][quad], drawx*scale, drawy*scale, 0, scale, scale)
		
		if self.text then
			properprint(self.text, (drawx+10)*scale, (drawy+1)*scale)
		end
	elseif self.type == "dropdown" then
		local high = self:inhighlight(mouse.getPosition()) or (self.scrollbar and self.scrollbar.dragging)
		
		if self.extended then
			love.graphics.setColor(127, 127, 127, a)
			love.graphics.rectangle("fill", (drawx+2)*scale, (drawy+2)*scale, (13+self.width*8)*scale, (10*(#self.entries+1)+1)*scale)
		end
		
		love.graphics.setColor(127, 127, 127, a)
		if high then
			love.graphics.setColor(255, 255, 255, a)
		end
		
		love.graphics.rectangle("fill", drawx*scale, drawy*scale, (3+self.width*8)*scale, 11*scale)
		love.graphics.draw(dropdownarrowimg, (drawx+2+self.width*8)*scale, drawy*scale, 0, scale, scale)
		
		love.graphics.setColor(0, 0, 0, a)
		love.graphics.rectangle("fill", (drawx+1)*scale, (drawy+1)*scale, (1+self.width*8)*scale, 9*scale)
		
		love.graphics.setColor(255, 255, 255, a)
		if self.extended then
			love.graphics.setColor(127, 127, 127, a)
		end
		local s = self.entries[self.var]
		if self.cutoff then
			s = string.sub(s, 1, self.width)
		end
		
		properprint(s, (drawx+1)*scale, (drawy+2)*scale)
	
		if self.extended then
			love.graphics.setColor(127, 127, 127, a)
			if high then
				love.graphics.setColor(255, 255, 255, a)
			end
			
			love.graphics.rectangle("fill", drawx*scale, (drawy+11)*scale, (13+self.width*8)*scale, (10*#self.entries)*scale)
			
			for i = 1, #self.entries do
				local s = self.entries[i]
				if self.cutoff then
					s = string.sub(s, 1, self.width+1)
				end
				
				if high ~= i then
					love.graphics.setColor(0, 0, 0, a)
					love.graphics.rectangle("fill", (drawx+1)*scale, (drawy+1+i*10)*scale, (11+self.width*8)*scale, 9*scale)
					love.graphics.setColor(255, 255, 255, a)
					properprint(s, (drawx+1)*scale, (drawy+2+10*i)*scale)
				else
					love.graphics.setColor(0, 0, 0, a)
					properprint(s, (drawx+1)*scale, (drawy+2+10*i)*scale)
				end
			end
			
		end
		
		if self.scrollbar then
			self.scrollbar:draw(a)
		end
		
	elseif self.type == "button" then
		local high = self:inhighlight(mouse.getPosition())
		local r, g, b = unpack(self.bordercolor)
		love.graphics.setColor(r, g, b, a)
		if high then
			local r, g, b = unpack(self.bordercolorhigh)
			love.graphics.setColor(r, g, b, a)
		end
		
		love.graphics.rectangle("fill", drawx*scale, drawy*scale, (3+self.width+self.space*2)*scale, (1+self.height+self.space*2)*scale)
		
		local r, g, b = unpack(self.fillcolor)
		love.graphics.setColor(r, g, b, a)
		love.graphics.rectangle("fill", (drawx+1)*scale, (drawy+1)*scale, (1+self.width+self.space*2)*scale, (-1+self.height+self.space*2)*scale)
		
		local r, g, b = unpack(self.textcolor)
		love.graphics.setColor(r, g, b, a)
		if type(self.text) == "string" then
			properprint(self.text, (drawx+1+self.space)*scale, (drawy+2+self.space)*scale)
		elseif type(self.text) == "userdata" then
			love.graphics.draw(self.text, (drawx+1+self.space)*scale, (drawy+1+self.space)*scale, 0, scale, scale)
		end
		
	elseif self.type == "scrollbar" then
		if self.dir == "ver" then
			local high = self:inhighlight(mouse.getPosition())
			
			local r, g, b = unpack(self.backgroundcolor)
			love.graphics.setColor(r, g, b, a)
			love.graphics.rectangle("fill", drawx*scale, drawy*scale, self.width*scale, (self.yrange+self.height)*scale)
		
			local r, g, b = unpack(self.bordercolor)
			love.graphics.setColor(r, g, b, a)
			if self.dragging or high then
			local r, g, b = unpack(self.bordercolorhigh)
			love.graphics.setColor(r, g, b, a)
			end
			
			love.graphics.rectangle("fill", drawx*scale, (drawy+self.yrange*self.internvalue)*scale, (self.width)*scale, (self.height)*scale)
			
			local r, g, b = unpack(self.fillcolor)
			love.graphics.setColor(r, g, b, a)
			love.graphics.rectangle("fill", (drawx+1)*scale, (drawy+1+self.yrange*self.internvalue)*scale, (self.width-2)*scale, (self.height-2)*scale)
		else
			local high = self:inhighlight(mouse.getPosition())
			
			local r, g, b = unpack(self.backgroundcolor)
			love.graphics.setColor(r, g, b, a)
			love.graphics.rectangle("fill", drawx*scale, drawy*scale, (self.xrange+self.width)*scale, self.height*scale)
		
			local r, g, b = unpack(self.bordercolor)
			love.graphics.setColor(r, g, b, a)
			if self.dragging or high then
				local r, g, b = unpack(self.bordercolorhigh)
				love.graphics.setColor(r, g, b, a)
			end
			
			love.graphics.rectangle("fill", (drawx+self.xrange*self.internvalue)*scale, drawy*scale, (self.width)*scale, (self.height)*scale)
			
			local r, g, b = unpack(self.fillcolor)
			love.graphics.setColor(r, g, b, a)
			love.graphics.rectangle("fill", (drawx+1+self.xrange*self.internvalue)*scale, (drawy+1)*scale, (self.width-2)*scale, (self.height-2)*scale)
			
			if self.displaynumber then
				love.graphics.setColor(255, 255, 255, a)
				properprint(formatscrollnumber(self.value), math.floor((drawx+self.xrange*self.internvalue)*scale), (drawy+1)*scale)
			end
		end
	elseif self.type == "input" then
		local high = self:inhighlight(mouse.getPosition())

		local r, g, b = unpack(self.bordercolor)
		love.graphics.setColor(r, g, b, a)
		if self.inputting or high then
			local r, g, b = unpack(self.bordercolorhigh)
			love.graphics.setColor(r, g, b, a)
		end
		
		love.graphics.rectangle("fill", drawx*scale, drawy*scale, (3+self.width*8+2*self.spacing)*scale, (1+self.height*10+2*self.spacing)*scale)
		
		local r, g, b = unpack(self.fillcolor)
		love.graphics.setColor(r, g, b, a)
		love.graphics.rectangle("fill", (drawx+1)*scale, (drawy+1)*scale, (1+self.width*8+2*self.spacing)*scale, (-1+self.height*10+2*self.spacing)*scale)
		
		local r, g, b = unpack(self.textcolor)
		love.graphics.setColor(r, g, b, a)
		--format string
		local oldstring = self.value
		if self.height == 1 then
			oldstring = string.sub(self.value, self.offset+1, self.offset+self.width)
		end
		local newstring = {}
		for i = 1, string.len(oldstring), self.width do
			if math.ceil(i/self.width) > self.height then
				break
			end
			table.insert(newstring, string.sub(oldstring, i, i+self.width-1))
		end
		
		for i = 1, #newstring do
			properprint(newstring[i], (drawx+1+self.spacing)*scale, (drawy+2+self.spacing+(i-1)*10)*scale)
		end
		
		--cursor
		if self.inputting and self.cursorblink then
			local x, y
			if #newstring == 0 then
				x, y = 1, 1
			else
				x, y = #newstring[#newstring]+1, #newstring
			end
			
			if x > self.width then
				if y < self.height and self.height > 1 then
					x = 1
					y = y + 1
				else
					x = x - 1
				end
			end
			
			love.graphics.rectangle("fill", (drawx+1+self.spacing+(x-1)*8)*scale, (drawy+9+self.spacing+(y-1)*10)*scale, 8*scale, 1*scale)
		end
	elseif self.type == "text" then
		local r, g, b = unpack(self.color)
		love.graphics.setColor(r, g, b, a)
		properprint(self.value, drawx*scale, drawy*scale)
		
	elseif self.type == "submenu" then
		local high = self:inhighlight(mouse.getPosition()) or (self.scrollbar and self.scrollbar.dragging)
	
		love.graphics.setColor(127, 127, 127, a)
		if high then
			love.graphics.setColor(255, 255, 255, a)
		end
		
		love.graphics.rectangle("fill", drawx*scale, drawy*scale, (3+self.width*8)*scale, 11*scale)
		
		love.graphics.setColor(0, 0, 0, a)
		love.graphics.rectangle("fill", (drawx+1)*scale, (drawy+1)*scale, (1+self.width*8)*scale, 9*scale)
		
		love.graphics.setColor(255, 255, 255, a)
		if self.extended then
			love.graphics.setColor(127, 127, 127, a)
		end
		
		properprint(string.sub(self.entries[self.value], 1, self.width), (drawx+1)*scale, (drawy+2)*scale)
	
		if self.extended then
			love.graphics.setColor(127, 127, 127, a)
			if high then
				love.graphics.setColor(255, 255, 255, a)
			end
			
			love.graphics.rectangle("fill", (self.subx+9+self.width*8)*scale, (self.suby)*scale, (3+self.width2*8)*scale, (10*#self.entries+1)*scale)
			
			for i = 1, #self.entries do
				if high ~= i then
					love.graphics.setColor(0, 0, 0, a)
					love.graphics.rectangle("fill", (self.subx+10+self.width*8)*scale, (self.suby+1+(i-1)*10)*scale, (1+self.width2*8)*scale, 9*scale)
					love.graphics.setColor(255, 255, 255, a)
					properprint(string.sub(self.entries[i], 1, self.width2), (self.subx+10+self.width*8)*scale, (self.suby+2+10*(i-1))*scale)
				else
					love.graphics.setColor(0, 0, 0, a)
					properprint(string.sub(self.entries[i], 1, self.width2), (self.subx+10+self.width*8)*scale, (self.suby+2+10*(i-1))*scale)
				end
			end
			
			if self.scrollbar then
				self.scrollbar:draw(a)
			end
		end
		
		love.graphics.setColor(127, 127, 127, a)
		if high then
			love.graphics.setColor(255, 255, 255, a)
		end
		love.graphics.draw(dropdownarrowimg, (drawx+5+self.width*8)*scale, (drawy+5)*scale, -math.pi/2, scale, scale, 6, 6)
	end
	love.graphics.setColor(255, 255, 255, a)
end

function guielement:getheight()
	if self.type == "dropdown" then
		return 11+10*#self.entries
	elseif self.type == "submenu" then
		
	end
end

function guielement:click(x, y, button)
	if self.active then
		if self.type == "checkbox" then
			if button == "l" then
				if self:inhighlight(x, y) then
					if not self.func then
						self.var = not self.var
					else
						self.func()
					end
				end
			end
		elseif self.type == "dropdown" then
			if self.scrollbar then
				self.scrollbar:click(x, y, button)
			end
			
			if button == "l" then
				if self.extended == false then
					if self:inhighlight(x, y) then
						self.extended = true
						self.priority = true
						if self.y+self:getheight() > height*16 then
							self.y = height*16-self:getheight()
						end
						
						if self:getheight() > height*16 then
							self.missingy = -self.y
							self.y = 0
							self.scrollbar = guielement:new("scrollbar", self.x-9, 0, height*16, 10, 30, 0, "ver", false, 0, 1, nil, true)
						end
					end
				else
					local high = self:inhighlight(x, y)
					if high == -1 then --scrollbar
						return
					end
					
					self.extended = false
					self.priority = false
					self.y = self.starty
					self.scrollbar = nil
					
					if high then
						if high ~= 0 then
							self.func(high)
						end
						return true
					end
				end
			end
		elseif self.type == "submenu" then
			if self.scrollbar then
				self.scrollbar:click(x, y, button)
			end
			
			if button == "l" then
				if self.extended == false then
					if self:inhighlight(x, y) then
						self.extended = true
						self.priority = true
						
						if self.missingy then
							self.scrollbar = guielement:new("scrollbar", self.subx-9+8+self.width*8, 0, height*16, 10, 30, 0, "ver", false, 0, 1, nil, true)
						end
					end
				else
					local high = self:inhighlight(x, y)
					if high == -1 then --scrollbar
						return true
					end
					
					self.extended = false
					self.priority = false
					
					if high and high ~= 0 then
						self.value = high
						return true
					end
					
					self.scrollbar = nil
				end
			elseif button == "wd" or button == "wu" then
				return true
			end
		elseif self.type == "rightclick" then --Not used anymore I think?
			if button == "l" then
				local high = self:inhighlight(x, y)
				
				if high then
					if high ~= 0 then
						self.func(high)
					end
					return true
				end
			end
		elseif self.type == "button" then
			if button == "l" then
				if self:inhighlight(x, y) then
					self.holding = true
					
					if self.func then
						self.func(unpack(self.arguments))
					end
					return true
				end
			end
		elseif self.type == "scrollbar" then
			if button == "l" then
				if self.dir == "ver" then
					if self:inhighlight(x, y) then
						self.dragging = true
						self.draggingy = y-(self.y+self.yrange*self.internvalue)*scale
					end
				else
					if self:inhighlight(x, y) then
						self.dragging = true
						self.draggingx = x-(self.x+self.xrange*self.internvalue)*scale
					end
				end
			elseif button == "wd" then
				if self.usemousewheel then
					self.internvalue = math.min(1, self.internvalue+0.2)
					self.value = round((self.min + (self.max-self.min)*self.internvalue)/self.step)*self.step
				end
			elseif button == "wu" then
				if self.usemousewheel then
					self.internvalue = math.max(0, self.internvalue-0.2)
					self.value = round((self.min + (self.max-self.min)*self.internvalue)/self.step)*self.step
				end
			end
		elseif self.type == "input" then
			if button == "l" then
				if self:inhighlight(x, y) then
					self.inputting = true
					self.timer = 0
					self.cursorblink = true
				else
					self.inputting = false
				end
			end
		end
	end
end

function guielement:keypress(key)
	if self.active then
		if self.type == "input" then
			if self.inputting then
				--if key == "-" or key == "," or key == ":" or key == ";" then
				--	return
				--end
				if key == "escape" then
					self.inputting = false
				elseif (key == "return" or key == "enter" or key == "kpenter") then
					if self.func then
						self:func()
					else
						self.inputting = false
					end
				elseif key == "backspace" then
					self.value = string.sub(self.value, 1, string.len(self.value)-1)
					if self.cursorpos > 1 and self.cursorpos > string.len(self.value)+1 then
						self.cursorpos = self.cursorpos - 1
					end
					if self.offset > 0 and self.offset > string.len(self.value)-self.width+1 then
						self.offset = self.offset - 1
					end
				else
					if string.len(self.value) < self.maxlength or self.maxlength == 0 then
						local found = false
						for i = 1, string.len(fontglyphs) do
							if key == string.sub(fontglyphs, i, i) then
								found = true
								break
							end
						end
						
						if found and (not self.numerical or tonumber(key) or key == "." or key == ",") then
							if key == "," then
								key = "."
							end
							
							self.value = self.value .. key
							if self.cursorpos ~= self.maxlength then
								self.cursorpos = self.cursorpos + 1
							end
							if self.cursorpos > self.offset+self.width then
								self.offset = self.offset + 1
							end
						end
					end
				end
				
				return true
			end
		end
	end
end

function guielement:unclick(x, y, button)
	if self.active then
		if self.type == "scrollbar" then
			self.dragging = false
		elseif self.type == "button" then
			if button == "l" and self:inhighlight(x, y) then
				if self.releasefunc then
					self.releasefunc(unpack(self.arguments))
				end
				self.holding = false
				return true
			else
				self.holding = false
			end
		elseif self.type == "dropdown" then
			if self.scrollbar then
				self.scrollbar:unclick(x, y, button)
			end
		elseif self.type == "submenu" then
			if self.scrollbar then
				self.scrollbar:unclick(x, y, button)
			end
		end
	end
end

function guielement:inhighlight(x, y)
	if self.type == "checkbox" then
		local xadd = 0
		if self.text then
			xadd = string.len(self.text)*8+1
		end
		if x >= self.x*scale and x < (self.x+9+xadd)*scale and y >= self.y*scale and y < (self.y+9)*scale then
			return true
		end
	elseif self.type == "dropdown" then
		if self.extended == false then
			if x >= self.x*scale and x < (self.x+13+self.width*8)*scale and y >= self.y*scale and y < (self.y+11)*scale then
				return true
			end
		else
			local myx, widthadd = self.x, 0
			if self.scrollbar then
				myx = self.x - self.scrollbar.width+1
				widthadd = self.scrollbar.width-1
			end
			
			if x >= myx*scale and x < (myx+13+self.width*8+widthadd)*scale and y >= self.y*scale and y < (self.y+10*#self.entries+11)*scale then
				if x < self.x*scale then
					return -1
				end
				--get which entry
				return math.max(0, math.floor((y-(self.y+1)*scale) / (10*scale)))
			end
		end
	elseif self.type == "submenu" then
		local r = false
		if x >= self.x*scale and x < (self.x+10+self.width*8)*scale and y >= self.y*scale and y < (self.y+11)*scale then
			r = 0
		end
		if self.extended then
			local subx = self.subx
			local widthadd = 0
			if self.scrollbar then
				subx = subx - self.scrollbar.width
				widthadd = self.scrollbar.width
			end
			
			if x >= (subx+9+self.width*8)*scale and x < (subx+12+self.width*8+self.width2*8+widthadd)*scale and y >= self.suby*scale and y < (self.suby+10*#self.entries+1)*scale then
			
				if x < (subx+9+self.width*8+widthadd)*scale then
					return -1
				end
			
				--get which entry
				if math.max(0, math.floor((y-(self.suby+1)*scale) / (10*scale)))+1 then
					r = math.max(0, math.floor((y-(self.suby+1)*scale) / (10*scale)))+1
				end
			end
		end
		
		return r
	elseif self.type == "rightclick" then
		if self.direction == "down" then
			if x >= self.x*scale and x < (self.x+3+self.width*8)*scale and y >= self.y*scale and y < (self.y+10*#self.entries+1)*scale then
				--get which entry
				return math.max(0, math.floor((y-(self.y+1)*scale) / (10*scale))+1)
			end
		else
			if x >= self.x*scale and x < (self.x+3+self.width*8)*scale and y >= (self.y-10*(#self.entries-1))*scale and y < (self.y+11)*scale then
				--get which entry
				return math.max(0, math.floor((self.y*scale-y) / (10*scale))+2)
			end
		end
	elseif self.type == "button" then
		if x >= self.x*scale and x < (self.x+3+self.width+self.space*2)*scale and y >= self.y*scale and y < (self.y+1+self.height+self.space*2)*scale then
			return true
		end
	elseif self.type == "scrollbar" then
		if self.dir == "ver" then
			if x >= self.x*scale and x < (self.x+self.width)*scale and y >= (self.y+self.yrange*self.internvalue)*scale and y < (self.height+self.y+self.yrange*self.internvalue)*scale then
				return true
			end
		else
			if x >= (self.x+self.xrange*self.internvalue)*scale and x < (self.x+self.width+self.xrange*self.internvalue)*scale and y >= self.y*scale and y < (self.height+self.y)*scale then
				return true
			end
		end
	elseif self.type == "input" then
		if x >= self.x*scale and x < (self.x+3+self.width*8+2*self.spacing)*scale and y >= self.y*scale and y < (self.y+1+self.height*10+2*self.spacing)*scale then
			return true
		end
	end
	
	return false
end
end end)()end;
do require("package").preload["characterloader"] = (function() local package;return function(...)-- <pack characterloader> --
function loadcharacter(charname)
	local folder = "characters/" .. charname .. "/"
	if not love.filesystem.exists(folder .. "config.txt") then
		return false
	end
	
	local s = love.filesystem.read(folder .. "config.txt")
	
	--------------------
	--VARIABLE LOADING-- 
	--------------------
	
	local char = JSON:decode(s)
	char.name = (char.name and string.lower(char.name)) or string.lower(charname)
	
	-----------------
	--IMAGE LOADING--
	-----------------
	for t = 1, 4 do
		local curtype
		if t == 1 then
			curtype = "animations"
		elseif t == 2 then
			curtype = "biganimations"
		elseif t == 3 then
			curtype = "nogunanimations"
		else
			curtype = "nogunbiganimations"
		end
		
		if char.defaultcolors and love.filesystem.exists(folder .. curtype .. "1.png") then --MULTIPLE IMAGES
			local imagecount = #char.defaultcolors[1]
			for i = 1, imagecount do
				if not love.filesystem.exists(folder .. curtype .. i .. ".png") then
					if t <= 2 then
						return false
					else
						break
					end
				end
				if not char[curtype] then
					char[curtype] = {}
				end
				char[curtype][i] = love.graphics.newImage(folder .. curtype .. i .. ".png")
			end
			
			--0 Image
			if love.filesystem.exists(folder .. curtype .. "0.png") then
				char[curtype][0] = love.graphics.newImage(folder .. curtype .. "0.png")
			end
			
			--Dot Image
			if love.filesystem.exists(folder .. curtype .. "dot.png") then
				char[curtype]["dot"] = love.graphics.newImage(folder .. curtype .. "dot.png")
			end
		else
			if love.filesystem.exists(folder .. curtype .. ".png") then
				char[curtype] = love.graphics.newImage(folder .. curtype .. ".png")
			end
		end
	end
	
	----------------
	--QUAD LOADING--
	----------------
	local quadnum = 5
	if char.nopointing then
		quadnum = 1
	end
	char.idle = {}
	char.run = {}
	char.slide = {}
	char.jump = {}
	char.die = {}
	char.climb = {}
	char.swim = {}
	char.grow = {}
	char.customframe = {}
	
	for i = 1, quadnum do
		local add = 0
		char.idle[i] = love.graphics.newQuad(0, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		
		char.run[i] = {}
		for j = 1, char.runframes do
			char.run[i][j] = love.graphics.newQuad(j*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		end
		add = add + char.runframes
		
		char.slide[i] = love.graphics.newQuad((add+1)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		
		char.jump[i] = {}
		for j = 1, char.jumpframes do
			char.jump[i][j] = love.graphics.newQuad((add+1+j)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		end
		add = add + char.jumpframes
		
		char.die[i] = love.graphics.newQuad((add+2)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		
		char.climb[i] = {}
		char.climb[i][1] = love.graphics.newQuad((add+3)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		char.climb[i][2] = love.graphics.newQuad((add+4)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		
		char.swim[i] = {}
		char.swim[i][1] = love.graphics.newQuad((add+5)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		char.swim[i][2] = love.graphics.newQuad((add+6)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		
		char.grow[i] = love.graphics.newQuad((add+7)*char.smallquadwidth, 0, char.smallquadwidth, char.smallimgheight, char.smallimgwidth, char.smallimgheight)
		
		char.customframe[i] = {}
		for j = 1, (char.customframes or 0) do
			char.customframe[i][j] = love.graphics.newQuad((add+7+j)*char.smallquadwidth, (i-1)*char.smallquadheight, char.smallquadwidth, char.smallquadheight, char.smallimgwidth, char.smallimgheight)
		end
	end
	
	char.bigidle = {}
	char.bigrun = {}
	char.bigslide = {}
	char.bigjump = {}
	char.bigfire = {}
	char.bigclimb = {}
	char.bigswim = {}
	char.bigduck = {} --hehe duck.
	char.bigcustomframe = {}

	for i = 1, quadnum do
		local add = 0
		char.bigidle[i] = love.graphics.newQuad(0, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		
		char.bigrun[i] = {}
		for j = 1, char.runframes do
			char.bigrun[i][j] = love.graphics.newQuad(j*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		end
		add = add + char.runframes
		
		char.bigslide[i] = love.graphics.newQuad((add+1)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		
		char.bigjump[i] = {}
		for j = 1, char.jumpframes do
			char.bigjump[i][j] = love.graphics.newQuad((add+1+j)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		end
		add = add + char.jumpframes
		
		char.bigfire[i] = love.graphics.newQuad((add+2)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		
		char.bigclimb[i] = {}
		char.bigclimb[i][1] = love.graphics.newQuad((add+3)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		char.bigclimb[i][2] = love.graphics.newQuad((add+4)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		
		char.bigswim[i] = {}
		char.bigswim[i][1] = love.graphics.newQuad((add+5)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		char.bigswim[i][2] = love.graphics.newQuad((add+6)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		
		char.bigduck[i] = love.graphics.newQuad((add+7)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		
		char.bigcustomframe[i] = {}
		for j = 1, (char.customframes or 0) do
			char.bigcustomframe[i][j] = love.graphics.newQuad((add+7+j)*char.bigquadwidth, (i-1)*char.bigquadheight, char.bigquadwidth, char.bigquadheight, char.bigimgwidth, char.bigimgheight)
		end
	end
	
	return char
end

characterlist = {}
characters = {}
for i, v in pairs(love.filesystem.getDirectoryItems("characters/")) do
	if (love.filesystem.isDirectory("characters/" .. v)) then
		local temp = loadcharacter(v)
		if temp then
			characters[v] = temp
			table.insert(characterlist, v)
		end
	end
end
end end)()end;
do require("package").preload["portal"] = (function() local package;return function(...)-- <pack portal> --
portal = class("portal")

function portal:init(number, c1, c2, parent)	
	self.parent = parent
	self.number = number
	self.portal1color = c1 or {60, 188, 252}
	self.portal2color = c2 or {232, 130, 30}
	self.animationtimer = 0
	self.portalframe = 1
	self.openscale = {0, 0}
	
	self.x1, self.y1, self.facing1, self.x2, self.y2, self.facing2 = false, false, false, false, false, false
end

function portal:createportal(i, cox, coy, side, tendency)
	if cox and tendency then
		local otheri = 1
		if i == 1 then
			otheri = 2
		end
		
		--@NOTE: Wonder what would happen if we *didn't* do this. Try it out some time.
		moveoutportal(i)
	
		--remove the portal temporarily so that it doesn't obstruct itself
		local oldx, oldy, oldfacing
		if i == 1 then
			oldx, oldy, oldfacing = self.x1, self.y1, self.facing1
			self.x1, self.y1 = false, false
		else
			oldx, oldy, oldfacing = self.x2, self.y2, self.facing2
			self.x2, self.y2 = false, false
		end
		
		local newx, newy = getportalposition(i, cox, coy, side, tendency)
		
		if newx and (newx ~= oldx or newy ~= oldy or side ~= oldfacing) then
			if i == 1 then
				self.x1 = newx
				self.y1 = newy
				self.facing1 = side
			else
				self.x2 = newx
				self.y2 = newy
				self.facing2 = side
			end
	
			--physics
			--Recreate old hole
			if oldfacing == "up" then	
				modifyportaltiles(oldx, oldy, 1, 0, self, i, "add")
			elseif oldfacing == "down" then	
				modifyportaltiles(oldx, oldy, -1, 0, self, i, "add")
			elseif oldfacing == "left" then	
				modifyportaltiles(oldx, oldy, 0, -1, self, i, "add")
			elseif oldfacing == "right" then	
				modifyportaltiles(oldx, oldy, 0, 1, self, i, "add")
			end
			
			local otheri = 1
			if i == 1 then
				otheri = 2
			end
			
			if oldx == false then --Remove blocks from other portal
				local x, y, side
				if otheri == 1 then
					side = self.facing1
					x, y = self.x1, self.y1
				else
					side = self.facing2
					x, y = self.x2, self.y2
				end
					
				if side == "up" then
					modifyportaltiles(x, y, 1, 0, self, otheri, "remove")
				elseif side == "down" then
					modifyportaltiles(x, y, -1, 0, self, otheri, "remove")
				elseif side == "left" then
					modifyportaltiles(x, y, 0, -1, self, otheri, "remove")
				elseif side == "right" then
					modifyportaltiles(x, y, 0, 1, self, otheri, "remove")
				end
			end
			
			if i == 1 then
				playsound("portal1open", x, y)
			else
				
				playsound("portal2open", x, y)
			end
			
			modifyportalwalls()
			updateranges()
			self.openscale[i] = 0
		else
			--recreate the temporarily removed portal
			self["x" .. i],  self["y" .. i] = oldx, oldy
		end
	end
end

function portal:removeportal(i)
	if self["x" .. i] then
		moveoutportal(i)
		local otheri = 1
		if i == 1 then
			otheri = 2
		end
		
		if self["facing" .. i] == "up" then	
			modifyportaltiles(self["x" .. i], self["y" .. i], 1, 0, self, i, "add")
		elseif self["facing" .. i] == "down" then	
			modifyportaltiles(self["x" .. i], self["y" .. i], -1, 0, self, i, "add")
		elseif self["facing" .. i] == "left" then	
			modifyportaltiles(self["x" .. i], self["y" .. i], 0, -1, self, i, "add")
		elseif self["facing" .. i] == "right" then	
			modifyportaltiles(self["x" .. i], self["y" .. i], 0, 1, self, i, "add")
		end
		
		if self["x" .. otheri] then
			if self["facing" .. otheri] == "up" then	
				modifyportaltiles(self["x" .. otheri], self["y" .. otheri], 1, 0, self, otheri, "add")
			elseif self["facing" .. otheri] == "down" then	
				modifyportaltiles(self["x" .. otheri], self["y" .. otheri], -1, 0, self, otheri, "add")
			elseif self["facing" .. otheri] == "left" then	
				modifyportaltiles(self["x" .. otheri], self["y" .. otheri], 0, -1, self, otheri, "add")
			elseif self["facing" .. otheri] == "right" then	
				modifyportaltiles(self["x" .. otheri], self["y" .. otheri], 0, 1, self, otheri, "add")
			end
		end
		
		playsound("portalfizzle", self["x"..i], self["y"..i]) --point entity, no velocity
		
		self["x" .. i] = false
		self["y" .. i] = false
		self["facing" .. i] = false
		
		modifyportalwalls()
		for j = 1, 6 do
			objects["portalwall"][self.number .. "-" .. i .. "-" .. j] = nil
		end
		updateranges()
	end
end

function portal:update(dt)
	self.animationtimer = self.animationtimer + dt
	while self.animationtimer > portalanimationdelay do
		self.animationtimer = 0
		self.portalframe = self.portalframe + 1
		if self.portalframe > portalanimationcount then
			self.portalframe = 1
		end
	end
	
	for i = 1, 2 do
		self.openscale[i] = math.min(1, self.openscale[i]+dt*15)
	end
end

function portal:draw()
	for i = 1, 2 do
		if self["x" .. i] ~= false then
			--Standard values "up"
			local rotation = 0
			local offsetx, offsety = 16, -3
			if self["facing" .. i] == "right" then
				rotation = math.pi/2
				offsetx, offsety = 11, 8
			elseif self["facing" .. i] == "down" then
				rotation = math.pi
				offsetx, offsety = 0, 3
			elseif self["facing" .. i] == "left" then
				rotation = math.pi*1.5
				offsetx, offsety = 5, -8
			end
			
			local glowalpha = 100
			if self.x2 and self.x1 then
				--portal glow
				love.graphics.setColor(255, 255, 255, 80 - math.abs(self.portalframe-3)*10)
				love.graphics.draw(portalglowimg, math.floor(((self["x" .. i]-1-xscroll)*16+offsetx)*scale), math.floor(((self["y" .. i]-yscroll-1)*16+offsety)*scale), rotation, scale*self.openscale[i], scale, 16, 20)
				love.graphics.setColor(255, 255, 255, 255)
			end
			
			love.graphics.setColor(unpack(self["portal" .. i .. "color"]))
			love.graphics.draw(portalimg, portalquad[self.portalframe], math.floor(((self["x" .. i]-1-xscroll)*16+offsetx)*scale), math.floor(((self["y" .. i]-yscroll-1)*16+offsety)*scale), rotation, scale*self.openscale[i], scale, 16, 8)
		end
	end
end
end end)()end;
do require("package").preload["soundman"] = (function() local package;return function(...)-- <pack soundman> --
soundman = class("soundman")

--[[
	this is a class meant to manage all sound sources, mostly to allow us to manage 3d sound sources easily
]]


function soundman:init()
	self.soundlist = {} --the list of sounds that should be managed
	self.delaylist = {} --the list of sounds to be delayed
	self.soundenabled = true --whether or not sounds are enabled globally
	self.usepositionalsound = true --whether the listener is global, whether
	
	-- listener sfx properties:
	--DistanceModel: distmodel (none, inverse, inverse clamped, linear, linear clamped, exponent, exponent clamped)
	--Orientation: vector upward, vector forward
	--default: 0, 0, -1; 0, 1, 0
	--Position: x, y, z
	--default: 0, 0, 0
	--Velocity: x, y, z
	--Volume: float volume
	
	-- individual sfx properties:
	--AttenuationDistances: num ref, num max
	--Cone: rad innerAngle, rad outerAngle, float outerVolume
	--Direction: x, y, z
	--Looping: bool
	--Pitch: float
	--Position: x, y, z
	--Relative: bool
	--Rolloff: num
	--Velocity: x, y, z
	--Volume: float volume (max: 1.0)
	--VolumeLimits: min, max
	
end

function playsound2(sound)
	if not soundlist[sound] then
		return
	end

	if soundenabled then
		if delaylist[sound] then
			local currenttime = love.timer.getTime()
			if currenttime-soundlist[sound].lastplayed > delaylist[sound] then
				soundlist[sound].lastplayed = currenttime
			else
				return
			end
		end
		
		soundlist[sound].source:stop()
		soundlist[sound].source:rewind()
		soundlist[sound].source:play()
	end
end

end end)()end;
do require("package").preload["globals"] = (function() local package;return function(...)-- <pack globals> --
--[[
	The purpose of this is to document / list variables in the global scope.
]]

soundsearchdirs = {
	"mappacks/%(mappack)s/sounds/%(soundpack)s/%(file)s",
	"mappacks/%(mappack)s/sounds/DEFAULT/%(file)s",
	"mappacks/%(mappack)s/music/%(file)s",
	"sounds/%(soundpack)s/%(file)s",
	"sounds/DEFAULT/%(file)s",
	"sounds/DEFAULT/missingsound.ogg"
}

graphicssearchdirs = {
	"mappacks/%(mappack)s/graphics/%(graphicspack)s/%(file)s",
	"mappacks/%(mappack)s/graphics/DEFAULT/%(file)s",
	"mappacks/%(mappack)s/graphics/%(file)s",
	"graphics/%(graphicspack)s/%(file)s",
	"graphics/DEFAULT/%(file)s",
	"graphics/DEFAULT/guihud/missinggraphic.png"
}

enemygraphicsearchdirs = {
	"mappacks/%(mappack)s/graphics/%(graphicspack)s/enemies/%(file)s",
	"mappacks/%(mappack)s/graphics/DEFAULT/enemies/%(file)s",
	"mappacks/%(mappack)s/enemies/%(file)s",
	"graphics/%(graphicspack)s/enemies/%(file)s",
	"graphics/DEFAULT/enemies/%(file)s",
	"enemies/%(file)s",
}

neuControlTable = {
	playerDebug = {
		itype = "key",
		const = "x",
	},
	comboDebug = {
		{
			itype = "key",
			const = "x",
		},
		{
			itype = "key",
			const = "c",
		},
	},
}

controlTable = {
	keys = {
		x = "playerDebug",
		w = {"playerUp", "menuUp", "editorNudgeUp"},
		a = {"playerLeft", "menuLeft", "editorNudgeLeft"},
		s = {"playerDown", "menuDown", "editorNudgeDown", "editorQuickSave"},
		d = {"playerRight", "menuRight", "editorNudgeRight"},
		e = {"editorErase"},
		up = {"menuUp", "editorScrollUp"},
		left = {"menuLeft", "editorScrollLeft"},
		m = {"gameShortcutMappackFolder"},
		down = {"menuDown", "editorScrollDown"},
		right = {"menuRight", "editorScrollRight"},
		--k = {"replaySave"},
		
		--(key == "return" or key == "enter" or key == "kpenter" or key == " ")
		["return"] = "menuSelect",
		tab = "menuNextElement", --unimplemented
		f = {"playerUse", "debugEmbiggen"},
		escape = {"playerPause", "menuBack"},
		--l = "playerSuicide",
		t = {"editorTestLevelToggle"},
		lshift = {"playerRun", "debugModifier"},
		lctrl = "editorShortcutModifier",
		--lalt = "debugModifier", --Until love 0.9.2 or 0.10.0 we can't use alt on Windows-based machines. :(
		r = "playerReload",
		delete = "editorDelete",
		[" "] = {"playerJump", "menuSelect"},
		
		h = "editorCameraFollowToggle",
		tab = "editorQuickToggle",
		
		kp4 = "editorPreviousLevel",
		kp6 = "editorNextLevel",
		
		
		f1 = "editorTabMain",
		--f2 = "editorTabTiles",
		f2 = "editorTabTools",
		f3 = "editorTabMaps",
		f4 = "editorTabAnimations",
		
		f9 = "debugLua",
		f10 = "debugCrash",
		f11 = "gameScreenshot",
		f12 = "gameGrabMouseToggle",
		--y = "recordToggle",
		
		["1"] = "editorTilesAll",
		--["2"] = "editorTilesSMB",
		--["3"] = "editorTilesPortal",
		--["4"] = "editorTilesCustom",
		["2"] = "editorTilesAnimated",
		["3"] = "editorTilesEntities",
		["4"] = "editorTilesEnemies",
	},
	mouseBtns = {
		l = {"playerPrimaryFire", "editorSelect", "editorPaint"},
		m = {"playerReload", "editorDropper"},
		r = {"playerSecondaryFire", "editorContext"},
		wu = {"playerPrevWeapon", "editorPrevBlock", "gameFrameSkipDecrease", "gameBulletTimeDecrease", "debugSpeedDecrease"},
		wd = {"playerNextWeapon", "editorNextBlock", "gameFrameSkipIncrease", "gameBulletTimeIncrease", "debugSpeedIncrease"},
		x1 = "editorGetMousePosition", --mouse4
		x2 = "", --mouse5
	},
	joyBtns = {
		[1] = { -- first controller
			[1] = {--[["playerUp",]] "menuUp", "editorNudgeUp"}, -- xbox povup
			[2] = {--[["playerDown",]] "menuDown", "editorNudgeDown"}, -- xbox povdown
			[3] = {--[["playerLeft",]] "menuLeft", "editorNudgeLeft", "playerPrevWeapon", "editorPrevBlock", "gameFrameSkipDecrease", "gameBulletTimeDecrease", "debugSpeedDecrease"}, -- xbox povleft
			[4] = {--[["playerRight",]] "menuRight", "editorNudgeRight", "playerNextWeapon", "editorNextBlock", "gameFrameSkipIncrease", "gameBulletTimeIncrease", "debugSpeedIncrease"}, -- xbox povright
			[5] = {"playerPause"}, -- xbox start
			[6] = {"menuBack"}, -- xbox back
			[7] = {"playerRun"}, -- xbox leftstickclick
			[8] = {"playerJump"}, -- xbox rightstickclick
			[9] = {"playerRun"}, -- xbox lbumper
			[10] = {"playerJump"}, -- xbox rbumper
			[11] = {"menuSelect", "playerJump"}, -- xbox A
			[12] = {"menuBack", "playerUse"}, -- xbox B
			[13] = {"playerRun"}, -- xbox X
			[14] = {"playerReload", "editorDropper"}, -- xbox Y
			[15] = {}, -- xbox home
		},
	},
	--[[joyAxes = {
		[1] = {
			[1] = { -- xbox left X
				"leftx",
			},
			[2] = { -- xbox left Y
				"lefty",
			},
			[3] = { -- xbox right X
				"rightx",
			},
			[4] = { -- xbox right Y
				"righty",
			},
			[5] = { -- xbox left trigger
				"lefttrigger",
			},
			[6] = { -- xbox right trigger
				"righttrigger",
			},
		},
	},]]
	pairedAxes = {
		[1] = {
			[1] = {1, 2},
			[2] = {3, 4},
			[3] = {5, 6},
		},
	},
	deadzoneAxes = {
		[1] = {
			[1] = "playerMoveX", -- xbox left X
			[2] = "playerMoveY", -- xbox left Y
			[3] = "playerAimX", -- xbox right X
			[4] = "playerAimY", -- xbox right Y
			[5] = "playerPressureLeft", -- xbox left trigger
			[6] = "playerPressureRight", -- xbox right trigger
		},
	},
	maps = {
		--a       --d
		playerMoveX = {
			--h=0 --o={}
			{"playerLeft", "menuLeft", "editorNudgeLeft"},
			{"playerRight", "menuRight", "editorNudgeRight"},
		},
		playerMoveY = {
			{"playerUp", "menuUp", "editorNudgeUp"},
			{"playerDown", "menuDown", "editorNudgeDown"},
		},
		playerAimX = {
			{"editorScrollLeft"},
			{"editorScrollRight"},
		},
		playerAimY = {
			{"editorScrollUp"},
			{"editorScrollDown"},
		},
		playerPressureLeft = {
			{},
			{"playerPrimaryFire", "editorSelect", "editorPaint"},
		},
		playerPressureRight = {
			{},
			{"playerSecondaryFire", "editorContext"},
		},
	},
	--[[deadzoneAxes = {
		[1] = {
			
		},
	},]]
	deadzone = 0.3,
	useJoystick = true,
	useKeyboard = true,
	useMouse = true,
}
end end)()end;
do require("package").preload["netplay2"] = (function() local package;return function(...)-- <pack netplay2> --
net={}
net.listenTable={}
net.udpSocket=nil

function net.assign(mode)
	if mode=="client" then
		net.udpSocket = udp
	elseif mode=="server" then
		net.udpSocket = server_udp
	end
end

function net.queue(chan, data)
	table.insert(networksendqueue, von.serialize({chan=chan, data=data, client=networkclientnumber}))
end

function net.send(chan, data)
	net.udpSocket:send(von.serialize({chan=chan,data=data,client=networkclientnumber}))
end

function net.sendto(chan, data, ip, port)
	net.udpSocket:sendto(von.serialize({chan=chan,data=data,client=networkclientnumber}), ip, port)
end

function net.pump()
	for k,v in ipairs(networksendqueue) do
		net.udpSocket:send(v)
		networksendqueue[k]=nil
	end
end

function net.receive()
	local data, msg = net.udpSocket:receive()
	if data==nil then return nil, nil end
	data = von.deserialize(data)
	--@TODO: use the ip and port to bind to a particular address
	return data.chan, data.data
end

function net.receivefrom()
	local data, ip, port = net.udpSocket:receivefrom()
	--@TODO: In the odd circumstance we are sent no data from somebody?
	if data==nil then return nil, nil, ip, port end
	data = von.deserialize(data)
	--@TODO: use the ip and port to bind to a particular address
	return data.chan, data.data, ip, port
end



---- SERVER related things
serve = {} --using serve instead of server because it probably already exists in the mess of globals
serve.peers = {}
--[[
	{
		
	}
]]
end end)()end;
do require("package").preload["variables"] = (function() local package;return function(...)-- <pack variables> --
--DELIMITERS old: ,-;*=   new: 
BLOCKDELIMITER = ""
LAYERDELIMITER = ""
CATEGORYDELIMITER = ""
MULTIPLYDELIMITER = ""
EQUALSIGN = ""



--SETABLE VARS--	
--almost all vars are in "blocks", "blocks per second" or just "seconds". Should be obvious enough what's what.
-- I couldn't think of a way to draw 
uiscales = {
	
}

debugflags = {
	userect = true, --draws the userects on usable objects
	netplay = false, --INCOMPLETE: controls access to netplay features
	console = false, --INCOMPLETE: allows the console to be loaded
	--speeddebug
	--portalwalldebug
	--incognito
	--physicsdebug
}
enum_errors = { --setting error_level to one of these
	debug = {},
	note = {}, 
	alert = {},
	warn = {},
	critical = {},
}
alert_show_types = { -- entries in this list will allow the user to see alerts of the above type in the enums
	"debug",
	"note",
	"alert",
	"warn",
	"critical"
}

uiscale = 2 --sometimes the ui is too big for higher resolutions, this is independent from the HUD

spritebatchsize = 10000

portalgundelay = 0.2
gellifetime = 2
bulletbilllifetime = 20
playertypelist = {"portalgun", "gelcannon"}
gameplaytypelist = {"na", "vanilla", "oddjob"}
help_tips = { 
	"i love men",
	"this is a helpful tip i promise",
	"flabberific",
	"beware of gaping buttholes",
	"first jo is best jo",
	"cake is a lie joke ban me",
	"that was easy",
	"george lucas is an asshole",
	"what the fuck is wrong with his neck",
	"now with more hints",
	"shoot it until it dies",
	"watashi wa desu",
	"naah he-man",
	"where the video games at",
	"toddy always has the best memes",
	"bingle bangle bongle bungalo",
	"dirty old mattress",
	"pass the whiskey",
	"praise the sun",
	"he",
	"did you just say girl cock?",
	"doge gonnit",
	"ol feshioned hamburge",
	"error: failed to load paid ad",
	"this is just like dark souls",
	"have you ever exhaled and shot a booger out of your nose like cannon?",
	"oh gross, don't touch me",
	"knock knock, its ya main man knuckles!",
	"i saw a drawing of mario and luigi kissing. Please don't do this.",
	"put it all the way in if that's the new normal",
	"quit gettin' mad at video games",
	"guys, the thermal drill, go get it",
	"enemy boat spotted!",
	"i have altered the sandwich. pray i do not alter it further",
	"wwhy shrek is piss. why shrek is piss #italiano",
	"hp and mp restored! but you're still hungry",
	"i do not move out of the way",
	"sometimes you gotta make a silent takedown",
	"don't believe me? it's all in the numbers",
	"busting makes me feel good",
	"bleh, my name is seedywizard, and i love cum",
	"it is like a ball pit, but full of dicks",
	"people are allowed to be as ineloquent as they want",
	"i'm not racist but all pugs look the same",
	"white people are ignorant as fuck",
	"try to touch all booty",
	"never go on reddit",
	"corn",
	"Carrots are racist",
	"Benis. :DD",
	"\"I just wanted to eat bacon and excrete beards, is that so hard?! You just HAD to go and give me superpowers instead!\"--Nelson",
}
help_tipi = 1

latetable = {"portalwall", "castlefirefire", "platform"}
-- the above is used in physics.lua to calculate late physics entities

newpoweruproutine=true --makes it so that if mario touches a "tier2" powerup he skips bigmario ala nsmb
powerupstates = {
	"death", --this bypasses the powerup chain processing and kills mario instantly
	"hurt",  --causes mario to simply be hurt, you shouldn't use this as a powerdowntarget
	"small", --mario spawns with this
	"super", --mario after getting a mushroom
	"fire",  --mario after getting a flower
}

numgeltypes=6
enum_gels = {"blue", "orange", "white", "purple", "water", "black"}
gelsthattarnishmirrors = {"blue", "orange", "white", "purple", "black"}

spawnarea = {1, 1, 1, 1}

joystickdeadzone = 0.2
joystickaimdeadzone = 0.5

outofboundstime = 1 --time to wait before playing out of bounds music
was_anyone_outofbounds = false --if anyone has been out of bounds long enough to trigger

walkacceleration = 8 --acceleration of walking on ground
runacceleration = 16 --acceleration of running on ground
walkaccelerationair = 8 --acceleration of walking in the air
runaccelerationair = 16 --acceleration of running in the air
minspeed = 0.7 --When friction is in effect and speed falls below this, speed is set to 0
maxwalkspeed = 6.4 --fastest speedx when walking
maxrunspeed = 9.0 --fastest speedx when running
friction = 14 --amount of speed that is substracted when not pushing buttons, as well as speed added to acceleration when changing directions
superfriction = 100 --see above, but when speed is greater than maxrunspeed
frictionair = 0 --see above, but in air
airslidefactor = 0.8 --multiply of acceleration in air when changing direction

loading_header = "pretending to load"
loadingtexts = {
	"#meatlesstaco",
	"subtweeting entrancejew",
	"flabberizing data to new efficient format",
	"reticulating splines",
	"rendering important stuff",
	"01110000011011110110111001111001",
	"sometimes, i dream about cheese",
	"baking cake",
	"happy explosion day",
	"raising coolness by a fifth",
	"yay facepunch",
	"yay somethingawful",
	"stabbing myself",
	"sharpening knives",
	"tanaka, thai kick",
	"slime will find you",
	"becoming self-aware",
	"it's a secret to everybody",
	"there is probably not a minus world",
	"oh my god, jc, a bomb",
	"silly loading message here",
	"motivational art by jorichi",
	"downloading pacman hentai",
	"you're my favorite deputy",
	"licensed under wtfpl",
	"banned in australia",
	"loading anti-piracy module",
	"watch out there's a sni",
	"attack while its tail's up!",
	"what a horrible night to have a curse",
	"why is george lucas an asshole",
	"establishing connection to nsa servers",
	"how do i programm",
	"making palette inaccurate",
	"restandardizing ntsc",
	"y cant mario crawl?",
	"gordon freeman",
	"passing the whiskey"
}

damage_types = {
	"mystery",		--this is here as a fallback for the killicons, I'm a very disorganized person
	"toilet",		--if this happens, something had an undefined kill type, mostly for bug finding
	"kill",			--generic, this happens as a fallback for icon purposes (skull & crossbones)
	
	"physics",		--box crushes enemy, or other deaths caused by inaction
	
	"stomp",		--when feet land on something's head, sometimes side-kicks
	"shell",		--shells from koopas
	"star",			--reflective rampage man
	"fireball",		--the projectiles that come out of the player's hands
	
	"touch",		--goombas and any other oddly threatining simpletons
	"bump", 		--hit by the underside of a block
	"suicide",		--generic self-kill
	"pit",			--fell off screen boundary
	"spike",		--landed on a sharp block
	"tailspin",		--spinning as a raccoon
	"spin",			--I'm not sure when/where this happens nor if it differs from tailspin
	"pow",			--kill everything on the screen
	"laser",		--giant red light dissolves flesh and patience
}

combo_enums = {
	stomp = {100, 200, 400, 500, 800, 1000, 2000, 4000, 5000, 8000},
	shell = {500, 800, 1000, 2000, 4000, 5000, 8000},
}

score_enum = {
	block_break			= 50,	--for when mario gets bricky
	generic				= 100,	--reward people for doing things we're not even aware of!
	underside_bump		= 100,	--killing something with our heads, with a block as the medium
	generic_firepoints	= 200,	--for when an enemy has no sense of self-worth
	coin				= 200,	--for every individual coin we get
	collect_star		= 1000, --good job
}

enemy_score_enum = {
	fireball = {
		goomba = 100,
		koopa = 200,
		plant = 200,
		bowser = 5000,
		squid = 200,
		cheep = 200,
		flyingfish = 200,
		hammerbro = 1000,
		lakito = 200,
		bulletbill = 200,
	},
	--star scores are identical, but, now we have an opportunity to change that
	star = {
		goomba = 100,
		koopa = 200,
		plant = 200,
		bowser = 5000,
		squid = 200,
		cheep = 200,
		flyingfish = 200,
		hammerbro = 1000,
		lakito = 200,
		bulletbill = 200,
	},
}


yacceleration = 80 --gravity
mariogravity = yacceleration
yaccelerationjumping = 30 --gravity while jumping (Only for mario)
maxyspeed = 100 --SMB: 14
jumpforce = 16
jumpforceadd = 1.9 --how much jumpforce is added at top speed (linear from 0 to topspeed)
headforce = 2 --how fast mario will be sent back down when hitting a block with his head
bounceheight = 14/16 --when jumping on enemy, the height that mario will fly up
passivespeed = 4 --speed that mario is moved against the pointing direction when inside blocks (by crouch sliding under low blocks and standing up for example)

--Variables that are different for underwater

uwwalkacceleration = 8
uwrunacceleration = 16
uwwalkaccelerationair = 8
uwmaxairwalkspeed = 5
uwmaxwalkspeed = 3.6
uwmaxrunspeed = 5
uwfriction = 14
uwsuperfriction = 100
uwfrictionair = 0
uwairslidefactor = 0.8
uwjumpforce = 5.9
uwjumpforceadd = 0
uwyacceleration = 9
uwyaccelerationjumping = 12

waterdamping = 0.2
waterjumpforce = 13

uwmaxheight = 2.5
uwpushdownspeed = 3

bubblestime = {1.2, 1.6}

gelmaxrunspeed = 50
gelmaxwalkspeed = 25
gelrunacceleration = 25
gelwalkacceleration = 12.5

uwgelmaxrunspeed = 50
uwgelmaxwalkspeed = 12.5
uwgelrunacceleration = 12.5
uwgelwalkacceleration = 6.25

horbouncemul = 1.5
horbouncespeedy = 20
horbouncemaxspeedx = 15
horbounceminspeedx = 2

--items
mushroomspeed = 3.6
mushroomtime = 0.7 --time until it fully emerged out the block
mushroomjumpforce = 13
starjumpforce = 13
staranimationdelay = 0.04
mariostarblinkrate = 0.08 --/disco
mariostarblinkrateslow = 0.16 --/disco
mariostarduration = 12
mariostarrunout = 1 --subtracts, doesn't add.

bowseranimationspeed = 0.5
bowserspeedbackwards = 1.875
bowserspeedforwards = 0.875
bowserjumpforce = 7--v
bowsergravity = 10.9--v
bowserjumpdelay = 1
bowserfallspeed = 8.25--v said "for animation" but still limited bowser all the time

bowserhammertable = {0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1, 0.5, 1, 2, 1}--v
bowserhammerdrawtime = 0.5--v as throwpreparetime?

bowserhealth = 5--v

platformverdistance = 8.625
platformhordistance = 3.3125
platformvertime = 6.4
platformhortime = 4
platformbonusspeed = 3.75

platformspawndelay = 2.18 --time between platform spawns

platformjustspeed = 3.5

seesawspeed = 4
seesawgravity = 30
seesawfriction = 4

-- loiters between 4 blocks behind and 4 blocks ahead of you (total 9 blocks he goes above)
-- spawns only 3 of the hedgehog things and then hides until they're offscreen/dead
-- in 4-1 he disappears when you touch the first step (not stand on, touch from side while on the ground)
-- can be killed by single fireflower
-- the spiky dudes turn towards you after they fall down

maxfireballs = 2
fireanimationtime = 0.11

shotspeedx = 4 --X speed (constant) of fire/shell killed enemies
shotjumpforce = 8 --initial speedy (negative) when shot
shotgravity = 60 --how fast enemies that have been killed by fire or shell accellerate downwards

deathanimationjumpforce = 17
deathanimationjumptime = 0.3
deathgravity = 40
deathtotaltime = 4

portalanimationcount = 6 --frame count of portal animation
portalanimation = 1
portalanimationtimer = 0
portalanimationdelay = 0.08 --frame delay of portal animation
portalrotationalignmentspeed = 15 --how fast things return to a rotation of 0 rad(-ical)

scrollrate = 5
superscrollrate = 40
maxscrollrate = maxrunspeed*2
blockbouncetime = 0.2
blockbounceheight = 0.4
coinblocktime = 0.3
coinblockdelay = 0.5/30

runanimationspeed = 10
swimanimationspeed = 10

spriteset = 1
speed = 1
speedtarget = 1
speedmodifier = 10

portalparticlespeed = 1
portalparticletimer = 0
portalparticletime = 0.05
portalparticleduration = 0.5

portaldotstime = 0.8
portaldotsdistance = 1.2
portaldotsinner = 10
portaldotsouter = 70

portalprojectilespeed = 100
portalprojectilesinemul = 100
portalprojectiledelay = 2
portalprojectilesinesize = 0.3
portalprojectileparticledelay = 0.002

emanceparticlespeed = 3
emanceparticlespeedmod = 0.3
emanceimgwidth = 64
emancelinecolor = {100, 100, 255, 10}

boxfriction = 20
boxfrictionair = 0

faithplatetime = 0.3

spacerunroom = 1.2/16 --How far you can fall but still be allowed onto the top of a block (For running over 1 tile wide gaps)

doorspeed = 2
groundlightdelay = 1

geldispensespeed = 0.05
gelmaxspeed = 30

cubedispensertime = 1

pushbuttontime = 1

bulletbillspeed = 8.0
bulletbilltimemax = 4.5
bulletbilltimemin = 1.0
bulletbillrange = 3

hammerbropreparetime = 0.5
hammerbrotime = {0.6, 1.6}
hammerbrospeed = 1.5
hammerbroanimationspeed = 0.15


hammerbrojumptime = 3
hammerbrojumpforce = 19
hammerbrojumpforcedown = 6


hammerspeed = 4
hammerstarty = 8
hammergravity = 25
hammeranimationspeed = 0.05

squidfallspeed = 0.9
squidxspeed = 3
squidupspeed = 3
squidacceleration = 10
squiddowndistance = 1

firespeed = 4.69
fireverspeed = 2
fireanimationdelay = 0.05

upfireforce = 19
upfiregravity = 20

flyingfishgravity = 20
flyingfishforce = 23

userange = 1
usesquaresize = 1

castlefireangleadd = 1.125
castlefiredelay = .34/(360/castlefireangleadd) --the number in front of the bracket is how long a full turn takes
castlefireanimationdelay = 0.07

--plants
plantintime = 1.8
plantouttime = 2
plantanimationdelay = 0.15
plantmovedist = 23/16
plantmovespeed = 2.3

vinespeed = 2.13
vinemovespeed = 3.21
vinemovedownspeed = vinemovespeed*2
vineframedelay = 0.15
vineframedelaydown = vineframedelay/2

vineanimationstart = 4
vineanimationgrowheight = 6
vineanimationmariostart = vineanimationgrowheight/vinespeed
vineanimationstop = 1.75
vineanimationdropdelay = 0.5

--animationstuff
pipeanimationtime = 0.7
pipeanimationdelay = 1
pipeanimationdistancedown = 32/16
pipeanimationdistanceright = 16/16
pipeanimationrunspeed = 3
pipeupdelay = 1

growtime = 0.9
shrinktime = 0.9
growframedelay = 0.08
shrinkframedelay = 0.08
invicibleblinktime = 0.02
invincibletime = 3.2

blinktime = 0.5

levelscreentime = 2.4 --2.4
gameovertime = 7
blacktimesub = 0.1
sublevelscreentime = 0.2

--flag animation
flagclimbframedelay = 0.07
scoredelay = 2
flagdescendtime = 0.9
flagydistance = 7+10/16
flaganimationdelay = 0.6
scoresubtractspeed = 1/60
castleflagstarty = 1.5
castleflagspeed = 3
castlemintime = 7
fireworkdelay = 0.55
fireworksoundtime = 0.2
endtime = 2

--smokepuff
smokepuffdelay = 0.55
smokepuffoundtime = 0.2

--spring
springtime = 0.2
springhighforce = 41 --Regular Springboard
springhighhighforce = 190 --High Springboard
springforce = 24
springytable = {0, 0.5, 1}

--flag scores and positions
flagscores = {100, 400, 800, 2000, 5000}
flagvalues = {9.8125, 7.3125, 5.8125, 2.9375}

--castle win animation
castleanimationchaindisappear = 0.38 --delay from axe disappearing to chain disappearing; once this starts, bowser starts tapping feet with a delay of 0.0666666
castleanimationbowserframedelay = 0.0666
castleanimationbridgedisappeardelay = 0.06 --delay between each bridge block disappearing, also delay between chain and first block
--bowser starts falling and stops moving immediately after the last block disappears
castleanimationmariomove = 1.07 --time when mario starts moving after bowser starts falling and is also unfrozen. music also starts playing at this point
castleanimationcameraaccelerate = 1.83 -- time when camera starts moving faster than mario, relative to start of his move
castleanimationmariostop = 2.3 -- when mario stops next to toad, relative to start of his move
castleanimationtextfirstline = 3.2 -- when camera stops and first line of text appears, relative to the start of his move
castleanimationtextsecondline = 5.3 --second line appears
castleanimationnextlevel = 9.47 -- splash screen for next level appears

endanimationtextfirstline = 3.2 -- when camera stops and first line of text appears, relative to the start of his move
endanimationtextsecondline = 7.4 --second line appears
endanimationtextthirdline = 8.4 --third line appears
endanimationtextfourthline = 9.4 --fourth line appears
endanimationtextfifthline = 10.4 --fifth line appears
endanimationend = 12 -- user can press any button

drainspeed = 20
drainmax = 10

konamilength = 10
konamihash = "7d0b25cc0abdcc216e9f26b078c0cb5c9032ed8c"
konamitable = {}
for i = 1, konamilength do
	konamitable[i] = ""
end

earthquakespeed = 40

cheats_active = {
	rainboom = false,
	goombaattack = false,
	bigmario = false,
	bullettime = false,
	portalknockback = false,
	playercollisions = false,
	infinitetime = false,
	infinitelives = false,
}
scalefactor = 5
gelcannondelay = 0.05
gelcannonspeed = 30

pausemenuoptions = {"resume", "suspend", "volume", "quit to", "quit to"}
pausemenuoptions2 = {"", "", "", "menu", "desktop"}

guirepeatdelay = 0.07
mappackhorscrollrange = 220

maximumbulletbills = 5
coinblocktime = 4

funnelspeed = 3
funnelforce = 5
funnelmovespeed = 4
excursionbaseanimationtime = 0.1
funnelbuildupspeed = 50

yscrollingrate = 10
userscrolltime = 1
userscrollspeed = 13
userscrollrange = 5

--Rightclickmenu values
funnelminspeed = 1
funnelmaxspeed = 10

linktoolfadeouttimefast = 0.1
linktoolfadeouttimeslow = 0.5

pedestaltime = 1

--Functions, functions everywhere.

--[[ Oh noes this shit sucks
platformwidthfunction = function (i) return math.floor(i*18+2)/2 end
platformspeedfunction = function (i) return i*9.5+0.5 end	
platformspawndelayfunc = function (i) return i*9+1 end

scaffoldwidthfunction = function (i) return math.floor(i*18+2)/2 end
scaffoldspeedfunction = function (i) return i*9.5+0.5 end
scaffolddistancefunction = function (i) return i*14.5+.5 end
scaffoldtimefunction = function (i) return i*10 end

faithplatexfunction = function (i) return (i-.5)*100 end
faithplateyfunction = function (i) return i*45+5 end

timerfunction = function (i) return i*9+1 end

seesawdistancefunction = function (i) return math.floor(i*8+2) end
seesawheightfunction = function (i) return math.floor(i*9+1) end

castlefirelengthfunction = function (i) return math.floor(i*15+1) end
castlefiredelayfunction = function (i) return i*0.97+0.03 end

rgbfunction = function (i) return math.floor(i*255) end

squarewavetimefunction = function (i) return i*9.9+0.1 end

upfireheightfunction = function (i) return i*14.5+.5 end
upfirewaitfunction = function (i) return i*5.9+.1 end
upfirerandomfunction = function (i) return i*6 end

platformdistancefunction = function (i) return i*14.5+.5 end
platformtimefunction = function (i) return i*9+1 end 
--]]

arcadeexittime = 2
arcadeblinkrate = 1.7
arcadetimeout = 15

raccoonstarttime = 1
raccoontime = 4
raccoonascendspeed = 8
raccoonbuttondelay = 0.25
raccoondescendspeed = 4
raccoontailwagdelay = 0.08
raccoonspindelay = 0.1

scrollingstart = width/2 --when the scrolling begins to set in (Both of these take the player who is the farthest on the left)
scrollingcomplete = width/2-width/10 --when the scrolling will be as fast as mario can run
scrollingleftstart = width/3 --See above, but for scrolling left, and it takes the player on the right-estest.
scrollingleftcomplete = width/3-width/10
upscrollborder = 4
downscrollborder = 4
superscroll = 100
portaldotstimer = 0

pswitchtime = 20
end end)()end;
do require("package").preload["game"] = (function() local package;return function(...)-- <pack game> --
networkupdatetimer = 0
enemyupdatetimer = 0
angletimer = 0

networkclientnumber = 0
networksendqueue = {}

chatlog = {}

chatmessageinprogressstring = "> "
chatmessagegradient = 0

local chatmessageoriginaldeletetimer = 0
local chatmessagedeletecharactertimer = 0

function game_load(suspended)
	checkpointx = {}
	checkpointy = {}
	checkpointsub = false
	
	scrollfactor = 0
	fscrollfactor = 0
	love.graphics.setBackgroundColor(backgroundcolor[1])

	
	--LINK STUFF
	
	--get mariolives
	mariolivecount = 3
	if love.filesystem.exists("mappacks/" .. mappack .. "/settings.txt") then
		local s = love.filesystem.read( "mappacks/" .. mappack .. "/settings.txt" )
		local s1 = s:split("\n")
		for j = 1, #s1 do
			local s2 = s1[j]:split("=")
			if s2[1] == "lives" then
				mariolivecount = tonumber(s2[2])
			end
		end
	end
	
	if mariolivecount == 0 then
		mariolivecount = false
	end
	
	mariosizes = {}
	for i = 1, players do
		mariosizes[i] = 1
	end
	
	autoscroll = true
	
	jumpitems = { "mushroom", "oneup" }
	
	--currentmap = "1-1"
	marioworld = 1
	mariolevel = 1
	mariosublevel = 0
	respawnsublevel = 0
	
	objects = nil
	--[[if suspended == true then
		continuegame()
	elseif suspended then
		marioworld = suspended
	end]]
	
	musicname = nil
	
	--FINALLY LOAD THE DAMN LEVEL
	print("from game_load to levelscreen_load")
	levelscreen_load("initial")
end

function game_update(dt)
	if not objects then return end
	pt = {
		p1 = objects["player"][1],
		b1 = objects["box"][1]
	}
	dt = dt * speed
	gdt = dt
	
	--@DEBUG: doing player update here just for testing
	--[[for i, v in pairs(objects["player"]) do
		v:update(dt)
	end]]
	
	--------
	--GAME--
	--------
	
	--animationS
	animationsystem_update(dt)
	
	
	--earthquake reset
	if earthquake > 0 then
		earthquake = math.max(0, earthquake-dt*earthquake*2-0.001)
		sunrot = sunrot + dt
	end
	
	--pausemenu
	if pausemenuopen then
		return
	end
	
	--Animate animated tiles because I say so
	for i = 1, #animatedtiles do
		animatedtiles[i]:update(dt)
	end
	
	for i = 1, #animatedtimerlist do
		animatedtimerlist[i]:update(dt)
	end
	
	--coinanimation
	coinanimation = coinanimation + dt*6.75
	while coinanimation >= 6 do
		coinanimation = coinanimation - 5
	end	
	
	coinframe = math.floor(coinanimation)

	--redcoinanimation
	redcoinanimation = redcoinanimation + dt*6.75
	while redcoinanimation >= 5 do
		redcoinanimation = redcoinanimation - 4
	end	
	
	redcoinframe = math.floor(redcoinanimation)
	
	if replaysystem then
		for j = 1, #replaydata do
			if replaydata[j].data then
				replaytimer[j] = replaytimer[j] + dt
				while replaydata[j].data[replayi[j]].time < replaytimer[j] and replayi[j] < #replaydata[j].data do
					replayi[j] = replayi[j] + 1
				end
			end
		end
	end
	
	--If everyone's dead, just update the players and coinblock timer.
	if everyonedead then
		for i, v in pairs(objects["player"]) do
			v:update(dt)
		end
		
		return
	end
	
	--timer	
	if editormode == false then
		--get if any player has their controls disabled
		local notime = false
		for i = 1, players do
			if (objects["player"][i].controlsenabled == false and objects["player"][i].dead == false) then
				notime = true
			end
		end
		
		if notime == false and infinitetime == false and mariotime ~= 0 then
			mariotime = mariotime - 2.5*dt
			
			if mariotime > 0 and mariotime + 2.5*dt >= 99 and mariotime < 99 then
				love.audio.stop()
				playsound("lowtime") --allowed global
			end
			
			if mariotime > 0 and mariotime + 2.5*dt >= 99-8 and mariotime < 99-8 then
				local star = false
				for i = 1, players do
					if objects["player"][i].starred then
						star = true
					end
				end
				
				if not star then
					playmusic()
				else
					music:play("starmusic.ogg")
				end
			end
			
			if mariotime <= 0 then
				mariotime = 0
				for i, v in pairs(objects["player"]) do
					v:die("time")
				end
			end
		end
	end
	
	--out of bounds
	local anyone_outofbounds = false
	for i, v in pairs(objects["player"]) do
		if v.outofboundstimer > outofboundstime then
			anyone_outofbounds = true
			break
		end
	end
	
	if not was_anyone_outofbounds and anyone_outofbounds then
		print("TRIGGER: OB!")
		stopmusic()
		music:play("outofbounds.ogg")
	elseif was_anyone_outofbounds and not anyone_outofbounds then
		print("TRIGGER: Welcome back to earth.")
		music:stop("outofbounds.ogg")
		playmusic()
	end
	was_anyone_outofbounds = anyone_outofbounds
	
	--Portaldots
	portaldotstimer = portaldotstimer + dt
	while portaldotstimer > portaldotstime do
		portaldotstimer = portaldotstimer - portaldotstime
	end
	
	--portalgundelay
	for i = 1, players do
		if portaldelay[i] > 0 then
			portaldelay[i] = math.max(0, portaldelay[i] - dt/speed)
		end
	end
	
	--check if updates are blocked for whatever reason
	if noupdate then
		for i, v in pairs(objects["player"]) do --But update players anyway.
			v:update(dt)
		end
		return
	end
	
	--blockbounce
	local delete = {}
	
	for i, v in pairs(blockbouncetimer) do
		if blockbouncetimer[i] < blockbouncetime then
			blockbouncetimer[i] = blockbouncetimer[i] + dt
			if blockbouncetimer[i] > blockbouncetime then
				blockbouncetimer[i] = blockbouncetime
				if blockbouncecontent then
					item(blockbouncecontent[i], blockbouncex[i], blockbouncey[i], blockbouncecontent2[i])
				end
				table.insert(delete, i)
			end
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		table.remove(blockbouncetimer, v)
		table.remove(blockbouncex, v)
		table.remove(blockbouncey, v)
		table.remove(blockbouncecontent, v)
		table.remove(blockbouncecontent2, v)
	end
	
	if #delete >= 1 then
		generatespritebatch()
	end
	
	--coinblocktimer things
	for i, v in pairs(coinblocktimers) do
		if v[3] > 0 then
			v[3] = v[3] - dt
		end
	end
	
	--UPDATE STUFFFFF
	
	local updatetable = {
		dialogboxes,
		userects,
		coinblockanimations,
		itemanimations
	}
	local noupdateobjects = {"tile", "portalwall", "screenboundary"}
	for i, v in pairs(objects) do
		if not table.contains(noupdateobjects, i) then
			table.insert(updatetable, v)
		end
	end
	
	
	-- the big update
	for i, v in pairs(updatetable) do
		delete = {}
		
		for j, w in pairs(v) do
			if w.update and w:update(dt) then
				table.insert(delete, j)
			elseif w.autodelete then
				if w.y > mapheight+5 or w.x > mapwidth+5 or w.x < -5 or w.y < -5 then
					if w.autodeleted then
						w:autodeleted()
					end
					table.insert(delete,j)
				end
			end
		end
		
		if #delete > 0 then
			table.sort(delete, function(a,b) return a>b end)
			
			for j, w in pairs(delete) do
				table.remove(v, w)
			end
		end
	end
	
	
	--PHYSICS
	physicsupdate(dt)
	
	
	--SCROLLING
	--HORIZONTAL
	local oldxscroll = xscroll
	local oldyscroll = yscroll
	
	-- abandon hope all who enter: scrollhandler
	if autoscroll and minimapdragging == false then
		--scrolling
		local i = 1
		while i <= players and (objects["player"][i].dead or objects["player"][i].remote) do
			i = i + 1
		end
		
		local fastestplayer = objects["player"][i]
		
		if fastestplayer then
			for i = 1, players do
				if not objects["player"][i].dead and not objects["player"][i].remote and objects["player"][i].x > fastestplayer.x then
					fastestplayer = objects["player"][i]
				end
			end
			local speedx = converttostandard(fastestplayer, fastestplayer.speedx, fastestplayer.speedy)
			
			if fastestplayer.dead then -- scrolling fix for online multiplayer if all local players suck. I mean, are dead.
				for i = 1, players do
					if not objects["player"][i].dead and objects["player"][i].x > fastestplayer.x then
						fastestplayer = objects["player"][i]
					end
				end
			end
			
			--LEFT
			if fastestplayer.x < xscroll + scrollingleftstart and xscroll > 0 then
				
				if fastestplayer.x < xscroll + scrollingleftstart and speedx < 0 then
					if speedx < -scrollrate then
						xscroll = xscroll - scrollrate*dt
					else
						xscroll = xscroll + speedx*dt
					end
				end
				
				if fastestplayer.x < xscroll + scrollingleftcomplete then
					if fastestplayer.x > xscroll + scrollingleftcomplete - 1/16 then
						xscroll = xscroll - scrollrate*dt
					else
						xscroll = xscroll - superscrollrate*dt
					end
				end
			end
			
			--RIGHT
			
			if fastestplayer.x > xscroll + width - scrollingstart and xscroll < mapwidth - width then
				if fastestplayer.x > xscroll + width - scrollingstart and speedx > 0.3 then
					if speedx > scrollrate then
						xscroll = xscroll + scrollrate*dt
					else
						xscroll = xscroll + speedx*dt
					end
				end
				
				if fastestplayer.x > xscroll + width - scrollingcomplete then
					if fastestplayer.x > xscroll + width - scrollingcomplete then
						xscroll = xscroll + scrollrate*dt
						if xscroll > fastestplayer.x - (width - scrollingcomplete) then
							xscroll = fastestplayer.x - (width - scrollingcomplete)
						end
					else
						xscroll = fastestplayer.x - (width - scrollingcomplete)
					end
				end
			end
			
			--just force that shit
			if not levelfinished then
				if fastestplayer.x > xscroll + width - scrollingcomplete then
					xscroll = xscroll + superscroll*dt
					if fastestplayer.x < xscroll + width - scrollingcomplete then
						xscroll = fastestplayer.x - width + scrollingcomplete
					end
					--xscroll = fastestplayer.x + width - scrollingcomplete - width
				end
			end
			
			if xscroll > mapwidth-width then
				xscroll = math.max(0, mapwidth-width)
				hitrightside()
			end
				
			if xscroll < 0 then
				xscroll = 0
			end
			
			--[[if (axex and xscroll > axex-width and axex >= width) then
				xscroll = axex-width
				hitrightside()
			end]]
		end
	
		--VERTICAL SCROLLING
		for i = 1, players do
			local v = objects["player"][i]
			local old = ylookmodifier
			if v.binds.control.down then
				if v.looktimer < userscrolltime then
					v.looktimer = v.looktimer + dt
				else
					if ylookmodifier < math.min(userscrollrange, mapheight-(height+yscroll)) then
						ylookmodifier = ylookmodifier + dt*userscrollspeed
						if ylookmodifier > math.min(userscrollrange, mapheight-(height+yscroll)) then
							ylookmodifier = math.min(userscrollrange, mapheight-(height+yscroll))
						end
					end
				end
			elseif v.binds.control.up then
				if v.looktimer < userscrolltime then
					v.looktimer = v.looktimer + dt
				else
					if ylookmodifier > -math.min(userscrollrange, yscroll) then
						ylookmodifier = ylookmodifier - dt*userscrollspeed
						if ylookmodifier < -math.min(userscrollrange, yscroll) then
							ylookmodifier = -math.min(userscrollrange, yscroll)
						end
					end
				end
			else
				v.looktimer = 0
				if ylookmodifier > 0 then
					ylookmodifier = math.max(0, ylookmodifier - userscrollspeed*dt)
				elseif ylookmodifier < 0 then
					ylookmodifier = math.min(0, ylookmodifier + userscrollspeed*dt)
				end
			end
			
			yscroll = yscroll + (ylookmodifier-old)
		end
		
		local i = 1
		while i <= players and (objects["player"][i].dead or objects["player"][i].remote) do
			i = i + 1
		end
		local fastestplayer = objects["player"][i]
		if fastestplayer then
			for i = 1, players do
				if not objects["player"][i].dead and not objects["player"][i].remote and objects["player"][i].y > fastestplayer.y then
					fastestplayer = objects["player"][i]
				end
			end
			local dummy, speedy = converttostandard(fastestplayer, fastestplayer.speedx, fastestplayer.speedy)
			if fastestplayer.y-yscroll < upscrollborder then
				local minspeed = (fastestplayer.y-yscroll-upscrollborder)*yscrollingrate
				yscroll = yscroll+math.min(speedy, minspeed)*dt
			elseif fastestplayer.y-yscroll > height-downscrollborder then
				local minspeed = (fastestplayer.y-yscroll - (height-downscrollborder))*yscrollingrate
				yscroll = yscroll+math.max(speedy, minspeed)*dt
			end
		end
			
		if yscroll > mapheight-height-1 then
			yscroll = math.max(0, mapheight-height-1)
		end
		
		if yscroll < 0 then
			yscroll = 0
		end
	end
	
	if firstpersonview then
		xscroll = objects["player"][1].x-width/2+objects["player"][1].width/2
		yscroll = objects["player"][1].y-height/2+objects["player"][1].height/2-.5
	end
	
	if mapwidth > width then
		xscroll = math.min(xscroll, mapwidth-width)
	end
	
	--[[ Code I wrote for testing all levels for crashes.. doesn't properly change the levels anymore..
	for i = 1, 10 do
		mazesolved[i] = true
	end
	xscroll = xscroll + dt*100
	if xscroll >= mapwidth-width then
		while true do
			mariosublevel = mariosublevel + 1
			if mariosublevel > 5 then
				mariosublevel = 0
				mariolevel = mariolevel + 1
				if mariolevel > 4 then
					mariolevel = 1
					marioworld = marioworld + 1
				end
			end
			love.timer.sleep(0.1)
			if mariosublevel == 0 then
				print(marioworld .. "-" .. mariolevel .. ".txt")
				if love.filesystem.exists("mappacks/" .. mappack .. "/" .. marioworld .. "-" .. mariolevel .. ".txt") then
					startlevel(marioworld .. "-" .. mariolevel)
					break
				end
			else
				print(marioworld .. "-" .. mariolevel .. "_" .. mariosublevel .. ".txt")
				if love.filesystem.exists("mappacks/" .. mappack .. "/" .. marioworld .. "-" .. mariolevel .. "_" .. mariosublevel .. ".txt") then
					startlevel(marioworld .. "-" .. mariolevel .. "_" .. mariosublevel)
					break
				end
			end
		end
	end
	--]]
	
	
	--camera pan x
	if xpan then
		xpantimer = xpantimer + dt
		if xpantimer >= xpantime then
			xpan = false
			xpantimer = xpantime
		end
		
		local i = xpantimer/xpantime
		
		xscroll = xpanstart + xpandiff*i
	end
	
	--camera pan y
	if ypan then
		ypantimer = ypantimer + dt
		if ypantimer >= ypantime then
			ypan = false
			ypantimer = ypantime
		end
		
		local i = ypantimer/ypantime
		
		yscroll = ypanstart + ypandiff*i
	end
	
	--enemy spawning
	if not editormode then
		if round(xscroll) ~= round(oldxscroll) then
			local xstart, xend
			if xscroll > oldxscroll then
				xstart, xend = round(oldxscroll)+1+math.ceil(width), round(xscroll)+math.ceil(width)
			else
				xstart, xend = round(xscroll), round(oldxscroll)-1
			end
			
			for x = xstart, xend do
				for y = round(yscroll)-1, round(yscroll)+height+1 do
					spawnenemy(x, y)
				end
			end
		end
		
		if round(yscroll) ~= round(oldyscroll) then
			local ystart, yend
			if yscroll > oldyscroll then
				ystart, yend = round(oldyscroll)+1+math.ceil(height), round(yscroll)+math.ceil(height)
			else
				ystart, yend = round(yscroll), round(oldyscroll)-1
			end
			
			for y = ystart, yend do
				for x = round(xscroll)-1, round(xscroll)+width+1 do
					spawnenemy(x, y)
				end
			end
		end
	end
	
	--SPRITEBATCH UPDATE and CASTLEREPEATS
	if math.floor(xscroll) ~= spritebatchX[1] then
		if not editormode then
			for currentx = lastrepeat+1+width, math.floor(xscroll)+1+width do
				reachedx(currentx)
			end
		end
		
		generatespritebatch()
		spritebatchX[1] = math.floor(xscroll)
	elseif math.floor(yscroll) ~= spritebatchY[1] then
		generatespritebatch()
		spritebatchY[1] = math.floor(yscroll)
	end
	
	--portal update
	for i, v in pairs(portals) do
		v:update(dt)
	end
	
	--portal particles
	portalparticletimer = portalparticletimer + dt
	while portalparticletimer > portalparticletime do
		portalparticletimer = portalparticletimer - portalparticletime
		
		for i, v in pairs(portals) do
			if v.facing1 and v.x1 and v.y1 then
				local x1, y1
				
				if v.facing1 == "up" then
					x1 = v.x1 + math.random(1, 30)/16-1
					y1 = v.y1-1
				elseif v.facing1 == "down" then
					x1 = v.x1 + math.random(1, 30)/16-2
					y1 = v.y1
				elseif v.facing1 == "left" then
					x1 = v.x1-1
					y1 = v.y1 + math.random(1, 30)/16-2
				elseif v.facing1 == "right" then
					x1 = v.x1
					y1 = v.y1 + math.random(1, 30)/16-1
				end
				
				table.insert(objects["portalparticle"], portalparticle:new(x1, y1, v.portal1color, v.facing1))
			end
			
			if v.facing2 ~= nil and v.x2 and v.y2 then
				local x2, y2
				
				if v.facing2 == "up" then
					x2 = v.x2 + math.random(1, 30)/16-1
					y2 = v.y2-1
				elseif v.facing2 == "down" then
					x2 = v.x2 + math.random(1, 30)/16-2
					y2 = v.y2
				elseif v.facing2 == "left" then
					x2 = v.x2-1
					y2 = v.y2 + math.random(1, 30)/16-2
				elseif v.facing2 == "right" then
					x2 = v.x2
					y2 = v.y2 + math.random(1, 30)/16-1
				end
				
				table.insert(portalparticles, portalparticle:new(x2, y2, v.portal2color, v.facing2))
			end
		end
	end
	
	
	--Editor
	if editormode then
		editor_update(dt)
	end
	
	--Update pointing angle of players
	for i, v in pairs(objects.player) do
		if not v.disableaiming then
			v:updateangle()
		end
	end
end

function drawlevel()
	if incognito then
		return
	end
	love.graphics.setColor(love.graphics.getBackgroundColor())
	love.graphics.rectangle("fill", 0, 0, width*16*scale, height*16*scale)
	love.graphics.setColor(255, 255, 255, 255)
	local xtodraw
	if mapwidth < width+1 then
		xtodraw = math.ceil(mapwidth)
	else
		if mapwidth > width and xscroll < mapwidth-width then
			xtodraw = math.ceil(width+1)
		else
			xtodraw = math.ceil(width)
		end
	end
	
	local ytodraw
	if mapheight < height+1 then
		ytodraw = math.ceil(mapheight)
	else
		if mapheight > height and yscroll < mapheight-height then
			ytodraw = height+1
		else
			ytodraw = height
		end
	end
	
	--custom background
	if custombackground then
		if custombackground == true then
			local xscroll = xscroll / (scrollfactor + 1)
			if reversescrollfactor() == 1 then
				xscroll = 0
			end
			for y = 1, math.ceil(height/14)+1 do
				for x = 1, math.ceil(width)+1 do
					love.graphics.draw(portalbackgroundimg, math.floor((x-1)*16*scale) - math.floor(math.mod(xscroll, 1)*16*scale), math.floor(((y-1)*14)*16*scale) - math.floor(math.mod(yscroll, 14)*16*scale), 0, scale, scale)
				end
			end
		else
			if custombackgroundimg[custombackground] then
				for i = #custombackgroundimg[custombackground], 1, -1  do
					local xscroll = xscroll / (i * scrollfactor + 1)
					if reversescrollfactor() == 1 then
						xscroll = 0
					end
					
					local yscroll = yscroll / (i * scrollfactor + 1)
					if reversescrollfactor() == 1 then
						yscroll = 0
					end
					
					for y = 1, math.ceil(height/custombackgroundheight[custombackground][i])+1 do
						for x = 1, math.ceil(width/custombackgroundwidth[custombackground][i])+1 do
							love.graphics.draw(custombackgroundimg[custombackground][i], math.floor(((x-1)*custombackgroundwidth[custombackground][i])*16*scale) - math.floor(math.mod(xscroll, custombackgroundwidth[custombackground][i])*16*scale), math.floor(((y-1)*custombackgroundheight[custombackground][i])*16*scale) - math.floor(math.mod(yscroll, custombackgroundheight[custombackground][i])*16*scale), 0, scale, scale)
						end
					end
				end
			end
		end
	end
	
	--castleflag
	if levelfinished and levelfinishtype == "flag" and not custombackground then
		love.graphics.draw(castleflagimg, math.floor((flagx+6-xscroll)*16*scale), (flagy-7+10/16)*16*scale+(castleflagy-yscroll)*16*scale, 0, scale, scale)
	end
	
	--itemanimations
	for j, w in pairs(itemanimations) do
		w:draw()
	end
	
	--TILES
	love.graphics.draw(smbspritebatch, math.floor(-math.mod(xscroll, 1)*16*scale), math.floor(-math.mod(yscroll, 1)*16*scale))
	love.graphics.draw(portalspritebatch, math.floor(-math.mod(xscroll, 1)*16*scale), math.floor(-math.mod(yscroll, 1)*16*scale))
	if customtiles then
		love.graphics.draw(customspritebatch, math.floor(-math.mod(xscroll, 1)*16*scale), math.floor(-math.mod(yscroll, 1)*16*scale))
	end
	
	local lmap = map
	
	local flooredxscroll
	if xscroll >= 0 then
		flooredxscroll = math.floor(xscroll)
	else
		flooredxscroll = math.ceil(xscroll)
	end
	
	local flooredyscroll
	if yscroll >= 0 then
		flooredyscroll = math.floor(yscroll)
	else
		flooredyscroll = math.ceil(yscroll)
	end
	
	for y = 1, ytodraw do
		for x = 1, xtodraw do
			if inmap(flooredxscroll+x, flooredyscroll+y) then
				local bounceyoffset = 0
				for i, v in pairs(blockbouncex) do
					if blockbouncex[i] == flooredxscroll+x and blockbouncey[i] == flooredyscroll+y then
						if blockbouncetimer[i] < blockbouncetime/2 then
							bounceyoffset = blockbouncetimer[i] / (blockbouncetime/2) * blockbounceheight
						else
							bounceyoffset = (2 - blockbouncetimer[i] / (blockbouncetime/2)) * blockbounceheight
						end
					end	
				end
				
				local cox, coy = flooredxscroll+x, flooredyscroll+y
				local t = lmap[flooredxscroll+x][flooredyscroll+y]
				
				local tilenumber = t[1]
				if tilequads[tilenumber]:getproperty("coinblock", cox, coy) and tilequads[tilenumber]:getproperty("invisible", cox, coy) == false then --coinblock
					love.graphics.draw(coinblockimg, coinblockquads[spriteset][coinframe], math.floor((x-1-math.mod(xscroll, 1))*16*scale), math.floor(((y-1-math.mod(yscroll, 1)-bounceyoffset)*16-8)*scale), 0, scale, scale)
				elseif coinmap[cox][coy] then --coin
					love.graphics.draw(coinimg, coinquads[spriteset][coinframe], math.floor((x-1-math.mod(xscroll, 1))*16*scale), math.floor(((y-1-math.mod(yscroll, 1)-bounceyoffset)*16-8)*scale), 0, scale, scale)
				elseif bounceyoffset ~= 0 or tilenumber > 10000 then
					if not tilequads[tilenumber]:getproperty("invisible", cox, coy) then
						love.graphics.draw(tilequads[tilenumber].image, tilequads[tilenumber]:quad(flooredxscroll+x, flooredyscroll+y), math.floor((x-1-math.mod(xscroll, 1))*16*scale), math.floor(((y-1-math.mod(yscroll, 1)-bounceyoffset)*16-8)*scale), 0, scale, scale)
					end
				end
				
				--Gel overlays!
				if t["gels"] then
					for i = 1, 4 do
						local dir = "top"
						local r = 0
						if i == 2 then
							dir = "right"
							r = math.pi/2
						elseif i == 3 then
							dir = "bottom"
							r = math.pi
						elseif i == 4 then
							dir = "left"
							r = math.pi*1.5
						end
						
						for i = 1, numgeltypes do
							if t["gels"][dir] == i then
								local img
								if i == 1 then
									img = gel1groundimg
								elseif i == 2 then
									img = gel2groundimg
								elseif i == 3 then
									img = gel3groundimg
								elseif i == 4 then
									img = gel4groundimg
								elseif i == 5 then
									img = gel5groundimg
								elseif i == 6 then
									img = gel6groundimg
								end
								
								love.graphics.draw(img, math.floor((x-.5-math.mod(xscroll, 1))*16*scale), math.floor((y-1-math.mod(yscroll, 1)-bounceyoffset)*16*scale), r, scale, scale, 8, 8)
							end
						end
					end
				end
				
				if editormode then
					if tilequads[t[1]]:getproperty("invisible", cox, coy) and t[1] ~= 1 then
						love.graphics.draw(tilequads[t[1]].image, tilequads[t[1]]:quad(), math.floor((x-1-math.mod(xscroll, 1))*16*scale), ((y-1-math.mod(yscroll, 1))*16-8)*scale, 0, scale, scale)
					end
					
					if #t > 1 and t[2] ~= "link" then
						tilenumber = t[2]
						love.graphics.setColor(255, 255, 255, 150)
						--@WARNING: Somehow enemies is empty when it shouldn't be.
						if enemies and table.contains(enemies, tilenumber) then --ENEMY PREVIEW THING
							local v = enemiesdata[tilenumber]
							local xoff, yoff = (((v.spawnoffsetx or 0)+v.width/2-.5)*16 - v.offsetX + v.quadcenterX)*scale, (((v.spawnoffsety or 0)-v.height+1)*16-v.offsetY - v.quadcenterY)*scale
							
							local mx, my = getMouseTile(mouse.getX(), mouse.getY()+8*scale)
							local alpha = 150
							if x == mx and y == my then
								alpha = 255
							end
							
							love.graphics.setColor(255, 0, 0, alpha)
							love.graphics.rectangle("fill", math.floor((x-1-math.mod(xscroll, 1))*16*scale), math.floor(((y-1-math.mod(yscroll, 1))*16-8)*scale), 16*scale, 16*scale)
							love.graphics.setColor(255, 255, 255, alpha)
							love.graphics.draw(v.graphic, v.quad, math.floor((x-1-math.mod(xscroll, 1))*16*scale+xoff), math.floor(((y-1-math.mod(yscroll, 1))*16)*scale+yoff), 0, scale, scale)
						else
							if entityquads[tilenumber] and entityquads[tilenumber].image and entityquads[tilenumber].quad then
								love.graphics.draw(
									entityquads[tilenumber].image,
									entityquads[tilenumber].quad,
									math.floor((x-1-math.mod(xscroll, 1))*16*scale),
									math.floor(((y-1-math.mod(yscroll, 1))*16-8)*scale),
									0,
									scale,
									scale
								)
							else
								print("WARNING: Told to draw image/quad of tilenumber=", tilenumber, "and I couldn't do it.")
							end
						end
						love.graphics.setColor(255, 255, 255, 255)
					end
					
					if entitylist[map[x][y][2]] and entitylist[map[x][y][2]].t == "platform" then
						local dir, dist
						if rightclickm and rightclickm.tx == x and rightclickm.ty == y then
							dir = rightclickm.variables[2].value
							dist = tonumber(rightclickm.t[6].value)
						else
							dir = map[x][y][3]
							dist = tonumber(map[x][y][5])
						end
						
						
						love.graphics.setColor(252, 152, 56, 150)
						if dir == "down" then
							love.graphics.line((x-xscroll-.5)*16*scale, (y-yscroll-1.2)*16*scale, (x-xscroll-.5)*16*scale, (y-yscroll-1.2+dist)*16*scale)
						elseif dir == "left" then
							love.graphics.line((x-xscroll-.5)*16*scale, (y-yscroll-1.2)*16*scale, (x-xscroll-.5-dist)*16*scale, (y-yscroll-1.2)*16*scale)
						end
						love.graphics.setColor(255, 255, 255, 255)
					end
				end
			end
		end
	end
end

function drawui(hidetime)
	local printfunction = properprint
	if custombackground then
		printfunction = properprintbackground
	end

	---UI/HUD
	love.graphics.setColor(255, 255, 255)
	love.graphics.translate(0, -yoffset*scale)
	if yoffset < 0 then
		love.graphics.translate(0, yoffset*scale)
	end
	
	if gameplaytype ~= "na" then
		--player name
		local texttodraw = characters[mariocharacter[1]].name 
		if editormode and activeeditortool then
			texttodraw = activeeditortool.name
		end
		printfunction(texttodraw, uispace*.5 - 24*scale, 8*scale)
		
		--player score
		local texttodraw="mystery"
		if objects and objects["player"] and objects["player"][1] then
			texttodraw=addzeros(objects["player"][1].score, 6)
		end
		if editormode and activeeditortool then
			texttodraw = activeeditortool.status
		end
		printfunction(texttodraw, uispace*0.5-24*scale, 16*scale)

		--coin count
		local texttodraw="??"
		if objects and objects["player"] and objects["player"][1] then
			texttodraw=addzeros(objects["player"][1].coins, 2)
		end
		love.graphics.draw(coinanimationimg, coinanimationquads[spriteset][coinframe], uispace*1.5-16*scale, 16*scale, 0, scale, scale)
		printfunction("*", uispace*1.5-8*scale, 16*scale)
		printfunction(texttodraw, uispace*1.5-0*scale, 16*scale)
		
		--world indicator
		local texttodraw = " map"
		local texttodraw2 = currentmap --marioworld .. "-" .. mariolevel
		if gameplaytype == "oddjob" and oddjobquotas and oddjobquotas[1] then
			texttodraw = "oddjob"
			texttodraw2 = nil
			for i = 1, oddjobquotas[1] do
				if redcoincollected[i] == 0 then
					love.graphics.draw(oddjobhudimg, oddjobhudquads[1], (uispace*2.5 - 12*scale)+((8*i)-8)*scale, 16*scale, 0, scale, scale)
				elseif redcoincollected[i] == 1 then
					love.graphics.draw(oddjobhudimg, oddjobhudquads[2], (uispace*2.5 - 12*scale)+((8*i)-8)*scale, 16*scale, 0, scale, scale)
				end
			end
			if oddjobquotas[2] == 1 then
				love.graphics.draw(oddjobhudimg, oddjobhudquads[3], (uispace*2.5 - 12*scale)-(8*scale), 16*scale, 0, scale, scale)
			end
		end
		printfunction(texttodraw, uispace*2.5 - 20*scale, 8*scale)
		if texttodraw2 then printfunction(texttodraw2, uispace*2.5 - 12*scale, 16*scale) end
		
		--time area
		local texttodraw = "time"
		if editormode then
			texttodraw = "edit"
		end
		local texttodraw2
		if type(mariotime) == "number" then
			texttodraw2=addzeros(math.ceil(mariotime), 3)
		else
			texttodraw2=mariotime
		end
		
		printfunction(texttodraw, uispace*3.5 - 16*scale, 8*scale)
		printfunction(texttodraw2, uispace*3.5 - 8*scale, 16*scale)
	end
	
	if players > 1 and gamestate ~= "menu" then
		for i = 1, players do
			local x = (width*16)/players/2 + (width*16)/players*(i-1)
			if mariolivecount ~= false then
				printfunction("p" .. i .. " * " .. objects["player"][i].lives, (x-string.len("p" .. i .. " * " .. objects["player"][i].lives)*4+4)*scale, 25*scale)
				love.graphics.setColor(mariocolors[i][1] or {255, 255, 255})
				love.graphics.rectangle("fill", (x-string.len("p" .. i .. " * " .. objects["player"][i].lives)*4-3)*scale, 25*scale, 7*scale, 7*scale)
				love.graphics.setColor(255, 255, 255, 255)
			end
		end
	end
end

function drawforeground()
	--TILES FOREGROUND
	love.graphics.draw(smbspritebatchfront, math.floor(-math.mod(xscroll, 1)*16*scale), math.floor(-math.mod(yscroll, 1)*16*scale))
	love.graphics.draw(portalspritebatchfront, math.floor(-math.mod(xscroll, 1)*16*scale), math.floor(-math.mod(yscroll, 1)*16*scale))
	if customtiles then
		love.graphics.draw(customspritebatchfront, math.floor(-math.mod(xscroll, 1)*16*scale), math.floor(-math.mod(yscroll, 1)*16*scale))
	end
	
	
	--ANY NON STATIC BLOCKS AND STUFF.
	local lmap = map
	
	local xtodraw
	if mapwidth < width+1 then
		xtodraw = math.ceil(mapwidth)
	else
		if mapwidth > width and xscroll < mapwidth-width then
			xtodraw = math.ceil(width+1)
		else
			xtodraw = math.ceil(width)
		end
	end
	
	local ytodraw
	if mapheight < height+1 then
		ytodraw = math.ceil(mapheight)
	else
		if mapheight > height and yscroll < mapheight-height then
			ytodraw = height+1
		else
			ytodraw = height
		end
	end
	
	local flooredxscroll
	if xscroll >= 0 then
		flooredxscroll = math.floor(xscroll)
	else
		flooredxscroll = math.ceil(xscroll)
	end
	
	local flooredyscroll
	if yscroll >= 0 then
		flooredyscroll = math.floor(yscroll)
	else
		flooredyscroll = math.ceil(yscroll)
	end
	
	for y = 1, ytodraw do
		for x = 1, xtodraw do
			if inmap(flooredxscroll+x, flooredyscroll+y) then
				local cox, coy = flooredxscroll+x, flooredyscroll+y
				local t = lmap[cox][coy]
				
				local tilenumber = t[1]
				
				if tilequads[tilenumber]:getproperty("foreground", cox, coy) then
					if tilequads[tilenumber]:getproperty("coinblock", cox, coy) and not tilequads[tilenumber]:getproperty("invisible", cox, coy) then --coinblock
						love.graphics.draw(coinblockimg, coinblockquads[spriteset][coinframe], math.floor((x-1-math.mod(xscroll, 1))*16*scale), math.floor(((y-1-math.mod(yscroll, 1))*16-8)*scale), 0, scale, scale)
					elseif coinmap[x][y] then --coin
						love.graphics.draw(coinimg, coinquads[spriteset][coinframe], math.floor((x-1-xscroll)*16*scale), math.floor(((y-1-yscroll)*16-8)*scale), 0, scale, scale)
					elseif tilenumber > 10000 then
						if not tilequads[tilenumber]:getproperty("invisible", cox, coy) then
							love.graphics.draw(tilequads[tilenumber].image, tilequads[tilenumber]:quad(flooredxscroll+x, flooredyscroll+y), math.floor((x-1-math.mod(xscroll, 1))*16*scale), math.floor(((y-1-math.mod(yscroll, 1))*16-8)*scale), 0, scale, scale)
						end
					end
					
					--Gel overlays!
					if t["gels"] then
						for i = 1, 4 do
							local dir = "top"
							local r = 0
							if i == 2 then
								dir = "right"
								r = math.pi/2
							elseif i == 3 then
								dir = "bottom"
								r = math.pi
							elseif i == 4 then
								dir = "left"
								r = math.pi*1.5
							end
							
							for i = 1, 4 do
								if t["gels"][dir] == i then
									local img
									if i == 1 then
										img = gel1groundimg
									elseif i == 2 then
										img = gel2groundimg
									elseif i == 3 then
										img = gel3groundimg
									elseif i == 4 then
										img = gel4groundimg
									elseif i == 5 then
										img = gel5groundimg
									elseif i == 6 then
										img = gel6groundimg
									end
										
									love.graphics.draw(img, math.floor((x-.5-math.mod(xscroll, 1))*16*scale), math.floor((y-1-math.mod(yscroll, 1))*16*scale), r, scale, scale, 8, 8)
								end
							end
						end
					end
				end
			end
		end
	end
	
	--custom foreground
	if customforeground then
		if customforeground == true then
			--None
		else
			if custombackgroundimg[customforeground] then
				for i = 1, #custombackgroundimg[customforeground]  do
				
					local xscroll = xscroll * (i * fscrollfactor + 1)
					if reversefscrollfactor() == 1 then
						xscroll = 0
					end
					
					local yscroll = yscroll / (i * fscrollfactor + 1)
					if reversefscrollfactor() == 1 then
						yscroll = 0
					end
					
					for y = 1, math.ceil(height/custombackgroundheight[customforeground][i])+1 do
						for x = 1, math.ceil(width/custombackgroundwidth[customforeground][i])+1 do
							love.graphics.draw(custombackgroundimg[customforeground][i], math.floor(((x-1)*custombackgroundwidth[customforeground][i])*16*scale) - math.floor(math.mod(xscroll, custombackgroundwidth[customforeground][i])*16*scale), math.floor(((y-1)*custombackgroundheight[customforeground][i])*16*scale) - math.floor(math.mod(yscroll, custombackgroundheight[customforeground][i])*16*scale), 0, scale, scale)
						end
					end
				end
			end
		end
	end
end

function game_draw()
	if not objects then return end
	if firstpersonview and firstpersonrotate then
		local xtranslate = width/2*16*scale
		local ytranslate = height/2*16*scale
		love.graphics.translate(xtranslate, ytranslate)
		love.graphics.rotate(-objects["player"][1].rotation/2)
		love.graphics.translate(-xtranslate, -ytranslate)
	end
	
	currentscissor = {0, 0,love.window.getWidth(), love.window.getHeight()}
	--This is just silly
	if earthquake > 0 and #objects["rainboom"] > 0 then
		for i = 1, rainboom.effectstripes do
			local r, g, b = unpack(rainboom.colortable[math.mod(i-1, 6)+1])
			local a = earthquake/rainboom.effectearthquake*255
			
			love.graphics.setColor(r, g, b, a)
			
			local alpha = math.rad((i/rainboom.effectstripes + math.mod(sunrot/5, 1)) * 360)
			local point1 = {width*8*scale+300*scale*math.cos(alpha), 112*scale+300*scale*math.sin(alpha)}
			
			local alpha = math.rad(((i+1)/rainboom.effectstripes + math.mod(sunrot/5, 1)) * 360)
			local point2 = {width*8*scale+300*scale*math.cos(alpha), 112*scale+300*scale*math.sin(alpha)}
			
			love.graphics.polygon("fill", width*8*scale, 112*scale, point1[1], point1[2], point2[1], point2[2])
		end
	end
	
	love.graphics.setColor(255, 255, 255, 255)
	--tremoooor!
	if earthquake > 0 then
		tremorx = (math.random()-.5)*2*earthquake
		tremory = (math.random()-.5)*2*earthquake
		
		love.graphics.translate(round(tremorx), round(tremory))
	end
	
	love.graphics.setColor(255, 255, 255, 255)
	
	--THIS IS WHERE MAP DRAWING AND SHIT BEGINS
	
	function scenedraw()
		drawlevel()
		
		if bdrawui then
			drawui()
		end
		
		--@WARNING: These draws are partially redundant. Objects handled by the master handler are sometimes drawn twice and there's not much I can do about it until I get my hands in it and start managing it.
		-- We're going to buck draw depth for now.
		for _, entname in pairs(saneents) do
			love.graphics.setColor(255, 255, 255)
			for k,v in pairs(objects[entname]) do
				if v.draw then v:draw() end
			end
		end
		
		-- same, but #based
		for _, entname in pairs(basedents) do
			love.graphics.setColor(255, 255, 255)
			for k,v in pairs(objects[entname]) do
				if v.draw then v:draw() end
			end
		end

		love.graphics.setColor(255, 255, 255)
		--warpzonetext
		if displaywarpzonetext then
			properprint("welcome to warp zone!", (mapwidth-14-1/16-xscroll)*16*scale, (5.5-yscroll)*16*scale)
			for i, v in pairs(warpzonenumbers) do
				properprint(v[3], math.floor((v[1]-xscroll-1-9/16)*16*scale), (v[2]-3-yscroll)*16*scale)
			end
		end
		
		love.graphics.setColor(255, 255, 255)
		--flag
		if flagx then
			love.graphics.draw(flagimg, math.floor((flagimgx-1-xscroll)*16*scale), ((flagimgy-yscroll)*16-8)*scale, 0, scale, scale)
			if levelfinishtype == "flag" then
				properprint2(flagscore, math.floor((flagimgx+4/16-xscroll)*16*scale), ((14-flagimgy-yscroll+(flagy-13)*2)*16-8)*scale, 0, scale, scale)
			end
		end
		
		love.graphics.setColor(255, 255, 255)
		--levelfinish text and toad
		local lastaxe = objects["axe"][#objects["axe"]]
		if levelfinished and levelfinishtype == "castle" then
			if marioworld ~= 8 then
				love.graphics.draw(toadimg, math.floor((mapwidth-7-xscroll)*16*scale), (lastaxe.coy+2.0625-yscroll)*16*scale, 0, scale, scale)
			else
				print(math.floor((mapwidth-7-xscroll)*16*scale), (lastaxe.y+2.0625-yscroll)*16*scale)
				love.graphics.draw(peachimg, math.floor((mapwidth-7-xscroll)*16*scale), (lastaxe.coy+2.0625-yscroll)*16*scale, 0, scale, scale)
			end
		
			if levelfinishedmisc2 == 1 then
				if levelfinishedmisc >= 1 then
					properprint("thank you " .. characters[mariocharacter[1]].name .. "!", math.floor(((mapwidth-12-xscroll)*16-1)*scale), (lastaxe.coy-4.5-yscroll)*16*scale)
				end
				if levelfinishedmisc == 2 then
					properprint("but our princess is in", math.floor(((mapwidth-13.5-xscroll)*16-1)*scale), (lastaxe.coy-2.5-yscroll)*16*scale) --say what
					properprint("another castle!", math.floor(((mapwidth-13.5-xscroll)*16-1)*scale), (lastaxe.coy-1.5-yscroll)*16*scale) --bummer.
				end
			else
				if levelfinishedmisc >= 1 then	
					properprint("thank you mario!", math.floor(((mapwidth-12-xscroll)*16-1)*scale), (lastaxe.coy-4.5-yscroll)*16*scale)
				end
				if levelfinishedmisc >= 2 then
					properprint("your quest is over.", math.floor(((mapwidth-12.5-xscroll)*16-1)*scale), (lastaxe.coy-3-yscroll)*16*scale)
				end
				
				--todo
				if levelfinishedmisc >= 3 then
					properprint("we present you a new quest.", math.floor(((mapwidth-14.5-xscroll)*16-1)*scale), (lastaxe.coy-2-yscroll)*16*scale)
				end
				if levelfinishedmisc >= 4 then
					properprint("push button b", math.floor(((mapwidth-11-xscroll)*16-1)*scale), (lastaxe.coy-.5-yscroll)*16*scale)
				end
				if levelfinishedmisc == 5 then
					properprint("to play as steve", math.floor(((mapwidth-12-xscroll)*16-1)*scale), (lastaxe.coy+.5-yscroll)*16*scale)
				end
			end
		end
		
		love.graphics.setColor(255, 255, 255)
		
		--@DEV: THE GREAT BIG DRAW HANDLER
		for j, w in pairs(objects) do
			if j ~= "tile" then
				for i, v in pairs(w) do
					if v.drawable and v.graphic and v.quad then
						love.graphics.setScissor()
						love.graphics.setColor(255, 255, 255)
						local dirscale
						
						if j == "player" then
							if (v.portalsavailable[1] or v.portalsavailable[2]) then
								if (v.pointingangle+math.pi*2 > -v.rotation+math.pi*2 and (not (v.pointingangle > -v.rotation+math.pi))) or v.pointingangle < -v.rotation-math.pi then
									dirscale = -scale
								else
									dirscale = scale
								end
							else
								if v.animationdirection == "right" then
									dirscale = scale
								else
									dirscale = -scale
								end
							end
							
							if bigmario then
								dirscale = dirscale * scalefactor
							end
						else
							if v.animationdirection == "left" then
								dirscale = -scale
							else
								dirscale = scale
							end
						end
						
						if v.mirror then
							dirscale = -dirscale
						end
						
						local horscale = scale
						if v.shot or v.upsidedown then
							horscale = -scale
						end
						
						if j == "player" and bigmario then
							horscale = horscale * scalefactor
						end
						
						if v.customscale then
							horscale = horscale * v.customscale
							dirscale = dirscale * v.customscale
						end
						
						local portal, portaly = insideportal(v.x, v.y, v.width, v.height)
						local entryX, entryY, entryfacing, exitX, exitY, exitfacing
						
						--SCISSOR FOR ENTRY
						if v.customscissor and v.portalable ~= false then
							local t = "setStencil"
							if v.invertedscissor then
								t = "setInvertedStencil"
							end
							love.graphics[t](function() love.graphics.rectangle("fill", math.floor((v.customscissor[1]-xscroll)*16*scale), math.floor((v.customscissor[2]-.5-yscroll)*16*scale), v.customscissor[3]*16*scale, v.customscissor[4]*16*scale) end)
						end
							
						if v.moves and v.portalable ~= false then
							if not v.customscissor and portal ~= false and (v.active or v.portaloverride) then
								if portaly == 1 then
									entryX, entryY, entryfacing = portal.x1, portal.y1, portal.facing1
									exitX, exitY, exitfacing = portal.x2, portal.y2, portal.facing2
								else
									entryX, entryY, entryfacing = portal.x2, portal.y2, portal.facing2
									exitX, exitY, exitfacing = portal.x1, portal.y1, portal.facing1
								end
								
								if entryfacing == "right" then
									love.graphics.setScissor(math.floor((entryX-xscroll)*16*scale), math.floor(((entryY-3.5-yscroll)*16)*scale), 64*scale, 96*scale)
								elseif entryfacing == "left" then
									love.graphics.setScissor(math.floor((entryX-xscroll-5)*16*scale), math.floor(((entryY-4.5-yscroll)*16)*scale), 64*scale, 96*scale)
								elseif entryfacing == "up" then
									love.graphics.setScissor(math.floor((entryX-xscroll-3)*16*scale), math.floor(((entryY-5.5-yscroll)*16)*scale), 96*scale, 64*scale)
								elseif entryfacing == "down" then
									love.graphics.setScissor(math.floor((entryX-xscroll-4)*16*scale), math.floor(((entryY-0.5-yscroll)*16)*scale), 96*scale, 64*scale)
								end
							end
						end
						
						if type(v.graphic) == "table" then
							for k = 1, #v.graphic do
								if v.colors[k] then
									love.graphics.setColor(v.colors[k])
								else
									love.graphics.setColor(255, 255, 255)
								end
								love.graphics.draw(v.graphic[k], v.quad, math.floor(((v.x-xscroll)*16+v.offsetX)*scale), math.floor(((v.y-yscroll)*16-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
							end
						else
							if v.graphic and v.quad then
								love.graphics.draw(v.graphic, v.quad, math.floor(((v.x-xscroll)*16+v.offsetX)*scale), math.floor(((v.y-yscroll)*16-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
							end
						end
						
						--HATS
						if v.drawhat then
							local offsets = gethatoffset(v.char, v.graphic, v.animationstate, v.runframe, v.jumpframe, v.climbframe, v.swimframe, v.underwater, v.infunnel, v.fireanimationtimer, v.ducking)
							
							if offsets and #v.hats > 0 then
								local yadd = 0
								for i = 1, #v.hats do
									if v.hats[i] ~= 0 then
										if v.hats[i] == 1 then
											love.graphics.setColor(v.colors[1])
										else
											love.graphics.setColor(255, 255, 255)
										end
										if v.graphic == v.biggraphic or v.animationstate == "grow" then
											love.graphics.draw(bighat[v.hats[i]].graphic, math.floor(((v.x-xscroll)*16+v.offsetX)*scale), math.floor(((v.y-yscroll)*16-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX - bighat[v.hats[i]].x + offsets[1], v.quadcenterY - bighat[v.hats[i]].y + offsets[2] + yadd)
											yadd = yadd + bighat[v.hats[i]].height
										else
											love.graphics.draw(hat[v.hats[i]].graphic, math.floor(((v.x-xscroll)*16+v.offsetX)*scale), math.floor(((v.y-yscroll)*16-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX - hat[v.hats[i]].x + offsets[1], v.quadcenterY - hat[v.hats[i]].y + offsets[2] + yadd)
											yadd = yadd + hat[v.hats[i]].height
										end
									end
								end
							end
							love.graphics.setColor(255, 255, 255)
						end
						
						if type(v.graphic) == "table" then
							if v.graphic[0] then
								love.graphics.setColor(255, 255, 255)
								love.graphics.draw(v.graphic[0], v.quad, math.floor(((v.x-xscroll)*16+v.offsetX)*scale), math.floor(((v.y-yscroll)*16-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
							end
							if v.graphic.dot then
								love.graphics.setColor(unpack(v["portal" .. (v.lastportal or 1) .. "color"]))
								love.graphics.draw(v.graphic["dot"], v.quad, math.floor(((v.x-xscroll)*16+v.offsetX)*scale), math.floor(((v.y-yscroll)*16-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
							end	
						end
						
						--portal duplication
						if v.customscissor and v.portalable ~= false then
							local t = "setStencil"
							if v.invertedscissor then
								t = "setInvertedStencil"
							end
							love.graphics[t](function() love.graphics.rectangle("fill", math.floor((v.customscissor[1]-xscroll)*16*scale), math.floor((v.customscissor[2]-.5-yscroll)*16*scale), v.customscissor[3]*16*scale, v.customscissor[4]*16*scale) end)
						end
						
						if v.moves and (v.active or v.portaloverride) and v.portalable ~= false then
							if not v.customscissor and portal ~= false then
								love.graphics.setScissor(unpack(currentscissor))
								local px, py, pw, ph, pr, pad = v.x, v.y, v.width, v.height, v.rotation, v.animationdirection
								px, py, d, d, pr, pad = portalcoords(px, py, 0, 0, pw, ph, pr, pad, entryX, entryY, entryfacing, exitX, exitY, exitfacing)
								
								if pad ~= v.animationdirection then
									dirscale = -dirscale
								end
								
								horscale = scale
								if v.shot or v.upsidedown then
									horscale = -scale
								end
								
								if exitfacing == "right" then
									love.graphics.setScissor(math.floor((exitX-xscroll)*16*scale), math.floor(((exitY-yscroll-3.5)*16)*scale), 64*scale, 96*scale)
								elseif exitfacing == "left" then
									love.graphics.setScissor(math.floor((exitX-xscroll-5)*16*scale), math.floor(((exitY-yscroll-4.5)*16)*scale), 64*scale, 96*scale)
								elseif exitfacing == "up" then
									love.graphics.setScissor(math.floor((exitX-xscroll-3)*16*scale), math.floor(((exitY-yscroll-5.5)*16)*scale), 96*scale, 64*scale)
								elseif exitfacing == "down" then
									love.graphics.setScissor(math.floor((exitX-xscroll-4)*16*scale), math.floor(((exitY-yscroll-0.5)*16)*scale), 96*scale, 64*scale)
								end
								
								if type(v.graphic) == "table" then
									for k = 1, #v.graphic do
										if v.colors[k] then
											love.graphics.setColor(v.colors[k])
										else
											love.graphics.setColor(255, 255, 255)
										end
										love.graphics.draw(v.graphic[k], v.quad, math.floor(((px-xscroll)*16+v.offsetX)*scale), math.floor(((py-yscroll)*16-v.offsetY)*scale), pr, dirscale, horscale, v.quadcenterX, v.quadcenterY)
									end
								else
									love.graphics.draw(v.graphic, v.quad, math.ceil(((px-xscroll)*16+v.offsetX)*scale), math.ceil(((py-yscroll)*16-v.offsetY)*scale), pr, dirscale, horscale, v.quadcenterX, v.quadcenterY)
								end
								
								--HAAAATS
								if v.drawhat then
									local offsets = gethatoffset(v.char, v.graphic, v.animationstate, v.runframe, v.jumpframe, v.climbframe, v.swimframe, v.underwater, v.infunnel, v.fireanimationtimer, v.ducking)
							
									if offsets and #v.hats > 0 then
										local yadd = 0
										for i = 1, #v.hats do
											if v.hats[i] ~= 0 then
												if v.hats[i] == 1 then
													love.graphics.setColor(v.colors[1])
												else
													love.graphics.setColor(255, 255, 255)
												end
												if v.graphic == v.biggraphic or v.animationstate == "grow" then
													love.graphics.draw(bighat[v.hats[i]].graphic, math.floor(((px-xscroll)*16+v.offsetX)*scale), math.floor(((py-yscroll)*16-v.offsetY)*scale), pr, dirscale, horscale, v.quadcenterX - bighat[v.hats[i]].x + offsets[1], v.quadcenterY - bighat[v.hats[i]].y + offsets[2] + yadd)
													yadd = yadd + bighat[v.hats[i]].height
												else
													love.graphics.draw(hat[v.hats[i]].graphic, math.floor(((px-xscroll)*16+v.offsetX)*scale), math.floor(((py-yscroll)*16-v.offsetY)*scale), pr, dirscale, horscale, v.quadcenterX - hat[v.hats[i]].x + offsets[1], v.quadcenterY - hat[v.hats[i]].y + offsets[2] + yadd)
													yadd = yadd + hat[v.hats[i]].height
												end
											end
										end
									end
								end
								
								if type(v.graphic) == "table" then
									if v.graphic[0] then
										love.graphics.setColor(255, 255, 255)
										love.graphics.draw(v.graphic[0], v.quad, math.floor(((px-xscroll)*16+v.offsetX)*scale), math.floor(((py-yscroll)*16-v.offsetY)*scale), pr, dirscale, horscale, v.quadcenterX, v.quadcenterY)
									end
									if v.graphic.dot and v.lastportal then
										love.graphics.setColor(unpack(v["portal" .. v.lastportal .. "color"]))
										love.graphics.draw(v.graphic["dot"], v.quad, math.floor(((px-xscroll)*16+v.offsetX)*scale), math.floor(((py-yscroll)*16-v.offsetY)*scale), pr, dirscale, horscale, v.quadcenterX, v.quadcenterY)
									end
								end
							end
						end
						love.graphics.setScissor(unpack(currentscissor))
						love.graphics.setStencil()
					end
				end
			end
		end
		
		love.graphics.setColor(255, 255, 255)
		--particles
		for j, w in pairs(portalparticles) do
			w:draw()
		end
		
		love.graphics.setColor(255, 255, 255)
		
		--portals
		for i, v in pairs(portals) do
			v:draw()
		end		
		
		love.graphics.setColor(255, 255, 255)
		
		--COINBLOCKanimation
		for i, v in pairs(coinblockanimations) do
			love.graphics.draw(coinblockanimationimg, coinblockanimationquads[coinblockanimations[i].frame], math.floor((coinblockanimations[i].x - xscroll)*16*scale), math.floor(((coinblockanimations[i].y-yscroll)*16-8)*scale), 0, scale, scale, 4, 54)
		end
		
		local minex, miney, minecox, minecoy
		
		--PORTAL UI STUFF
		if levelfinished == false then
			for pl = 1, players do
				if objects["player"][pl].controlsenabled and objects["player"][pl].t == "portalgun" and objects["player"][pl].vine == false and (objects["player"][pl].portalsavailable[1] or objects["player"][pl].portalsavailable[2]) then
					local sourcex, sourcey = objects["player"][pl].x+6/16, objects["player"][pl].y+6/16
					local cox, coy, side, tend, x, y = traceline(sourcex, sourcey, objects["player"][pl].pointingangle)
					
					local portalpossible = true
					if cox == false or getportalposition(1, cox, coy, side, tend) == false then
						portalpossible = false
					end
					
					love.graphics.setColor(255, 255, 255, 255)
					
					local dist = math.sqrt(((x-xscroll)*16*scale - (sourcex-xscroll)*16*scale)^2 + ((y-.5-yscroll)*16*scale - (sourcey-.5-yscroll)*16*scale)^2)/16/scale
					
					for i = 1, dist/portaldotsdistance+1 do
						if((i-1+portaldotstimer/portaldotstime)/(dist/portaldotsdistance)) < 1 then
							local xplus = ((x-xscroll)*16*scale - (sourcex-xscroll)*16*scale)*((i-1+portaldotstimer/portaldotstime)/(dist/portaldotsdistance))
							local yplus = ((y-.5-yscroll)*16*scale - (sourcey-.5-yscroll)*16*scale)*((i-1+portaldotstimer/portaldotstime)/(dist/portaldotsdistance))
						
							local dotx = (sourcex-xscroll)*16*scale + xplus
							local doty = (sourcey-.5-yscroll)*16*scale + yplus
						
							local radius = math.sqrt(xplus^2 + yplus^2)/scale
							
							local alpha = 255
							if radius < portaldotsouter then
								alpha = (radius-portaldotsinner) * (255/(portaldotsouter-portaldotsinner))
								if alpha < 0 then
									alpha = 0
								end
							end
							
							
							if portalpossible == false then
								love.graphics.setColor(255, 0, 0, alpha)
							else
								love.graphics.setColor(0, 255, 0, alpha)
							end
						
							love.graphics.draw(portaldotimg, math.floor(dotx-0.25*scale), math.floor(doty-0.25*scale), 0, scale, scale)
						end
					end
				
					love.graphics.setColor(255, 255, 255, 255)
					
					if cox ~= false then
						if portalpossible == false then
							love.graphics.setColor(255, 0, 0)
						else
							love.graphics.setColor(0, 255, 0)
						end
						
						local rotation = 0
						if side == "right" then
							rotation = math.pi/2
						elseif side == "down" then
							rotation = math.pi
						elseif side == "left" then
							rotation = math.pi/2*3
						end
						love.graphics.draw(portalcrosshairimg, math.floor((x-xscroll)*16*scale), math.floor((y-.5-yscroll)*16*scale), rotation, scale, scale, 4, 8)
					end
				end
			end
		end
		love.graphics.setColor(255, 255, 255)
		
		drawforeground()
	end --SCENE DRAW FUNCTION END
	
	if players == 1 and love.graphics.isSupported("canvas") and seethroughportals then
		--what's this all about
		if not scenecanvas then
			scenecanvas = love.graphics.newCanvas()
		end
		
		local pl = objects["player"][1]
		scenecanvas:clear()
		love.graphics.setCanvas(scenecanvas)
		scenedraw()
		love.graphics.setCanvas(completecanvas)
		love.graphics.draw(scenecanvas, 0, 0)
		
		if firstpersonview and firstpersonrotate then
			local xtranslate = width/2*16*scale
			local ytranslate = height/2*16*scale
			love.graphics.translate(xtranslate, ytranslate)
			love.graphics.rotate(-objects["player"][1].rotation/2)
			love.graphics.translate(-xtranslate, -ytranslate)
		end
		
		currentscissor = {0, 0,width*16*scale, height*16*scale}
		
		for k, v in pairs(portals) do
			if v.x1 and v.x2 then
				for i = 1, 2 do
					local otheri = 1
					if i == 1 then
						otheri = 2
					end
				
					local x, y, facing = v["x" .. i], v["y" .. i], v["facing" .. i]
					local x2, y2, facing2 = v["x" .. otheri], v["y" .. otheri], v["facing" .. otheri]
					local pass = false
					
					if facing == "up" then
						pass = pl.y+pl.height/2 < y-1
					elseif facing == "right" then
						pass = pl.x+pl.width/2 > x
					elseif facing == "down" then
						pass = pl.y+pl.height/2 > y
					elseif facing == "left" then
						pass = pl.x+pl.width/2 < x-1
					end
					
					if pass then
						local p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y
						if facing == "right" then
							p1x, p1y = (x-xscroll), (y-yscroll-1.5)
							p2x, p2y = p1x, p1y+2
						elseif facing == "down" then
							p1x, p1y = (x-xscroll-2), (y-yscroll-.5)
							p2x, p2y = p1x+2, p1y
						elseif facing == "left" then
							p1x, p1y = (x-xscroll-1), (y-yscroll-2.5)
							p2x, p2y = p1x, p1y+2
						elseif facing == "up" then
							p1x, p1y = (x-xscroll-1), (y-yscroll-1.5)
							p2x, p2y = p1x+2, p1y
						end
						
						local r1 = math.atan2((pl.x+pl.width/2-xscroll)-p1x, (pl.y+pl.height/2-yscroll-.5)-p1y)
						local r2 = math.atan2((pl.x+pl.width/2-xscroll)-p2x, (pl.y+pl.height/2-yscroll-.5)-p2y)
						
						local limit = (width+height)*100
						
						p3x = -math.sin(r1)*limit+p1x
						p3y = -math.cos(r1)*limit+p1y
						
						p4x = -math.sin(r2)*limit+p2x
						p4y = -math.cos(r2)*limit+p2y
						
						
						--Calculate the middle of the portals
						local tx, ty
						local r1
						if facing == "right" then
							tx, ty = (x-xscroll), (y-yscroll-.5)
							r1 = math.pi/2
						elseif facing == "down" then
							tx, ty = (x-xscroll-1), (y-yscroll-.5)
							r1 = math.pi
						elseif facing == "left" then
							tx, ty = (x-xscroll-1), (y-yscroll-1.5)
							r1 = math.pi*1.5
						elseif facing == "up" then
							tx, ty = (x-xscroll), (y-yscroll-1.5)
							r1 = 0
						end
						
						local ox, oy
						if facing2 == "right" then
							ox, oy = (x2-xscroll), (y2-yscroll-.5)
							r2 = math.pi/2
						elseif facing2 == "down" then
							ox, oy = (x2-xscroll-1), (y2-yscroll-.5)
							r2 = math.pi
						elseif facing2 == "left" then
							ox, oy = (x2-xscroll-1), (y2-yscroll-1.5)
							r2 = math.pi*1.5
						elseif facing2 == "up" then
							ox, oy = (x2-xscroll), (y2-yscroll-1.5)
							r2 = 0
						end
						
						local offx, offy = tx-ox, ty-oy
						
						local a = r2-r1
						
						local xscale, yscale = 1, 1
						
						if facing == facing2 then
							if facing == "left" or facing == "right" then
								xscale = -xscale
							else
								yscale = -yscale
							end
						end
						
						if (facing == "left" and facing2 == "right") or (facing == "right" and facing2 == "left") or (facing == "up" and facing2 == "down") or (facing == "down" and facing2 == "up") then
							a = a - math.pi
						end
						
						love.graphics.setStencil(function()
							love.graphics.polygon("fill", p1x*16*scale, p1y*16*scale, p2x*16*scale, p2y*16*scale, p4x*16*scale, p4y*16*scale, p3x*16*scale, p3y*16*scale)
						end) --feels like javascript
						
						love.graphics.setColor(unpack(background))
						love.graphics.rectangle("fill", 0, 0, width*16*scale, height*16*scale)
						
						
						love.graphics.setColor(255, 255, 255)
						love.graphics.draw(scenecanvas, (offx+ox)*16*scale, (offy+oy)*16*scale, a, xscale, yscale, ox*16*scale, oy*16*scale)
						
						local r, g, b = unpack(v["portal" .. i .. "color"])
						--love.graphics.setColor(r, g, b, 150)
						--love.graphics.rectangle("fill", 0, 0, width*16*scale, height*16*scale)
						
						love.graphics.setStencil()
						love.graphics.setColor(r, g, b)
						love.graphics.line(p1x*16*scale, p1y*16*scale, p3x*16*scale, p3y*16*scale)
						love.graphics.line(p2x*16*scale, p2y*16*scale, p4x*16*scale, p4y*16*scale)
					end
				end
			end
		end
	else
		scenedraw()
	end
	
	love.graphics.setColor(255, 255, 255, 255)
	
	if debugflags.userect then
		for k,v in pairs(objects["userect"]) do
			love.graphics.setColor(255, 255, 255, 100)
			love.graphics.rectangle("fill", (v.x-xscroll)*16*scale, (v.y-yscroll-.5)*16*scale, v.width*16*scale, v.height*16*scale)
			love.graphics.setColor(255, 255, 255, 255)
		end
	end
	
	--Player markers
	for i = 1, players do
		local v = objects["player"][i]
		if false and not v.dead and v.drawable and v.y < mapheight-.5 then
			--get if player offscreen
			local right, left, up, down = false, false, false, false
			if v.x > xscroll+width then
				right = true
			end
			
			if v.x+v.width < xscroll then
				left = true
			end
			
			if v.y > yscroll + .5 + height then
				down = true
			end
			
			if v.y+v.height < yscroll +.5 then
				up = true
			end
			
			if up or left or down or right then
				local x, y
				local angx, angy = 0, 0
				
				if right then
					x = width
					angx = 1
				elseif left then
					x = 0
					angx = -1
				end
				
				if up then
					y = 0
					angy = -1
				elseif down then
					y = height
					angy = 1
				end
				
				if not x then
					x = v.x-xscroll+v.width/2
				end
				
				if not y then
					y = v.y-yscroll-3/16
				end
				
				local r = -math.atan2(angx, angy)-math.pi/2
				
				--limit x or y if right angle
				if math.mod(r, math.pi/2) == 0 then
					if up or down then
						x = math.max(x, 15/16)
						x = math.min(x, width-15/16)
					else
						y = math.max(y, 15/16)
						y = math.min(y, height-15/16)
					end
				end
				
				love.graphics.setColor(background)
				love.graphics.draw(markbaseimg, math.floor(x*16*scale), math.floor(y*16*scale), r, scale, scale, 0, 15)
				
				local dist = 21.5
				
				local xadd = math.cos(r)*dist
				local yadd = math.sin(r)*dist
				
				love.graphics.setColor(255, 255, 255)
				love.graphics.setStencil(function() love.graphics.circle("fill", math.floor((x*16+xadd)*scale), math.floor((y*16+yadd-.5)*scale), 13.5*scale) end)
				
				local playerx, playery = x*16+xadd, y*16+yadd+3
				
				--draw map
				for x = math.floor(v.x), math.floor(v.x)+3 do
					for y = math.floor(v.y), math.floor(v.y)+3 do
						if inmap(x, y) then
							tilenumber = map[x][y][1]
							
							if tilenumber ~= 0 and not tilequads[tilenumber]:getproperty("invisible", x, y) then
								local img
								
								if tilenumber <= smbtilecount then
									img = smbtilesimg
								elseif tilenumber <= smbtilecount+portaltilecount then
									img = portaltilesimg
								elseif tilenumber <= smbtilecount+portaltilecount+customtilecount then
									img = customtilesimg
								end
								
								love.graphics.draw(img, tilequads[tilenumber]:quad(), math.floor((x-1-v.x-6/16)*16*scale+playerx*scale), math.floor((y-1.5-v.y)*16*scale+playery*scale), 0, scale, scale)
							end
						end
					end
				end
				
				drawplayer(i, playerx, playery)
				
				love.graphics.setStencil()
				
				love.graphics.setColor(v.colors[1] or {255, 255, 255})
				love.graphics.draw(markoverlayimg, math.floor(x*16*scale), math.floor(y*16*scale), r, scale, scale, 0, 15)
			end
		end
	love.graphics.setScissor()
	end
	
	--Physics debug
	if physicsdebug or incognito then
		local lw = love.graphics.getLineWidth()
		love.graphics.setLineWidth(1)
		for i, v in pairs(objects) do
			for j, k in pairs(v) do
				if k.width then
					if xscroll >= k.x-width and k.x+k.width > xscroll then
						if k.active then
							love.graphics.setColor(255, 255, 255)
						else
							love.graphics.setColor(255, 0, 0)
						end
						if incognito then
							love.graphics.rectangle("fill", math.floor((k.x-xscroll)*16*scale)+.5, math.floor((k.y-yscroll-.5)*16*scale)+.5, k.width*16*scale-1, k.height*16*scale-1)
						else
							love.graphics.rectangle("line", math.floor((k.x-xscroll)*16*scale)+.5, math.floor((k.y-yscroll-.5)*16*scale)+.5, k.width*16*scale-1, k.height*16*scale-1)
						end
					end
				end
			end
		end
		love.graphics.setLineWidth(lw)
	end
	
	--Use region debug
	
	--portalwalldebug
	if portalwalldebug then
		for j, v in pairs(portals) do
			for k = 1, 2 do
				for i = 1, 6 do
					if objects["portalwall"][v.number .. "-" .. k .. "-" .. i] then
						objects["portalwall"][v.number .. "-" .. k .. "-" .. i]:draw()
					end
				end
			end
		end
	end
	
	for i, v in pairs(dialogboxes) do
		v:draw()
	end
	
	if earthquake > 0 then
		love.graphics.translate(-round(tremorx), -round(tremory))
	end
	
	if editormode then
		editor_draw()
	end
	
	--speed gradient
	if bullettime and speed < 1 then
		love.graphics.setColor(255, 255, 255, 255-255*speed)
		love.graphics.draw(gradientimg, 0, 0, 0, scale, scale)
	end
	
	if yoffset < 0 then
		love.graphics.translate(0, -yoffset*scale)
	end
	love.graphics.translate(0, yoffset*scale)
	
	if testlevel then
		love.graphics.setColor(0, 128, 0)
		properprint("test", 0, 0)
	end
	
	--pause menu
	if pausemenuopen then
		love.graphics.setColor(0, 0, 0, 100)
		love.graphics.rectangle("fill", 0, 0, width*16*scale, height*16*scale)
		
		love.graphics.setColor(0, 0, 0)
		love.graphics.rectangle("fill", (width*8*scale)-50*scale, (112*scale)-75*scale, 100*scale, 150*scale)
		love.graphics.setColor(255, 255, 255)
		drawrectangle(width*8-49, 112-74, 98, 148)
		
		for i = 1, #pausemenuoptions do
			love.graphics.setColor(100, 100, 100, 255)
			if pausemenuselected == i and not menuprompt and not desktopprompt then
				love.graphics.setColor(255, 255, 255, 255)
				properprint(">", (width*8*scale)-45*scale, (112*scale)-60*scale+(i-1)*25*scale)
			end
			properprint(pausemenuoptions[i], (width*8*scale)-35*scale, (112*scale)-60*scale+(i-1)*25*scale)
			properprint(pausemenuoptions2[i], (width*8*scale)-35*scale, (112*scale)-50*scale+(i-1)*25*scale)
			
			if pausemenuoptions[i] == "volume" then
				drawrectangle((width*8)-34, 68+(i-1)*25, 74, 1)
				drawrectangle((width*8)-34, 65+(i-1)*25, 1, 7)
				drawrectangle((width*8)+40, 65+(i-1)*25, 1, 7)
				love.graphics.draw(volumesliderimg, math.floor(((width*8)-35+74*volume)*scale), (112*scale)-47*scale+(i-1)*25*scale, 0, scale, scale)
			end
		end
		
		if menuprompt then
			love.graphics.setColor(0, 0, 0, 255)
			love.graphics.rectangle("fill", (width*8*scale)-100*scale, (112*scale)-25*scale, 200*scale, 50*scale)
			love.graphics.setColor(255, 255, 255, 255)
			drawrectangle((width*8)-99, 112-24, 198, 48)
			properprint("quit to menu?", (width*8*scale)-string.len("quit to menu?")*4*scale, (112*scale)-10*scale)
			if pausemenuselected2 == 1 then
				properprint(">", (width*8*scale)-51*scale, (112*scale)+4*scale)
				love.graphics.setColor(255, 255, 255, 255)
				properprint("yes", (width*8*scale)-44*scale, (112*scale)+4*scale)
				love.graphics.setColor(100, 100, 100, 255)
				properprint("no", (width*8*scale)+28*scale, (112*scale)+4*scale) 
			else
				properprint(">", (width*8*scale)+20*scale, (112*scale)+4*scale)
				love.graphics.setColor(100, 100, 100, 255)
				properprint("yes", (width*8*scale)-44*scale, (112*scale)+4*scale)
				love.graphics.setColor(255, 255, 255, 255)
				properprint("no", (width*8*scale)+28*scale, (112*scale)+4*scale)
			end
		end
		
		if desktopprompt then
			love.graphics.setColor(0, 0, 0, 255)
			love.graphics.rectangle("fill", (width*8*scale)-100*scale, (112*scale)-25*scale, 200*scale, 50*scale)
			love.graphics.setColor(255, 255, 255, 255)
			drawrectangle((width*8)-99, 112-24, 198, 48)
			properprint("quit to desktop?", (width*8*scale)-string.len("quit to desktop?")*4*scale, (112*scale)-10*scale)
			if pausemenuselected2 == 1 then
				properprint(">", (width*8*scale)-51*scale, (112*scale)+4*scale)
				love.graphics.setColor(255, 255, 255, 255)
				properprint("yes", (width*8*scale)-44*scale, (112*scale)+4*scale)
				love.graphics.setColor(100, 100, 100, 255)
				properprint("no", (width*8*scale)+28*scale, (112*scale)+4*scale)
			else
				properprint(">", (width*8*scale)+20*scale, (112*scale)+4*scale)
				love.graphics.setColor(100, 100, 100, 255)
				properprint("yes", (width*8*scale)-44*scale, (112*scale)+4*scale)
				love.graphics.setColor(255, 255, 255, 255)
				properprint("no", (width*8*scale)+28*scale, (112*scale)+4*scale)
			end
		end
		
		if suspendprompt then
			love.graphics.setColor(0, 0, 0, 255)
			love.graphics.rectangle("fill", (width*8*scale)-100*scale, (112*scale)-25*scale, 200*scale, 50*scale)
			love.graphics.setColor(255, 255, 255, 255)
			drawrectangle((width*8)-99, 112-24, 198, 48)
			properprint("suspend game? this can", (width*8*scale)-string.len("suspend game? this can")*4*scale, (112*scale)-20*scale)
			properprint("only be loaded once!", (width*8*scale)-string.len("only be loaded once!")*4*scale, (112*scale)-10*scale)
			if pausemenuselected2 == 1 then
				properprint(">", (width*8*scale)-51*scale, (112*scale)+4*scale)
				love.graphics.setColor(255, 255, 255, 255)
				properprint("yes", (width*8*scale)-44*scale, (112*scale)+4*scale)
				love.graphics.setColor(100, 100, 100, 255)
				properprint("no", (width*8*scale)+28*scale, (112*scale)+4*scale)
			else
				properprint(">", (width*8*scale)+20*scale, (112*scale)+4*scale)
				love.graphics.setColor(100, 100, 100, 255)
				properprint("yes", (width*8*scale)-44*scale, (112*scale)+4*scale)
				love.graphics.setColor(255, 255, 255, 255)
				properprint("no", (width*8*scale)+28*scale, (112*scale)+4*scale)
			end
		end
	end
end

function drawreplay(j, i)
	local self = replaydata[j].data[i]
	local angleframe = 1
	
	if not self.drawable then
		return
	end
	
	if self.level ~= mariolevel or self.world ~= marioworld or self.sublevel ~= mariosublevel then
		return
	end
	
	local char = replaychar[j]
	
	if j == 1 and firstreplayblue then
		replaychar[j] = characters.mario
	end
	
	if replaychar[j].nopointing then
		angleframe = 1
	else
		angleframe = getAngleFrame(self.pointingangle, self.rotation)
	end
	
	local animationstate = self.animationstate
	local size = self.size
	local quad
	
	if size == 1 then
		if self.infunnel then
			quad = replaychar[j].jump[angleframe][self.jumpframe]
		elseif self.underwater and (self.animationstate == "jumping" or self.animationstate == "falling") then
			quad = replaychar[j].swim[angleframe][self.swimframe]
		elseif animationstate == "running" or animationstate == "falling" then
			quad = replaychar[j].run[angleframe][self.runframe]
		elseif animationstate == "idle" then
			quad = replaychar[j].idle[angleframe]
		elseif animationstate == "sliding" then
			quad = replaychar[j].slide[angleframe]
		elseif animationstate == "jumping" then
			quad = replaychar[j].jump[angleframe][self.jumpframe]
		elseif animationstate == "climbing" then
			quad = replaychar[j].climb[angleframe][self.climbframe]
		elseif animationstate == "dead" then
			quad = replaychar[j].die[angleframe]
		elseif animationstate == "grow" then
			quad = replaychar[j].grow[angleframe]
		end
	elseif size > 1 then
		if self.infunnel then
			quad = replaychar[j].bigjump[angleframe][self.jumpframe]
		elseif self.underwater and (self.animationstate == "jumping" or self.animationstate == "falling") then
			quad = replaychar[j].bigswim[angleframe][self.swimframe]
		elseif self.ducking then
			quad = replaychar[j].bigduck[angleframe]
		elseif self.fireanimationtimer < fireanimationtime then
			quad = replaychar[j].bigfire[angleframe]
		else
			if animationstate == "running" or animationstate == "falling" then
				quad = replaychar[j].bigrun[angleframe][self.runframe]
			elseif animationstate == "idle" then
				quad = replaychar[j].bigidle[angleframe]
			elseif animationstate == "sliding" then
				quad = replaychar[j].bigslide[angleframe]
			elseif animationstate == "climbing" then
				quad = replaychar[j].bigclimb[angleframe][self.climbframe]
			elseif animationstate == "jumping" then
				quad = replaychar[j].bigjump[angleframe][self.jumpframe]
			end
		end
	end
	
	local graphic
	local biggraphic = replaychar[j].nogunbiganimations
	if self.size == 1 then
		graphic = replaychar[j].nogunanimations
	else
		graphic = replaychar[j].nogunbiganimations
	end
	
	if self.customscissor then
		love.graphics.setScissor(math.floor((self.customscissor[1]-xscroll)*16*scale), math.floor((self.customscissor[2]-.5-yscroll)*16*scale), self.customscissor[3]*16*scale, self.customscissor[4]*16*scale)
	end
	
	if true then
		self.pointingangle = -math.pi
		if self.animationdirection == "left" then
			self.pointingangle = math.pi
		end
	end
	
	drawplayer(nil, (self.x-xscroll+6/16)*16, self.y*16, scale, self.offsetX, self.offsetY, self.rotation, self.quadcenterX, self.quadcenterY, self.animationstate, self.underwater, self.ducking, self.hats, graphic, quad, self.pointingangle, self.shot, self.upsidedown, self.colors, self.lastportal, self.portal1color, self.portal2color, self.runframe, self.swimframe, self.climbframe, self.jumpframe, biggraphic, self.fireanimationtimer, replaychar[j])
	love.graphics.setScissor()
	replaychar[j] = char
end

function drawplayer(i, x, y, cscale,     offsetX, offsetY, rotation, quadcenterX, quadcenterY, animationstate, underwater, ducking, hats, graphic, quad, pointingangle, shot, upsidedown, colors, lastportal, portal1color, portal2color, runframe, swimframe, climbframe, jumpframe, biggraphic, fireanimationtimer, char)
	x = x-6

	local scale = scale
	if cscale then
		scale = cscale
	end
	
	local v
	
	if not offsetX then
		v = objects["player"][i]
	else
		v = {offsetX=offsetX, offsetY=offsetY, rotation=rotation, quadcenterX=quadcenterX, quadcenterY=quadcenterY, animationstate=animationstate, underwater=underwater, ducking=ducking, hats=hats, graphic=graphic, quad=quad, pointingangle=pointingangle, shot=shot, upsidedown=upsidedown, colors=colors, lastportal=lastportal, portal1color=portal1color, portal2color=portal2color, runframe=runframe, swimframe=swimframe, climbframe=climbframe, jumpframe=jumpframe, biggraphic=biggraphic, fireanimationtimer=fireanimationtimer, char=char}
		if v.char and v.graphic == v.char.biggraphic then
			v.size = 2
		else
			v.size = 1
		end
	end
	
	if (not objects or not objects["player"][i] or objects["player"][i].portalsavailable[1] or objects["player"][i].portalsavailable[2]) then
		if v.pointingangle > 0 then
			dirscale = -scale
		else
			dirscale = scale
		end
	else
		if objects["player"][i].animationdirection == "right" then
			dirscale = scale
		else
			dirscale = -scale
		end
	end
	
	local horscale = scale
	if v.shot or v.upsidedown then
		horscale = -scale
	end
	
	if type(v.graphic) == "table" then
		for k = 1, #v.graphic do
			if v.colors[k] then
				love.graphics.setColor(v.colors[k])
			else
				love.graphics.setColor(255, 255, 255)
			end
			love.graphics.draw(v.graphic[k], v.quad, math.floor((x+v.offsetX)*scale), math.floor((y-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
		end
	else
		if v.graphic and v.quad then
			love.graphics.setColor(255, 255, 255)
			love.graphics.draw(v.graphic, v.quad, math.floor((x+v.offsetX)*scale), math.floor((y-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
		end	
	end
	
	
	if v.drawhat ~= false then
		local offsets = gethatoffset(v.char, v.graphic, v.animationstate, v.runframe, v.jumpframe, v.climbframe, v.swimframe, v.underwater, v.infunnel, v.fireanimationtimer, v.ducking)
		
		if offsets and #v.hats > 0 then
			local yadd = 0
			for i = 1, #v.hats do
				if v.hats[i] ~= 0 then
					if v.hats[i] == 1 then
						love.graphics.setColor(v.colors[1])
					else
						love.graphics.setColor(255, 255, 255)
					end
					if v.graphic == v.biggraphic or v.animationstate == "grow" then
						love.graphics.draw(bighat[v.hats[i]].graphic, math.floor((x+v.offsetX)*scale), math.floor((y-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX - bighat[v.hats[i]].x + offsets[1], v.quadcenterY - bighat[v.hats[i]].y + offsets[2] + yadd)
						yadd = yadd + bighat[v.hats[i]].height
					else
						local debugtable = {x, v.offsetX, y, v.offsetY, v.quadcenterX, hat[v.hats[i]].x, offsets[1], v.quadcenterY, hat[v.hats[i]].y, offsets[2], yadd}
						--TIMETRIAL
						for i, v in pairs(debugtable) do
							if type(v) == "table" then
								return
							end
						end
						
						love.graphics.draw(hat[v.hats[i]].graphic, math.floor((x+v.offsetX)*scale), math.floor((y-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX - hat[v.hats[i]].x + offsets[1], v.quadcenterY - hat[v.hats[i]].y + offsets[2] + yadd)
						yadd = yadd + hat[v.hats[i]].height
					end
				end
			end
		end
	end
	
	if type(v.graphic) == "table" then
		if v.graphic[0] then
			love.graphics.setColor(255, 255, 255)
			love.graphics.draw(v.graphic[0], v.quad, math.floor((x+v.offsetX)*scale), math.floor((y-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
		end
		if v.graphic.dot then
			love.graphics.setColor(unpack(v["portal" .. v.lastportal .. "color"]))
			love.graphics.draw(v.graphic["dot"], v.quad, math.floor((x+v.offsetX)*scale), math.floor((y-v.offsetY)*scale), v.rotation, dirscale, horscale, v.quadcenterX, v.quadcenterY)
		end	
	end
end

function reachedx(currentx)
	if not currentx or currentx <= lastrepeat+width then
		return
	end
	
	lastrepeat = math.floor(currentx)-width
	--castlerepeat?
	--get mazei
	local mazei = 0
	
	for j = 1, #mazeends do
		if mazeends[j] < currentx then
			mazei = j
		end
	end
	
	--check if maze was solved!
	for i = 1, players do
		if objects["player"][i].mazevar == mazegates[mazei] then
			local actualmaze = 0
			for j = 1, #mazestarts do
				if objects["player"][i].x > mazestarts[j] then
					actualmaze = j
				end
			end
			mazesolved[actualmaze] = true
			for j = 1, players do
				objects["player"][j].mazevar = 0
			end
			break
		end
	end
	
	if not mazesolved[mazei] or mazeinprogress then --get if inside maze
		if not mazesolved[mazei] then
			mazeinprogress = true
		end
		
		local x = math.ceil(currentx)
		
		if repeatX == 0 then
			repeatX = mazestarts[mazei]
		end
		
		table.insert(map, x, {{1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}, {1}})
		table.insert(coinmap, x, {})
		for y = 1, mapheight do
			for j = 1, #map[repeatX][y] do
				map[x][y][j] = map[repeatX][y][j]
				coinmap[x][y] = coinmap[repeatX][y]
			end
			map[x][y]["gels"] = {}
			map[x][y]["portaloverride"] = {}
			
			for cox = mapwidth, x, -1 do
				--move objects
				if objects["tile"][cox .. "-" .. y] then
					objects["tile"][cox + 1 .. "-" .. y] = tile:new(cox, y-1)
					objects["tile"][cox .. "-" .. y] = nil
				end
			end
			
			--create object for block
			if tilequads[map[repeatX][y][1]]:getproperty("collision", repeatX, y) then
				objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
			end
		end
		mapwidth = mapwidth + 1
		repeatX = repeatX + 1
		if flagx then
			flagx = flagx + 1
			flagimgx = flagimgx + 1
			objects["screenboundary"]["flag"].x = objects["screenboundary"]["flag"].x + 1
		end
		
		-- I'm not sure what this does exactly, so, here we are.
		for k,v in pairs(objects["axe"]) do
			--v.x = v.x + 1
			--objects["screenboundary"]["axe"].x = objects["screenboundary"]["axe"].x + 1
		end
		
		if firestartx then
			firestartx = firestartx + 1
		end
		
		objects["screenboundary"]["right"].x = objects["screenboundary"]["right"].x + 1
		
		--move mazestarts and ends
		for i = 1, #mazestarts do
			mazestarts[i] = mazestarts[i]+1
			mazeends[i] = mazeends[i]+1
		end
		
		--check for endblock
		local x = math.ceil(currentx)
		for y = 1, mapheight do
			if map[x][y][2] and entitylist[map[x][y][2]].t == "mazeend" then
				if mazesolved[mazei] then
					repeatX = mazestarts[mazei+1]
				end
				mazeinprogress = false
			end
		end
		
		--reset thingie
		
		local x = math.ceil(currentx)-1
		for y = 1, mapheight do
			if map[x][y][2] and entitylist[map[x][y][2]].t == "mazeend" then
				for j = 1, players do
					objects["player"][j].mazevar = 0
				end
			end
		end
	end
	
	--ENEMY STUFF
	--[[if editormode == false and currentx < mapwidth then
		for y = 1, mapheight do
			spawnenemy(currentx, y)
		end
		if goombaattack then
			local randomtable = {}
			for y = 1, mapheight do
				table.insert(randomtable, y)
			end
			while #randomtable > 0 do
				local rand = math.random(#randomtable)
				if tilequads[map[currentx][randomtable[rand] ][1] ]:getproperty("collision", currentx, randomtable[rand]) then
					table.remove(randomtable, rand)
				else
					table.insert(objects["goomba"], goomba:new(currentx-.5, math.random(13)))
					break
				end
			end
		end
	end--]]
end

function loadlevel(level, is_sublevel)
	print("inside loadlevel")
	collectgarbage("collect")
	love.audio.stop()
	animationsystem_load()
	
	if replaysystem then
		for i = 1, #replaydata do
			replaytimer[i] = 0
			replayi[i] = 1
			replaychar[i] = characters.mario
		end
	end

	if is_sublevel then
		prevsublevel = mariosublevel
		mariosublevel = level
		level = level
		currentmap = level
	else
		mariosublevel = 0
		prevsublevel = currentmap
		mariotime = 400
		
		--check for checkpoint!
		if checkpointsub then
			mariosublevel = checkpointsub
			level = level
			-- assign "checkpointsub" to something I guess? I don't know
		end
	end
	
	--MISC VARS; Misc Global Variables
	gameplaytype = "oddjob" --List over in variables.lua
	everyonedead = false
	levelfinished = false
	coinanimation = 1
	redcoinanimation = 1
	flagx = false
	levelfinishtype = nil
	firedelay = math.random(4)
	flyingfishdelay = 1
	bulletbilldelay = 1
	windtimer = 0.1
	firetimer = firedelay
	flyingfishtimer = flyingfishdelay
	bulletbilltimer = bulletbilldelay
	lakitoendx = false
	lakitoend = false
	noupdate = false
	xscroll = 0
	repeatX = 0
	lastrepeat = 0
	ylookmodifier = 0
	displaywarpzonetext = false
	mazestarts = {}
	mazeends = {}
	mazesolved = {}
	mazesolved[0] = true
	mazeinprogress = false
	earthquake = 0
	sunrot = 0
	gelcannontimer = 0
	pausemenuselected = 1
	coinblocktimers = {}

	switchtimeout = false
	pswitchactive = {blue = false, grey = false}
	pswitchtimers = {blue = 0, grey = 0}
		
	givemestuff = {lives = 0, times = 0, coinage = 0}
	
	portaldelay = {}
	for i = 1, players do
		portaldelay[i] = 0
	end
	
	--class tables
	coinblockanimations = {}
	portalparticles = {}
	dialogboxes = {}
	inventory = {}
	for i = 1, 9 do
		inventory[i] = {}
	end
	mccurrentblock = 1
	itemanimations = {}
	
	blockbouncetimer = {}
	blockbouncex = {}
	blockbouncey = {}
	blockbouncecontent = {}
	blockbouncecontent2 = {}
	warpzonenumbers = {}
	
	portals = {}
	
	objects = {}
	-- Initialize all registered object arrays.
	for _,v in pairs(basedents) do
		objects[v]={}
	end
	for _,v in pairs(saneents) do
		objects[v]={}
	end
	
	xscroll = 0
	yscroll = 0
	ylookmodifier = 0
	
	startx = {3, 3, 3, 3, 3}
	starty = {13, 13, 13, 13, 13}
	pipestartx = nil
	pipestarty = nil
	globalanimation = nil
	
	enemiesspawned = {}
	
	intermission = false
	haswarpzone = false
	underwater = false
	bonusstage = false
	custombackground = false
	customforeground = false
	mariotimelimit = 400
	spriteset = 1
	
	--LOAD THE MAP
	if not loadmap(level, true) then --make one up
		mapwidth = width
		background = {unpack(backgroundcolor[1])}
		mapheight = 15
		portalsavailable = {true, true}
		musicname = "overworld.ogg"
		map = {}
		coinmap = {}
		for x = 1, width do
			map[x] = {}
			coinmap[x] = {}
			for y = 1, mapheight do
				if y > 13 then
					map[x][y] = {2}
					objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
					map[x][y]["gels"] = {}
					map[x][y]["portaloverride"] = {}
				else
					map[x][y] = {1}
					map[x][y]["gels"] = {}
					map[x][y]["portaloverride"] = {}
				end
			end
		end
		
		
		smbspritebatch = love.graphics.newSpriteBatch( smbtilesimg, 10000 )
		smbspritebatchfront = love.graphics.newSpriteBatch( smbtilesimg, 10000 )
		portalspritebatch = love.graphics.newSpriteBatch( portaltilesimg, 10000 )
		portalspritebatchfront = love.graphics.newSpriteBatch( portaltilesimg, 10000 )
		if customtiles then
			customspritebatch = love.graphics.newSpriteBatch( customtilesimg, 10000 )
			customspritebatchfront = love.graphics.newSpriteBatch( customtilesimg, 10000 )
		end
		spritebatchX = {}
		spritebatchY = {}
	end
	
	
	enemies_load()
	print("did load enemies")
	
	
	objects["screenboundary"] = {}
	objects["screenboundary"]["left"] = screenboundary:new(0)
	
	objects["screenboundary"]["right"] = screenboundary:new(mapwidth)
	
	if flagx then
		objects["screenboundary"]["flag"] = screenboundary:new(flagx+6/16)
	end
	
	if objects["axe"] and objects["axe"][#objects["axe"]] then
		objects["screenboundary"]["axe"] = screenboundary:new(objects["axe"][#objects["axe"]].cox)
	end
	
	if intermission then
		globalanimation = "intermission"
	end
	
	if not is_sublevel then
		mariotime = mariotimelimit
	end
	
	--Maze setup
	--check every block between every start/end pair to see how many gates it contains
	if #mazestarts == #mazeends then
		mazegates = {}
		for i = 1, #mazestarts do
			local maxgate = 1
			for x = mazestarts[i], mazeends[i] do
				for y = 1, mapheight do
					if map[x][y][2] and entitylist[map[x][y][2]] and entitylist[map[x][y][2]].t == "mazegate" then
						if tonumber(map[x][y][3]) > maxgate then
							maxgate = tonumber(map[x][y][3])
						end
					end
				end
			end
			mazegates[i] = maxgate
		end
	else
		print("Mazenumber doesn't fit!")
	end
	
	--check if it's a bonusstage (boooooooonus!)
	if bonusstage then
		globalanimation = "vinestart"
	end
		
	--set startx to pipestart
	
	--@NOTE: Here's where we overload to set the position of pipers! Yee.
	if warpdestid then
		local foundit=false
		local thepipex, thepipey, thepipe
		for lxi,lxa in pairs(map) do
			for lyi,lya in pairs(lxa) do
				if lya[3] == warpdestid then
					foundit=true
					pipestartx = lxi
					pipestarty = lyi
					thepipe = map[lxi][lyi]
					break
				end
			end
			if foundit then
				break
			end
		end
		
		if foundit then
			
			local pipeoffx, pipeoffy
			if thepipe[7] == "up" then
				pipeoffx = 1
				pipeoffy = 0
			elseif thepipe[7] == "down" then
				pipeoffx = 1
				pipeoffy = -1
			elseif thepipe[7] == "left" then
				pipeoffx = -1
				pipeoffy = 0
			elseif thepipe[7] == "right" then
				pipeoffx = 0
				pipeoffy = 0
			end
			
			globalanimation = "pipe_"..thepipe[7].."_out"
			
			startx = {pipestartx-pipeoffx, pipestartx-pipeoffx, pipestartx-pipeoffx, pipestartx-pipeoffx, pipestartx-pipeoffx}
			starty = {pipestarty-pipeoffy, pipestarty-pipeoffy, pipestarty-pipeoffy, pipestarty-pipeoffy, pipestarty-pipeoffy}
			
			--check if startpos is a colliding block
			--if tilequads[map[startx[1]][starty[1]][1]]:getproperty("collision", startx[1], starty[1]) then
			--	animation = "pipeup2"
			--end
		else
			print("WARNING: Tried to take a pipe to a level that did not have corresponding destination pipe (",warpdestid,")")
		end
		--clear warpdestid because it would never get cleared otherwise
		warpdestid = nil
	end
	
	--set starts to checkpoint
	--@NOTE: I goofed with these. Don't tell anyone.
	if not is_sublevel and checkpointsub then
		for i = 1, checkpointsub do
			if checkpointx[i] then
				startx[i] = checkpointx[i]
			end
			if checkpointy[i] then
				starty[i] = checkpointy[i]
			end
		end
	end
	
	--Adjust start X scroll
	xscroll = startx[1]-scrollingleftcomplete-2
	if xscroll > mapwidth - width then
		xscroll = mapwidth - width
	end
	
	if xscroll < 0 then
		xscroll = 0
	end
	
	--and Y too
	yscroll = starty[1]-height+downscrollborder
	if yscroll > mapheight - height - 1 then
		yscroll = mapheight - height - 1
	end
	
	if yscroll < 0 then
		yscroll = 0
	end
	
	spawnrestrictions = {}
	
	--Clear spawn area from enemies
	for i = 1, #startx do
		if startx[i] == checkpointx[i] and starty[i] == checkpointy[i] then
			table.insert(spawnrestrictions, {startx[i], starty[i]})
		end
	end
	
	--add the players
	--@NOTE: I just don't feel like messing with this.
	local mul = 0.5
	if mariosublevel ~= 0 or prevsublevel ~= false then
		mul = 2/16
	end
	
	objects["player"] = {}
	local spawns = {}
	for i = 1, players do
		local lanimation = globalanimation
		
		local astartx, astarty
		if i > 4 then
			astartx = startx[5]
			astarty = starty[5]
		else
			astartx = startx[i]
			astarty = starty[i]
		end
		
		if astartx then
			local add = -6/16
			for j, v in pairs(spawns) do
				if v.x == astartx and v.y == astarty then
					add = add + mul
				end
			end
			
			table.insert(spawns, {x=astartx, y=astarty})
			
			objects["player"][i] = player:new(astartx+add, astarty-1, i, lanimation, mariosizes[i], playertype)
		else
			objects["player"][i] = player:new(1.5 + (i-1)*mul-6/16+1.5, 13, i, lanimation, mariosizes[i], playertype)
		end
	end
	
	--ADD ENEMIES ON START SCREEN
	if editormode == false then
		local xtodo = width+1
		if mapwidth < width+1 then
			xtodo = mapwidth
		end
		
		local ytodo = height+1
		if mapheight < height+1 then
			ytodo = mapheight
		end
			
		for x = math.floor(xscroll), math.floor(xscroll)+xtodo do
			for y = math.floor(yscroll), math.floor(yscroll)+ytodo do
				spawnenemy(x, y)
			end
		end
	end
	
	--load editor
	editor_load()
	
	updateranges()
	
	generatespritebatch()
	print("finished loadlevel without problems")
end

function startlevel(levelstart)
	gamestate = "game"
	skipupdate = true
	
	--background
	love.graphics.setBackgroundColor(unpack(background))
	oddjobquotas = {} -- Red coin quota, if trophy was found, score quota, coin count quota, if the run was successfully ascetic.
	if levelstart then
	-- Oddjob Variables
		redcoincount = 0
		levelscore = 0
	
		for i = 1, 5 do
				oddjobquotas[i] = 0
		end	
		oddjobquotas[1] = 5
		
		redcoincollected = {}
		for i = 1, oddjobquotas[1] do
				redcoincollected[i] = 0
		end	
	end
	
	--PLAY BGM
	if intermission == false then
		playmusic()
	else
		playsound("intermission") --allowed global
	end
	
	if replaysystem and levelstart then
		livereplaydata = {{}}
		livereplaydelay = {0}
		livereplaystored = {{}}
	end
end

function loadmap(filename, createobjects)
	--print("**************************" .. string.rep("*", #(mappack .. filename)))
	print("LOADING: mappacks/" .. mappack .. "/" .. filename .. ".txt")
	if love.filesystem.exists("mappacks/" .. mappack .. "/" .. filename .. ".txt") == false then
		print("mappacks/" .. mappack .. "/" .. filename .. ".txt not found!")
		return false
	end
	local s = love.filesystem.read( "mappacks/" .. mappack .. "/" .. filename .. ".txt" )
	local s2 = s:split(CATEGORYDELIMITER)
	
	local t
	if string.find(s2[1], BLOCKDELIMITER) then
		mapheight = 15
		t = s2[1]:split(BLOCKDELIMITER)
	else
		mapheight = tonumber(s2[1])
		t = s2[2]:split(BLOCKDELIMITER)
	end
	
	map = {}
	unstatics = {}
	
	smbspritebatch = love.graphics.newSpriteBatch( smbtilesimg, 10000 )
	smbspritebatchfront = love.graphics.newSpriteBatch( smbtilesimg, 10000 )
	portalspritebatch = love.graphics.newSpriteBatch( portaltilesimg, 10000 )
	portalspritebatchfront = love.graphics.newSpriteBatch( portaltilesimg, 10000 )
	if customtiles then
		customspritebatch = love.graphics.newSpriteBatch( customtilesimg, 10000 )
		customspritebatchfront = love.graphics.newSpriteBatch( customtilesimg, 10000 )
	end
	spritebatchX = {}
	spritebatchY = {}
	
	--get mapwidth
	local entries = 0
	for i = 1, #t do
		local s = t[i]:split(MULTIPLYDELIMITER)
		if s[2] then
			entries = entries + tonumber(s[2])
		else
			entries = entries + 1
		end
	end
	
	if math.mod(entries, mapheight) ~= 0 then
		print("Incorrect number of entries: " .. #t)
		return false
	end
	
	mapwidth = entries/mapheight
	coinmap = {}
	
	for x = 1, mapwidth do
		map[x] = {}
		coinmap[x] = {}
		for y = 1, mapheight do
			map[x][y] = {}
			map[x][y]["gels"] = {}
			map[x][y]["portaloverride"] = {}
		end
	end
	
	local x, y = 1, 1
	for i = 1, #t do
		if string.find(t[i], MULTIPLYDELIMITER) then --new stuff!
			local r = tostring(t[i]):split(MULTIPLYDELIMITER)
			
			local coin = false
			if string.sub(r[1], -1) == "c" then
				r[1] = string.sub(r[1], 1, -2)
				coin = true
			end
			
			for j = 1, tonumber(r[2]) do
				if coin then
					coinmap[x][y] = true
				end
			
				if (tonumber(r[1]) > smbtilecount+portaltilecount+customtilecount and tonumber(r[1]) <= 10000) or tonumber(r[1]) > 10000+animatedtilecount then
					r[1] = 1
				end
				
				map[x][y][1] = tonumber(r[1])
				
			
				--create object for block
				if createobjects and tilequads[tonumber(r[1])]:getproperty("collision", x, y) == true then
					objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
				end
				
				x = x + 1
				if x > mapwidth then
					x = 1
					y = y + 1
				end
			end
			
		else --Old stuff.
			local r = tostring(t[i]):split(LAYERDELIMITER)
			
			if string.sub(r[1], -1) == "c" then
				r[1] = string.sub(r[1], 1, -2)
				coinmap[x][y] = true
			end
			
			if (tonumber(r[1]) > smbtilecount+portaltilecount+customtilecount and tonumber(r[1]) <= 10000) or tonumber(r[1]) > 10000+animatedtilecount then
				r[1] = 1
			end
			
			for i = 1, #r do
				if tonumber(r[i]) then
					map[x][y][i] = tonumber(r[i])
				else
					map[x][y][i] = r[i]
				end
			end
			
			--create object for block
			if createobjects and tilequads[tonumber(r[1])]:getproperty("collision", x, y) == true then
				objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
			end
			
			x = x + 1
			if x > mapwidth then
				x = 1
				y = y + 1
			end
		end
	end
	
	--ANIMATED TIMERS
	animatedtimers = {}
	for x = 1, mapwidth do
		animatedtimers[x] = {}
	end
	
	for y = 1, mapheight do
		for x = 1, mapwidth do
			local r = map[x][y]
			
			if r[1] > 10000 then
				if tilequads[r[1]].triggered then
					animatedtimers[x][y] = animatedtimer:new(x, y, r[1])
				end
			end
			
			if tilequads[r[1] ]:getproperty("coin", x, y) then
				coinmap[x][y] = true
			end
			
			if #r > 1 then 
				if entitylist[r[2]] then
					local t = entitylist[r[2]].t
					print(t)
					
					if t == "spawn" then
						local r2 = {unpack(r)}
						table.remove(r2, 1)
						table.remove(r2, 1)
						
						--compatibility for Mari0
						if #r2 == 0 then
							startx = {x, x, x, x, x}
							starty = {y, y, y, y, y}
						else
							if r2[1] == "true" then --all
								startx = {x, x, x, x, x}
								starty = {y, y, y, y, y}
							else
								for i = 1, 5 do
									if r2[i+1] == "true" then
										startx[i] = x
										starty[i] = y
									end
								end
							end
						end
					elseif createobjects and not editormode then
						-- All the sane entities get to play nicely here.
						if table.contains(saneents, t) then
							table.insert(objects[t], _G[t]:new(x, y, r))
							--table.insert(textentities, textentity:new(x-1, y-1, r))
						elseif table.contains(basedents, t) then
							table.insert(objects[t], _G[t]:new(x, y, r))
						elseif t == "warppipe" then
							table.insert(warpzonenumbers, {x, y, r[3]})
							
						elseif t == "manycoins" then
							map[x][y][3] = 7
							
						elseif t == "flag" then
							flagx = x-1
							flagy = y
							
						elseif t == "lakitoend" then
							lakitoendx = x
							
						elseif t == "pipespawn" and (prevsublevel == r[3]-1 or (mariosublevel == r[3]-1 and blacktime == sublevelscreentime)) then
							pipestartx = x
							pipestarty = y
							
						elseif t == "gel" then
							if tilequads[map[x][y][1]]:getproperty("collision", x, y) then
								if r[4] == "true" then
									map[x][y]["gels"]["left"] = r[3]
								end
								if r[5] == "true" then
									map[x][y]["gels"]["top"] = r[3]
								end
								if r[6] == "true" then
									map[x][y]["gels"]["right"] = r[3]
								end
								if r[7] == "true" then
									map[x][y]["gels"]["bottom"] = r[3]
								end
							end
							
						elseif t == "mazestart" then
							if not table.contains(mazestarts, x) then
								table.insert(mazestarts, x)
							end
							
						elseif t == "mazeend" then
							if not table.contains(mazeends, x) then
								table.insert(mazeends, x)
							end
						end
					end
				end
			end
		end
	end
	
	if createobjects then
		--Add links
		for i, v in pairs(objects) do
			for j, w in pairs(v) do
				if w.link then
					w:link()
				end
			end
		end
	end
	
	if flagx then
		flagimgx = flagx+8/16
		flagimgy = flagy-10+1/16
	end
	
	for x = 0, -30, -1 do
		map[x] = {}
		for y = 1, mapheight-2 do
			map[x][y] = {1}
		end
		
		for y = mapheight-1, mapheight do
			map[x][y] = {2}
			if createobjects then
				objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
			end
		end
	end
	
	--background
	background = {unpack(backgroundcolor[1])}
	custombackground = false
	
	--portalgun
	portalsavailable = {true, true}
	
	levelscreenback = nil
	levelscreenbackname = nil
	
	--MORE STUFF
	for i = 3, #s2 do
		s3 = s2[i]:split(EQUALSIGN)
		if s3[1] == "backgroundr" then
			background[1] = tonumber(s3[2])
		elseif s3[1] == "backgroundg" then
			background[2] = tonumber(s3[2])
		elseif s3[1] == "backgroundb" then
			background[3] = tonumber(s3[2])
		elseif s3[1] == "background" then
			background = {unpack(backgroundcolor[tonumber(s3[2])])}
		elseif s3[1] == "spriteset" then
			spriteset = tonumber(s3[2])
		elseif s3[1] == "intermission" then
			intermission = true
		elseif s3[1] == "haswarpzone" then
			haswarpzone = true
		elseif s3[1] == "underwater" then
			underwater = true
		elseif s3[1] == "music" then
			if tonumber(s3[2]) then
				local i = tonumber(s3[2])
				musicname = musiclist[i]
			else
				musicname = s3[2]
			end
		elseif s3[1] == "bonusstage" then
			bonusstage = true
		elseif s3[1] == "custombackground" or s3[1] == "portalbackground" then
			custombackground = true
			if s3[2] and custombackgroundimg[s3[2]] then
				custombackground = s3[2]
			end
		elseif s3[1] == "customforeground" then
			customforeground = true
			if s3[2] and custombackgroundimg[s3[2]] then
				customforeground = s3[2]
			end
		elseif s3[1] == "timelimit" then
			mariotimelimit = tonumber(s3[2])
		elseif s3[1] == "scrollfactor" then
			scrollfactor = tonumber(s3[2])
		elseif s3[1] == "fscrollfactor" then
			fscrollfactor = tonumber(s3[2])
		elseif s3[1] == "portalgun" then
			if s3[2] == "none" then
				portalsavailable = {false, false}
			elseif s3[2] == "blue" then
				portalsavailable = {true, false}
			elseif s3[2] == "orange" then
				portalsavailable = {false, true}
			end
		elseif s3[1] == "levelscreenback" then
			if love.filesystem.exists("mappacks/" .. mappack .. "/levelscreens/" .. s3[2] .. ".png") then
				levelscreenbackname = s3[2]
				levelscreenback = {}
				levelscreenback = love.graphics.newImage("mappacks/" .. mappack .. "/levelscreens/" .. s3[2] .. ".png")
			end
		end
	end
	
	--print("* DONE!" .. string.rep(" ", #(mappack .. filename)+17) .. " *")
	--print("**************************" .. string.rep("*", #(mappack .. filename)))
	return true
end

function changemapwidth(width)
	if width > mapwidth then
		for x = mapwidth+1, width do
			map[x] = {}
			for y = 1, mapheight-2 do
				map[x][y] = {1}
				map[x][y].gels = {}
				map[x][y].portaloverride = {}
				objects["tile"][x .. "-" .. y] = nil
			end
		
			for y = mapheight-1, mapheight do
				map[x][y] = {2}
				objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
				map[x][y].gels = {}
				map[x][y].portaloverride = {}
			end
		end
	end

	mapwidth = width
	objects["screenboundary"]["right"].x = mapwidth
	
	if objects["player"][1].x > mapwidth then
		objects["player"][1].x = mapwidth-1
	end
	
	generatespritebatch()
end

function changemapheight(height)
	if height > mapheight then
		for x = 1, mapwidth do
			for y = mapheight+1, height do
				map[x][y] = {currenttile}
				map[x][y].gels = {}
				map[x][y].portaloverride = {}
				
				if tilequads[currenttile]:getproperty("collision", x, y) then
					objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1, 1, 1, true)
				else
					objects["tile"][x .. "-" .. y] = nil
				end			
			end
		end
	end
	
	mapheight = height
	
	for i, v in pairs(objects["screenboundary"]) do
		v.height = 1000+mapheight
	end
	
	if objects["player"][1].y > mapheight then
		objects["player"][1].y = mapheight-1
	end
	
	generatespritebatch()
end

function generatespritebatch()
	smbspritebatch:clear()
	smbspritebatchfront:clear()
	smbspritebatch:bind()
	smbspritebatchfront:bind()
	
	portalspritebatch:clear()
	portalspritebatchfront:clear()
	portalspritebatch:bind()
	portalspritebatchfront:bind()
	
	if customtiles then
		customspritebatch:clear()
		customspritebatchfront:clear()
		customspritebatch:bind()
		customspritebatchfront:bind()
	end
	
	
	local xtodraw
	if mapwidth < width+1 then
		xtodraw = math.ceil(mapwidth)
	else
		if mapwidth > width and xscroll < mapwidth-width then
			xtodraw = math.ceil(width+1)
		else
			xtodraw = math.ceil(width)
		end
	end
	
	local ytodraw
	if mapheight < height+1 then
		ytodraw = math.ceil(mapheight)
	else
		if mapheight > height and yscroll < mapheight-height then
			ytodraw = height+1
		else
			ytodraw = height
		end
	end
	
	local lmap = map
	
	local flooredxscroll
	if xscroll >= 0 then
		flooredxscroll = math.floor(xscroll)
	else
		flooredxscroll = math.ceil(xscroll)
	end
	
	local flooredyscroll
	if yscroll >= 0 then
		flooredyscroll = math.floor(yscroll)
	else
		flooredyscroll = math.ceil(yscroll)
	end
	
	for y = 0, ytodraw+1 do
		for x = 1, xtodraw do
			if inmap(flooredxscroll+x, math.min(flooredyscroll+y+1, mapheight)) then
				local bounceyoffset = 0
				
				local draw = true
				for i, v in pairs(blockbouncex) do
					if blockbouncex[i] == flooredxscroll+x and blockbouncey[i] == math.min(flooredyscroll+y+1, mapheight) then
						draw = false
					end
				end	
				if draw == true then
					local cox, coy = flooredxscroll+x, math.min(flooredyscroll+y+1, mapheight)
					local t = lmap[cox][coy]
					
					local tilenumber = t[1]
					
					if not tilequads[tilenumber]:getproperty("foreground", cox, coy) then
						if tilenumber ~= 0 and tilequads[tilenumber]:getproperty("invisible", cox, coy) == false and tilequads[tilenumber]:getproperty("coinblock", cox, coy) == false then
							if tilenumber <= smbtilecount then
								smbspritebatch:add( tilequads[tilenumber]:quad(), (x-1)*16*scale, ((y)*16-8)*scale, 0, scale, scale )
							elseif tilenumber <= smbtilecount+portaltilecount then
								portalspritebatch:add( tilequads[tilenumber]:quad(), (x-1)*16*scale, ((y)*16-8)*scale, 0, scale, scale )
							elseif tilenumber <= smbtilecount+portaltilecount+customtilecount then
								customspritebatch:add( tilequads[tilenumber]:quad(), (x-1)*16*scale, ((y)*16-8)*scale, 0, scale, scale )
							end
						end
					else
						if tilenumber ~= 0 and tilequads[tilenumber]:getproperty("invisible", cox, coy) == false and tilequads[tilenumber]:getproperty("coinblock", cox, coy) == false then
							if tilenumber <= smbtilecount then
								smbspritebatchfront:add( tilequads[tilenumber]:quad(), (x-1)*16*scale, ((y)*16-8)*scale, 0, scale, scale )
							elseif tilenumber <= smbtilecount+portaltilecount then
								portalspritebatchfront:add( tilequads[tilenumber]:quad(), (x-1)*16*scale, ((y)*16-8)*scale, 0, scale, scale )
							elseif tilenumber <= smbtilecount+portaltilecount+customtilecount then
								customspritebatchfront:add( tilequads[tilenumber]:quad(), (x-1)*16*scale, ((y)*16-8)*scale, 0, scale, scale )
							end
						end
					end
				end
			end
		end
	end
	
	--Unbind spritebatches
	smbspritebatch:unbind()
	smbspritebatchfront:unbind()
	
	portalspritebatch:unbind()
	portalspritebatchfront:unbind()
	
	if customtiles then
		customspritebatch:unbind()
		customspritebatchfront:unbind()
	end
end

function game_controlupdate(dt)
	if controls.debugModifier then
		if controls.tap.editorToggle then
			-- does not engage full editor
			editormode = not editormode
		end
		if controls.tap.debugEmbiggen then
			local p1 = objects["player"][1]
			if p1.size==1 then
				p1:getpowerup("super", "small","debug embiggen")
			elseif p1.size==2 then
				p1:getpowerup("fire", "super","debug embiggen")
			end
		end
	end
	
	if pausemenuopen then
		if menuprompt then
			if controls.tap.menuLeft then
				pausemenuselected2 = 1
			elseif controls.tap.menuRight then
				pausemenuselected2 = 2
			elseif controls.tap.menuSelect then
				if pausemenuselected2 == 1 then
					love.audio.stop()
					pausemenuopen = false
					saveconfig()
					menuprompt = false
					menu_load()
				else
					menuprompt = false
				end
			elseif controls.tap.menuBack then
				menuprompt = false
			end
		elseif desktopprompt then
			if controls.tap.menuLeft then
				pausemenuselected2 = 1
			elseif controls.tap.menuRight then
				pausemenuselected2 = 2
			elseif controls.tap.menuSelect then
				if pausemenuselected2 == 1 then
					love.audio.stop()
					love.event.quit()
				else
					desktopprompt = false
				end
			elseif controls.tap.menuBack then
				desktopprompt = false
			end
		elseif suspendprompt then
			if controls.tap.menuLeft then
				pausemenuselected2 = 1
			elseif controls.tap.menuRight then
				pausemenuselected2 = 2
			elseif controls.tap.menuEnter then
				if pausemenuselected2 == 1 then
					love.audio.stop()
					suspendgame()
					suspendprompt = false
					pausemenuopen = false
					saveconfig()
				else
					suspendprompt = false
				end
			elseif controls.tap.menuBack then
				suspendprompt = false
			end
		end
		if controls.tap.menuDown then
			pausemenuselected = pausemenuselected + 1
			if pausemenuselected > #pausemenuoptions then
				pausemenuselected = 1
			end
		elseif controls.tap.menuUp then
			pausemenuselected = pausemenuselected - 1
			if pausemenuselected < 1 then
				pausemenuselected = #pausemenuoptions
			end
		elseif controls.tap.menuSelect then
			if pausemenuoptions[pausemenuselected] == "resume" then
				pausemenuopen = false
				saveconfig()
				love.audio.resume()
			elseif pausemenuoptions[pausemenuselected] == "suspend" then
				suspendprompt = true
				pausemenuselected2 = 1
			elseif pausemenuoptions2[pausemenuselected] == "menu" then
				menuprompt = true
				pausemenuselected2 = 1
			elseif pausemenuoptions2[pausemenuselected] == "desktop" then
				desktopprompt = true
				pausemenuselected2 = 1
			end
		elseif controls.tap.playerPause then
			pausemenuopen = false
			saveconfig()
			love.audio.resume()
		elseif controls.tap.menuRight then
			if pausemenuoptions[pausemenuselected] == "volume" then
				if volume < 0.99 then
					volume = volume + 0.1
					love.audio.setVolume( volume )
					soundenabled = true
					playsound("coin") --allowed global
				end
			end
			
		elseif controls.tap.menuLeft then
			if pausemenuoptions[pausemenuselected] == "volume" then
				volume = math.max(volume - 0.1, 0)
				love.audio.setVolume( volume )
				if volume == 0 then
					soundenabled = false
				end
				playsound("coin") --allowed global
			end
		end
	end
	--[[if endpressbutton then
		endpressbutton = false
		endgame()
		return
	end]]
	if controls.tap.playerPause then
		-- code to open the editor menu from here was moved
		-- sorry folks
		if not editormode and not everyonedead then
			pausemenuopen = true
			love.audio.pause()
			playsound("pause") --allowed global
		end
	end
	
	if frameskip then
		if controls.tap.gameFrameSkipDecrease then
			frameskip = math.max(0, frameskip - 1)
			return
		elseif controls.tap.gameFrameSkipIncrease then
			frameskip = frameskip + 1
			return
		end
	end
	
	if bullettime then
		if controls.tap.gameBulletTimeDecrease then
			speedtarget = speedtarget - 0.1
			if speedtarget < 0.1 then
				speedtarget = 0.1
			end
		end
		if controls.tap.gameBulletTimeIncrease then
			speedtarget = speedtarget + 0.1
			if speedtarget > 1 then
				speedtarget = 1
			end
		end
	end
	
	if speeddebug then
		if controls.tap.debugSpeedDecrease then
			speed = math.max(0, speed/2)
		end
		if controls.tap.debugSpeedIncrease then
			speed = math.min(1, speed*2)
		end
	end
	
	if editormode or testlevel then
		editor_controlupdate(dt)
	end
end

function shootportal(plnumber, i, sourcex, sourcey, direction, mirrored)
	if objects["player"][plnumber].portalgundisabled then
		return
	end
	
	--check if available
	if not objects["player"][plnumber].portalsavailable[i] then
		return
	end
	
	--box
	if objects["player"][plnumber].pickup then
		return
	end
	--portalgun delay
	if portaldelay[plnumber] > 0 then
		return
	else
		portaldelay[plnumber] = portalgundelay
	end
	
	local otheri = 1
	local color = objects["player"][plnumber].portal2color
	if i == 1 then
		otheri = 2
		color = objects["player"][plnumber].portal1color
	end
	
	if not mirrored then
		objects["player"][plnumber].lastportal = i
	end
	local mirror = false
	local cox, coy, side, tendency, x, y = traceline(sourcex, sourcey, direction)
	if cox then
		mirror = tilequads[map[cox][coy][1]]:getproperty("mirror", cox, coy)
		if map[cox][coy]["gels"] and map[cox][coy]["gels"][side] then
			local gelstat = map[cox][coy]["gels"][side]
			if mirror and table.contains(gelsthattarnishmirrors, enum_gels[gelstat]) then
				mirror = false
			end
		--	elseif mirror and enum_gels[gelstat] == "white" then
		--		mirror = false
		--	end
		end
	end
	
	objects["player"][plnumber].lastportal = i
	
	table.insert(objects["portalprojectile"], portalprojectile:new(sourcex, sourcey, x, y, color, true, {objects["player"][plnumber].portal, i, cox, coy, side, tendency, x, y}, mirror, mirrored))
	if not mirrored and portalknockback then
		local xadd = math.sin(objects["player"][plnumber].pointingangle)*30
		local yadd = math.cos(objects["player"][plnumber].pointingangle)*30
		objects["player"][plnumber].speedx = objects["player"][plnumber].speedx + xadd
		objects["player"][plnumber].speedy = objects["player"][plnumber].speedy + yadd
		objects["player"][plnumber].falling = true
		objects["player"][plnumber].animationstate = "falling"
		objects["player"][plnumber]:setquad()
	end
end

function modifyportalwalls()
	--Create and remove new stuff
	for a, b in pairs(portals) do
		for i = 1, 2 do
			if b["x" .. i] then
				if b["facing" .. i] == "up" then
					objects["portalwall"][a .. "-" .. i .. "-1"] = portalwall:new(b["x" .. i]-1, b["y" .. i]-1, 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-2"] = portalwall:new(b["x" .. i]-1, b["y" .. i], 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-3"] = portalwall:new(b["x" .. i], b["y" .. i], 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-4"] = portalwall:new(b["x" .. i]+1, b["y" .. i]-1, 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-5"] = portalwall:new(b["x" .. i]-1, b["y" .. i]-1, 0, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-6"] = portalwall:new(b["x" .. i]+1, b["y" .. i]-1, 0, 0, true)
					
					modifyportaltiles(b["x" .. i], b["y" .. i], 1, 0, portals[a], i, "remove")
				elseif b["facing" .. i] == "down" then
					objects["portalwall"][a .. "-" .. i .. "-1"] = portalwall:new(b["x" .. i]-2, b["y" .. i]-1, 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-2"] = portalwall:new(b["x" .. i]-1, b["y" .. i]-1, 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-3"] = portalwall:new(b["x" .. i]-2, b["y" .. i]-1, 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-4"] = portalwall:new(b["x" .. i], b["y" .. i]-1, 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-5"] = portalwall:new(b["x" .. i]-2, b["y" .. i], 0, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-6"] = portalwall:new(b["x" .. i], b["y" .. i], 0, 0, true)
					
					modifyportaltiles(b["x" .. i], b["y" .. i], -1, 0, portals[a], i, "remove")
				elseif b["facing" .. i] == "left" then
					objects["portalwall"][a .. "-" .. i .. "-1"] = portalwall:new(b["x" .. i], b["y" .. i]-2, 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-2"] = portalwall:new(b["x" .. i], b["y" .. i]-1, 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-3"] = portalwall:new(b["x" .. i]-1, b["y" .. i]-2, 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-4"] = portalwall:new(b["x" .. i]-1, b["y" .. i], 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-5"] = portalwall:new(b["x" .. i]-1, b["y" .. i], 0, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-6"] = portalwall:new(b["x" .. i]-1, b["y" .. i]-2, 0, 0, true)
					
					modifyportaltiles(b["x" .. i], b["y" .. i], 0, -1, portals[a], i, "remove")
				elseif b["facing" .. i] == "right" then
					objects["portalwall"][a .. "-" .. i .. "-1"] = portalwall:new(b["x" .. i]-1, b["y" .. i]-1, 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-2"] = portalwall:new(b["x" .. i]-1, b["y" .. i], 0, 1, true)
					objects["portalwall"][a .. "-" .. i .. "-3"] = portalwall:new(b["x" .. i]-1, b["y" .. i]-1, 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-4"] = portalwall:new(b["x" .. i]-1, b["y" .. i]+1, 1, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-5"] = portalwall:new(b["x" .. i], b["y" .. i]-1, 0, 0, true)
					objects["portalwall"][a .. "-" .. i .. "-6"] = portalwall:new(b["x" .. i], b["y" .. i]+1, 0, 0, true)
					
					modifyportaltiles(b["x" .. i], b["y" .. i], 0, 1, portals[a], i, "remove")
				end
			end
		end
	end
	
	--remove conflicting portalwalls (only exist when both portals exists!)
	for a, b in pairs(portals) do
		for j = 1, 2 do
			local otherj = 1
			if j == 1 then
				otherj = 2
			end
			for c, d in pairs(portals) do
				for i = 1, 2 do
					local otheri = 1
					if i == 1 then
						otheri = 2
					end
					--B.J PORTAL WILL REMOVE WALLS OF D.OTHERJ, SO B.OTHERJ MUST EXIST
					
					if b["x" .. j] and b["x" .. otherj] and d["x" .. i] then
						local conside, conx, cony = b["facing" .. j], b["x" .. j], b["y" .. j]
						
						for k = 1, 4 do
							local w = objects["portalwall"][c .. "-" .. i .. "-" .. k]
							if w then
								if conside == "right" then
									if w.x == conx and w.y == cony-1 and w.height == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx and w.y == cony and w.height == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx-1 and w.y == cony and w.width == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
								elseif conside == "left" then
									if w.x == conx-1 and w.y == cony-2 and w.height == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx-1 and w.y == cony-1 and w.height == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx-1 and w.y == cony-1 and w.width == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
								elseif conside == "up" then
									if w.x == conx-1 and w.y == cony-1 and w.width == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx and w.y == cony-1 and w.width == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx and w.y == cony-1 and w.height == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
								else
									if w.x == conx-2 and w.y == cony and w.width == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx-1 and w.y == cony and w.width == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
									if w.x == conx-1 and w.y == cony-1 and w.height == 1 then
										objects["portalwall"][c .. "-" .. i .. "-" .. k] = nil
									end
								end
							end
						end
					end
				end
			end
		end
	end
end

function modifyportaltiles(x, y, xplus, yplus, portal, i, mode)
	if not x or not y then
		return
	end
	if i == 1 then
		if portal.facing2 ~= false then
			if mode == "add" then
				objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
				objects["tile"][x+xplus .. "-" .. y+yplus] = tile:new(x-1+xplus, y-1+yplus)
			else
				objects["tile"][x .. "-" .. y] = nil
				objects["tile"][x+xplus .. "-" .. y+yplus] = nil
			end
		end
	else
		if portal.facing1 ~= false then
			if mode == "add" then
				objects["tile"][x .. "-" .. y] = tile:new(x-1, y-1)
				objects["tile"][x+xplus .. "-" .. y+yplus] = tile:new(x-1+xplus, y-1+yplus)
			else
				objects["tile"][x .. "-" .. y] = nil
				objects["tile"][x+xplus .. "-" .. y+yplus] = nil
			end
		end
	end
end

function getportalposition(i, x, y, side, tendency) --returns the "optimal" position according to the parsed arguments (or false if no possible position was found)
	local xplus, yplus = 0, 0
	if side == "up" then
		yplus = -1
	elseif side == "right" then
		xplus = 1
	elseif side == "down" then
		yplus = 1
	elseif side == "left" then
		xplus = -1
	end
	
	if side == "up" or side == "down" then
		if tendency == -1 then
			if getTile(x-1, y, true, true, side) == true and getTile(x, y, true, true, side) == true and getTile(x-1, y+yplus, nil, false, side, true) == false and getTile(x, y+yplus, nil, false, side, true) == false then
				if side == "up" then
					return x-1, y
				else
					return x, y
				end
			elseif getTile(x, y, true, true, side) == true and getTile(x+1, y, true, true, side) == true and getTile(x, y+yplus, nil, false, side, true) == false and getTile(x+1, y+yplus, nil, false, side, true) == false then
				if side == "up" then
					return x, y
				else
					return x+1, y
				end
			end
		else
			if getTile(x, y, true, true, side) == true and getTile(x+1, y, true, true, side) == true and getTile(x, y+yplus, nil, false, side, true) == false and getTile(x+1, y+yplus, nil, false, side, true) == false then
				if side == "up" then
					return x, y
				else
					return x+1, y
				end
			elseif getTile(x-1, y, true, true, side) == true and getTile(x, y, true, true, side) == true and getTile(x-1, y+yplus, nil, false, side, true) == false and getTile(x, y+yplus, nil, false, side, true) == false then
				if side == "up" then
					return x-1, y
				else
					return x, y
				end
			end
		end
	else
		if tendency == -1 then
			if getTile(x, y-1, true, true, side) == true and getTile(x, y, true, true, side) == true and getTile(x+xplus, y-1, nil, false, side, true) == false and getTile(x+xplus, y, nil, false, side, true) == false then
				if side == "right" then
					return x, y-1
				else
					return x, y
				end
			elseif getTile(x, y, true, true, side) == true and getTile(x, y+1, true, true, side) == true and getTile(x+xplus, y, nil, false, side, true) == false and getTile(x+xplus, y+1, nil, false, side, true) == false then
				if side == "right" then
					return x, y
				else
					return x, y+1
				end
			end
		else
			if getTile(x, y, true, true, side) == true and getTile(x, y+1, true, true, side) == true and getTile(x+xplus, y, nil, false, side, true) == false and getTile(x+xplus, y+1, nil, false, side, true) == false then
				if side == "right" then
					return x, y
				else
					return x, y+1
				end
			elseif getTile(x, y-1, true, true, side) == true and getTile(x, y, true, true, side) == true and getTile(x+xplus, y-1, nil, false, side, true) == false and getTile(x+xplus, y, nil, false, side, true) == false then
				if side == "right" then
					return x, y-1
				else
					return x, y
				end
			end
		end
	end
	
	return false
end

function getTile(x, y, portalable, portalcheck, facing, ignoregrates, dir) --returns masktable value of block (As well as the ID itself as second return parameter) also includes a portalcheck and returns false if a portal is on that spot.
	if portalcheck then
		for i, v in pairs(portals) do
			--Get the extra block of each portal
			local portal1xplus, portal1yplus, portal2xplus, portal2yplus = 0, 0, 0, 0
			if v.facing1 == "up" then
				portal1xplus = 1
			elseif v.facing1 == "right" then
				portal1yplus = 1
			elseif v.facing1 == "down" then
				portal1xplus = -1
			elseif v.facing1 == "left" then
				portal1yplus = -1
			end
			
			if v.facing2 == "up" then
				portal2xplus = 1
			elseif v.facing2 == "right" then
				portal2yplus = 1
			elseif v.facing2 == "down" then
				portal2xplus = -1
			elseif v.facing2 == "left" then
				portal2yplus = -1
			end
			
			if v.x1 ~= false then
				if (x == v.x1 or x == v.x1+portal1xplus) and (y == v.y1 or y == v.y1+portal1yplus) and (facing == nil or v.facing1 == facing) then
					return false
				end
			end
		
			if v.x2 ~= false then
				if (x == v.x2 or x == v.x2+portal2xplus) and (y == v.y2 or y == v.y2+portal2yplus) and (facing == nil or v.facing2 == facing) then
					return false
				end
			end
		end
	end
	
	--check for tubes
	for i, v in pairs(objects["geldispenser"]) do
		if (x == v.cox or x == v.cox+1) and (y == v.coy or y == v.coy+1) then
			if portalcheck then
				return false
			else
				return true
			end
		end
	end
	
	for i, v in pairs(objects["cubedispenser"]) do
		if (x == v.cox or x == v.cox+1) and (y == v.coy or y == v.coy+1) then
			if portalcheck then
				return false
			else
				return true
			end
		end
	end
	
	--bonusstage thing for keeping it from fucking up by allowing portals to be shot next to the vine in 4-2_2 for example
	if bonusstage then
		if y == mapheight and (x == 4 or x == 6) then
			if portalcheck then
				return false
			else
				return true
			end
		end
	end
	
	if x <= 0 or y <= 0 or y >= mapheight+1 or x > mapwidth then
		return false, 1
	end
	
	if tilequads[map[x][y][1]]:getproperty("invisible", x, y) then
		return false
	end
	
	if portalcheck then
		local side
		if facing == "up" then
			side = "top"
		elseif facing == "right" then
			side = "right"
		elseif facing == "down" then
			side = "bottom"
		elseif facing == "left" then
			side = "left"
		end
		local conditions = {
			not_mirror = not tilequads[map[x][y][1]]:getproperty("mirror", x, y),
			collision = tilequads[map[x][y][1]]:getproperty("collision", x, y),
			portalable = tilequads[map[x][y][1]]:getproperty("portalable", x, y),
			not_grate = not tilequads[map[x][y][1]]:getproperty("grate", x, y), --not a fan of grates either
		}
		-- this is used for named condition checks so there's no ambiguity
		if map[x][y]["gels"] and map[x][y]["gels"][side] then
			local gelstat = map[x][y]["gels"][side]
			if enum_gels[gelstat] == "black" then
				conditions["portalable"] = false
			end
			if not conditions["not_mirror"] and table.contains(gelsthattarnishmirrors, enum_gels[gelstat]) then
				conditions["portalable"] = false
			end
			if not conditions["portalable"] and enum_gels[gelstat] == "white" then
				conditions["portalable"] = true
				conditions["not_mirror"] = true
			end
		end
		
		
		--To stop people from portalling under the vine, which caused problems, but was fixed elsewhere (and betterer)
		--[[for i, v in pairs(objects["vine"]) do
			if x == v.cox and y == v.coy and side == "top" then
				return false, 1
			end
		end--]]
		
		if map[x][y]["portaloverride"][side] then
			return true, map[x][y][1]
		end
		
		-- if anything in the conditions table is false, then it's a no-go and we give a false
		return (not table.contains(conditions, false)) or conditions["not_mirror"], map[x][y][1]
	else
		if ignoregrates then
			return tilequads[map[x][y][1]]:getproperty("collision", x, y) and tilequads[map[x][y][1]]:getproperty("grate", x, y) == false, map[x][y][1]
		else
			return tilequads[map[x][y][1]]:getproperty("collision", x, y), map[x][y][1]
		end
	end
end

function getPortal(x, y, dir) --returns the block where you'd come out when you'd go in the argument's block
	for i, v in pairs(portals) do
		if v.x1 ~= false and v.x2 ~= false then
			--Get the extra block of each portal
			local portal1xplus, portal1yplus, portal2xplus, portal2yplus = 0, 0, 0, 0
			if v.facing1 == "up" then
				portal1xplus = 1
			elseif v.facing1 == "right" then
				portal1yplus = 1
			elseif v.facing1 == "down" then
				portal1xplus = -1
			elseif v.facing1 == "left" then
				portal1yplus = -1
			end
			
			if v.facing2 == "up" then
				portal2xplus = 1
			elseif v.facing2 == "right" then
				portal2yplus = 1
			elseif v.facing2 == "down" then
				portal2xplus = -1
			elseif v.facing2 == "left" then
				portal2yplus = -1
			end
			
			if v.x1 ~= false and (not dir or v.facing1 == dir) then
				if (x == v.x1 or x == v.x1+portal1xplus) and (y == v.y1 or y == v.y1+portal1yplus) and (facing == nil or v.facing1 == facing) then
					if v.facing1 ~= v.facing2 then
						local xplus, yplus = 0, 0
						if v.facing1 == "left" or v.facing1 == "right" then
							if y == v.y1 then
								if v.facing2 == "left" or v.facing2 == "right" then
									yplus = portal2yplus
								else
									xplus = portal2xplus
								end
							end
							
							return v.x2+xplus, v.y2+yplus, v.facing2, v.facing1, v.x2, v.y2, v.x1, v.y1
						else
							if x == v.x1 then
								if v.facing2 == "left" or v.facing2 == "right" then
									yplus = portal2yplus
								else
									xplus = portal2xplus
								end
							end
							
							return v.x2+xplus, v.y2+yplus, v.facing2, v.facing1, v.x2, v.y2, v.x1, v.y1
						end	
					else
						return v.x2+(x-v.x1), v.y2+(y-v.y1), v.facing2, v.facing1, v.x2, v.y2, v.x1, v.y1
					end
				end
			end
		
			if v.x2 ~= false and (not dir or v.facing2 == dir) then
				if (x == v.x2 or x == v.x2+portal2xplus) and (y == v.y2 or y == v.y2+portal2yplus) and (facing == nil or v.facing2 == facing) then
					if v.facing1 ~= v.facing2 then
						local xplus, yplus = 0, 0
						if v.facing2 == "left" or v.facing2 == "right" then
							if y == v.y2 then
								if v.facing1 == "left" or v.facing1 == "right" then
									yplus = portal1yplus
								else
									xplus = portal1xplus
								end
							end
							
							return v.x1+xplus, v.y1+yplus, v.facing1, v.facing2, v.x1, v.y1, v.x2, v.y2
						else
							if x == v.x2 then
								if v.facing1 == "left" or v.facing1 == "right" then
									yplus = portal1yplus
								else
									xplus = portal1xplus
								end
							end
							
							return v.x1+xplus, v.y1+yplus, v.facing1, v.facing2, v.x1, v.y1, v.x2, v.y2
						end	
					else
						return v.x1+(x-v.x2), v.y1+(y-v.y2), v.facing1, v.facing2, v.x1, v.y1, v.x2, v.y2
					end
				end
			end
		end
	end
	
	return false
end

function insideportal(x, y, width, height) --returns whether an object is in, and which, portal.
	if width == nil then
		width = 12/16
	end
	if height == nil then
		height = 12/16
	end
	for i, v in pairs(portals) do
		if v.x1 ~= false and v.x2 ~= false then
			for j = 1, 2 do				
				local portalx, portaly, portalfacing
				if j == 1 then
					portalx = v.x1
					portaly = v.y1
					portalfacing = v.facing1
				else
					portalx = v.x2
					portaly = v.y2
					portalfacing = v.facing2
				end
				
				if portalfacing == "up" then
					xplus = 1
				elseif portalfacing == "down" then
					xplus = -1
				elseif portalfacing == "left" then
					yplus = -1
				end
				
				if portalfacing == "right" then
					if (math.floor(y) == portaly or math.floor(y) == portaly-1) and inrange(x, portalx-width, portalx, false) then
						return portals[i], j
					end
				elseif portalfacing == "left" then
					if (math.floor(y) == portaly-1 or math.floor(y) == portaly-2) and inrange(x, portalx-1-width, portalx-1, false) then
						return portals[i], j
					end
				elseif portalfacing == "up" then
					if inrange(y, portaly-height-1, portaly-1, false) and inrange(x, portalx-1.5-.2, portalx+.5+.2, true) then
						return portals[i], j
					end	
				elseif portalfacing == "down" then
					if inrange(y, portaly-height, portaly, false) and inrange(x, portalx-2, portalx-.5, true) then
						return portals[i], j
					end	
				end
				
				--widen rect by 3 pixels?
				
			end
		end
	end
	
	return false
end

function moveoutportal() --pushes objects out of the portal i in.
	for i, v in pairs(objects) do
		if i ~= "tile" and i ~= "portalwall" then
			for j, w in pairs(v) do
				if w.active and w.moves then
					local p1, p2 = insideportal(w.x, w.y, w.width, w.height)
					
					if p1 ~= false then
						local portalfacing, portalx, portaly
						if p2 == 1 then
							portalfacing = p1.facing1
							portalx = p1.x1
							portaly = p1.y1
						else
							portalfacing = p1.facing2
							portalx = p1.x2
							portaly = p1.y2
						end
						
						if portalfacing == "right" then
							w.x = portalx
						elseif portalfacing == "left" then
							w.x = portalx - 1 - w.width
						elseif portalfacing == "up" then
							w.y = portaly - 1 - w.height
						elseif portalfacing == "down" then
							w.y = portaly
						end
					end
				end
			end
		end
	end
end

function nextlevel()
	if not levelfinished then
		return
	end
	
	if testlevel then
		editormode = true
		testlevel = false
		currentmap = marioworld .. "-" .. mariolevel .. (mariosublevel > 0 and ("_" .. mariosubevel) or "") --@WARNING: This will eventually not work.
		loadlevel(marioworld .. "-" .. mariolevel .. (mariosublevel > 0 and ("_" .. mariosubevel) or ""))
		startlevel()
		return
	end
	
	love.audio.stop()
	
	mariolevel = mariolevel + 1
	if mariolevel > 4 then
		mariolevel = 1
		marioworld = marioworld + 1
	end
	levelscreen_load("next")
end

function seek_level(from_warp_id, dest_map, dest_id, exit_dir, is_sublevel)
	--[[warpfrommap = currentmap
	warpfromid = from_warp_id
	currentmap = dest_map
	warpdestid = dest_id
	warpdestdir = exit_dir
	warpissublevel = is_sublevel]]
	
	--[[@TODO: 
		exit_dir actually does nothing because we're meant to use the exit_dir of
		the pipe whose id we are seeking
	]]
	
	warpdestid = dest_id
	
	if is_sublevel then --sublevel
		print("seeked to a sublevel", dest_map)
		levelscreen_load("sublevel", dest_map)
	else --warpzone
		warpzone(self.animationmisc2, self.animationmisc3)
	end
end

function warpzone(w, l)	
	love.audio.stop()
	mariolevel = l
	marioworld = w
	currentmap = w.."-"..l --@WARNING: This will eventually not work.
	mariosublevel = 0
	prevsublevel = false
	
	-- minus 1 world glitch just because I can.
	if not displaywarpzonetext and w == 4 and l == 1 and mappack == "smb" then
		marioworld = "M"
	end
	
	levelscreen_load("next")
end

function getMouseTile(x, y)
	local xout = math.floor((x+xscroll*16*scale)/(16*scale))+1
	local yout = math.floor((y+yscroll*16*scale-yoffset*scale)/(16*scale))+1
	return xout, yout
end

function savemap2(filename)
	local tmap = {
		version = 1,
		tilewidth = 16,
		tileheight = 16,
		
		width = mapwidth,
		height = mapheight,
		
		orientation = "orthogonal",
		renderorder = "right-down",
		
		properties = {},
		
		tilesets = { -- this is for tile images and properties
			{
				firstgid = 1,
				image = "../../graphics/DEFAULT/smbtiles.png",
				imageheight = 119,
				imagewidth = 374,
				margin = 0,
				name = "smbtiles",
				properties = {},
				spacing = 1,
				tileheight = 16,
				tilewidth = 16,
				tileproperties = {
					-- all this junk
					[1] = {
						solid = false,
					}
				}
			},
		},
		
		layers = {
			[1] = {
				type = "tilelayer",
				name = "tiles",
				-- we don't handle offset for x/y yet because
				-- I can't think of a way to make it make sense to the old engine
				x = 0,
				y = 0,
				width = mapwidth,
				height = mapheight,
				visible = true,
				opacity = 1,
				properties = {},
				
				data = {}, --a single dimensional array of indexes that refer to tileset ids
			},
			[2] = {
				type = "tilelayer",
				name = "coins",
				x = 0,
				y = 0,
				width = mapwidth,
				height = mapheight,
				visible = true,
				opacity = 1,
				properties = {},
				
				data = {},
			},
			[3] = {
				type = "objectgroup",
				name = "entities",
				visible = true,
				opacity = 1,
				properties = {},
				objects = {},
			},
			[4] = {
				type = "objectgroup",
				name = "enemies",
				visible = true,
				opacity = 1,
				properties = {},
				objects = {},
			},
		},
	}
	--JSON:encode_pretty(lua_table_or_value)
	
	-- instead of doing RLE on the blocks, have a pass to optimize large chunks of blocks into single objects
	
	for y = 0, mapheight-1 do
		for x = 0, mapwidth-1 do
			local dex = y*mapwidth+x+1 --plus one because the 0 index is true twice and would be invalid
			--print("NEWDEX: ", dex, x, y)
			local tile = map[x+1][y+1]
			
			-- tile ID
			tmap.layers[1].data[dex] = tile[1]
			
			-- is there a coin here
			if coinmap[x+1][y+1] then
				tmap.layers[2].data[dex] = 1
			else
				tmap.layers[2].data[dex] = 0
			end
			
			-- entities
			local target_layer
			if tile[2] then
				-- this will also handle gels, since gels are technically entities
				-- portaloverride will not get handled, though
				if type(tile[2]) == "number" then --entity
					target_layer = tmap.layers[3].objects
				elseif type(tile[2]) == "string" then --enemy
					target_layer = tmap.layers[4].objects
				else
					print("WARNING: tile property#2 wasn't a number or string at "..tostring(x+1)..","..tostring(y+1))
				end
				
				local nent = {
					name = "", --we don't have a way to determine globally unique names
					shape = "rectangle",
					
					type = tile[2], --supposed to be a string, but we can't reverse entity names yet
					x = x*tmap.tilewidth,
					y = y*tmap.tileheight,
					-- since we can't manage object size yet, we'll stub these
					width = tmap.tilewidth,
					height = tmap.tileheight,
					
					rotation = 0,
					visible = true,
					properties = {}
				}
				
				local i = 3
				while i <= #tile do
					if tile[i] == "link" then
						-- i+1 = link name; +2, +3 = link coords
						-- serialized because alternate data types aren't processed by tiled
						nent.properties["link_"..tostring(tile[i+1])] = tostring(tile[i+2])..","..tostring(tile[i+3])
						i = i + 4
					else
						nent.properties["r_"..tostring(i)] = tostring(tile[i])
						i = i + 1
					end
				end
				
				table.insert(target_layer, nent)
			end
			
			
			--[[@NOTE:
				because not being able to manipulate the index complicates things,
				we do a second loop for named values and just take their word for things
				
				if we wanted to fix this, we'd assign i+4 and lt compare 
				while assigning/grabbing everything the first time and skipping everything else
				
				but since we don't have a layer specifically for dicking with gel types,
				none of this note even matters
			]]
		end
	end
	
	--print("FULL CABOOSE: ", #tmap.layers[1].data, 3360)
	
	--options
	tmap.properties.backgroundcolor = background --r, g, b
	tmap.properties.spriteset = spriteset
	tmap.properties.music = musicname --conditional
	tmap.properties.intermission = intermission --conditional, bool
	tmap.properties.bonusstage = bonusstage --conditional, bool
	tmap.properties.haswarpzone = haswarpzone --conditional, bool
	tmap.properties.underwater = underwater --conditional, bool
	tmap.properties.custombackground = custombackground --conditional, true or string
	tmap.properties.customforeground = customforeground --conditional, true or string
	tmap.properties.timelimit = mariotimelimit
	tmap.properties.scrollfactor = scrollfactor
	tmap.properties.fscrollfactor = fscrollfactor
	
	if not portalsavailable[1] or not portalsavailable[2] then
		local ptype = "none"
		if portalsavailable[1] then
			ptype = "blue"
		elseif portalsavailable[2] then
			ptype = "orange"
		end
		
		tmap.properties.portalgun = ptype --if missing, assume both
	end
	
	tmap.properties.levelscreenback = levelscreenbackname --conditional, string
	
	love.filesystem.createDirectory( "mappacks" )
	love.filesystem.createDirectory( "mappacks/" .. mappack )
	
	jsonencoded = JSON:encode_pretty(tmap)
	
	love.filesystem.write("mappacks/" .. mappack .. "/" .. filename .. ".json", jsonencoded)
	
	--preview
	
	previewimg = renderpreview()
	previewimg:encode("mappacks/" .. mappack .. "/" .. filename .. ".png")
	
	print("Map saved as " .. "mappacks/" .. filename .. ".json")
	notice.new("Map saved!", notice.white, 2)
end

function savemap(filename)
	local s = ""
	
	--mapheight
	local s = s .. mapheight .. CATEGORYDELIMITER
	
	local mul = 1
	local prev = nil
	
	for y = 1, mapheight do
		for x = 1, mapwidth do
			local current = map[x][y][1] .. (coinmap[x][y] and "c" or "")
			
			--check if previous is the same
			if #map[x][y] == 1 then
				if prev == current and (y ~= mapheight or x ~= mapwidth) then
					mul = mul + 1
				elseif prev == current and y == mapheight and x == mapwidth then
					mul = mul + 1
					s = s .. prev .. MULTIPLYDELIMITER .. mul
				else
					if prev then
						if mul > 1 then
							s = s .. prev .. MULTIPLYDELIMITER .. mul
						else
							s = s .. prev
						end
						
						if y ~= mapheight or x ~= mapwidth then
							s = s .. BLOCKDELIMITER
						end
					end
					prev = current
					mul = 1
					if y == mapheight and x == mapwidth then
						if prev then
							s = s .. BLOCKDELIMITER
						end
						s = s .. prev
					end
				end
			else
				if prev then
					if mul > 1 then
						s = s .. prev .. MULTIPLYDELIMITER .. mul
					else
						s = s .. prev
					end
					
					s = s .. BLOCKDELIMITER
				end
				prev = nil
				mul = 1
				
				for i = 1, #map[x][y] do
					if tonumber(map[x][y][i]) and tonumber(map[x][y][i]) < 0 then
						s = s .. "m" .. math.abs(tostring(map[x][y][i]))
					else
						s = s .. tostring(map[x][y][i])
					end
					
					if i == 1 and coinmap[x][y] then
						s = s .. "c"
					end
					
					if i ~= #map[x][y] then
						s = s .. LAYERDELIMITER
					end
				end
				
				if y ~= mapheight or x ~= mapwidth then
					s = s .. BLOCKDELIMITER
				end
			end
		end
	end
	
	--options
	s = s .. CATEGORYDELIMITER .. "backgroundr" .. EQUALSIGN ..  background[1]
	s = s .. CATEGORYDELIMITER .. "backgroundg" .. EQUALSIGN ..  background[2]
	s = s .. CATEGORYDELIMITER .. "backgroundb" .. EQUALSIGN ..  background[3]
	s = s .. CATEGORYDELIMITER .. "spriteset" .. EQUALSIGN ..  spriteset
	if musicname then
		s = s .. CATEGORYDELIMITER .. "music" .. EQUALSIGN ..  musicname
	end
	if intermission then
		s = s .. CATEGORYDELIMITER .. "intermission"
	end
	if bonusstage then
		s = s .. CATEGORYDELIMITER .. "bonusstage"
	end
	if haswarpzone then
		s = s .. CATEGORYDELIMITER .. "haswarpzone"
	end
	if underwater then
		s = s .. CATEGORYDELIMITER .. "underwater"
	end
	if custombackground then
		if custombackground == true then
			s = s .. CATEGORYDELIMITER .. "custombackground"
		else
			s = s .. CATEGORYDELIMITER .. "custombackground" .. EQUALSIGN ..  custombackground
		end
	end
	if customforeground then
		if customforeground == true then
			s = s .. CATEGORYDELIMITER .. "customforeground"
		else
			s = s .. CATEGORYDELIMITER .. "customforeground" .. EQUALSIGN ..  customforeground
		end
	end
	s = s .. CATEGORYDELIMITER .. "timelimit" .. EQUALSIGN ..  mariotimelimit
	s = s .. CATEGORYDELIMITER .. "scrollfactor" .. EQUALSIGN ..  scrollfactor
	s = s .. CATEGORYDELIMITER .. "fscrollfactor" .. EQUALSIGN ..  fscrollfactor
	if not portalsavailable[1] or not portalsavailable[2] then
		local ptype = "none"
		if portalsavailable[1] then
			ptype = "blue"
		elseif portalsavailable[2] then
			ptype = "orange"
		end
		
		s = s .. CATEGORYDELIMITER .. "portalgun" .. EQUALSIGN ..  ptype
	end
	
	if levelscreenbackname then
		s = s .. CATEGORYDELIMITER .. "levelscreenback" .. EQUALSIGN ..  levelscreenbackname
	end
	
	--tileset
	
	love.filesystem.createDirectory( "mappacks" )
	love.filesystem.createDirectory( "mappacks/" .. mappack )
	
	love.filesystem.write("mappacks/" .. mappack .. "/" .. filename .. ".txt", s)
	
	--preview
	
	previewimg = renderpreview()
	previewimg:encode("mappacks/" .. mappack .. "/" .. filename .. ".png")
	
	print("Map saved as " .. "mappacks/" .. filename .. ".txt")
	notice.new("Map saved!", notice.white, 2)
end

function renderpreview()
	local out = love.image.newImageData(mapwidth, height+1)
	
	--find startpoint
	local startx, starty = 3, 13
	
	for x = 1, mapwidth do
		for y = 1, mapheight do
			if map[x][y][2] and entitylist[map[x][y][2]] and entitylist[map[x][y][2]].t == "spawn" then
				startx, starty = x, y
				break
			end
		end
	end
	
	yadd = math.max(0, math.min(mapheight-height-1, starty-math.floor(height/2)))
	
	for x = 1, mapwidth do --blocks
		for y = 1, 15 do
			local id = map[x][y+yadd][1]
			if id ~= nil and id ~= 0 and rgblist[id] and tilequads[id]:getproperty("invisible", x, y+yadd) == false then
				out:setPixel(x-1, y-1, unpack(rgblist[id]))
			else
				out:setPixel(x-1, y-1, unpack(background))
			end
		end
	end
	
	return out
end

function savelevel()
	if mariosublevel == 0 then
		savemap(currentmap)
	else
		savemap(currentmap)
	end
end

function traceline(sourcex, sourcey, radians, reportal)
	local currentblock = {}
	local x, y = sourcex, sourcey
	currentblock[1] = math.floor(x)
	currentblock[2] = math.floor(y+1)
		
	local emancecollide = false
	for i, v in pairs(objects["emancipationgrill"]) do
		if v:getTileInvolved(currentblock[1]+1, currentblock[2]) then
			emancecollide = true
		end
	end
	
	local doorcollide = false
	for i, v in pairs(objects["door"]) do
		if v.dir == "hor" then
			if v.open == false and (v.cox == currentblock[1] or v.cox == currentblock[1]+1) and v.coy == currentblock[2] then
				doorcollide = true
			end
		else
			if v.open == false and v.cox == currentblock[1]+1 and (v.coy == currentblock[2] or v.coy == currentblock[2]+1) then
				doorcollide = true
			end
		end
	end
	
	if emancecollide or doorcollide then
		return false, false, false, false, x, y
	end
	
	local side
	local lastaxe = objects["axe"][#objects["axe"]]
	while currentblock[1]+1 > 0 and
	currentblock[1]+1 <= mapwidth and
	-- we'll just get rid of this and see what happens
	(flagx == false or currentblock[1]+1 <= flagx or radians > 0) and
	(not lastaxe or currentblock[1]+1 <= lastaxe.cox) and 
	(currentblock[2] > 0 or currentblock[2] >= math.floor(sourcey+0.5)) and 
	currentblock[2] < mapheight+1 do --while in map range
		local oldy = y
		local oldx = x
		
		--calculate X and Y diff..
		local ydiff, xdiff
		local side1, side2
		
		if inrange(radians, -math.pi/2, math.pi/2, true) then --up
			ydiff = (y-(currentblock[2]-1)) / math.cos(radians)
			y = currentblock[2]-1
			side1 = "down"
		else
			ydiff = (y-(currentblock[2])) / math.cos(radians)
			y = currentblock[2]
			side1 = "up"
		end
		
		if inrange(radians, 0, math.pi, true) then --left
			xdiff = (x-(currentblock[1])) / math.sin(radians)
			x = currentblock[1]
			side2 = "right"
		else
			xdiff = (x-(currentblock[1]+1)) / math.sin(radians)
			x = currentblock[1]+1
			side2 = "left"
		end
		
		--smaller diff wins
		
		if xdiff < ydiff then
			y = oldy - math.cos(radians)*xdiff
			side = side2
		else
			x = oldx - math.sin(radians)*ydiff
			side = side1
		end
		
		if side == "down" then
			currentblock[2] = currentblock[2]-1
		elseif side == "up" then
			currentblock[2] = currentblock[2]+1
		elseif side == "left" then
			currentblock[1] = currentblock[1]+1
		elseif side == "right" then
			currentblock[1] = currentblock[1]-1
		end
		
		local collide, tileno = getTile(currentblock[1]+1, currentblock[2])
		local emancecollide = false
		for i, v in pairs(objects["emancipationgrill"]) do
			if v:getTileInvolved(currentblock[1]+1, currentblock[2]) then
				emancecollide = true
			end
		end
		
		local doorcollide = false
		for i, v in pairs(objects["door"]) do
			if v.dir == "hor" then
				if v.open == false and (v.cox == currentblock[1] or v.cox == currentblock[1]+1) and v.coy == currentblock[2] then
					doorcollide = true
				end
			else
				if v.open == false and v.cox == currentblock[1]+1 and (v.coy == currentblock[2] or v.coy == currentblock[2]+1) then
					doorcollide = true
				end
			end
		end
		
		-- < 0 rechts
		
		--Check for ceilblocker
		if y < 0 then
			if entitylist[map[currentblock[1]][1][2]] and entitylist[map[currentblock[1]][1][2]].t == "ceilblocker" then
				return false, false, false, false, x, y
			end
		end
		
		if collide == true and tilequads[map[currentblock[1]+1][currentblock[2]][1]]:getproperty("grate", currentblock[1]+1, currentblock[2]) == false then
			break
		elseif emancecollide or doorcollide then
			return false, false, false, false, x, y
		elseif (radians <= 0 and x > xscroll + width) or (radians >= 0 and x < xscroll) then
			return false, false, false, false, x, y
		end
	end
	
	if currentblock[1]+1 > 0 and currentblock[1]+1 <= mapwidth and (currentblock[2] > 0 or currentblock[2] >= math.floor(sourcey+0.5))  and currentblock[2] < mapheight+1 and currentblock[1] ~= nil then
		local tendency
	
		--get tendency
		if side == "down" or side == "up" then
			if math.mod(x, 1) > 0.5 then
				tendency = 1
			else
				tendency = -1
			end
		elseif side == "left" or side == "right" then
			if math.mod(y, 1) > 0.5 then
				tendency = 1
			else
				tendency = -1
			end
		end
		
		return currentblock[1]+1, currentblock[2], side, tendency, x, y
	else
		return false, false, false, false, x, y
	end
end

function spawnenemy(x, y)
	if not inmap(x, y) then
		return
	end
	
	--don't spawn when on a coinblock or breakable block
	if tilequads[map[x][y][1] ]:getproperty("breakable", x, y) or tilequads[map[x][y][1] ]:getproperty("coinblock", x, y) then
		table.insert(enemiesspawned, {x, y})
		return
	end

	for i = 1, #enemiesspawned do
		if x == enemiesspawned[i][1] and y == enemiesspawned[i][2] then
			return
		end
	end
	
	--spawnrestriction
	allowenemy = true
	for i = 1, #spawnrestrictions do
		if x > spawnrestrictions[i][1]-6 and x < spawnrestrictions[i][1]+6 and y > spawnrestrictions[i][2]-6 and y < spawnrestrictions[i][2]+6 then
			allowenemy = false
		end
	end
	
	local r = map[x][y]
	if #r > 1 then 
		local wasenemy = false
		if allowenemy and table.contains(enemies, r[2]) and not editormode then
			if not tilequads[map[x][y][1] ]:getproperty("breakable", x, y) and not tilequads[map[x][y][1] ]:getproperty("coinblock", x, y) then
				table.insert(objects["enemy"], enemy:new(x, y, r[2], r))
				wasenemy = true
			end
		elseif entitylist[r[2]] then
			local t = entitylist[r[2]].t
			if allowenemy and t == "cheepcheep" then
				if math.random(2) == 1 then
					table.insert(objects["enemy"], enemy:new(x, y, "cheepcheepwhite", r))
				else
					table.insert(objects["enemy"], enemy:new(x, y, "cheepcheepred", r))
				end
				wasenemy = true
				
			elseif t == "platformfall" then
				table.insert(objects["platform"], platform:new(x, y, {0, 0, r[3]}, "fall")) --Platform fall
				
			elseif t == "platformbonus" then
				table.insert(objects["platform"], platform:new(x, y, {0, 0, 3}, "justright"))
			end
		end
		
		table.insert(enemiesspawned, {x, y})
		
		if wasenemy then
			--spawn enemies in 5x1 line so they spawn as a unit and not alone.
			spawnenemy(x-2, y)
			spawnenemy(x-1, y)
			spawnenemy(x+1, y)
			spawnenemy(x+2, y)
		end
	end
end

function item(i, x, y, size)
	if i == "powerup" then
		if size == 1 then
			table.insert(itemanimations, itemanimation:new(x, y, "mushroom"))
		else
			table.insert(itemanimations, itemanimation:new(x, y, "flower"))
		end
	elseif i == "vine" then
		table.insert(objects["vine"], vine:new(x, y))
	elseif enemiesdata[i] then
		table.insert(itemanimations, itemanimation:new(x, y, i))
	end
end

function givelive(id, t)
	scrollingscore:new(t.x, t.y, givemestuff["lives"], "life")
	if mariolivecount ~= false then
		for i = 1, players do
			objects["player"][i].lives = objects["player"][i].lives + givemestuff["lives"]
		end
		givemestuff["lives"] = 0
		respawnplayers()
	end
	t.destroy = true
	t.active = false
	playsound("oneup", t.x, t.y)
end	

function givetime(id, t)
	scrollingtext:new(t.x, t.y, givemestuff["time"], "time")
	mariotime = mariotime+givemestuff["time"]
	givemestuff["time"] = 0
	playsound("addtime", t.x, t.y) --point entity
end	

function gotatrophy(id, t)
	playsound("trophy", t.x, t.y) --point entity
end

function addzeros(s, i)
	s=s or ""
	for j = string.len(s)+1, i do
		s = "0" .. s
	end
	return s
end

function properprint2(s, x, y)
	for i = 1, string.len(tostring(s)) do
		if fontquads[string.sub(s, i, i)] then
			love.graphics.draw(fontimage2, font2quads[string.sub(s, i, i)], x+((i-1)*4)*scale, y, 0, scale, scale)
		end
	end
end

function properprint3(s, x, y)
	for i = 1, string.len(tostring(s)) do
		if fontquads[string.sub(s, i, i)] then
			love.graphics.draw(fontimage3, font3quads[string.sub(s, i, i)], x+((i-1)*4)*scale, y, 0, scale, scale)
		end
	end
end

function playsound(sound, px, py, vx, vy)
	if not soundlist[sound] then
		return
	end
	px = px or 0
	py = py or 0
	vx = vx or 0
	vy = vy or 0

	if soundenabled then
		if delaylist[sound] then
			local currenttime = love.timer.getTime()
			if currenttime-soundlist[sound].lastplayed > delaylist[sound] then
				soundlist[sound].lastplayed = currenttime
			else
				return
			end
		end
		soundlist[sound].source:stop()
		--soundlist[sound].source:rewind()
		-- we don't need this because stop rewinds in every instance
		if px~=0 and py~=0 then
			soundlist[sound].source:setRelative(false)
			soundlist[sound].source:setPosition(px, py, 0)
		else
			soundlist[sound].source:setRelative(true)
			soundlist[sound].source:setPosition(0,0,0)
		end
		if vx~=0 and vy~=0 then
			soundlist[sound].source:setVelocity(vx, vy, 0)
		else
			soundlist[sound].source:setVelocity(0,0,0)
		end
		soundlist[sound].source:play()
	end
end

--[[function runkey(i)
	local s = controls[i]["run"]
	return checkkey(s)
end

function rightkey(i)
	local s
	if objects["player"][i].gravitydirection > math.pi/4*1 and objects["player"][i].gravitydirection <= math.pi/4*3 then
		s = controls[i]["right"]
	elseif objects["player"][i].gravitydirection > math.pi/4*3 and objects["player"][i].gravitydirection <= math.pi/4*5 then
		s = controls[i]["down"]
	elseif objects["player"][i].gravitydirection > math.pi/4*5 and objects["player"][i].gravitydirection <= math.pi/4*7 then
		s = controls[i]["left"]
	else
		s = controls[i]["up"]
	end
	return checkkey(s)
end

function leftkey(i)
	local s
	if objects["player"][i].gravitydirection > math.pi/4*1 and objects["player"][i].gravitydirection <= math.pi/4*3 then
		s = controls[i]["left"]
	elseif objects["player"][i].gravitydirection > math.pi/4*3 and objects["player"][i].gravitydirection <= math.pi/4*5 then
		s = controls[i]["up"]
	elseif objects["player"][i].gravitydirection > math.pi/4*5 and objects["player"][i].gravitydirection <= math.pi/4*7 then
		s = controls[i]["right"]
	else
		s = controls[i]["down"]
	end
	return checkkey(s)
end

function downkey(i)
	local s
	if objects["player"][i].gravitydirection > math.pi/4*1 and objects["player"][i].gravitydirection <= math.pi/4*3 then
		s = controls[i]["down"]
	elseif objects["player"][i].gravitydirection > math.pi/4*3 and objects["player"][i].gravitydirection <= math.pi/4*5 then
		s = controls[i]["left"]
	elseif objects["player"][i].gravitydirection > math.pi/4*5 and objects["player"][i].gravitydirection <= math.pi/4*7 then
		s = controls[i]["up"]
	else
		s = controls[i]["right"]
	end
	return checkkey(s)
end

function upkey(i)
	local s
	if objects["player"][i].gravitydirection > math.pi/4*1 and objects["player"][i].gravitydirection <= math.pi/4*3 then
		s = controls[i]["up"]
	elseif objects["player"][i].gravitydirection > math.pi/4*3 and objects["player"][i].gravitydirection <= math.pi/4*5 then
		s = controls[i]["right"]
	elseif objects["player"][i].gravitydirection > math.pi/4*5 and objects["player"][i].gravitydirection <= math.pi/4*7 then
		s = controls[i]["down"]
	else
		s = controls[i]["left"]
	end
	return checkkey(s)
end]]

function inrange(i, a, b, include)
	if a > b then
		b, a = a, b
	end
	
	if include then
		if i >= a and i <= b then
			return true
		else
			return false
		end
	else
		if i > a and i < b then
			return true
		else
			return false
		end
	end
end

function drawrectangle(x, y, width, height)
	love.graphics.rectangle("fill", x*scale, y*scale, width*scale, scale)
	love.graphics.rectangle("fill", x*scale, y*scale, scale, height*scale)
	love.graphics.rectangle("fill", x*scale, (y+height-1)*scale, width*scale, scale)
	love.graphics.rectangle("fill", (x+width-1)*scale, y*scale, scale, height*scale)
end

function inmap(x, y)
	if not x or not y then
		return false
	end
	if x >= 1 and x <= mapwidth and y >= 1 and y <= mapheight then
		return true
	else
		return false
	end
end

function playmusic()
	if not editormode and musicname then
		if mariotime <= 99 and mariotime > 0 then
			music:play(musicname, true)
		else
			music:play(musicname)
		end
	end
end

function stopmusic()
	if musicname then
		if mariotime <= 99 and mariotime > 0 then
			music:stop(musicname, true)
		else
			music:stop(musicname)
		end
	end
end

function updatesizes()
	mariosizes = {}
	if not objects then
		for i = 1, players do
			mariosizes[i] = 1
		end
	else
		for i = 1, players do
			mariosizes[i] = objects["player"][i].size
		end
	end
end

function hitrightside()
	if haswarpzone then
		for i, v in pairs(objects["enemy"]) do
			if v.t == "plant" then	
				v.kill = true
			end
		end
		displaywarpzonetext = true
	end
end

function getclosestplayer(x)
	--@WARNING: This should also check y.
	closestplayer = 1
	for i = 2, players do
		if math.abs(objects["player"][closestplayer].x+6/16-x) < math.abs(objects["player"][i].x+6/16-x) then
			closestplayer = i
		end
	end
	
	return closestplayer
end

function endgame()
	print("endgame called")
	if testlevel then
		marioworld = testlevelworld
		mariolevel = testlevellevel
		testlevel = false
		editormode = true
		loadlevel(marioworld .. "-" .. mariolevel)
		startlevel()
	else
		love.audio.stop()
		gamefinished = true
		saveconfig()
		menu_load()
	end
end

function respawnplayers()
	if mariolivecount == false then
		return
	end
	for i = 1, players do
		if objects["player"].lives == 1 and objects["player"].dead then
			objects["player"][i]:respawn()
		end
	end
end

function cameraxpan(target, t)
	xpan = true
	xpanstart = xscroll
	xpandiff = target-xpanstart
	xpantime = t
	xpantimer = 0
end

function cameraypan(target, t)
	ypan = true
	ypanstart = yscroll
	ypandiff = target-ypanstart
	ypantime = t
	ypantimer = 0
end

function updateranges()
	for i, v in pairs(objects["laser"]) do
		v:updaterange()
	end
	for i, v in pairs(objects["lightbridge"]) do
		v:updaterange()
	end
	for i, v in pairs(objects["funnel"]) do
		v:updaterange()
	end
end

function createdialogbox(text, speaker)
	dialogboxes = {}
	table.insert(dialogboxes, dialogbox:new(text, speaker))
end

function checkportalremove(x, y)
	for i, v in pairs(portals) do
		--Get the extra block of each portal
		local portal1xplus, portal1yplus, portal2xplus, portal2yplus = 0, 0, 0, 0
		if v.facing1 == "up" then
			portal1xplus = 1
		elseif v.facing1 == "right" then
			portal1yplus = 1
		elseif v.facing1 == "down" then
			portal1xplus = -1
		elseif v.facing1 == "left" then
			portal1yplus = -1
		end
		
		if v.facing2 == "up" then
			portal2xplus = 1
		elseif v.facing2 == "right" then
			portal2yplus = 1
		elseif v.facing2 == "down" then
			portal2xplus = -1
		elseif v.facing2 == "left" then
			portal2yplus = -1
		end
		
		if v.x1 ~= false then
			if (x == v.x1 or x == v.x1+portal1xplus) and (sy == v.y1 or y == v.y1+portal1yplus) then--and (facing == nil or v.facing1 == facing) then
				v:removeportal(1)
			end
		end
	
		if v.x2 ~= false then
			if (x == v.x2 or x == v.x2+portal2xplus) and (y == v.y2 or y == v.y2+portal2yplus) then--and (facing == nil or v.facing2 == facing) then
				v:removeportal(2)
			end
		end
	end
end
end end)()end;
do require("package").preload["shaders.init"] = (function() local package;return function(...)-- <pack shaders.init> --
local supported = love.graphics.isSupported and love.graphics.isSupported("canvas") and love.graphics.isSupported("shader")
local supports_npo2 = love.graphics.isSupported and love.graphics.isSupported("npot") or false -- on the safe side
if not supported then 
	shaderssupported = false
	print("post-processing shaders not supported")
end


local function FindNextPO2(x)
	return 2 ^ math.ceil(math.log(x)/math.log(2))
end


shaders = {}
shaders.effects = {}
shaders.supported = supported

local function CreateShaderPass()
	local pass = {
		cureffect = "",
		on = false,
		xres = width*16*scale,
		yres = height*16*scale,
	}
	
	function pass:useCanvas(usenpo2)
		local po2xr = usenpo2 and shaders.xres or shaders.po2xres
		local po2yr = usenpo2 and shaders.yres or shaders.po2yres
		
		local c = usenpo2 and self.canvas_npo2 or self.canvas_po2
		
		if not c or c.canvas:getWidth() ~= po2xr or c.canvas:getHeight() ~= po2yr then
			c = {}
			local status, canvas = pcall(love.graphics.newCanvas, po2xr, po2yr)
			if status then
				canvas:setFilter("nearest", "nearest")
				c.canvas = canvas
				c.quad = love.graphics.newQuad(0, 0, shaders.xres, shaders.yres, po2xr, po2yr)
			else
				-- error or something?
				print(string.format("shader error: could not create canvas for %s", self.cureffect or "?"))
				self.on = false
				return
			end
			if usenpo2 then
				self.canvas_npo2 = c
			else
				self.canvas_po2 = c
			end
		elseif self.xres ~= shaders.xres or self.yres ~= shaders.yres then
			c.quad = love.graphics.newQuad(0, 0, shaders.xres, shaders.yres, po2xr, po2yr)
		end
		
		self.xres, self.yres = shaders.xres, shaders.yres
				
		self.defs = {
			["textureSize"] = {po2xr/scale, po2yr/scale},
			-- ["textureSizeReal"] = {po2xr, po2yr},
			["inputSize"] = {shaders.xres/scale, shaders.yres/scale},
			["outputSize"] = {shaders.xres, shaders.yres},
			["time"] = love.timer.getTime()
		}

		self.canvas = c
	end
	
	function pass:predraw()
		if supported and self.on and self.canvas then
			self.canvas.canvas:clear(love.graphics.getBackgroundColor())
			love.graphics.setCanvas(self.canvas.canvas)
			return self.canvas.canvas
		end
	end
	
	function pass:postdraw()
		local effect = shaders.effects[self.cureffect]
		if supported and self.on and self.cureffect and effect and self.canvas then
			for def in pairs(effect[3]) do
				if self.defs[def] then
					if def == "time" then
						self.defs[def] = love.timer.getTime()
					end
					effect[1]:send(def, self.defs[def])
				end
			end
			if effect.supported == nil then
				effect.supported = pcall(love.graphics.setShader, effect[1])
				if not effect.supported then
					print(string.format("Error setting shader: %s!", self.cureffect))
				end
			elseif effect.supported then
				love.graphics.setShader(effect[1])
			else
				love.graphics.setShader()
			end
			
			if fullscreen then
				if fullscreenmode == "full" then
					love.graphics.draw(self.canvas.canvas, self.canvas.quad, 0, 0, 0, desktopsize.width/(width*16*scale), desktopsize.height/(height*16*scale))
				else
					love.graphics.draw(self.canvas.canvas, self.canvas.quad, 0, touchfrominsidemissing/2, 0, touchfrominsidescaling/scale, touchfrominsidescaling/scale)
				end
			else
				love.graphics.draw(self.canvas.canvas, self.canvas.quad, 0, 0)
			end
		end
	end
	
	return pass
end


-- list of shaders that need po2-sized canvases
shaders.needspo2 = {
	["4xBR"] = true,
	["waterpaint"] = true,
	["CRT"] = true,
}

shaders.passes = {}


-- call at the end of love.load
-- numpasses is the max number of concurrent shaders (default 2)
function shaders:init(numpasses)
	numpasses = numpasses or 2
	
	if not supported then
		return
	end
	
	local files = love.filesystem.getDirectoryItems("shaders")
	
	for i,v in ipairs(files) do
		local filename, filetype = v:match("(.+)%.(.-)$")
		if filetype == "frag" then
			local name = "shaders".."/"..v
			if love.filesystem.isFile(name) then
				local str = love.filesystem.read(name)
				--local effect = love.graphics.newShader(str)
				local success, effect = pcall(love.graphics.newShader, str)
				if success and effect then
					local defs = {}
					for vtype, extern in str:gmatch("extern (%w+) (%w+)") do
						defs[extern] = true
					end
					self.effects[filename] = {effect, str, defs, needspo2 = not not self.needspo2[filename]}
				else
					print(string.format("shader (%s) is fucked up, yo:\n", filename), effect)
				end
			end
		end
	end
	
	for i=1, numpasses do
		self.passes[i] = CreateShaderPass()
	end
	
	self:refresh()
end



-- call when setting shader for first time and when changing shaders
-- i is the index (1 or 2, unless you specify a different number of max passes on init)
-- pass nil as the second argument to disable that shader pass
-- don't call before shaders:init()
function shaders:set(i, shadername)
	if not supported then return end
	
	i = i or 1
	local pass = self.passes[i]
	if not pass then return end
	
	if shadername == nil or not self.effects[shadername] or not supported then
		pass.on = false
		pass.cureffect = nil
	else
		pass.on = true
		pass.cureffect = shadername
		pass:useCanvas(supports_npo2 and not self.effects[shadername].needspo2)
		print(string.format("post-processing shader selected for pass %d: %s", i, shadername))
	end
end


-- for tweaking some of the 'extern' parameters in the shaders
-- returns true if it worked, false with an error message otherwise
function shaders:setParameter(shadername, paramname, ...)
	if self.effects[shadername] then
		local effect = self.effects[shadername][1]
		return pcall(effect.send, effect, paramname, ...)
	end
end


-- automatically called on init
-- should also be called when resolution changes or fullscreen is toggled
function shaders:refresh()
	if not supported then return end
	
	if not self.scale or self.scale ~= scale
	or not self.xres or not self.yres
	or self.xres ~= width*16*scale or self.yres ~= height*16*scale then
		self.scale = scale
		
		self.xres, self.yres = width*16*scale, height*16*scale
		self.po2xres, self.po2yres = FindNextPO2(self.xres), FindNextPO2(self.yres)
		
		for i,v in ipairs(self.passes) do
			self:set(i, v.cureffect)
		end
	end
	
	--collectgarbage("collect")
end


-- call in love.draw before drawing whatever you want post-processed
-- note: don't change shaders in between predraw and postdraw!
function shaders:predraw()
	if not supported then return end
	
	-- only predraw the first available pass here (we'll do the rest in postdraw)
	self.curcanvas = nil
	for i,v in ipairs(self.passes) do
		local canvas = v:predraw()
		if canvas then
			self.curcanvas = {canvas=canvas, index=i}
			break
		end
	end
end


-- call in love.draw after drawing whatever you want post-processed
function shaders:postdraw()
	if not supported or not self.curcanvas then return end
	
	local blendmode = love.graphics.getBlendMode()
	love.graphics.setBlendMode("premultiplied")
	love.graphics.setColor(255, 255, 255)
	
	local activepasses = {}
	
	for i = self.curcanvas.index, #self.passes do
		local pass = self.passes[i]
		if pass.on and pass.canvas then
			table.insert(activepasses, pass)
		end
	end
	
	for i,v in ipairs(activepasses) do
		if i < #activepasses then
			activepasses[i+1]:predraw()
		else
			love.graphics.setCanvas()
		end
		v:postdraw()
	end

	love.graphics.setBlendMode(blendmode)
	love.graphics.setShader()
end
end end)()end;
do require("package").preload["coinblockanimation"] = (function() local package;return function(...)-- <pack coinblockanimation> --
coinblockanimation = class("coinblockanimation")

function coinblockanimation:init(x, y)
	self.x = x
	self.y = y
	
	self.timer = 0
	self.frame = 1
end 

function coinblockanimation:update(dt)
	self.timer = self.timer + dt
	while self.timer > coinblockdelay do
		self.frame = self.frame + 1
		self.timer = self.timer - coinblockdelay
	end
	
	if self.frame >= 31 then
		--addpoints(-200, self.x, self.y)
		--@WARNING: I'm not sure why this is here. At all.
		return true
	end
	
	return false
end
end end)()end;
do require("package").preload["utils"] = (function() local package;return function(...)-- <pack utils> --
--[[ strange language sorcery takes place here ]]
function table.pack(...)
	return { n = select("#", ...), ... }
end

function table.contains(t, entry)
	for i, v in pairs(t) do
		if v == entry then
			return true
		end
	end
	return false
end

function table.find(t, k)
	for _,v in pairs(t) do
		if v == k then
			return _
		end
	end
	return nil
end

function table.print(t)
	--print(Tserial.pack(t, true, true))
	-- the above causes a stack overflow, so we are doing this the dumb way
	if t~=nil then
		for k,v in pairs(t) do print(k, "=", v) end
	else
		print("nothing, got a nil")
	end
end

-- this code was originally from TLbind, also works to clone
function table.combine(a, b)
	local t = {}
	for k, v in pairs(a) do if type(v)=="table" then t[k]=table.combine(v) else t[k]=v end end
	if b then for k, v in pairs(b) do if type(v)=="table" then t[k]=table.combine(v) else t[k]=v end end end
	return t
end

function string:split(delimiter) --Not by me
	local result = {}
	local from  = 1
	local delim_from, delim_to = string.find( self, delimiter, from  )
	while delim_from do
		table.insert( result, string.sub( self, from , delim_from-1 ) )
		from = delim_to + 1
		delim_from, delim_to = string.find( self, delimiter, from  )
	end
	table.insert( result, string.sub( self, from  ) )
	return result
end

local function interp(s, tab)
	return (s:gsub('%%%((%a%w*)%)([-0-9%.]*[cdeEfgGiouxXsq])',
			function(k, fmt) return tab[k] and ("%"..fmt):format(tab[k]) or
				'%('..k..')'..fmt end))
end
getmetatable("").__mod = interp
-- refer to: https://docs.python.org/2/library/stdtypes.html#string-formatting if confused

function nop()
	
end

function table.fdelete(tbl, filterfunc, ex)
	--[[
		delete elements in a table where the filterfunc returns true
		
		filterfunc is supplied the index and the object, plus whatever is in ex
	]]
	local delete = {}
	
	for i, v in pairs(tbl) do
		if filterfunc(i, v, ex) then
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end) -- why are we doing this
	
	for i, v in pairs(delete) do
		table.remove(tbl, v) --remove
	end
end
end end)()end;
do require("package").preload["hook"] = (function() local package;return function(...)-- <pack hook> --
--[[
	We're going to use this to experiment with the concept of hookable events.
	If we play our cards right we won't die!
	
	You make a hook available by using hook.Call("YerHookName", args)
	People can subscribe to this by using hook.Add("YerHookName", "MyIdentifier", functionReference)
	
	This is modeled after the hook library in gmod:
		http://wiki.garrysmod.com/page/hook
	
	We don't do any type checking so if someone goofs the whole thing comes toppling down.
]]

hook = {hookTable={}}
-- this is where we store our hooks and the things that latch on to them like greedy little hellions

function hook.Add( eventName, identifier, func )
	--string, string, function
	if hook.hookTable[eventName]==nil then
		hook.hookTable[eventName]={}
	end
	hook.hookTable[eventName][identifier] = func
end

function hook.Call( eventName, ... )
	--string, varargs
	if hook.hookTable[eventName]==nil then
		-- skip processing the hook because nobody's listening
		return nil
	else
		local results
		for identifier,func in pairs(hook.hookTable[eventName]) do
			local results = table.pack(func({...}))
			results.n = nil
			if #results>0 then
				-- potential problems if relying on sandwiching a nil in the return results
				return results
			end
		end
	end
end

function hook.GetTable()
	return hook.hookTable()
end

function hook.Remove( eventName, identifier )
	--[[string, string]]
	if hook.hookTable[eventName]==nil or hook.hookTable[eventName][identifier]==nil then
		return false
	else
		hook.hookTable[eventName][identifier]=nil
	end
	-- see if the table is empty and nil it for the benefit of hook.Call's optimization
	for k,v in pairs(hook.hookTable[eventName]) do
		-- we found something, exit the function
		return true
	end
	-- if we reach this far then the table must've been empty
	hook.hookTable[eventName] = nil
	return true
end
end end)()end;
do require("package").preload["gui.maptree"] = (function() local package;return function(...)-- <pack gui.maptree> --
maptree = class('maptree')

function maptree:init(maps)
	self.active = false
	self.lines = {} --unused
	self.area = {12, 33, 399, 212}
	--{4, 21, 381, 220} old map area
	self.lineinset = 14 --unused
	self.maplist = {}
	self.existingmaps = {} --not sure what it's for
	--self.itemlist = anims2
	self.elements = {}
	self.viewtype = 1
	self.buildfrom = maps --entirely unused
	
	-- original
	--[[guielements["savebutton2"] = guielement:new("button", 10, 140, "save", savelevel, 2)
	guielements["savebutton2"].bordercolor = {255, 0, 0}
	guielements["savebutton2"].bordercolorhigh = {255, 127, 127}--]]
	--guielements["mapscrollbar"] = guielement:new("scrollbar", 381, 21, 199, 15, 40, 0, "ver", nil, nil, nil, nil, true)]]
	
	self.elements["scrollbarver"] = guielement:new("scrollbar", self.area[1]-10, self.area[2], self.area[4]-self.area[2], 10, 40, 0, "ver", nil, nil, nil, nil, true)
	self.elements["scrollbarhor"] = guielement:new("scrollbar", self.area[1], self.area[4], self.area[3]-self.area[1], 40, 10, 0, "hor", nil, nil, nil, nil, false)
	
	--[[local args = {}
	--table.insert(args, self)
	for i, v in ipairs(self.buildfrom) do
		table.insert(args, string.sub(v.name, 1, -6))
	end]]
	--self.elements["selectdrop"] = guielement:new("dropdown", 15, 20, 15, function(i) self:selectview(i) end, 1, unpack(args))
	self.elements["newbutton"] = guielement:new("button", 3, 20, "+", self.newmap, nil, {self})
	self.elements["mapname"] = guielement:new("input", 15, 20, 15, nil, currentmap, 0)
	--self.elements["savebutton"] = guielement:new("button", 150, 19, "save", self.save, 1, {self})
	
	--self.elements["addtriggerbutton"] = guielement:new("button", 0, 0, "+", self.addtrigger, nil, {self}, nil, 8)
	--self.elements["addtriggerbutton"].textcolor = {0, 200, 0}
	
	--self.elements["addconditionbutton"] = guielement:new("button", 0, 0, "+", self.addcondition, nil, {self}, nil, 8)
	--self.elements["addconditionbutton"].textcolor = {0, 200, 0}
	
	--self.elements["addactionbutton"] = guielement:new("button", 0, 0, "+", self.addaction, nil, {self}, nil, 8)
	--self.elements["addactionbutton"].textcolor = {0, 200, 0}
	
	self:generate()
end

function maptree:activate()
	self.active = true
	for k,v in pairs(self.elements) do
		v.active = true
	end
	
	self:generate()
end

function maptree:deactivate()
	self.active = false
	for k,v in pairs(self.elements) do
		v.active = false
	end
end

function maptree:changemap(mapname)
	print("WHOA: I was told to change to ", mapname)
	--print("NOTICE: Map changed because a map icon was clicked.")
	currentmap = mapname
	marioworld = 1
	mariolevel = 1
	mariosublevel = 0
	editorloadopen = false
	self.elements["mapname"].value = mapname
	loadlevel(mapname)
	startlevel()
end

function maptree:generate()
	self.existingmaps = {}
	
	local mapdir = "mappacks/" .. mappack .. "/"
	local maplist = love.filesystem.getDirectoryItems(mapdir)
	self.maplist = {}
	local yadd = 0
	local xadd = 0
	
	for k,v in pairs(maplist) do
		if v:sub(-4) == ".txt" and love.filesystem.isFile(mapdir..v) and v~="settings.txt" then
			local curmapname = v:sub(0, -5)
			self.elements["map_"..curmapname.."_label"] = guielement:new("text", 4, yadd+21, curmapname)
			self.elements["map_"..curmapname.."_label"].starty = yadd+21
			
			yadd = yadd + 10
			
			if love.filesystem.exists(mapdir..curmapname..".png") then
				self.elements["map_"..curmapname.."_button"] = guielement:new("button", 4+xadd, yadd+21, love.graphics.newImage(mapdir..curmapname..".png"), function(cmap) self:changemap(cmap) end, 0, {curmapname})
			else
				self.elements["map_"..curmapname.."_button"] = guielement:new("button", 4+xadd, yadd+21, "no preview", function() self:changemap(curmapname) end, 0)
			end
			self.elements["map_"..curmapname.."_button"].starty = yadd+21
			self.maplist[curmapname] = {
				label=self.elements["map_"..curmapname.."_label"],
				button=self.elements["map_"..curmapname.."_button"]
			}
			yadd = yadd + 20
		end
	end
	self.mapsymissing = math.max(0, yadd-200)
end

function maptree:newmap()
	savemap(currentmap)
	savemap(self.elements["mapname"].value)
	self:changemap(self.elements["mapname"].value)
end

function maptree:draw()
	-- original draw had this commented out
	--[[love.graphics.setColor(255, 255, 255)
	for i = 1, 8 do
		properprint("w" .. i, ((i-1)*49 + 19)*scale, 23*scale)
	end
	properprint("do not forget to save your current map before|changing!", 5*scale, 120*scale)--]]
	
	-- original draw method
	--[[local scroll = guielements["mapscrollbar"].value * mapsymissing
	love.graphics.setScissor(mapbuttonarea[1]*scale, mapbuttonarea[2]*scale, (mapbuttonarea[3]-mapbuttonarea[1])*scale, (mapbuttonarea[4]-mapbuttonarea[2])*scale)
	
	for i, v in pairs(mapbuttons) do
		v.y = v.starty - scroll
		v:draw()
	end
	love.graphics.setScissor()]]
	
	-- nodetree compliant draw
	if self.active then
		love.graphics.setScissor(self.area[1]*scale, self.area[2]*scale, (self.area[3]-self.area[1])*scale, (self.area[4]-self.area[2])*scale)
		local completeheight = self.area[4]-self.area[2] --(self.area[3]-self.area[1])*scale
		local completewidth = 0
		for k,v in pairs(self.elements) do
			if k:sub(0,4) == "map_" then
				completeheight = completeheight+v.height
				if completewidth < 32+v.width then
					completewidth = 32+v.width
				end
			end
		end
		
		--local offy = math.max(0, self.elements["scrollbarver"].value/1*(completeheight-(self.area[4]-self.area[2])))-14
		local offy = self.elements["scrollbarver"].value*completeheight*scale
		
		local offx = math.max(0, self.elements["scrollbarhor"].value/1*(completewidth-(self.area[3]-self.area[1])))
		
		love.graphics.setColor(255, 255, 255)
		local y = self.area[2]+1-offy
		y = y + 2
		
		for k,v in pairs(self.elements) do
			if k:sub(0,4) == "map_" then
				v.x = self.area[1]+self.lineinset+offx
				v.y = self.area[2] + v.starty - (offy/scale) - 16
				--y = y + v.height
				--v.y = v.starty - scroll
				v:draw()
			else
				v:draw()
			end
		end
		
		love.graphics.setScissor()
		
		love.graphics.setColor(90, 90, 90)
		drawrectangle(self.area[1]-10, self.area[4], 10, 10)
		
		for k, v in pairs(self.elements) do
			if k:sub(0,4) ~= "map_" then
				v:draw()
			end
		end
	end
	
	-- this is commented out because it was included above I guess
	--[[if self.active then
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do
				for anotherletter, fuck in pairs(w.elements) do
					if fuck.gui and fuck.gui.priority then
						fuck.gui:draw()
					end
				end
			end
		end
	end]]
end

function maptree:update(dt)
	for i, v in pairs(self.elements) do
		--for k, w in pairs(v) do
			v:update(dt)
		--end
	end
end

function maptree:keypressed(key)
	for i, v in pairs(self.elements) do
		if v:keypress(string.lower(key)) then
			--return
			-- do we /really/ wanna do this?
		end
	end
	
	--[[for k,v in pairs(self.lines) do
		for k2,v2 in pairs(v) do
			v2:keypressed(key)
		end
	end]]
end

function maptree:mousepressed(x, y, button)
	for i, v in pairs(self.elements) do
		if v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(self.elements) do
		if not v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	
	-- original
	--[[if mapbuttons then
		for i, v in pairs(mapbuttons) do
			v:click(x, y, button)
		end
	end]]
	
	-- ex
	--[[if self.lines and self.active and not self.elements["selectdrop"].extended then
		local b = false
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do
				if w:haspriority() then
					w:click(x, y, button)
					return
				end
			end
		end
		
		if x >= self.area[1]*scale and y >= self.area[2]*scale and x < self.area[3]*scale and y < self.area[4]*scale then
			self.elements["addtriggerbutton"]:click(x, y, button)
			self.elements["addconditionbutton"]:click(x, y, button)
			self.elements["addactionbutton"]:click(x, y, button)
			
			for i, v in pairs(self.lines) do
				for k, w in pairs(v) do						
					if w:click(x, y, button) then
						return
					end
				end
			end
		end
	end]]
end

function maptree:mousereleased(x, y, button)
	for i, v in pairs(self.elements) do
		if v.priority then
			if v:unclick(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(self.elements) do
		if not v.priority then
			if v:unclick(x, y, button) then
				return
			end
		end
	end
	
	--[[if self.lines and self.active then
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do					
				w:unclick(x, y, button)
			end
		end
	end]]
end
end end)()end;
do require("package").preload["gui.killfeed"] = (function() local package;return function(...)-- <pack gui.killfeed> --
killfeed = {}

killfeed.themes = {
	dark = {
		background = {30,28,17},
		icon = {229,224,181},
		alpha = 200,
		
		attacker = {184,59,59},
		neutral = {255,255,255},
		victim = {89,121,139}
	},
	light = {
		background = {179,171,141},
		icon = {61,57,35},
		alpha = 200,
		
		attacker = {184,59,59},
		neutral = {0,0,0},
		victim = {89,121,139}
	},
	humiliation = {
		background = {213,198,217},
		icon = {89,76,93},
		alpha = 200,
		
		attacker = {229,172,182},
		neutral = {0,0,0},
		victim = {229,172,182}
	},
}

killfeed.killfeeds = {}
killfeed.duration = 5 --seconds
killfeed.fadetime = 0.5

function killfeed.glob(glob)
	if glob == nil then
		return ""
	end
	local fallbackname = tostring(glob):split("class ")[2].."?"
	local name = ""
	
	if objects~=nil then
		for k,v in pairs(objects) do
			for k2,v2 in pairs(v) do
				if glob == v2 then
					local subclass=tostring(k)
					if subclass=="enemy" then
						subclass = glob.t
					end
					name = subclass.."#"..tostring(k2)
				end
			end
		end
		
		if name=="" then
			name=fallbackname
		end
		return name
	else
		return fallbackname
	end
end

function killfeed.process_dtypes(dtype)
	
end

function killfeed.new(attackers, dtype, victims, ex)
	local duration = duration or killfeed.duration
	local theme = "dark"
	
	local trashname = tostring(attackers):split("class ")[2]
	local attackername = ""
	if attackers and attackers.isInstanceOf and attackers:isInstanceOf(_G[trashname]) then
		if attackers.playernumber == 1 then
			theme = "light"
		end
		attackername = killfeed.glob(attackers)
	elseif attackers then
		for k,v in pairs(attackers) do
			if v.playernumber == 1 then
				theme = "light"
			end
			attackername = attackername .. killfeed.glob(v)
			if k<#attackers then
				attackername = attackername.." + "
			end
		end
	else
		attackername = "world"
	end
	dtype = dtype or "mystery"
	if killfeed.icons[dtype] then
		dicon = killfeed.icons[dtype]
	else
		dicon = killfeed.icons["mystery"]
	end
	local victimname = killfeed.glob(victims)
	
	if (victims and victims.playernumber == 1) then
		theme = "light"
	end
	if attackers==victims or (type(attackers)=="table" and table.contains(attackers, victims)) then
		theme = "humiliation"
	end
	
	table.insert(killfeed.killfeeds, {
		attacker=attackername:lower(),
		dtype=dtype:lower(),
		icon=dicon,
		victim=victimname:lower(),
		theme=theme,
		--text=attackername:lower().." "..dtype:lower().."ed "..victimname:lower(),
		life=duration,
		duration=duration,
	})
end 

function killfeed.update(dt)
	for i = #killfeed.killfeeds, 1, -1 do
		local v = killfeed.killfeeds[i]
		
		v.life = v.life - dt
		
		if v.life <= 0 then
			table.remove(killfeed.killfeeds, i)
		end
	end
end

function killfeed.draw()
	local y = 0
	for i = #killfeed.killfeeds, 1, -1 do
		local v = killfeed.killfeeds[i]
		
		--get width by finding longest line 
		local thewidth = (
			v.attacker:len()
			+ v.victim:len()
			+ .75
		)*8 + v.icon:getWidth()
		--[[local split = v.text:split("|")
		local longest = #split[1]
		for i = 2, #split do
			if #split[i] > longest then
				longest = #split[i]
			end
		end]]
		
		
		
		local height = 1*10+3 --1 was #split
		local actualy = killfeed.gety(y, v.life, height, v.duration)
		
		local targetrect = {
			width*16 - thewidth-5,
			actualy,
			thewidth+5,
			height
		}
		local scissor = {
			(width*16 - thewidth-5)*scale,
			y*scale,
			(thewidth+5)*scale,
			(actualy-y+height)*scale
		}
		local datheme = killfeed.themes[v.theme]
		
		-- background
		love.graphics.setColor(datheme.background, datheme.alpha)
		--love.graphics.rectangle("fill", targetrect[1]*scale, targetrect[2]*scale, targetrect[3]*scale, targetrect[4]*scale)
		love.graphics.roundrect("fill", targetrect[1]*scale, targetrect[2]*scale, targetrect[3]*scale, targetrect[4]*scale, 16, 16)
		
		-- outline
		local tline = love.graphics.getLineWidth()
		love.graphics.setColor(datheme.neutral, datheme.alpha)
		love.graphics.setLineWidth(2)
		love.graphics.roundrect("line", targetrect[1]*scale, targetrect[2]*scale, targetrect[3]*scale, targetrect[4]*scale, 16, 16)
		--love.graphics.roundrect("line", (targetrect[1]+1)*scale, (targetrect[2]+1)*scale, (targetrect[3]-2)*scale, (targetrect[4]-2)*scale, 16, 16)
		love.graphics.setLineWidth(tline)
		
		--drawrectangle(targetrect[1]+1, targetrect[2]+1, targetrect[3]-2, targetrect[4]-2)
		
		--love.graphics.setColor(killfeed.white)
		--properprint(v.text, 	(targetrect[1]+2)*scale, (actualy+3)*scale)
		
		--attacker(s)
		local xoff = targetrect[1]+3
		love.graphics.setColor(datheme.attacker, datheme.alpha)
		properprint(v.attacker, xoff*scale, (actualy+3)*scale)
		xoff = xoff + (v.attacker):len()*8+4
		
		-- icon
		love.graphics.setColor(datheme.icon, datheme.alpha)
		love.graphics.draw(v.icon, xoff*scale, (actualy+scale/2)*scale, 0, scale-1, scale-1) 
		-- we offset the scales because otherwise the scissor would pee on our icons
		-- the 1.5 is, uh, what it takes to center the graphic
		--properprint(v.dtype.."ed", xoff*scale, (actualy+3)*scale)
		xoff = xoff + v.icon:getWidth()
		
		-- victim(s)
		love.graphics.setColor(datheme.victim, datheme.alpha)
		properprint(v.victim, xoff*scale, (actualy+3)*scale)
		
		y = actualy+height
	end
	
	love.graphics.setColor(255, 255, 255)
end

function killfeed.gety(y, life, height, duration)
	if life > duration-killfeed.fadetime then
		return y - height*((life-(duration-killfeed.fadetime))/killfeed.fadetime)^2
	elseif life < killfeed.fadetime then
		return y - height*((killfeed.fadetime-life)/killfeed.fadetime)^2
	else
		return y
	end
end
end end)()end;
do require("package").preload["gui.nodetree"] = (function() local package;return function(...)-- <pack gui.nodetree> --
nodetree = class('nodetree')

function nodetree:init(anims, anims2)
	self.active = true
	self.lines = {}
	self.area = {12, 33, 399, 212}
	self.lineinset = 14
	self.itemlist = anims2
	self.elements = {}
	self.viewtype = 1
	self.buildfrom = anims
	
	self.elements["scrollbarver"] = guielement:new("scrollbar", self.area[1]-10, self.area[2], self.area[4]-self.area[2], 10, 40, 0, "ver", nil, nil, nil, nil, true)
	self.elements["scrollbarhor"] = guielement:new("scrollbar", self.area[1], self.area[4], self.area[3]-self.area[1], 40, 10, 0, "hor", nil, nil, nil, nil, false)
	
	local args = {}
	--table.insert(args, self)
	for i, v in ipairs(self.buildfrom) do
		table.insert(args, string.sub(v.name, 1, -6))
	end
	self.elements["selectdrop"] = guielement:new("dropdown", 15, 20, 15, function(i) self:selectview(i) end, 1, unpack(args))
	self.elements["newbutton"] = guielement:new("button", 3, 20, "+", self.newanimation, nil, {self})
	self.elements["savebutton"] = guielement:new("button", 150, 19, "save", self.save, 1, {self})
	
	self.elements["addtriggerbutton"] = guielement:new("button", 0, 0, "+", self.addtrigger, nil, {self}, nil, 8)
	self.elements["addtriggerbutton"].textcolor = {0, 200, 0}
	
	self.elements["addconditionbutton"] = guielement:new("button", 0, 0, "+", self.addcondition, nil, {self}, nil, 8)
	self.elements["addconditionbutton"].textcolor = {0, 200, 0}
	
	self.elements["addactionbutton"] = guielement:new("button", 0, 0, "+", self.addaction, nil, {self}, nil, 8)
	self.elements["addactionbutton"].textcolor = {0, 200, 0}
	
	self:generate()
end

function nodetree:activate()
	self.active = true
	for k,v in pairs(self.elements) do
		v.active = true
	end
	
	self:generate()
end

function nodetree:deactivate()
	self.active = false
	for k,v in pairs(self.elements) do
		v.active = false
	end
end

function nodetree:generate()
	-- viewtype unused
	if not self.buildfrom[self.viewtype] then
		self:newanimation()
	end
	--print("absurd")
	--table.print(self.buildfrom[self.viewtype])
	local holder = self.buildfrom[self.viewtype]

	self.lines = {}
	self.lines.triggers = {}
	for i, v in pairs(holder.triggers) do
		table.insert(self.lines.triggers, animationguiline:new(v, "trigger", self))
	end
	self.lines.conditions = {}
	for i, v in pairs(holder.conditions) do
		table.insert(self.lines.conditions, animationguiline:new(v, "condition", self))
	end
	self.lines.actions = {}
	for i, v in pairs(holder.actions) do
		table.insert(self.lines.actions, animationguiline:new(v, "action", self))
	end
end

function nodetree:newanimation()
	local s = {}
	s.triggers = {}
	s.conditions = {}
	s.actions = {}
	
	local i = 1
	while love.filesystem.exists("mappacks/" .. mappack .. "/animations/animation" .. i .. ".json") do
		i = i + 1
	end
	love.filesystem.createDirectory("mappacks/" .. mappack .. "/animations/")
	love.filesystem.write("mappacks/" .. mappack .. "/animations/animation" .. i .. ".json", JSON:encode_pretty(s))
	
	table.insert(self.buildfrom, animation:new("mappacks/" .. mappack .. "/animations/animation" .. i .. ".json", "animation" .. i .. ".json"))
	self.viewtype = #self.buildfrom
	
	self:updatedropdown()
end

function nodetree:updatedropdown()
	local args = {}
	--table.insert(args, self)
	for i, v in ipairs(self.buildfrom) do
		table.insert(args, string.sub(v.name, 1, -6))
	end
	
	self.elements["selectdrop"] = guielement:new("dropdown", 15, 20, 15, function(i) self:selectview(i) end, self.viewtype, unpack(args))
end

function nodetree:deleteline(t, tabl)
	for i, v in ipairs(self.lines[t .. "s"]) do
		if v == tabl then
			table.remove(self.lines[t .. "s"], i)
		end
	end
end

function nodetree:movedownline(t, tabl)
	for i, v in ipairs(self.lines[t .. "s"]) do
		if v == tabl then
			if i ~= #self.lines[t .. "s"] then
				self.lines[t .. "s"][i], self.lines[t .. "s"][i+1] = self.lines[t .. "s"][i+1], self.lines[t .. "s"][i]
				break
			end
		end
	end
end

function nodetree:moveupline(t, tabl)
	for i, v in ipairs(self.lines[t .. "s"]) do
		if v == tabl then
			if i ~= 1 then
				self.lines[t .. "s"][i], self.lines[t .. "s"][i-1] = self.lines[t .. "s"][i-1], self.lines[t .. "s"][i]
				break
			end
		end
	end
end

function nodetree:selectview(i)
	--print("selectview", self, i)
	self.elements["selectdrop"].var = i
	self:save()
	self.viewtype = i
	self:generate()
end

function nodetree:save()
	notice.new("animations saved!")
	local out = {}
	
	local typelist = {"triggers", "conditions", "actions"}
	for h, w in ipairs(typelist) do
		out[w] = {}
		for i, v in ipairs(self.lines[w]) do
			out[w][i] = {}
			for j, k in ipairs(v.elements) do
				if k.gui then
					local val = ""
					if k.gui.type == "dropdown" then
						if j == 1 then
							--find normal name
							for l, m in pairs(self.itemlist) do
								if m.nicename == k.gui.entries[k.gui.var] then
									val = l
									break
								end
							end
						else
							val = k.gui.entries[k.gui.var]
						end
					elseif k.gui.type == "input" then
						val = k.gui.value
					end
					table.insert(out[w][i], val)
				end
			end
		end
	end
	
	self.buildfrom[self.viewtype].triggers = out.triggers
	self.buildfrom[self.viewtype].conditions = out.conditions
	self.buildfrom[self.viewtype].actions = out.actions
	
	local json = JSON:encode_pretty(out)
	love.filesystem.write(self.buildfrom[self.viewtype].filepath, json)
end

function nodetree:addtrigger()
	table.insert(self.lines.triggers, animationguiline:new({}, "trigger", self))
end

function nodetree:addcondition()
	table.insert(self.lines.conditions, animationguiline:new({}, "condition", self))
end

function nodetree:addaction()
	table.insert(self.lines.actions, animationguiline:new({}, "action", self))
end

function nodetree:draw()
	if #self.buildfrom > 0 then
		love.graphics.setScissor(self.area[1]*scale, self.area[2]*scale, (self.area[3]-self.area[1])*scale, (self.area[4]-self.area[2])*scale)
		local completeheight = 14+#self.lines.triggers*13+12+#self.lines.conditions*13+12+#self.lines.actions*13
		local offy = math.max(0, self.elements["scrollbarver"].value/1*(completeheight-(self.area[4]-self.area[2])))
		local completewidth = 0
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do
				local width = 32+self.lineinset
				for j, z in pairs(w.elements) do
					width = width + w.elements[j].width
				end
				if width > completewidth then
					completewidth = width
				end
			end
		end
		
		local offx = -math.max(0, self.elements["scrollbarhor"].value/1*(completewidth-(self.area[3]-self.area[1])))
		
		love.graphics.setColor(255, 255, 255)
		
		local y = self.area[2]+1-offy
		y = y + 2
		
		self.elements["addtriggerbutton"].x = self.area[1]+2+offx
		self.elements["addtriggerbutton"].y = y-2
		self.elements["addtriggerbutton"]:draw()
		
		properprint("triggers:", (self.area[1]+13+offx)*scale, y*scale)
		y = y + 10
		
		for i, v in pairs(self.lines.triggers) do
			v:draw((self.area[1]+self.lineinset+offx), y)
			y = y + 13
		end
		y = y + 2
		
		self.elements["addconditionbutton"].x = self.area[1]+2+offx
		self.elements["addconditionbutton"].y = y-2
		self.elements["addconditionbutton"]:draw()
		
		properprint("conditions:", (self.area[1]+13+offx)*scale, y*scale)
		y = y + 10
		
		for i, v in pairs(self.lines.conditions) do
			v:draw((self.area[1]+self.lineinset+offx), y)
			y = y + 13
		end
		y = y + 2
		
		self.elements["addactionbutton"].x = self.area[1]+2+offx
		self.elements["addactionbutton"].y = y-2
		self.elements["addactionbutton"]:draw()
		
		properprint("actions:", (self.area[1]+13+offx)*scale, y*scale)
		y = y + 10
		
		for i, v in pairs(self.lines.actions) do
			v:draw((self.area[1]+self.lineinset+offx), y)
			y = y + 13
		end
		
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do
				for anotherletter, fuck in pairs(w.elements) do
					if fuck.gui and not fuck.gui.priority then
						fuck.gui:draw()
					end
				end
			end
		end
		
		love.graphics.setScissor()
		
		love.graphics.setColor(90, 90, 90)
		drawrectangle(self.area[1]-10, self.area[4], 10, 10)
	end
	
	for i, v in pairs(self.elements) do
		v:draw()
	end
	
	-- this is commented out because it was included above I guess
	if self.active then
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do
				for anotherletter, fuck in pairs(w.elements) do
					if fuck.gui and fuck.gui.priority then
						fuck.gui:draw()
					end
				end
			end
		end
	end
end

function nodetree:update(dt)
	for i, v in pairs(self.lines) do
		for k, w in pairs(v) do
			w:update(dt)
		end
	end
end

function nodetree:keypressed(key)
	for i, v in pairs(self.elements) do
		if v:keypress(string.lower(key)) then
			--return
			-- do we /really/ wanna do this?
		end
	end
	
	for k,v in pairs(self.lines) do
		for k2,v2 in pairs(v) do
			v2:keypressed(key)
		end
	end
end

function nodetree:mousepressed(x, y, button)
	for i, v in pairs(self.elements) do
		if v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(self.elements) do
		if not v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	if self.lines and self.active and not self.elements["selectdrop"].extended then
		local b = false
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do
				if w:haspriority() then
					w:click(x, y, button)
					return
				end
			end
		end
		
		if x >= self.area[1]*scale and y >= self.area[2]*scale and x < self.area[3]*scale and y < self.area[4]*scale then
			self.elements["addtriggerbutton"]:click(x, y, button)
			self.elements["addconditionbutton"]:click(x, y, button)
			self.elements["addactionbutton"]:click(x, y, button)
			
			for i, v in pairs(self.lines) do
				for k, w in pairs(v) do						
					if w:click(x, y, button) then
						return
					end
				end
			end
		end
	end
end

function nodetree:mousereleased(x, y, button)
	for i, v in pairs(self.elements) do
		if v.priority then
			if v:unclick(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(self.elements) do
		if not v.priority then
			if v:unclick(x, y, button) then
				return
			end
		end
	end
	
	if self.lines and self.active then
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do					
				w:unclick(x, y, button)
			end
		end
	end
end
end end)()end;
do require("package").preload["gui.tiletree"] = (function() local package;return function(...)-- <pack gui.tiletree> --
tiletree = class('tiletree')

function tiletree:init(maps)
	self.active = false
	self.area = {12, 33, 399, 212}
	--original area {4, 37, 375, 167}
	--original scissor {5*scale, 38*scale, 373*scale, 165*scale}
	
	self.bgimg = transparencyimg
	self.bgimgdims = {16,16}
	self.bgquad = love.graphics.newQuad(0, 0, (self.area[3]-self.area[1])*scale, (self.area[4]-self.area[2])*scale, self.bgimgdims[1], self.bgimgdims[2])
	
	self.elements = {}
	self.viewtype = 1
	
	self.contentheight = 0
	self.contentwidth = 0
	
	self.offy = 0
	
	self.buildfrom = {"all", "smb", "portal", "custom", "animated", "entities", "enemies"}
	
	-- original
	--[[guielements["tilesall"] = guielement:new("button", 4, 20, "all", tilesall, 2) --72
	guielements["tilessmb"] = guielement:new("button", 37, 20, "smb", tilessmb, 2)
	guielements["tilesportal"] = guielement:new("button", 70, 20, "portal", tilesportal, 2)
	guielements["tilescustom"] = guielement:new("button", 127, 20, "custom", tilescustom, 2)
	guielements["tilesanimated"] = guielement:new("button", 184, 20, "animated", tilesanimated, 2)
	guielements["tilesentities"] = guielement:new("button", 257, 20, "entities", tilesentities, 2)
	guielements["tilesenemies"] = guielement:new("button", 330, 20, "enemies", tilesenemies, 2)
	
	guielements["tilesscrollbar"] = guielement:new("scrollbar", 381, 37, 167, 15, 40, 0, "ver", nil, nil, nil, nil, true)]]
	
	self.elements["scrollbarver"] = guielement:new("scrollbar", self.area[1]-10, self.area[2], self.area[4]-self.area[2], 10, 40, 0, "ver", nil, nil, nil, nil, true)
	self.elements["scrollbarhor"] = guielement:new("scrollbar", self.area[1], self.area[4], self.area[3]-self.area[1], 40, 10, 0, "hor", nil, nil, nil, nil, false)
	
	local args = {}
	for i, v in ipairs(self.buildfrom) do
		table.insert(args, v)
	end
	self.elements["selectdrop"] = guielement:new("dropdown", 15, 20, 15, function(i) self:selectview(i) end, 1, unpack(args))
	self.elements["statustext"] = guielement:new("text", 150, 22, "")
	self.elements["newbutton"] = guielement:new("button", 3, 20, "+", self.newmap, nil, {self})
	--self.elements["savebutton"] = guielement:new("button", 150, 19, "save", self.save, 1, {self})
	
	--self.elements["addtriggerbutton"] = guielement:new("button", 0, 0, "+", self.addtrigger, nil, {self}, nil, 8)
	--self.elements["addtriggerbutton"].textcolor = {0, 200, 0}
	
	--self.elements["addconditionbutton"] = guielement:new("button", 0, 0, "+", self.addcondition, nil, {self}, nil, 8)
	--self.elements["addconditionbutton"].textcolor = {0, 200, 0}
	
	--self.elements["addactionbutton"] = guielement:new("button", 0, 0, "+", self.addaction, nil, {self}, nil, 8)
	--self.elements["addactionbutton"].textcolor = {0, 200, 0}
	
	self:generate()
end

function tiletree:activate()
	self.active = true
	for k,v in pairs(self.elements) do
		v.active = true
	end
	
	self:generate()
end

function tiletree:deactivate()
	self.active = false
	for k,v in pairs(self.elements) do
		v.active = false
	end
end

function tiletree:selectview(i)
	--print("selectview", i, self.buildfrom[i])
	self.elements["selectdrop"].var = i
	self.viewtype = i
	if i==1 then --all
		self.tileliststart = 1
		self.tilelistcount = smbtilecount + portaltilecount + customtilecount -1
		self.contentheight = math.max(0, math.ceil((self.tilelistcount+1)/22)*17 - 1 - (17*9) - 12)
		editentities = false
		editenemies = false
	elseif i==2 then --smb
		animatedtilelist = false
		self.tileliststart = 1
		self.tilelistcount = smbtilecount-1
		self.contentheight = math.max(0, math.ceil((self.tilelistcount+1)/22)*17 - 1 - (17*9) - 12)
		editentities = false
		editenemies = false
	elseif i==3 then --portal
		animatedtilelist = false
		self.tileliststart = smbtilecount + 1
		self.tilelistcount = portaltilecount - 1
		
		self.contentheight = math.max(0, math.ceil((self.tilelistcount+1)/22)*17 - 1 - (17*9) - 12)
		editentities = false
		editenemies = false
	elseif i==4 then --custom
		animatedtilelist = false
		self.tileliststart = smbtilecount + portaltilecount + 1
		self.tilelistcount = customtilecount - 1
		
		self.contentheight = math.max(0, math.ceil((self.tilelistcount+1)/22)*17 - 1 - (17*9) - 12)
		editentities = false
		editenemies = false
	elseif i==5 then --animated
		animatedtilelist = true
		self.tileliststart = 1
		self.tilelistcount = animatedtilecount - 1
		
		self.contentheight = math.max(0, math.ceil((self.tilelistcount+1)/22)*17 - 1 - (17*9) - 12)
		editentities = false
		editenemies = false
	elseif i==6 then --entities
		animatedtilelist = false
		editentities = true
		editenemies = false
		
		currenttile = 1
		
		self:generateentitylist()
	elseif i==7 then --enemies
		animatedtilelist = false
		self.contentheight = math.max(0, math.ceil((#enemiesdata)/22)*17 - 1 - (17*9) - 12)
		editentities = true
		editenemies = true
		
		currenttile = enemies[1]
	end
end

function tiletree:generateentitylist()
	entitylistitems = {}
	for i, v in ipairs(entitylist) do
		if v.t ~= "" and not v.hidden then
			local cat = v.category or "misc"
			
			local cati = 0
			for j = 1, #entitylistitems do
				if entitylistitems[j].t == cat then
					cati = j
					break
				end
			end
			
			if cati == 0 then
				table.insert(entitylistitems, {t=cat, entries={}})
				cati = #entitylistitems
			end
			
			table.insert(entitylistitems[cati].entries, entitylistitem:new(v.t, i))
		end
	end
	
	--sort categories
	table.sort(entitylistitems, function(a, b) return a.t > b.t end)
	
	--calculate X and Y positions..
	local yadd = -3
	for i, v in ipairs(entitylistitems) do
		table.sort(v.entries, function(a, b) return a.t < b.t end)
		
		--Category name space
		yadd = yadd + 14
		
		for j, k in ipairs(v.entries) do
			local x, y = math.mod(j-1, 22)+1, math.ceil(j/22)
			k.x = (x-1)*17
			k.y = (y-1)*17+yadd
		end
		
		yadd = yadd + math.ceil(#v.entries/22)*17
	end
	
	yadd = yadd + 2
	
	self.contentheight = math.max(0, yadd - 1 - (17*9) - 12)
end

function tiletree:generate()
	self:selectview(self.viewtype)
end

function tiletree:updatedropdown() --unused
	local args = {}
	--table.insert(args, self)
	for i, v in ipairs(self.buildfrom) do
		table.insert(args, v)
	end
	
	self.elements["selectdrop"] = guielement:new("dropdown", 15, 20, 15, function(i) self:selectview(i) end, self.viewtype, unpack(args))
end

function tiletree:draw()
	--TILES
	if self.active then
		local id=self.buildfrom[self.viewtype]
		love.graphics.setColor(255, 255, 255)
		
		-- draw an obnoxious checkerboard to illustrate transparency
		love.graphics.draw(self.bgimg, self.bgquad, self.area[1]*scale, self.area[2]*scale, 0)
		
		love.graphics.setScissor(self.area[1]*scale, self.area[2]*scale, (self.area[3]-self.area[1])*scale, (self.area[4]-self.area[2])*scale)
		--love.graphics.setScissor(5*scale, 38*scale, 373*scale, 165*scale)
		
		local offy = self.offy
		--local offx = -math.max(0, self.elements["scrollbarhor"].value/1*(completewidth-(self.area[3]-self.area[1])))
		
		love.graphics.setColor(255, 255, 255)
		--local y = self.area[2]+1-offy
		--y = y + 2
		
		--v.x = self.area[1]+self.lineinset+offx
		--v.y = v.starty - offy
		
		-- draw each individual tile
		if id=="enemies" then
			for i = 1, #enemies do
				local v = enemiesdata[enemies[i]]
				local compx = math.mod((i-1), 22)*17*scale+self.area[1]*scale
				local compy = math.floor((i-1)/22)*17*scale+self.area[2]*scale
				  
				love.graphics.setScissor(compx, compy, 16*scale, 16*scale)
				love.graphics.draw(v.graphic, v.quad, compx, compy-offy, 0, scale, scale)
				love.graphics.setScissor()
			end
		elseif id=="entities" then
			for i, v in ipairs(entitylistitems) do
				local compx = (self.area[1])*scale
				local compy = (v.entries[1].y+self.area[2])*scale
				properprint(v.t, compx, compy-offy-(8*scale))
				for j, k in ipairs(v.entries) do
					local ecompx = (k.x+self.area[1])*scale
					local ecompy = (k.y+self.area[2])*scale
					love.graphics.draw(entityquads[k.i].image, entityquads[k.i].quad, ecompx, ecompy-offy, 0, scale, scale)
					k:calibrate(self.area[1], self.area[2], self.offy)
					if k:gethighlight(mouse.getX(), mouse.getY()) then
						love.graphics.setColor(255, 255, 255, 127)
						love.graphics.rectangle("fill", ecompx, ecompy-offy, 16*scale, 16*scale)
						love.graphics.setColor(255, 255, 255, 255)
					end
				end
			end
		elseif id=="animated" then
			for i = 1, self.tilelistcount+1 do
				local compx = math.mod((i-1), 22)*17*scale+self.area[1]*scale
				local compy = math.floor((i-1)/22)*17*scale+self.area[2]*scale
				
				love.graphics.draw(tilequads[i+self.tileliststart-1+10000].image, tilequads[i+self.tileliststart-1+10000]:quad(), compx, compy-offy, 0, scale, scale)
			end
		else
			-- standard tile sets
			for i = 1, self.tilelistcount+1 do
				local compx = math.mod((i-1), 22)*17*scale+self.area[1]*scale
				local compy = math.floor((i-1)/22)*17*scale+self.area[2]*scale
				
				love.graphics.draw(tilequads[i+self.tileliststart-1].image, tilequads[i+self.tileliststart-1]:quad(), compx, compy-offy, 0, scale, scale)
			end
		end
		
		-- draw selection
		local tile = self:gettilelistpos(mouse.getX(), mouse.getY())
		if id~="entities" then
			if tile and tile <= self.tilelistcount+1 then
				local compx = (self.area[1]+math.mod((tile-1), 22)*17)*scale
				local compy = (self.area[2]+math.floor((tile-1)/22)*17)*scale

				love.graphics.setColor(255, 255, 255, 127)
				love.graphics.rectangle("fill", compx, compy-offy, 16*scale, 16*scale)
			end
		elseif id=="enemies" then
			if tile and tile <= #enemies then
				local compx = (self.area[1]+math.mod((tile-1), 22)*17)*scale
				local compy = (self.area[2]+math.floor((tile-1)/22)*17)*scale
				
				love.graphics.setColor(255, 255, 255, 127)
				love.graphics.rectangle("fill", compx, compy, 16*scale, 16*scale)
			end
		end
		
		-- hover context string
		if true then
			love.graphics.setScissor()
			love.graphics.setColor(255, 255, 255)
			if id=="enemies" and enemies[tile] then --X
				--properprint(enemies[tile], 3*scale, 205*scale)
				self.elements["statustext"].value = enemies[tile]
			elseif id=="entities" then
				local ent = self:getentityhighlight(mouse.getX(), mouse.getY())
				if ent then
					self.elements["statustext"].value = entitylist[ent.i].description or ""
					--local newstring = entitylist[ent.i].description or ""
					--if string.len(newstring) > 49 then
						--newstring = string.sub(newstring, 1, 49) .. "|" .. string.sub(newstring, 50, 98)
					--end
					--properprint(newstring, 3*scale, 205*scale)
				end
			elseif id=="animated" and tile and animatedtiles[tile] then
				--properprint("frames: " .. #animatedtiles[tile].delays, 3*scale, 205*scale)
				local t = 0
				for i = 1, #animatedtiles[tile].delays do
					t = t + animatedtiles[tile].delays[i]
				end
				self.elements["statustext"].value = "frames: "..#animatedtiles[tile].delays..", time: "..t
				--properprint("total time: " .. t, 3*scale, 215*scale)
			elseif tile and tilequads[tile+self.tileliststart-1] then
				local bstring=""
				if tilequads[tile+self.tileliststart-1]:getproperty("collision") then
					--properprint("collision: true", 3*scale, 205*scale)
					bstring=bstring.."solid, "
				--else
					--properprint("collision: false", 3*scale, 205*scale)
				end
				
				if tilequads[tile+self.tileliststart-1]:getproperty("collision") and tilequads[tile+self.tileliststart-1]:getproperty("portalable") then
					bstring=bstring.."portal, "
					--properprint("portalable: true", 3*scale, 215*scale)
				--else
					--properprint("portalable: false", 3*scale, 215*scale)
				end
				self.elements["statustext"].value =bstring
			--else
				--print("WARNING: Tried to draw tile index beyond what is known.")
			end
		end
		
		-- draw the rest of the elements
		love.graphics.setScissor()
		for k, v in pairs(self.elements) do
			v:draw()
		end
		
		--tooltip tooltip uber alles
		if entitylistitems then
			for i, v in ipairs(entitylistitems) do
				for j, k in ipairs(v.entries) do
					--k:calibrate(self.area[1], self.area[2], self.offy)
					--should still be calibrated
					if k:gethighlight(mouse.getX(), mouse.getY()) then
						--love.graphics.setScissor()
						if entitytooltipobject then
							entitytooltipobject:draw(math.max(0, tooltipa))
						end
						--love.graphics.setScissor(self.area[1]*scale, self.area[2]*scale, (self.area[3]-self.area[1])*scale, (self.area[4]-self.area[2])*scale)
					end
				end
			end
		end
	end
end

function tiletree:update(dt)
	--self.tilesoffset = self.elements["scrollbarver"].value * self.contentheight * scale
	self.offy = self.elements["scrollbarver"].value * self.contentheight * scale
	--(math.max(0, self.elements["scrollbarver"].value/1*(self.contentheight-(self.area[4]-self.area[2])))*scale)
	
	local id=self.buildfrom[self.viewtype]
	for i, v in pairs(self.elements) do
		v:update(dt)
	end
	
	if id=="entities" then
		local x, y = mouse.getPosition()
		local tile = self:getentityhighlight(x, y)
		
		if tile ~= prevtile then
			if tile and tooltipimages[tile.i] then
				entitytooltipobject = entitytooltip:new(tile)
			end
		end
		
		if tile and tooltipimages[tile.i] then
			entitytooltipobject:update(dt)
			tooltipa = math.min(255, tooltipa + dt*4000)
		else
			tooltipa = math.max(-1000, tooltipa - dt*4000)
		end
		
		prevtile = tile
	end
end

function tiletree:keypressed(key)
	for i, v in pairs(self.elements) do
		if v:keypress(string.lower(key)) then
			--return
			-- do we /really/ wanna do this?
		end
	end
	
	--[[for k,v in pairs(self.lines) do
		for k2,v2 in pairs(v) do
			v2:keypressed(key)
		end
	end]]
end

function tiletree:gettilelistpos(x, y)
	--new area      {12, 33, 399, 212}
	--original area {4, 37, 375, 167}
	
	--new scissor      {12*scale, 33*scale, 387*scale, 179*scale)
	--original scissor {5*scale, 38*scale, 373*scale, 165*scale}
	
	if x >= self.area[1]*scale and y >= self.area[2]*scale and x < (self.area[3])*scale and y < (self.area[4])*scale then
		x = (x - self.area[1]*scale)/scale
		y = y + self.offy
		y = (y - self.area[2]*scale)/scale
		
		out = math.floor(x/17)+1
		out = out + math.floor(y/17)*22 --@MAGIC: where does 22 come from? I don't know
		
		return out
	end
	
	return false
end

function tiletree:getentityhighlight(x, y)
	if entitylistitems then
		for i, v in ipairs(entitylistitems) do
			for j, k in ipairs(v.entries) do
				k:calibrate(self.area[1], self.area[2], self.offy)
				if k:gethighlight(x, y) then
					return k
				end
			end
		end
	else
		print("WARNING: Editor called tiletree.lua:getentityhighlight() but 'entitylistitems' was not defined.")
	end
end

function tiletree:control_update(dt)
	local x, y = getMousePos()
	local id=self.buildfrom[self.viewtype]
	
	if controls.tap.editorSelect and not testlevel and editormenuopen and editorstate == "tiles" then
		if id=="enemies" then
			local tile = self:gettilelistpos(x, y, offy)
			if tile and tile <= #enemies then
				currenttile = enemies[tile]
				editorclose()
				allowdrag = false
			end
		elseif id=="entities" then
			local tile = self:getentityhighlight(x, y)
			if tile then
				currenttile = tile.i
				editorclose()
				allowdrag = false
			end
		else
			local tile = self:gettilelistpos(x, y)
			-- all tiles
			if tile and tile <= self.tilelistcount+1 then
				if id=="animated" then
					currenttile = tile + self.tileliststart-1+10000
				else
					currenttile = tile + self.tileliststart-1
				end
				
				changeTool("paintdraw", currenttile)
				activeeditortool.allowdrag = false
				
				editorclose()
				allowdrag = false
			end
		end
	end
end

function tiletree:mousepressed(x, y, button)
	for i, v in pairs(self.elements) do
		if v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(self.elements) do
		if not v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	
	-- original
	--[[if mapbuttons then
		for i, v in pairs(mapbuttons) do
			v:click(x, y, button)
		end
	end]]
	
	-- ex
	--[[if self.lines and self.active and not self.elements["selectdrop"].extended then
		local b = false
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do
				if w:haspriority() then
					w:click(x, y, button)
					return
				end
			end
		end
		
		if x >= self.area[1]*scale and y >= self.area[2]*scale and x < self.area[3]*scale and y < self.area[4]*scale then
			self.elements["addtriggerbutton"]:click(x, y, button)
			self.elements["addconditionbutton"]:click(x, y, button)
			self.elements["addactionbutton"]:click(x, y, button)
			
			for i, v in pairs(self.lines) do
				for k, w in pairs(v) do						
					if w:click(x, y, button) then
						return
					end
				end
			end
		end
	end]]
end

function tiletree:mousereleased(x, y, button)
	for i, v in pairs(self.elements) do
		if v.priority then
			if v:unclick(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(self.elements) do
		if not v.priority then
			if v:unclick(x, y, button) then
				return
			end
		end
	end
	
	--[[if self.lines and self.active then
		for i, v in pairs(self.lines) do
			for k, w in pairs(v) do					
				w:unclick(x, y, button)
			end
		end
	end]]
end
end end)()end;
do require("package").preload["gui.onlinemenu"] = (function() local package;return function(...)-- <pack gui.onlinemenu> --
function onlinemenu_load()
	objects = nil
	
	gamestate = "onlinemenu"
	
	localnicks = {"virt. reality", "no fun","smp2","motherducker", "smart9.0","avatar fad", "triple hat",  "a0zora", "99nasela", "wear will", "designer b","camel barrier", "moguri", "automatique", "superiorityman", "mythicalpastry", "not greencandy", "orthobot", "broken turret", "rektic", "honchkrow", "sol sucks", "201", "tortoise59", "wizard cushion"}
	localnick = localnicks[math.random(#localnicks)]

	if love.filesystem.exists("savenick.txt") then
		local returnedtable = love.filesystem.load("savenick.txt")()
		if returnedtable.nick then
			localnick = returnedtable.nick
		end

		for x = 1, #localnicks do
			if localnick == localnicks[x] then
				localnick = localnicks[math.random(#localnicks)]
				break
			end
		end
	end
	
	guielements = {}
	guielements.nickentry = guielement:new("input", 5, 30, 14, nil, localnick, 14, 1)
	
	guielements.configdecrease = guielement:new("button", 192, 31, "{", configdecrease, 0)
	guielements.configincrease = guielement:new("button", 214, 31, "}", configincrease, 0)
	
	
	guielements.ipentry = guielement:new("input", 6, 87, 23, joingame, "", 23, 1)
	guielements.portentry2 = guielement:new("input", 131, 155, 5, nil, "27020", 5, 1, true)
	
	guielements.portentry = guielement:new("input", 274, 87, 5, nil, "27020", 5, 1, true)
	
	guielements.magiccheckbox = guielement:new("checkbox", 220, 147, togglemagic, true)
	
	guielements.hostbutton = guielement:new("button", 247, 199, "create game", creategame, 2)
	guielements.hostbutton.bordercolor = {255, 0, 0}
	guielements.hostbutton.bordercolorhigh = {255, 127, 127}
	
	guielements.joinbutton = guielement:new("button", 61, 199, "join game", joingame, 2)
	guielements.joinbutton.bordercolor = {0, 255, 0}
	guielements.joinbutton.bordercolorhigh = {127, 255, 127}

	guielements.hideip = guielement:new("checkbox", 44, 142, togglehideip, false)
	onlinemenu_hidingip = false
	
	runanimationtimer = 0
	runanimationframe = 1
	runanimationdelay = 0.1
	
	playerconfig = 1
	
	usemagic = true
	
	magictimer = 0
	magicdelay = 0.15
	magics = {}
	hook.Call("GameOnlineMenuLoaded")
end

function onlinemenu_update(dt)
	runanimationtimer = runanimationtimer + dt
	while runanimationtimer > runanimationdelay do
		runanimationtimer = runanimationtimer - runanimationdelay
		runanimationframe = runanimationframe - 1
		if runanimationframe == 0 then
			runanimationframe = 3
		end
	end
	
	magictimer = magictimer + dt
	while magictimer > magicdelay do
		magictimer = magictimer - magicdelay
		if checkmagic(guielements.ipentry.value) then
			table.insert(magics, magic:new())
		end
	end
	
	local delete = {}
	
	for i, v in pairs(magics) do
		if v:update(dt) == true then
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		table.remove(magics, v) --remove
	end
	
	localnick = guielements.nickentry.value
end

function onlinemenu_draw()
	--TOP PART
	love.graphics.setColor(0, 0, 0, 200)
	love.graphics.rectangle("fill", 3*scale, 3*scale, 394*scale, 52*scale)
	love.graphics.setColor(255, 255, 255)
	
	properprint("online play", 4*scale, 5*scale)
	
	properprint("your nick:", 4*scale, 20*scale)
	guielements.nickentry:draw()
	
	properprint("use config", 140*scale, 20*scale)
	properprint("number  " .. playerconfig , 140*scale, 33*scale)
	guielements.configdecrease:draw()
	guielements.configincrease:draw()
	
	drawplayercard(240, 10, mariocolors[playerconfig], mariohats[playerconfig], localnick)
	
	
	--BOTTOM PART
	
	--LEFT (JOIN)
	love.graphics.setColor(0, 0, 0, 200)
	love.graphics.rectangle("fill", 3*scale, 58*scale, 196*scale, 163*scale)
	
	love.graphics.setColor(255, 255, 255)
	properprint("join game", 64*scale, 60*scale)
	
	properprint("address/magicdns", 36*scale, 77*scale)
	guielements.ipentry:draw()
	love.graphics.setColor(150, 150, 150)
	properprint("enter ip, hostname,", 24*scale, 107*scale)
	properprint("domain or magicdns", 28*scale, 117*scale)
	properprint("words to connect.", 32*scale, 127*scale)
	
	love.graphics.setColor(255, 255, 255)
	properprint("optional port:", 21*scale, 158*scale)
	guielements.portentry2:draw()
	
	love.graphics.setColor(150, 150, 150)
	properprint("not needed with", 40*scale, 172*scale)
	properprint("magicdns", 68*scale, 182*scale)
	
	guielements.joinbutton:draw()

	guielements.hideip:draw()

	properprint("hide address", guielements.hideip.x*scale+12*scale, 143*scale)
	
	--RIGHT (HOST)
	love.graphics.setColor(0, 0, 0, 200)
	love.graphics.rectangle("fill", 202*scale, 58*scale, 195*scale, 163*scale)
	
	love.graphics.setColor(255, 255, 255)
	properprint("host game", 260*scale, 60*scale)
	properprint("port", 280*scale, 77*scale)
	
	guielements.portentry:draw()
	
	love.graphics.setColor(150, 150, 150)
	properprint("port will need to", 230*scale, 107*scale)
	properprint("be udp forwarded for", 218*scale, 117*scale)
	properprint("internet play!", 242*scale, 127*scale)
	
	guielements.magiccheckbox:draw()
	properprint("use magicdns words", 230*scale, 148*scale)
	love.graphics.setColor(150, 150, 150)
	properprint("allows friends", 238*scale, 162*scale)
	properprint("to join using", 242*scale, 172*scale)
	properprint("two short words", 234*scale, 182*scale)
	
	guielements.hostbutton:draw()
	
	for i, v in pairs(magics) do
		v:draw()
	end
end

function drawplayercard(x, y, colortable, hattable, nick, ping)
	love.graphics.setColor(0, 0, 0, 255)
	love.graphics.rectangle("fill", (x-1)*scale, (y-1)*scale, 152*scale, 38*scale)
	love.graphics.setColor(255, 255, 255, 255)
	drawrectangle(x, y, 150, 36)

	for i = 0, 3 do
		if i > 0 then
			love.graphics.setColor(unpack(colortable[i]))
		else
			love.graphics.setColor(255, 255, 255)
		end
		--drawplayer(nil, x, y, scale, 0, 0) --, hats, graphic, quad, pointingangle, shot, upsidedown, colors, lastportal, portal1color, portal2color, runframe, swimframe, climbframe, jumpframe, biggraphic, fireanimationtimer, char)
		--drawplayercard(marioanimations[i], mariorun[3][runanimationframe], (x-6)*scale, (y-1)*scale, 0, scale*2)
	end
	love.graphics.setColor(255, 255, 255)

	--[[Scissors just for hat stacks
	local yadd = 0
	local addcolortohat = true

	if (type(hattable) == "table" and #hattable > 1) or hattable[1] ~= 1 then 
		addcolortohat = false
	end

	for i = 1, #hattable do
		if addcolortohat then
			love.graphics.setColor(unpack(colortable[1]))
		end]]
		--local offsets = hatoffsets["running"]
		--love.graphics.draw(hat[hattable[i]].graphic, (x-6)*scale, (y-1)*scale, 0, scale*2, scale*2, - hat[hattable[i]].x + offsets[runanimationframe][1], - hat[hattable[i]].y + offsets[runanimationframe][2] + yadd)
		--yadd = yadd + hat[hattable[i]].height
	--end

	love.graphics.setColor(255, 255, 255)
	properprint(nick, x*scale+35*scale, y*scale+10*scale)

	if not ping then
		love.graphics.setColor(127, 127, 127)
	end
	properprint("ping:", x*scale+35*scale, y*scale+22*scale)
	if not ping then
		properprint("host", x*scale+75*scale, y*scale+22*scale)
	else
		if tonumber(ping) < 40 then
			love.graphics.setColor(0, 255, 0)
		elseif tonumber(ping) >= 40 and tonumber(ping) < 80 then
			love.graphics.setColor(255, 225, 0)
		elseif tonumber(ping) >= 80 then
			love.graphics.setColor(255, 0, 0)
		end
		properprint(ping .. "ms", x*scale+75*scale, y*scale+22*scale)
	end
end

function configdecrease()
	playerconfig = math.max(1, playerconfig-1)
end

function configincrease()
	playerconfig = math.min(4, playerconfig+1)
end

function togglemagic()
	usemagic = not usemagic
	guielements.magiccheckbox.var = usemagic
end

function checkmagic(s)
	if string.find(s, " ") then
		return true
	else
		return false
	end
end

function creategame()
	port = tonumber(guielements.portentry.value)

	if usemagic then
		adjective, noun = magicdns_make()
	end

	if (usemagic and adjective and noun) or not usemagic then
		
		server_load()


		onlinemp = true
		network_load("localhost", port)
	end

end

function joingame()
	local ip, port
	port = tonumber(guielements.portentry2.value)
	local s = guielements.ipentry.value

	if checkmagic(s) then
		usemagic = true
		local split = s:split(" ")
		adjective, noun = split[1], split[2]
		ip, port = magicdns_find(adjective, noun)
		
		if ip == nil then
			notice.new("server not found", notice.red, 5)
			return
		end
	else
		usemagic = false
		ip = guielements.ipentry.value
	end

	onlinemp = true

	
	network_load(ip, port)

end

function togglehideip()
	onlinemenu_hidingip = not onlinemenu_hidingip
	guielements.hideip.var = onlinemenu_hidingip
	guielements.ipentry.hidetext = onlinemenu_hidingip
end

magicdns_validresponses = {"MADE", "KEPT", "REMOVED", "FOUND", "NOTFOUND", "ERROR"}

function magicdns_make()
	http.PORT = port
	s = http.request("http://dns.stabyourself.net/MAKE/" .. magicdns_identity .. "/" .. magicdns_session .. "/" .. port)
	if s then
		result = s:split("/")
		magicdns_error(result)
		
		if result[1] == "MADE" then
			return string.lower(result[2]), string.lower(result[3])
		else
			print("MAGICDNS MAKE FAILED HORRIBLY");
			usemagic = false
			return;
		end
	else
		print("nothing returned")
	end
end

function magicdns_keep()
	s = http.request("http://dns.stabyourself.net/KEEP/"..magicdns_identity.."/"..magicdns_session)
	if s then
		result = s:split("/")
		magicdns_error(result)
		if result[1] ~= "KEPT" then
			print("MAGICDNS KEEP FAILED! RETURNED: " .. s)
		elseif result[2] ~= "" then
			print("MAGICDNS EXTERNAL PORT KNOWN = " .. result[2])
		end
	else
		print("returned nothing")
	end
end

function magicdns_remove()
	s = http.request("http://dns.stabyourself.net/REMOVE/"..magicdns_identity.."/"..magicdns_session)
	if s then
		result = s:split("/")
		magicdns_error(result)
		if result[1] ~= "REMOVED" then
			print("MAGICDNS REMOVE FAILED! RETURNED: " .. s)
		end
	else
		print("returned nothing")
	end
end
	
function magicdns_find(adjective, noun)
	s = http.request("http://dns.stabyourself.net/FIND/" .. magicdns_identity .. "/" .. string.upper(adjective) .. "/" .. string.upper(noun))
	if s then
		local result = s:split("/")
		magicdns_error(result)
		if result[1] == "FOUND" then
			if result[4] == "" then
			print("MAGICDNS Server external port is not known!")
			end		
			return result[2], result[3], result[4]
		else
			return nil
		end
	else
		print("returned nothing")
	end
end

function magicdns_error(result)
	if result[1] == "ERROR" then
		
		print("MAGICDNS ERROR: "..result[2])
		return true
	elseif not table.contains(magicdns_validresponses, result[1]) then
		print("MAGICDNS: nonstandard response: "..result[1])
		return true
	end
	return false
end
end end)()end;
do require("package").preload["player"] = (function() local package;return function(...)-- <pack player> --
player = class("player")

function player:init(x, y, i, animation, size, t)
	print("DEBUG: Player was initialized.")
	if (SERVER or CLIENT) and i ~= netplayernumber then
		self.remote = true
	end
	
	self.alwaysactive = true
	self.char = characters[mariocharacter[i]]
	
	self.playernumber = i or 1
	if bigmario then
		self.size = 1
	else
		self.size = size or 1
	end
	--[[@WARNING:
		this is a bit of a hack but apparently every time a level transition
		happens we destroy our mario to set his position relative to the new world
		
		eventually we wanna use enemiesdata["powerup"] and register each powerup right
	]]
	
	if self.size == 1 then
		self.powerupstate = "small"
		self.powerdowntargetstate = "death"
	elseif self.size == 2 then
		self.powerupstate = "super"
		self.powerdowntargetstate = "small"
	elseif self.size == 3 then
		self.powerupstate = "fire"
		self.powerdowntargetstate = "super"
	end
	self.prefermouse = true
	self.t = t or "portalgun"
	self.activeweapon = nil
	self.weapons = {}
	--[[ { weaponname = reference } ]]
	if _G[self.t] and _G[self.t].isWeapon then
		self.weapons[self.t] = _G[self.t]:new(self)
		self.activeweapon = self.weapons[self.t]
	end
	
	self.portalsavailable = {unpack(portalsavailable)}
	local bindtable 
	if self.playernumber == 1 then
		bindtable = controlTable
		if false then
			bindtable.keys = nil
			bindtable.mouseBtns = nil
		end
	else
		bindtable = {}
	end
	self.binds, self.controls = TLbind.giveInstance(bindtable)
	self.binds.controlPressed = function(control)
		--print("wrap control press")
		self:controlPress(control, false)
	end
	self.binds.controlReleased = function(control)
		--print("wrap control release")
		self:controlRelease(control, false)
	end
	
	--PHYSICS STUFF
	self.speedx = 0
	self.speedy = 0
	self.x = x
	self.width = 12/16
	self.height = 12/16
	self.previouslyonground = true --for start falling
	
	if bigmario then
		self.width = self.width*scalefactor
		self.height = self.height*scalefactor
	end
	
	self.lastground = {0, 0}
	
	self.y = y+1-self.height
	self.moves = true
	self.active = true
	self.category = 3
	self.mask = {	true, 
					false, true, false, false, false,
					false, true, false, false, false,
					false, true, false, false, false,
					false, false, false, false, false,
					false, false, false, false, false,
					false, false, false, false, false}
					
	if playercollisions then
		self.mask[3] = false
	end
	
	self.emancipatecheck = true
	
	--IMAGE STUFF
	if self.portalsavailable[1] or self.portalsavailable[2] or not self.char.nogunanimations then
		self.smallgraphic = self.char.animations
		self.biggraphic = self.char.biganimations
	else
		self.smallgraphic = self.char.nogunanimations
		self.biggraphic = self.char.nogunbiganimations
	end
	self.outofboundstimer = 0
	self.drawable = true
	self.quad = self.char.idle[3]
	self.colors = mariocolors[self.playernumber]
	self.customscale = self.char.customscale
	if self.size == 1 then
		self.offsetX = self.char.smalloffsetX
		self.offsetY = self.char.smalloffsetY
		self.quadcenterX = self.char.smallquadcenterX
		self.quadcenterY = self.char.smallquadcenterY
		
		self.graphic = self.smallgraphic
	else
		self.graphic = self.biggraphic
		
		self.quadcenterY = self.char.bigquadcenterY
		self.quadcenterX = self.char.bigquadcenterX
		self.offsetY = self.char.bigoffsetY
		self.offsetX = self.char.bigoffsetX
		
		self.y = self.y - 12/16
		self.height = 24/16
		
		if self.size == 3 then
			self.colors = self.char.flowercolor or flowercolor
		end
	end
	
	if bigmario then
		self.offsetX = self.offsetX*scalefactor
		self.offsetY = self.offsetY*-scalefactor
	end
	
	--hat
	self.hats = mariohats[self.playernumber]
	self.drawhat = true
	
	--Change height according to hats
	
	--for i = 1, #self.hats do
		--self.height = self.height + (hat[self.hats[i]].height/16)
		--self.y = self.y - (hat[self.hats[i]].height/16)
		--self.offsetY = self.offsetY - hat[self.hats[i]].height
	--end
	
	self.customscissor = false
	
	if players == 1 and not arcade then
		self.portal1color = {60, 188, 252}
		self.portal2color = {232, 130, 30}
	else
		self.portal1color = portalcolor[self.playernumber][1]
		self.portal2color = portalcolor[self.playernumber][2]
	end
	
	if self.portalsavailable[1] then
		self.lastportal = 1
	elseif self.portalsavailable[2] then
		self.lastportal = 2
	end
	
	--OTHER STUFF!
	self.controlsenabled = true
	
	self.runframe = self.char.runframes
	self.jumpframe = 1
	self.swimframe = 1
	self.climbframe = 1
	self.runanimationprogress = 1
	self.jumpanimationprogress = 1
	self.swimanimationprogress = 1
	self.animationstate = "idle" --idle, running, jumping, falling, swimming, sliding, climbing, dead
	self.animationdirection = "right" --left, right. duh
	self.platform = false
	-- we're redoing the combo system to be generic
	self.killstreak = 0
	self.combos = {
		stomp = 1,
		shell = 1,
	}
	if not portals[self.playernumber] then
		portals[self.playernumber] = portal:new(self.playernumber, self.portal1color, self.portal2color, self)
	end
	self.portal = portals[self.playernumber]
	self.rotation = 0 --for portals
	self.pointingangle = -math.pi/2
	self.animationdirection = "right"
	self.passivemoved = false
	self.ducking = false
	self.invincible = false
	self.rainboomallowed = true
	self.looktimer = 0
	self.raccoonstarttimer = 0
	self.raccoontimer = 0
	self.raccoonascendtimer = 0
	self.tailwagframe = 1
	self.tailwagtimer = 0
	
	-- PROJECT: LOCALIZE THEM GLOBALS
	self.coins = 0
	self.lives = 3
	self.score = 0
	
	self.gravitydirection = math.pi/2
	
	self.animation = globalanimation or false --pipedown, piperight, pipeup, flag, vine, intermission
	self.animationx = false
	self.animationy = false
	self.animationtimer = 0
	
	self.falling = false
	self.jumping = false
	self.running = false
	self.walking = false
	self.starred = false
	self.dead = false
	self.vine = false
	self.spring = false
	self.startimer = mariostarduration
	self.starblinktimer = mariostarblinkrate
	self.starcolori = 1
	self.fireballcount = 0
	self.fireanimationtimer = fireanimationtime
	
	self.mazevar = 0
	
	self.bubbletimer = 0
	self.bubbletime = bubblestime[math.random(#bubblestime)]
	
	self.underwater = underwater
	if self.underwater then
		self:dive(true)
	end
	
	if self.animation == "intermission" and editormode then
		self.animation = false
	end
	
	if mariolivecount ~= false and self.lives <= 0 then
		self.dead = true
		self.drawable = false
		self.active = false
		self.moves = false
		self.controlsenabled = false
		self.animation = false
	end
	
	if self.animation == "pipe_up_out" then
		self.controlsenabled = false
		self.active = false
		self.animationx = x
		self.animationy = y
		self.customscissor = {x-2.5, y-4, 6, 4}
		self.y = self.animationy + 20/16
		
		self.animationstate = "idle"
		self:setquad()
		
		if self.size > 1 then
			self.animationy = y - 12/16
		end
		
		if arcade and not arcadeplaying[self.playernumber] then
			self.y = self.animationy + 20/16 - pipeanimationdistancedown
			self.animation = false
		end
	elseif self.animation == "pipe_down_out" then
		self.controlsenabled = false
		self.active = false
		self.animationx = x
		self.animationy = y
		self.customscissor = {x-2.5, y-4, 6, 4}
		self.y = self.animationy + 20/16
		
		self.animationstate = "idle"
		self:setquad()
		
		if self.size > 1 then
			self.animationy = y - 12/16
		end
		
		if arcade and not arcadeplaying[self.playernumber] then
			self.y = self.animationy + 20/16 - pipeanimationdistancedown
			self.animation = false
		end
	elseif self.animation == "pipe_right_out" then
		self.controlsenabled = false
		self.active = false
		self.animationx = x-2
		self.animationy = y
		self.customscissor = {x+(6/16), y-5, 2, 6}
		--self.y = self.animationy + 20/16
		self.x = self.animationx - 28/16 --+ pipeanimationdistanceright
		--self.x = self.animationx
		
		self.animationstate = "running"
		self:setquad()
		
		if self.size > 1 then
			self.animationy = y - 12/16
		end
		
		--[[if arcade and not arcadeplaying[self.playernumber] then
			self.y = self.animationy + 20/16 - pipeanimationdistancedown
			self.animation = false
		end]]
	elseif self.animation == "pipe_left_out" then
		self.controlsenabled = false
		self.active = false
		self.animationx = x
		self.animationy = y
		self.customscissor = {x-2+(6/16), y-5, -2, 6}
		--self.y = self.animationy + 20/16
		--self.x = self.animationx + 28/16 --+ pipeanimationdistanceright
		
		self.animationstate = "running"
		self:setquad()
		
		if self.size > 1 then
			self.animationy = y - 12/16
		end
		
		--[[if arcade and not arcadeplaying[self.playernumber] then
			self.y = self.animationy + 20/16 - pipeanimationdistancedown
			self.animation = false
		end]]
	elseif self.animation == "intermission" then
		self.controlsenabled = false
		self.active = true
		self.gravity = mariogravity
		self.animationstate = "running"
		self.speedx = 2.61
		self.pointingangle = -math.pi/2
		self.animationdirection = "right"
	elseif self.animation == "vinestart" then
		self.controlsenabled = false
		self.active = false
		self.pointingangle = -math.pi/2
		self.animationdirection = "right"
		self.climbframe = 2
		self.animationstate = "climbing"
		self:setquad()
		self.x = 4-3/16
		self.y = 15+0.4*(self.playernumber-1)
		self.vineanimationclimb = false
		self.vineanimationdropoff = false
		self.vinemovetimer = 0
		
		if #objects["vine"] == 0 then
			--@DEV: Does this ever happen? Does this ever *not* happen?
			table.insert(objects["vine"], vine:new(5, 16, "start"))
		end
	end
	self:setquad()
end


function player:controlPress(control, fromnetwork)
	if onlinemp and not fromnetwork then
		client_send("controlupdate", {control=control,direction="press"})
	end
	if fromnetwork then
		print("network-pressed: "..control)
		self.controls[control]=true
		self.controls.tap[control]=true
		self.controls.release[control]=true
	else
		--print("pressed: "..control)
	end
	if control=="playerJump" then
		self:jump()
	elseif control=="playerDebug" then
		playsound("shrink", 1, 1)
		killfeed.new({objects["enemy"][1],objects["enemy"][2]}, "physics", objects["enemy"][3])
		savemap2(currentmap)
		--debugbox()
		print("oh boy I'm a test")
	elseif control=="playerRun" then
		self:fire()
	elseif control=="playerReload" then
		self:removeportals()
	elseif control=="playerUse" then
		self:use()
	elseif control=="playerSuicide" then
		self:murder(self, "suicide", "Suicide")
	elseif control=="playerLeft" then
		self:leftkey()
	elseif control=="playerRight" then
		self:rightkey()
	elseif control=="playerPrimaryFire" then
		if self.activeweapon and (not editormode or testlevel) then 
			self.activeweapon:primaryFire()
		end
	elseif control=="playerSecondaryFire" then
		if self.activeweapon and (not editormode or testlevel) then 
			self.activeweapon:secondaryFire()
		end
	end
end
function player:controlRelease(control, fromnetwork)
	if onlinemp and not fromnetwork then
		client_send("controlupdate", {control=control,direction="release"})
	end
	if fromnetwork then
		print("network-released: "..control)
		self.controls[control]=false
		self.controls.tap[control]=false
		self.controls.release[control]=false
	else
		--print("released: "..control)
	end
	if control=="playerJump" then
		self:stopjump()
	end
end

function player:adddata()
	--i, x, y, cscale,     offsetX, offsetY, rotation, quadcenterX, quadcenterY, animationstate, underwater, ducking, hats, graphic, quad, pointingangle, shot, upsidedown, colors, lastportal, portal1color, portal2color)
	
	--local colors = {}
	--for i = 1, #self.colors do
	--	colors[i] = {unpack(self.colors[i])}
	--end
	
	table.insert(livereplaydata[self.playernumber], {time=love.timer.getTime()-livereplaytimer})
	
	local data = {
		x=self.x,
		y=self.y,
		offsetX=self.offsetX,
		offsetY=self.offsetY,
		rotation=self.rotation,
		quadcenterX=self.quadcenterX,
		quadcenterY=self.quadcenterY,
		animationstate=self.animationstate,
		underwater=self.underwater,
		ducking=self.ducking,
		--hats={unpack(self.hats)}, --!
		pointingangle=self.pointingangle,
		--shot=self.shot, --!
		--upsidedown=self.upsidedown, --!
		colors=self.colors, --!
		--lastportal=self.lastportal, --!
		--portal1color={unpack(self.portal1color)}, --!
		--portal2color={unpack(self.portal2color)}, --!
		runframe=self.runframe,
		jumpframe=self.jumpframe,
		climbframe=self.climbframe,
		swimframe=self.swimframe,
		fireanimationtimer=self.fireanimationtimer,
		size=self.size,
		drawable=self.drawable,
		customscissor=self.customscissor,
		world=marioworld,
		level=mariolevel,
		sublevel=mariosublevel,
		animationdirection=self.animationdirection
	}
	
	for i, v in pairs(data) do
		if livereplaystored[self.playernumber][i] == nil or livereplaystored[self.playernumber][i] ~= v then
			livereplaydata[self.playernumber][#livereplaydata[self.playernumber]][i] = v
			livereplaystored[self.playernumber][i] = v
		end
	end
end

function player:update(dt)
	if self.binds.update and self.controls and self.playernumber == 1 then
		self.binds:update()
	end
	
	if self.animationdirection == "right" and self.speedx > maxwalkspeed then --Checks for running movement
		self.running = true
		self.walking = true
	elseif self.animationdirection == "left" and self.speedx < -maxwalkspeed then
		self.running = true
		self.walking = true
	elseif self.animationdirection == "right" and self.speedx > maxwalkspeed/3 then 
		self.running = false
		self.walking = true
	elseif self.animationdirection == "left" and self.speedx < -maxwalkspeed/3 then
		self.running = false
		self.walking = true
	else
		self.running = false
		self.walking = false
	end
	
	-- this is handled in the giant objects iterable
	--[[if self.activeweapon then
		self.activeweapon:update(dt)
	end]]
	
	if replaysystem then
		livereplaydelay[self.playernumber] = livereplaydelay[self.playernumber] + dt
		while livereplaydelay[self.playernumber] >= 1/60 do
			self:adddata()
			livereplaydelay[self.playernumber] = livereplaydelay[self.playernumber] - 1/60
		end
	end
	
	self.passivemoved = false
	self.rotation = unrotate(self.rotation, self.gravitydirection, dt)
	
	--Tailwag!
	if self.char.raccoon and (self.tailwag or self.tailwagtimer > 0) then
		if self.tailwagtimer == 0 then
			self.tailwag = false
			playsound("tailwag", self.x, self.y, self.speedx, self.speedy)
		end
		self.tailwagtimer = self.tailwagtimer + dt
		while self.tailwagtimer > raccoontailwagdelay do
			self.tailwagframe = self.tailwagframe + 1
			self.tailwagtimer = self.tailwagtimer - raccoontailwagdelay
			if self.tailwagframe > 3 then
				self.tailwagframe = 1
				self.tailwagtimer = 0
			end
		end
	end
	
	--Spin!
	if self.char.raccoon and self.raccoonspinframe then
		if self.raccoonspintimer == 0 then
			playsound("tailwag", self.x, self.y, self.speedx, self.speedy)
		end
		self.raccoonspintimer = self.raccoonspintimer + dt
		while self.raccoonspintimer > raccoonspindelay and self.raccoonspinframe do
			self.raccoonspintimer = self.raccoonspintimer - raccoonspindelay
			self.raccoonspinframe = self.raccoonspinframe + 1
			if self.raccoonspinframe >= 4 then
				self.raccoonspinframe = false
			end
		end
	end
	
	if self.startimer < mariostarduration and not self.dead then
		self.startimer = self.startimer + dt
		self.starblinktimer = self.starblinktimer + dt
		
		local lmariostarblinkrate = mariostarblinkrate
		if self.startimer >= mariostarduration-mariostarrunout then
			lmariostarblinkrate = mariostarblinkrateslow
		end

		while self.starblinktimer > lmariostarblinkrate do
			self.starcolori = self.starcolori + 1
			if self.starcolori > 4 then
				self.starcolori = self.starcolori - 4
			end
			self.colors = starcolors[self.starcolori]
			
			self.starblinktimer = self.starblinktimer - lmariostarblinkrate
		end
		
		if self.startimer >= mariostarduration-mariostarrunout and self.startimer-dt < mariostarduration-mariostarrunout then
			--check if another starman is playing
			local starstill = false
			for i = 1, players do
				if i ~= self.playernumber and objects["player"][i].starred then
					starstill = true
				end
			end
			
			if not starstill and not levelfinished then
				playmusic()
				music:stop("starmusic.ogg")
			end
		end
		
		if self.startimer >= mariostarduration then
			if self.size == 3 then --flower colors
				self.colors = self.char.flowercolor or flowercolor
			else
				self.colors = mariocolors[self.playernumber]
			end
			self.starred = false
			self.startimer = mariostarduration
		end
	end
	
	if self.jumping then
		if self.underwater then
			self.gravity = uwyaccelerationjumping
		else
			self.gravity = yaccelerationjumping
		end
		
		if self.speedy > 0 then
			self.jumping = false
			self.falling = true
		end
	else
		if self.underwater then
			self.gravity = uwyacceleration
		else
			self.gravity = yacceleration
		end
	end
	
	if self.size ~= 1 then
		self.gravitydirection = math.pi/2
	end
	
	--animationS
	if self.animation == "animationwalk" then
		if self.animationmisc == "right" then
			self.speedx = maxwalkspeed
		else
			self.speedx = -maxwalkspeed
		end
		self:runanimation(dt)
		self:setquad()
		return
	elseif self.animation == "pipe_down_in" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeanimationtime then
			self.y = self.animationy - 28/16 + self.animationtimer/pipeanimationtime*pipeanimationdistancedown
		else
			self.y = self.animationy - 28/16 + pipeanimationdistancedown
			
			if self.animationtimer >= pipeanimationtime+pipeanimationdelay then
				updatesizes()
				seek_level(self.animationmisc[3], self.animationmisc[4], self.animationmisc[5], self.animationmisc[7], self.animationmisc[9])
			end
		end
		return
	elseif self.animation == "pipe_down_out" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeupdelay then
		
		elseif self.animationtimer < pipeanimationtime+pipeupdelay then
			self.y = self.animationy - 20/16 + (self.animationtimer-pipeupdelay)/pipeanimationtime*pipeanimationdistancedown
		else
			self.y = self.animationy - 20/16 + pipeanimationdistancedown
			
			if self.animationtimer >= pipeanimationtime then
				self.active = true
				self.controlsenabled = true
				self.animation = false
				self.customscissor = false
			end
		end
		return
	elseif self.animation == "pipe_up_in" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeanimationtime then
			self.y = self.animationy + 20/16 - (self.animationtimer)/pipeanimationtime*pipeanimationdistancedown
		else
			self.y = self.animationy + 20/16 - pipeanimationdistancedown
			
			if self.animationtimer >= pipeanimationtime+pipeanimationdelay then
				updatesizes()
				seek_level(self.animationmisc[3], self.animationmisc[4], self.animationmisc[5], self.animationmisc[7], self.animationmisc[9])
			end
		end
		return
	elseif self.animation == "pipe_up_out" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeupdelay then
		
		elseif self.animationtimer < pipeanimationtime+pipeupdelay then
			self.y = self.animationy + 20/16 - (self.animationtimer-pipeupdelay)/pipeanimationtime*pipeanimationdistancedown
		else
			self.y = self.animationy + 20/16 - pipeanimationdistancedown
			
			if self.animationtimer >= pipeanimationtime then
				self.active = true
				self.controlsenabled = true
				self.animation = false
				self.customscissor = false
			end
		end
		return
	elseif self.animation == "pipe_right_in" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeanimationtime then
			self.x = self.animationx - 28/16 + self.animationtimer/pipeanimationtime*pipeanimationdistanceright
			
			--Run animation
			if self.animationstate == "running" then
				self:runanimation(dt)
			end
			self:setquad()
		else
			self.x = self.animationx - 28/16 + pipeanimationdistanceright
			
			if self.animationtimer >= pipeanimationtime+pipeanimationdelay then
				updatesizes()
				seek_level(self.animationmisc[3], self.animationmisc[4], self.animationmisc[5], self.animationmisc[7], self.animationmisc[9])
			end
		end
		return
	elseif self.animation == "pipe_right_out" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeupdelay then
		
	elseif self.animationtimer < pipeanimationtime+pipeupdelay then
			self.x = self.animationx + self.animationtimer/pipeanimationtime*pipeanimationdistanceright
			--self.x = self.animationx - self.animationtimer/pipeanimationtime*pipeanimationdistanceright
			--Run animation
			if self.animationstate == "running" then
				self:runanimation(dt)
			end
			self:setquad()
		else
			--self.x = self.animationx + pipeanimationdistanceright
			--the x at this point is at the mercy of the timer of previous iterations
			
			if self.animationtimer >= pipeanimationtime+pipeanimationdelay then
				self.active = true
				self.controlsenabled = true
				self.animation = false
				self.customscissor = false
			end
		end
		return
	elseif self.animation == "pipe_left_in" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeanimationtime then
			self.x = self.animationx - self.animationtimer/pipeanimationtime*pipeanimationdistanceright
			
			--Run animation
			if self.animationstate == "running" then
				self:runanimation(dt)
			end
			self:setquad()
		else
			self.x = self.animationx - pipeanimationdistanceright
			
			if self.animationtimer >= pipeanimationtime+pipeanimationdelay then
				updatesizes()
				seek_level(self.animationmisc[3], self.animationmisc[4], self.animationmisc[5], self.animationmisc[7], self.animationmisc[9])
			end
		end
		return
	elseif self.animation == "pipe_left_out" and self.animationy and self.animationx then
		self.animationtimer = self.animationtimer + dt
		if self.animationtimer < pipeupdelay then
		
		elseif self.animationtimer < pipeanimationtime+pipeupdelay then
			self.x = self.animationx - self.animationtimer/pipeanimationtime*pipeanimationdistanceright
			
			--Run animation
			if self.animationstate == "running" then
				self:runanimation(dt)
			end
			self:setquad()
		else
			--self.x = self.animationx - pipeanimationdistanceright
			
			if self.animationtimer >= pipeanimationtime+pipeanimationdelay then
				self.active = true
				self.controlsenabled = true
				self.animation = false
				self.customscissor = false
			end
		end
		return
	elseif self.animation == "flag" and flagx then
		if self.animationtimer < flagdescendtime then 	
			flagimgy = flagy-10+1/16 + flagydistance * (self.animationtimer/flagdescendtime)
			self.y = self.y + flagydistance/flagdescendtime * dt
			
			self.animationtimer = self.animationtimer + dt
				
			if self.y > flagy-9+4/16 + flagydistance-self.height then
				self.y = flagy-9+4/16 + flagydistance-self.height
				self.climbframe = 2
			else
				if math.mod(self.animationtimer, flagclimbframedelay*2) >= flagclimbframedelay then
					self.climbframe = 1
				else
					self.climbframe = 2
				end
			end
			
			self.animationstate = "climbing"
			self:setquad()
			
			if self.animationtimer >= flagdescendtime then
				flagimgy = flagy-10+1/16 + flagydistance
				self.pointingangle = math.pi/2
				self.animationdirection = "left"
				self.x = flagx + 6/16
			end
			return
		elseif self.animationtimer < flagdescendtime+flaganimationdelay then
			self.animationtimer = self.animationtimer + dt
			
			if self.animationtimer >= flagdescendtime+flaganimationdelay then
				self.active = true
				self.gravity = mariogravity
				self.animationstate = "running"
				self.speedx = 4.27
				self.pointingangle = -math.pi/2
				self.animationdirection = "right"
			end
		else
			self.animationtimer = self.animationtimer + dt
		end
		
		local add = 6
		
		if (self.x >= flagx + add or self.speedx < maxwalkspeed/2) and self.active then
			self.drawable = false
			self.active = false
			if mariotime > 0 then
				playsound("scorering", self.x, self.y, self.speedx, self.speedy)
				subtractscore = true
				subtracttimer = 0
			else
				castleflagmove = true
			end
		end
		
		if subtractscore == true and mariotime >= 0 then
			subtracttimer = subtracttimer + dt
			while subtracttimer > scoresubtractspeed do
				subtracttimer = subtracttimer - scoresubtractspeed
				if mariotime > 0 then
					mariotime = math.ceil(mariotime - 1)
					self.score = self.score + 50
				end
				
				if mariotime <= 0 then
					subtractscore = false
					soundlist["scorering"].source:stop()
					castleflagmove = true
					mariotime = 0
				end
			end
		end
		
		if castleflagmove then
			if self.animationtimer < castlemintime then
				castleflagtime = self.animationtimer
				return
			end
			castleflagy = castleflagy - castleflagspeed*dt
			
			if castleflagy <= 0 then
				castleflagy = 0
				castleflagmove = false
				dofirework = true
				castleflagtime = self.animationtimer
			end
		end
		
		if dofirework then
			local timedelta = self.animationtimer - castleflagtime
			for i = 1, fireworkcount do
				local fireworktime = i*fireworkdelay
				if timedelta >= fireworktime and timedelta - dt < fireworktime then
					table.insert(objects["firework"], firework:new(flagx+6, flagy-13, self))
				end
			end
			
			if timedelta > fireworkcount*fireworkdelay+endtime then
				nextlevel()
				return
			end
		end
		
		--500 points per firework, appear at 1 3 and 6 (Who came up with this?)
		
		--Run animation
		if self.animationstate == "running" then
			self:runanimation(dt)
			self:setquad()
		end
		return
	
	elseif self.animation == "axe" then
		self.animationtimer = self.animationtimer + dt
		
		if not bowserfall and self.animationtimer - dt < castleanimationchaindisappear and self.animationtimer >= castleanimationchaindisappear then
			bridgedisappear = true
		end
		
		if bridgedisappear then
			local v = objects["bowser"][1]
			if v then
				v.walkframe = round(math.mod(self.animationtimer, castleanimationbowserframedelay*2)*(1/(castleanimationbowserframedelay*2)))+1
			end
			self.animationtimer2 = self.animationtimer2 + dt
			while self.animationtimer2 > castleanimationbridgedisappeardelay and self.animationbridgex > 0 do
				self.animationtimer2 = self.animationtimer2 - castleanimationbridgedisappeardelay
				local removedtile = true
			--	for y = 1, mapheight do
			--		if tilequads[map[self.animationbridgex][y][1]]:getproperty("bridge", self.animationbridgex, y) then
			--			removedtile = true
			--			map[self.animationbridgex][y][1] = 1
			--			objects["tile"][self.animationbridgex .. "-" .. y] = nil
			--		end
			--	end
				
				if removedtile then
					generatespritebatch()
			--		playsound("bridgebreak")
					self.animationbridgex = self.animationbridgex - 1
				else
					bowserfall = true
					bridgedisappear = false
				end
			end
		end
		
		if bowserfall then
			local v = objects["bowser"][1]
			if v and not v.fall then
				v.fall = true
				v.speedx = 0
				v.speedy = 0
				v.active = true
				v.gravity = 27.5
				playsound("bowserfall", v.x, v.y, v.speedx, v.gravity) --gravity doesn't get factored into speedy, which is a problem
				self.animationtimer = 0
				return
			end
		end
		
		if bowserfall and self.animationtimer - dt < castleanimationmariomove and self.animationtimer >= castleanimationmariomove then
			self.active = true
			self.gravity = mariogravity
			self.animationstate = "running"
			self.speedx = 4.27
			self.pointingangle = -math.pi/2
			self.animationdirection = "right"
		
			love.audio.stop()
			playsound("castleend", self.x, self.y) --technically not aligned to the axe, but, we don't care
		end
		
		if self.speedx > 0 and self.x >= mapwidth - 8 then
			self.x = mapwidth - 8
			self.animationstate = "idle"
			self:setquad()
			self.speedx = 0
		end
		
		if levelfinishedmisc2 == 1 then
			if self.animationtimer - dt < castleanimationtextfirstline and self.animationtimer >= castleanimationtextfirstline then
				levelfinishedmisc = 1
			end
			
			if self.animationtimer - dt < castleanimationtextsecondline and self.animationtimer >= castleanimationtextsecondline then
				levelfinishedmisc = 2
			end
		
			if self.animationtimer - dt < castleanimationnextlevel and self.animationtimer >= castleanimationnextlevel then
				nextlevel()
			end
		else
			if self.animationtimer - dt < endanimationtextfirstline and self.animationtimer >= endanimationtextfirstline then
				levelfinishedmisc = 1
			end
			
			if self.animationtimer - dt < endanimationtextsecondline and self.animationtimer >= endanimationtextsecondline then
				levelfinishedmisc = 2
				love.audio.stop()
				music:play("princessmusic.ogg")
			end
		
			if self.animationtimer - dt < endanimationtextthirdline and self.animationtimer >= endanimationtextthirdline then
				levelfinishedmisc = 3
			end
			
			if self.animationtimer - dt < endanimationtextfourthline and self.animationtimer >= endanimationtextfourthline then
				levelfinishedmisc = 4
			end
			
			if self.animationtimer - dt < endanimationtextfifthline and self.animationtimer >= endanimationtextfifthline then
				levelfinishedmisc = 5
			end
		
			if self.animationtimer - dt < endanimationend and self.animationtimer >= endanimationend then
				endpressbutton = true
			end
		end
		
		--Run animation
		if self.animationstate == "running" and self.animationtimer >= castleanimationmariomove then
			self:runanimation(dt)
			self:setquad()
		end
		return
		
	elseif self.animation == "death" or self.animation == "deathpit" then
		self.animationtimer = self.animationtimer + dt
		self.animationstate = "dead"
		self:setquad()
		
		if self.animation == "death" then
			if self.animationtimer >= deathanimationjumptime then
				if self.animationtimer - dt < deathanimationjumptime then
					self.speedy = -deathanimationjumpforce
				end
				self.speedy = self.speedy + deathgravity*dt
				self.y = self.y + self.speedy*dt
			end
		end
		
		if self.animationtimer > deathtotaltime then
			if self.animationmisc == "everyonedead" then
				levelscreen_load("death")
			elseif not everyonedead then
				self:respawn()
			end
		end
		
		return
	elseif self.animation == "intermission" then
		--Run animation
		if self.animationstate == "running" then
			self:runanimation(dt)
			self:setquad()
		end
		
		return
		
	elseif self.animation == "vine" then
		self.y = self.y - vinemovespeed*dt
		
		self.vinemovetimer = self.vinemovetimer + dt
		
		self.climbframe = math.ceil(math.mod(self.vinemovetimer, vineframedelay*2)/vineframedelay)
		self.climbframe = math.max(self.climbframe, 1)
		self:setquad()
		
		if self.y < -4 then
			levelscreen_load("vine", self.animationmisc)
		end
		return
	elseif self.animation == "vinestart" then
		self.animationtimer = self.animationtimer + dt
		if self.vineanimationdropoff == false and self.animationtimer - dt <= vineanimationmariostart and self.animationtimer > vineanimationmariostart then
			self.vineanimationclimb = true
		end
		
		if self.vineanimationclimb then
			self.vinemovetimer = self.vinemovetimer + dt
			
			self.climbframe = math.ceil(math.mod(self.vinemovetimer, vineframedelay*2)/vineframedelay)
			self.climbframe = math.max(self.climbframe, 1)
			
			self.y = self.y - vinemovespeed*dt
			if self.y <= 15-vineanimationgrowheight+vineanimationstop+0.4*(self.playernumber-1) then
				self.vineanimationclimb = false
				self.vineanimationdropoff = true
				self.animationtimer = 0
				self.y = 15-vineanimationgrowheight+vineanimationstop+0.4*(self.playernumber-1)
				self.climbframe = 2
				self.pointingangle = math.pi/2
				self.animationdirection = "left"
				self.x = self.x+9/16
			end
			self:setquad()
		end
		
		if self.vineanimationdropoff and self.animationtimer - dt <= vineanimationdropdelay and self.animationtimer > vineanimationdropdelay then
			self.active = true
			self.controlsenabled = true
			self.x = self.x + 7/16
			self.animation = false
		end
		
		return
	
	elseif self.animation == "shrink" then
		self.animationtimer = self.animationtimer + dt
		--set frame lol
		local frame = math.ceil(math.mod(self.animationtimer, growframedelay*3)/shrinkframedelay)
	
		if frame == 1 then
			self.graphic = self.biggraphic
			self:setquad("idle", 2)
			self.quadcenterY = self.char.shrinkquadcenterY
			self.quadcenterX = self.char.shrinkquadcenterX
			self.offsetY = self.char.bigoffsetY
			self.animationstate = "idle"
		else
			self.graphic = self.smallgraphic
			self.quadcenterX = self.char.smallquadcenterX
			self.offsetY = self.char.smalloffsetY
			if frame == 2 then
				self.animationstate = "grow"
				self:setquad("grow")
				self.quadcenterY = self.char.shrinkquadcenterY2
			else
				self.animationstate = "idle"
				self:setquad()
				self.quadcenterY = self.char.smallquadcenterY
			end
		end
		
		local invis = math.ceil(math.mod(self.animationtimer, invicibleblinktime*2)/invicibleblinktime)
		
		if invis == 1 then
			self.drawable = true
		else
			self.drawable = false
		end
		
		if self.animationtimer - dt < shrinktime and self.animationtimer > shrinktime then
			self:goinvincible()
		end
		return
	elseif self.animation == "invincible" then
		self.animationtimer = self.animationtimer + dt
		
		local invis = math.ceil(math.mod(self.animationtimer, invicibleblinktime*2)/invicibleblinktime)
		
		if invis == 1 then
			self.drawable = true
		else
			self.drawable = false
		end
		
		if self.animationtimer - dt < invincibletime and self.animationtimer > invincibletime then
			self.animation = false
			self.invincible = false
			self.drawable = true
		end
		
	elseif self.animation == "grow1" then
		self.animationtimer = self.animationtimer + dt
		--set frame lol
		local frame = math.ceil(math.mod(self.animationtimer, growframedelay*3)/growframedelay)
		
		if frame == 3 then
			self.animationstate = "idle"
			self.graphic = self.biggraphic
			self:setquad("idle")
			self.quadcenterY = self.char.bigquadcenterY
			self.quadcenterX = self.char.bigquadcenterX
			self.offsetY = self.char.bigoffsetY
		else
			self.graphic = self.smallgraphic
			self.quadcenterX = self.char.smallquadcenterX
			self.offsetY = self.char.smalloffsetY
			if frame == 2 then
				self.animationstate = "grow"
				self:setquad("grow", 1)
				self.quadcenterY = self.char.growquadcenterY
			else
				self.animationstate = "idle"
				self:setquad(nil, 1)
				self.quadcenterY = self.char.growquadcenterY2
			end
		end
		
		if self.animationtimer - dt < growtime and self.animationtimer > growtime then
			self.animationstate = self.animationmisc
			self.animation = false
			noupdate = false
			self.quadcenterY = self.char.bigquadcenterY
			self.graphic = self.biggraphic
			self.animationtimer = 0
			self.quadcenterX = self.char.bigquadcenterX
			self.offsetY = self.char.bigoffsetY
		end
		return
		
	elseif self.animation == "grow2" then
		self.animationtimer = self.animationtimer + dt
		--set frame lol
		local frame = math.ceil(math.mod(self.animationtimer, growframedelay*3)/growframedelay)
		self.colors = starcolors[frame]
		
		if self.animationtimer - dt < growtime and self.animationtimer > growtime then
			self.animation = false
			noupdate = false
			self.animationtimer = 0
			self.colors = self.char.flowercolor or flowercolor
		end
		return
	end
	
	if noupdate then
		return
	end
	
	if self.fireanimationtimer < fireanimationtime then
		self.fireanimationtimer = self.fireanimationtimer + dt
		if self.fireanimationtimer > fireanimationtime then
			self.fireanimationtimer = fireanimationtime
		end
	end
	
	--Funnels and fuck
	if self.funnel and not self.infunnel then
		self:enteredfunnel(true)
	end
	
	if self.infunnel and not self.funnel then
		self:enteredfunnel(false)
	end
	
	if self.funnel then
		self.animationstate = "jumping"
		self:setquad()
	end
	
	self.funnel = false
	
	--vine controls and shit
	if self.vine then
		self.gravity = 0
		self.animationstate = "climbing"
		if self.binds.control.playerUp then
			self.vinemovetimer = self.vinemovetimer + dt
			
			self.climbframe = math.ceil(math.mod(self.vinemovetimer, vineframedelay*2)/vineframedelay)
			self.climbframe = math.max(self.climbframe, 1)
			
			self.y = self.y-vinemovespeed*dt
			
			local t = checkrect(self.x, self.y, self.width, self.height, {"tile", "portalwall"})
			if #t ~= 0 then
				self.y = objects[t[1]][t[2]].y + objects[t[1]][t[2]].height
				self.climbframe = 2
			end
		elseif self.binds.control.playerDown then
			self.vinemovetimer = self.vinemovetimer + dt
			
			self.climbframe = math.ceil(math.mod(self.vinemovetimer, vineframedelaydown*2)/vineframedelaydown)
			self.climbframe = math.max(self.climbframe, 1)
			
			checkportalHOR(self, self.y+vinemovedownspeed*dt)
			
			self.y = self.y+vinemovedownspeed*dt
			
			local t = checkrect(self.x, self.y, self.width, self.height, {"tile", "portalwall"})
			if #t ~= 0 then
				self.y = objects[t[1]][t[2]].y - self.height
				self.climbframe = 2
			end
		else
			self.climbframe = 2
			self.vinemovetimer = 0
		end
			
		if self.vine.limit == -1 and self.y+self.height <= vineanimationstart then
			self:vineanimation()
		end
		
		--check if still on vine
		local t = checkrect(self.x, self.y, self.width, self.height, {"vine"})
		if #t == 0 then
			self:dropvine(self.vineside)
		end
		
		self:setquad()
		return
	end
	
	--springs
	if self.spring then
		self.x = self.springx
		self.springtimer = self.springtimer + dt
		self.y = self.springy - self.height - 31/16 + springytable[self.springb.frame]
		if self.springtimer > springtime then
			self:leavespring()
		end
		return
	end
	
	--coins
	if not editormode then
		local x = math.floor(self.x+self.width/2)+1
		local y = math.floor(self.y+self.height)+14/16
		if inmap(x, y) and coinmap[x][y] then
			self:getcoin(1, x, y)
		end
		local y = math.floor(self.y+self.height/2)+1
		if inmap(x, y) and coinmap[x][y] then
			self:getcoin(1, x, y)
		end
		if self.size > 1 then
			if inmap(x, y-1) and coinmap[x][y-1] then
				self:getcoin(1, x, y-1)
			end
		end
	end
	
	--mazegate
	local x = math.floor(self.x+self.width/2)+1
	local y = math.floor(self.y+self.height/2)+1
	if inmap(x, y) and map[x][y][2] and entitylist[map[x][y][2]] and entitylist[map[x][y][2]].t == "mazegate" then
		if map[x][y][3] == self.mazevar + 1 then
			self.mazevar = self.mazevar + 1
		elseif map[x][y][3] == self.mazevar then
			
		else
			self.mazevar = 0
		end
	end
	
	--axe
	local x = math.floor(self.x+self.width/2)+1
	local y = math.floor(self.y+self.height/2)+1
	
	if self.controlsenabled then
		--check for pipe pipe pipe
		local px, py = math.floor(self.x+30/16), math.floor(self.y+self.height+20/16)
		if inmap(px, py) and self.binds.control.playerDown and not self.falling and not self.jumping then
			local t2 = map[px][py][2]
			if t2 and entitylist[t2] and entitylist[t2].t == "warppipe" and map[px][py][8] then
				--self.animationmisc2 = tonumber(map[px][py][3]) or 1
				--self.animationmisc3 = tonumber(map[px][py][4]) or 1
				--"pipe"
				--self:pipe(px, py, "down", tonumber(map[px][py][3]-1))
				--"warppipe"
				self:pipe(px, py, "down", map[px][py])
				return
			end
		end
		
		--[[@DEV:
			For this section we have to +1 py2 because apparently map is still offset crazily.
			More specifically, inmap would fail with the correct py2 and the rest of the conditions
			would be right or the inverse, referencing a block just above the correct one.
		]]
		local px2, py2 = math.floor(self.x+30/16), math.floor(self.y-self.height)
		if inmap(px2, py2) then
			local t2 = map[px2][py2+1][2]
			if t2 
			and entitylist[t2] 
			and entitylist[t2].t == "warppipe" 
			and map[px2][py2+1][8] then
				print("warp up available", py2, self.y, self.height)
				if self.binds.control.playerUp then
					--self.animationmisc2 = tonumber(map[px][py][3]) or 1
					--self.animationmisc3 = tonumber(map[px][py][4]) or 1
					--"pipe"
					--self:pipe(px, py, "down", tonumber(map[px][py][3]-1))
					--"warppipe"
					self:pipe(px2, py2+1, "up", map[px2][py2+1])
					return
				end
			end
		end
		
		
		if self.falling == false and self.jumping == false and self.size > 1 then
			if self.binds.control.playerDown then
				if self.ducking == false then
					self:duck(true)
				end
			else
				if self.ducking then
					self:duck(false)
				end
			end
		end
		
		if not underwater then
			local x = math.floor(self.x+self.width/2)+1
			local y = math.floor(self.y+self.height/2)+1
			
			if inmap(x, y) then
				if tilequads[map[x][y][1]]:getproperty("water", x, y) then
					if not self.underwater then
						self:dive(true)
					end
				else
					if self.underwater then
						self:dive(false)
					end
				end
			end
		end
		
		if not self.underwater then
			self:movement(dt)
		else
			self:underwatermovement(dt)
		end
		
		--RACCOON STUFF
		if self.char.raccoon and self.size == 2 then
			if not self.falling and not self.jumping then
				if math.abs(self.speedx) >= maxwalkspeed and self.binds.control.playerRun and ((self.binds.control.playerRight and not self.binds.control.playerLeft) or (not self.binds.control.playerRight and self.binds.control.playerLeft)) then
					if self.raccoonstarttimer < raccoonstarttime then
						self.raccoonstarttimer = self.raccoonstarttimer + dt
						if self.raccoonstarttimer >= raccoonstarttime then
							self.raccoonstarttimer = raccoonstarttime
							self.raccoonjump = true
							playsound("planemode", self.x, self.y, self.speedx, self.speedy)
						end
					end
				else
					self.raccoonjump = false
					self.raccoonstarttimer = 0
				end
			else
				self.raccoonstarttimer = math.max(0, self.raccoonstarttimer-dt)
			end
		end
		
		if not self.raccoonjump and self.raccoontimer == 0 and not soundlist["planemode"].source:isStopped() then
			soundlist["planemode"].source:stop()
		end
		
		if self.raccoonascendtimer > 0 then
			if self.raccoontimer > 0 then
				self.raccoonascendtimer = math.max(0, self.raccoonascendtimer-dt)
				self.speedy = -raccoonascendspeed
				self.falling = true
			else
				self.speedy = math.min(raccoondescendspeed, self.speedy)
				self.raccoonascendtimer = math.max(0, self.raccoonascendtimer-dt)
			end
		end
		
		if self.raccoontimer > 0 then
			self.raccoontimer = math.max(0, self.raccoontimer-dt)
			if self.raccoontimer == 0 then
				self.raccoonascendtimer = 0
			end
		end
		
		--DEATH BY PIT
		if self.gravitydirection > math.pi/4*1 and self.gravitydirection <= math.pi/4*3 then --down
			if self.y >= mapheight then
				self:murder(nil, "pit", "pit")
			end
		elseif self.gravitydirection > math.pi/4*5 and self.gravitydirection <= math.pi/4*7 then --up
			if self.y <= -1 then
				self:murder(nil, "pit", "pit")
			end
		end
		
		
		if flagx and not levelfinished and self.x+self.width >= flagx+6/16 and self.y > flagy-10.8 then
			self:flag()
		end
		
--[[		if firestartx then
			if self.x >= firestartx - 1 then
				firestarted = true
			else
				--check for all players
				local disable = true
				for i = 1, players do
					if objects["player"][i].x >= firestartx - 1 then
						disable = false
					end
				end
				
				if disable then
					firestarted = false
				end
			end
		end
]]		
		if lakitoendx and self.x >= lakitoendx then
			lakitoend = true
		end
	else
		if not self.underwater then
			self:movement(dt)
		else
			self:underwatermovement(dt)
		end
	end
	
	--drains
	local x = math.floor(self.x+self.width/2)+1
	
	if inmap(x, mapheight) and map[x][mapheight][2] and entitylist[map[x][mapheight][2]] and entitylist[map[x][mapheight][2]].t == "drain" then
		if self.speedy < drainmax then
			self.speedy = math.min( drainmax, self.speedy + drainspeed*dt)
		end
	end
	
	--out of bounds
	if self.y < 0-self.height then
		self.outofboundstimer = self.outofboundstimer+dt
	elseif self.outofboundstimer > 0 then
		self.outofboundstimer = 0
	end
	
	--@DEV: Experimental audio foolery.
	if self.playernumber == 1 then
		love.audio.setPosition(self.x, self.y, 0)
		love.audio.setVelocity(self.speedx, self.speedy, 0)
	end
	self:setquad()
end

function player:updateangle()
	if self.remote then
		return
	end
	
	if self.vine or self.animation then
		return
	end
	--UPDATE THE PLAYER ANGLE
	if self.playernumber == mouseowner and self.prefermouse then
		local scale = scale
		if shaders and shaders.scale then scale = shaders.scale end
		self.pointingangle = math.atan2(self.x+6/16-xscroll-(mouse.getX()/16/scale), (self.y-yscroll+6/16-.5)-(mouse.getY()/16/scale))
	elseif self.binds.control.playerAimX then
		local x, y = -self.binds.control.playerAimX, -self.binds.control.playerAimY
		
		if not x or not y then
			return
		end
		
		if math.abs(x) > joystickaimdeadzone or math.abs(y) > joystickaimdeadzone then
			self.pointingangle = math.atan2(x, y)
			if self.pointingangle == 0 then
				self.pointingangle = 0
				--this is really silly, but will crash the game if I don't do this. It's because it's -0 or something. I'm not good with computers.
			end
		end
	else
		--assert(false, "Player#"..self.playernumber.." has no way of knowing where he's aiming.")
	end
end

function player:movement(dt)
	local maxrunspeed = maxrunspeed
	local maxwalkspeed = maxwalkspeed
	local runacceleration = runacceleration
	local walkacceleration = walkacceleration
	--Orange gel
	--not in air
	if self.falling == false and self.jumping == false then
		local orangegel = false
		local bluegel = false
		--On Tiles
		if math.mod(self.y+self.height, 1) == 0 then
			local x = round(self.x+self.width/2+.5)
			local y = self.y+self.height+1
			--x and y in map
			if inmap(x, y) then
				--top of block orange
				if map[x][y]["gels"]["top"] == 2 then
					orangegel = true
				elseif map[x][y]["gels"]["top"] == 1 then
					bluegel = true
				end
			end
		end
		
		--On Lightbridge
		local x = round(self.x+self.width/2+.5)
		local y = round(self.y+self.height+1)
		
		for i, v in pairs(objects["lightbridgebody"]) do
			if x == v.cox and y == v.coy and v.gels.top then
				orangegel = true
			end
		end
		
		if orangegel then
			maxrunspeed = gelmaxrunspeed
			maxwalkspeed = gelmaxwalkspeed
			runacceleration = gelrunacceleration
			walkacceleration = gelwalkacceleration
		elseif bluegel then
			if math.abs(self.speedx) > maxrunspeed*1.5 then
				self.speedy = -40
				self.falling = true
			end
		end
	end
	
	if self.animationstate == "running" then
		self:runanimation(dt)
	end
	
	if self.animationstate == "jumping" then
		self.jumpanimationprogress = self.jumpanimationprogress + dt*runanimationspeed
		while self.jumpanimationprogress > self.char.jumpframes+1 do
			self.jumpanimationprogress = self.jumpanimationprogress - self.char.jumpframes
		end
		self.jumpframe = math.floor(self.jumpanimationprogress)
	end
		
	--HORIZONTAL MOVEMENT
	if self.controlsenabled and self.binds.control.playerRun then --RUNNING
		if self.controlsenabled and self.binds.control.playerRight then --MOVEMENT RIGHT
			if self.jumping or self.falling then --IN AIR
				if self.speedx < maxwalkspeed then
					if self.speedx < 0 then
						self.speedx = self.speedx + runaccelerationair*dt*airslidefactor
					else
						self.speedx = self.speedx + runaccelerationair*dt
					end
					
					if self.speedx > maxwalkspeed then
						self.speedx = maxwalkspeed
					end
				elseif self.speedx > maxwalkspeed and self.speedx < maxrunspeed then
					if self.speedx < 0 then
						self.speedx = self.speedx + runaccelerationair*dt*airslidefactor
					else
						self.speedx = self.speedx + runaccelerationair*dt
					end
					
					if self.speedx > maxrunspeed then
						self.speedx = maxrunspeed
					end
				end
					
			elseif self.ducking == false then --ON GROUND
				if self.speedx < 0 then
					if self.speedx < -maxrunspeed then
						self.speedx = self.speedx + superfriction*dt + runacceleration*dt
					else
						self.speedx = self.speedx + friction*dt + runacceleration*dt
					end
					self.animationstate = "sliding"
					self.animationdirection = "right"
				else
					if self.speedx <= maxrunspeed then
						self.speedx = self.speedx + runacceleration*dt
						self.animationstate = "running"
						self.animationdirection = "right"
					
						if self.speedx > maxrunspeed then
							self.speedx = maxrunspeed
						end
					else
						self.speedx = self.speedx - superfriction*dt
					end
				end
			end
			
		elseif self.controlsenabled and self.binds.control.playerLeft then --MOVEMENT LEFT
			if self.jumping or self.falling then --IN AIR
				if self.speedx > -maxwalkspeed then
					if self.speedx > 0 then
						self.speedx = self.speedx - runaccelerationair*dt*airslidefactor
					else
						self.speedx = self.speedx - runaccelerationair*dt
					end
					
					if self.speedx < -maxwalkspeed then
						self.speedx = -maxwalkspeed
					end
				elseif self.speedx < -maxwalkspeed and self.speedx > -maxrunspeed then
					if self.speedx > 0 then
						self.speedx = self.speedx - runaccelerationair*dt*airslidefactor
					else
						self.speedx = self.speedx - runaccelerationair*dt
					end
					
					if self.speedx < -maxrunspeed then
						self.speedx = -maxrunspeed
					end
				end
				
			elseif self.ducking == false then --ON GROUND
				if self.speedx > 0 then
					if self.speedx > maxrunspeed then
						self.speedx = self.speedx - superfriction*dt - runacceleration*dt
					else
						self.speedx = self.speedx - friction*dt - runacceleration*dt
				
					end
					self.animationstate = "sliding"
					self.animationdirection = "left"
				else
					if self.speedx >= -maxrunspeed then
						self.speedx = self.speedx - runacceleration*dt
						self.animationstate = "running"
						self.animationdirection = "left"
					
						if self.speedx < -maxrunspeed then
							self.speedx = -maxrunspeed
						end
					else
						self.speedx = self.speedx + superfriction*dt
					end
				end
			end
		
		end
		if (not self.binds.control.playerRight and not self.binds.control.playerLeft) or (self.ducking and self.falling == false and self.jumping == false) or not self.controlsenabled then  --NO MOVEMENT
			if self.jumping or self.falling then
				if self.speedx > 0 then
					self.speedx = self.speedx - frictionair*dt
					if self.speedx < minspeed then
						self.speedx = 0
						self.runframe = 1
					end
				else
					self.speedx = self.speedx + frictionair*dt
					if self.speedx > -minspeed then
						self.speedx = 0
						self.runframe = 1
					end
				end
			else
				if self.speedx > 0 then
					if self.speedx > maxrunspeed then
						self.speedx = self.speedx - superfriction*dt
					else	
						self.speedx = self.speedx - friction*dt
					end
					if self.speedx < minspeed then
						self.speedx = 0
						self.runframe = 1
						self.animationstate = "idle"
					end
				else
					if self.speedx < -maxrunspeed then
						self.speedx = self.speedx + superfriction*dt
					else	
						self.speedx = self.speedx + friction*dt
					end
					if self.speedx > -minspeed then
						self.speedx = 0
						self.runframe = 1
						self.animationstate = "idle"
					end
				end
			end
		end
		
	else --WALKING
	
		if self.controlsenabled and self.binds.control.playerRight then --MOVEMENT RIGHT
			if self.jumping or self.falling then --IN AIR
				if self.speedx < maxwalkspeed then
					if self.speedx < 0 then
						self.speedx = self.speedx + walkaccelerationair*dt*airslidefactor
					else
						self.speedx = self.speedx + walkaccelerationair*dt
					end
					
					if self.speedx > maxwalkspeed then
						self.speedx = maxwalkspeed
					end
				end
			elseif self.ducking == false then --ON GROUND
				if self.speedx < maxwalkspeed then
					if self.speedx < 0 then
						if self.speedx < -maxrunspeed then
							self.speedx = self.speedx + superfriction*dt + runacceleration*dt
						else
							self.speedx = self.speedx + friction*dt + runacceleration*dt
						end
						self.animationstate = "sliding"
						self.animationdirection = "right"
					else
						self.speedx = self.speedx + walkacceleration*dt
						self.animationstate = "running"
						self.animationdirection = "right"
					end
					
					if self.speedx > maxwalkspeed then
						self.speedx = maxwalkspeed
					end
				else
					if self.speedx > maxrunspeed then
						self.speedx = self.speedx - superfriction*dt
					else
						self.speedx = self.speedx - friction*dt
					end
					
					if self.speedx < maxwalkspeed then
						self.speedx = maxwalkspeed
					end
				end
			end
			
		elseif self.controlsenabled and self.binds.control.playerLeft then --MOVEMENT LEFT
			if self.jumping or self.falling then --IN AIR
				if self.speedx > -maxwalkspeed then
					if self.speedx > 0 then
						self.speedx = self.speedx - walkaccelerationair*dt*airslidefactor
					else
						self.speedx = self.speedx - walkaccelerationair*dt
					end
					
					if self.speedx < -maxwalkspeed then
						self.speedx = -maxwalkspeed
					end
				end
			elseif self.ducking == false then --ON GROUND
				if self.speedx > -maxwalkspeed then
					if self.speedx > 0 then
						if self.speedx > maxrunspeed then
							self.speedx = self.speedx - superfriction*dt - runacceleration*dt
						else
							self.speedx = self.speedx - friction*dt - runacceleration*dt
						end
						self.animationstate = "sliding"
						self.animationdirection = "left"
					else
						self.speedx = self.speedx - walkacceleration*dt
						self.animationstate = "running"
						self.animationdirection = "left"
					end
					
					if self.speedx < -maxwalkspeed then
						self.speedx = -maxwalkspeed
					end
				else
					if self.speedx < -maxrunspeed then
						self.speedx = self.speedx + superfriction*dt
					else
						self.speedx = self.speedx + friction*dt
					end
					
					if self.speedx > -maxwalkspeed then
						self.speedx = -maxwalkspeed
					end
				end
			end
		
		end
		if (not self.binds.control.playerRight and not self.binds.control.playerLeft) or (self.ducking and self.falling == false and self.jumping == false) or not self.controlsenabled then --no movement
			if self.jumping or self.falling then
				if self.speedx > 0 then
					self.speedx = self.speedx - frictionair*dt
					if self.speedx < 0 then
						self.speedx = 0
						self.runframe = 1
					end
				else
					self.speedx = self.speedx + frictionair*dt
					if self.speedx > 0 then
						self.speedx = 0
						self.runframe = 1
					end
				end
			else
				if self.speedx > 0 then
					if self.speedx > maxrunspeed then
						self.speedx = self.speedx - superfriction*dt
					else	
						self.speedx = self.speedx - friction*dt
					end
					if self.speedx < 0 then
						self.speedx = 0
						self.runframe = 1
						self.animationstate = "idle"
					end
				else
					if self.speedx < -maxrunspeed then
						self.speedx = self.speedx + superfriction*dt
					else	
						self.speedx = self.speedx + friction*dt
					end
					if self.speedx > 0 then
						self.speedx = 0
						self.runframe = 1
						self.animationstate = "idle"
					end
				end
			end
		end
	end
end

function player:runanimation(dt)
	self.runanimationprogress = self.runanimationprogress + (math.abs(self.speedx)+4)/5*dt*(self.char.rundelay or runanimationspeed)
	while self.runanimationprogress > self.char.runframes+1 do
		self.runanimationprogress = self.runanimationprogress - self.char.runframes
	end
	self.runframe = math.floor(self.runanimationprogress)
end

function player:underwatermovement(dt)
	if self.jumping or self.falling then
		--Swim animation
		if self.animationstate == "jumping" or self.animationstate == "falling" then
			self.swimanimationprogress = self.swimanimationprogress + runanimationspeed*dt
			while self.swimanimationprogress >= 3 do
				self.swimanimationprogress = self.swimanimationprogress - 2
			end
			self.swimframe = math.floor(self.swimanimationprogress)
			self:setquad()
		end
	else
		if self.animationstate == "running" then
			self:runanimation(dt)
		end
	end
	
	local maxrunspeed = maxrunspeed
	local maxwalkspeed = maxwalkspeed
	local runacceleration = runacceleration
	local walkacceleration = walkacceleration
	--Orange gel
	--not in air
	if self.falling == false and self.jumping == false then
		--bottom on grid
		if math.mod(self.y+self.height, 1) == 0 then
			local x = round(self.x+self.width/2+.5)
			local y = self.y+self.height+1
			--x and y in map
			if inmap(x, y) then
				--top of block orange
				if map[x][y]["gels"]["top"] == 2 then
					maxrunspeed = uwgelmaxrunspeed
					maxwalkspeed = uwgelmaxwalkspeed
					runacceleration = uwgelrunacceleration
					walkacceleration = uwgelwalkacceleration
				end
			end
		end
	end
	
	--bubbles
	self.bubbletimer = self.bubbletimer + dt
	while self.bubbletimer > self.bubbletime do
		self.bubbletimer = self.bubbletimer - self.bubbletime
		self.bubbletime = bubblestime[math.random(#bubblestime)]
		bubble:new(self.x+8/12, self.y+2/12)
	end
	
	--HORIZONTAL MOVEMENT	
	if self.controlsenabled and self.binds.control.playerRight and (self.jumping or self.falling or not self.ducking) then --MOVEMENT RIGHT
		if self.jumping or self.falling then --IN AIR
			if self.speedx < uwmaxairwalkspeed then
				if self.speedx < 0 then
					self.speedx = self.speedx + walkaccelerationair*dt*uwairslidefactor
				else
					self.speedx = self.speedx + walkaccelerationair*dt
				end
				
				if self.speedx > uwmaxairwalkspeed then
					self.speedx = uwmaxairwalkspeed
				end
			end
		else --ON GROUND
			if self.speedx < maxwalkspeed then
				if self.speedx < 0 then
					if self.speedx < -maxrunspeed then
						self.speedx = self.speedx + uwsuperfriction*dt + runacceleration*dt
					else
						self.speedx = self.speedx + uwfriction*dt + runacceleration*dt
					end
					self.animationstate = "sliding"
					self.animationdirection = "right"
				else
					self.speedx = self.speedx + walkacceleration*dt
					self.animationstate = "running"
					self.animationdirection = "right"
				end
				
				if self.speedx > maxwalkspeed then
					self.speedx = maxwalkspeed
				end
			else
				self.speedx = self.speedx - uwfriction*dt
				if self.speedx < maxwalkspeed then
					self.speedx = maxwalkspeed
				end
			end
		end
	elseif self.controlsenabled and self.binds.control.playerLeft and (self.jumping or self.falling or not self.ducking) then --MOVEMENT LEFT
		if self.jumping or self.falling then --IN AIR
			if self.speedx > -uwmaxairwalkspeed then
				if self.speedx > 0 then
					self.speedx = self.speedx - walkaccelerationair*dt*uwairslidefactor
				else
					self.speedx = self.speedx - walkaccelerationair*dt
				end
				
				if self.speedx < -uwmaxairwalkspeed then
					self.speedx = -uwmaxairwalkspeed
				end
			end
		else --ON GROUND
			if self.speedx > -maxwalkspeed then
				if self.speedx > 0 then
					if self.speedx > maxrunspeed then
						self.speedx = self.speedx - uwsuperfriction*dt - runacceleration*dt
					else
						self.speedx = self.speedx - uwfriction*dt - runacceleration*dt
					end
					self.animationstate = "sliding"
					self.animationdirection = "left"
				else
					self.speedx = self.speedx - walkacceleration*dt
					self.animationstate = "running"
					self.animationdirection = "left"
				end
				
				if self.speedx < -maxwalkspeed then
					self.speedx = -maxwalkspeed
				end
			else
				self.speedx = self.speedx + uwfriction*dt
				if self.speedx > -maxwalkspeed then
					self.speedx = -maxwalkspeed
				end
			end
		end
	
	else --NO MOVEMENT
		if self.jumping or self.falling then
			if self.speedx > 0 then
				self.speedx = self.speedx - uwfrictionair*dt
				if self.speedx < 0 then
					self.speedx = 0
					self.runframe = 1
				end
			else
				self.speedx = self.speedx + uwfrictionair*dt
				if self.speedx > 0 then
					self.speedx = 0
					self.runframe = 1
				end
			end
		else
			if self.speedx > 0 then
				if self.speedx > maxrunspeed then
					self.speedx = self.speedx - uwsuperfriction*dt
				else	
					self.speedx = self.speedx - uwfriction*dt
				end
				if self.speedx < 0 then
					self.speedx = 0
					self.runframe = 1
					self.animationstate = "idle"
				end
			else
				if self.speedx < -maxrunspeed then
					self.speedx = self.speedx + uwsuperfriction*dt
				else	
					self.speedx = self.speedx + uwfriction*dt
				end
				if self.speedx > 0 then
					self.speedx = 0
					self.runframe = 1
					self.animationstate = "idle"
				end
			end
		end
	end
	
	if self.y+self.height < uwmaxheight then
		self.speedy = uwpushdownspeed
	end
end

function player:setquad(anim, s)
	local angleframe
	if self.char.nopointing then
		angleframe = 1
	elseif not self.portalsavailable[1] and not self.portalsavailable[2] and not self.char.nogunanimations then
		angleframe = 3
	else
		angleframe = getAngleFrame(self.pointingangle, self.rotation)
	end
	
	local animationstate = anim or self.animationstate
	local size = s or self.size
	
	if size == 1 then
		if self.infunnel or animationstate == "jumping" and not self.underwater then
			self.quad = self.char.jump[angleframe][self.jumpframe]
		elseif self.underwater and (self.animationstate == "jumping" or self.animationstate == "falling") then
			self.quad = self.char.swim[angleframe][self.swimframe]
		elseif animationstate == "running" or animationstate == "falling" then
			self.quad = self.char.run[angleframe][self.runframe]
		elseif animationstate == "idle" then
			self.quad = self.char.idle[angleframe]
		elseif animationstate == "sliding" then
			self.quad = self.char.slide[angleframe]
		elseif animationstate == "climbing" then
			self.quad = self.char.climb[angleframe][self.climbframe]
		elseif animationstate == "dead" then
			self.quad = self.char.die[angleframe]
		elseif animationstate == "grow" then
			self.quad = self.char.grow[angleframe]
		end
	elseif size > 1 then
		if self.char.raccoon and self.raccoontimer > 0 and self.falling and animationstate ~= "climbing" then
			self.quad = self.char.bigcustomframe[angleframe][self.tailwagframe+9]
		elseif self.char.raccoon and self.raccoonspinframe then
			if self.falling or self.jumping then
				self.quad = self.char.bigcustomframe[angleframe][self.raccoonspinframe+12]
			else
				self.quad = self.char.bigcustomframe[angleframe][self.raccoonspinframe]
			end
		elseif self.char.raccoon and (animationstate ~= "climbing" and not self.ducking and self.falling and not self.jumping) then
			self.quad = self.char.bigcustomframe[angleframe][self.tailwagframe+3]
			
		elseif self.infunnel or (animationstate == "jumping" and not self.ducking and not self.underwater) then
			self.quad = self.char.bigjump[angleframe][self.jumpframe]
		elseif self.underwater and (self.animationstate == "jumping" or self.animationstate == "falling") then
			self.quad = self.char.bigswim[angleframe][self.swimframe]
		elseif self.ducking then
			self.quad = self.char.bigduck[angleframe]
		elseif self.fireanimationtimer < fireanimationtime then
			self.quad = self.char.bigfire[angleframe]
		else
			if animationstate == "running" or animationstate == "falling" or (self.char.raccoon and animationstate == "jumping") then
				if self.raccoonjump then
					self.quad = self.char.bigcustomframe[angleframe][self.runframe+6]
				else
					self.quad = self.char.bigrun[angleframe][self.runframe]
				end
			elseif animationstate == "idle" then
				self.quad = self.char.bigidle[angleframe]
			elseif animationstate == "sliding" then
				self.quad = self.char.bigslide[angleframe]
			elseif animationstate == "climbing" then
				self.quad = self.char.bigclimb[angleframe][self.climbframe]
			end
		end
	end
end

function gethatoffset(char, graphic, animationstate, runframe, jumpframe, climbframe, swimframe, underwater, infunnel, fireanimationtimer, ducking)
	local hatoffset
	if graphic == char.animations or graphic == char.nogunanimations then
		if not char.hatoffsets then
			return
		end
		
		if infunnel then
			hatoffset = char.hatoffsets["jumping"][jumpframe]
		elseif underwater and (animationstate == "jumping" or animationstate == "falling") then
			hatoffset = char.hatoffsets["swimming"][swimframe]
		elseif animationstate == "jumping" then
			hatoffset = char.hatoffsets["jumping"][jumpframe]
		elseif animationstate == "running" or animationstate == "falling" then
			hatoffset = char.hatoffsets["running"][runframe]
		elseif animationstate == "climbing" then
			hatoffset = char.hatoffsets["climbing"][climbframe]
		end
	else
		if not char.bighatoffsets then
			return
		end
		if infunnel or animationstate == "jumping" and not ducking then
			hatoffset = char.bighatoffsets["jumping"][jumpframe]
		elseif underwater and (animationstate == "jumping" or animationstate == "falling") then
			hatoffset = char.bighatoffsets["swimming"][swimframe]
		elseif ducking then
			hatoffset = char.bighatoffsets["ducking"]
		elseif fireanimationtimer < fireanimationtime then
			hatoffset = char.bighatoffsets["fire"]
		else
			if animationstate == "running" or animationstate == "falling" then
				hatoffset = char.bighatoffsets["running"][runframe]
			elseif animationstate == "climbing" then
				hatoffset = char.bighatoffsets["climbing"][climbframe]
			end
		end
	end
	
	if not hatoffset then
		if graphic == char.animations or graphic == char.nogunanimations then
			hatoffset = char.hatoffsets[animationstate]
		else
			hatoffset = char.bighatoffsets[animationstate]
		end
	end
	
	return hatoffset
end

function player:jump(force)
	if ((not noupdate or self.animation == "grow1" or self.animation == "grow2") and self.controlsenabled) or force then
	
		if not self.underwater then
			if self.spring then
				self.springhigh = true
				return
			end
			
			if self.raccoonjump then
				self.raccoontimer = raccoontime
				self.raccoonjump = false
				self.tailwag = true
			end
			
			if self.char.raccoon and self.size >= 2 and self.falling and not self.jumping then
				self.raccoonascendtimer = raccoonbuttondelay
				self.tailwag = true
			end
			
			if self.raccoontimer > 0 then
				self.raccoonascendtimer = raccoonbuttondelay 
				self.tailwag = true
			else
				if ((self.animation ~= "grow1" and self.animation ~= "grow2") or self.falling) and (self.falling == false or self.animation == "grow1" or self.animation == "grow2" or (self.char.dbljmppls and not self.dbljmping)) then
					if self.falling and self.char.dbljmppls then
						self.dbljmping = true
					end
					
					if self.animation ~= "grow1" and self.animation ~= "grow2" then
						if self.size == 1 then
							playsound("jump", self.x, self.y, self.speedx, self.speedy)
						else
							playsound("jumpbig", self.x, self.y, self.speedx, self.speedy)
						end
					end
					
					local force = -jumpforce - (math.abs(self.speedx) / maxrunspeed)*jumpforceadd
					force = math.max(-jumpforce - jumpforceadd, force)
					
					self.speedy = force
					
					self.jumping = true
					self.animationstate = "jumping"
					self:setquad()
				end
			end
		else
			if self.ducking then
				self:duck(false)
			end
			playsound("swim", self.x, self.y, self.speedx, self.speedy)
			
			self.speedy = -uwjumpforce - (math.abs(self.speedx) / maxrunspeed)*uwjumpforceadd
			self.jumping = true
			self.animationstate = "jumping"
			self:setquad()
		end
		
		--check if upper half is inside block
		if self.size > 1 then
			local x = round(self.x+self.width/2+.5)
			local y = round(self.y)
			
			if inmap(x, y) and tilequads[map[x][y][1]]:getproperty("collision", x, y) then
				if getPortal(x, y) then
					self.speedy = 0
					self.jumping = false
					self.falling = true
				else
					self:ceilcollide("tile", objects["tile"][x .. "-" .. y], "player", self)
				end
			end
		end
	end
end

function player:stopjump(force)
	if self.controlsenabled or force then
		if self.jumping == true then
			self.jumping = false
			self.falling = true
		end
	end
end

function player:rightkey()
	if self.controlsenabled and self.vine then
		if self.vineside == "left" then
			local targetx = self.x + 8/16
			if #checkrect(targetx, self.y, self.width, self.height, {"exclude", self}, true) == 0 then
				self.x = targetx
				self.pointingangle = math.pi/2
				self.animationdirection = "left"
				self.vineside = "right"
			end
		else
			self:dropvine("right")
		end
	end
end

function player:leftkey()
	if self.controlsenabled and self.vine then
		if self.vineside == "right" then
			local targetx = self.x - 8/16
			if #checkrect(targetx, self.y, self.width, self.height, {"exclude", self}, true) == 0 then
				self.x = targetx
				self.pointingangle = -math.pi/2
				self.animationdirection = "right"
				self.vineside = "left"
			end
		else
			self:dropvine("left")
		end
	end
end
--[[function player:grow()
	self.animationmisc = self.animationstate
	if self.animation and self.animation ~= "invincible" then
		return
	end
	addpoints(1000, self.x+self.width/2, self.y)
	playsound("mushroomeat", self.x, self.y, self.speedx, self.speedy)
	
	if bigmario then
		return
	end
	
	if self.size > 2 then
		
	else
		self.size = self.size + 1
		if self.size == 2 then		
			self.y = self.y - 12/16
			self.height = 24/16
		elseif self.size == 3 then
			self.colors = self.char.flowercolor or flowercolor
		end
		
		if self.size == 2 then
			self.animation = "grow1"
		else
			self.animation = "grow2"
		end
		self.drawable = true
		self.invincible = false
		self.animationtimer = 0
		noupdate = true
	end
end]]

--[[function player:shrink()
	self.animationmisc = self.animationstate
	if self.animation then
		return
	end
	if self.ducking then
		self:duck(false)
	end
	playsound("shrink", self.x, self.y, self.speedx, self.speedy)
	
	self.size = 1
	
	self.colors = mariocolors[self.playernumber]
	
	self.animation = "shrink"
	self.drawable = true
	self.invincible = true
	self.animationtimer = 0
	self.raccoontimer = 0
	self.raccoonascendtimer = 0
	
	self.y = self.y + 12/16
	self.height = 12/16
	
	noupdate = true
end]]

function player:getpowerup(poweruptype, powerdowntarget, reason)
	powerdowntarget = powerdowntarget or "death"
	reason = reason or "it is a mystery"
	if self.powerupstate == poweruptype then
		-- this is here because for whatever reason touching a mushroom doubletaps
		-- which is very bad because the animation system is fucked
		return
	end
	--self.size = size
	print("Mario got powerup '"..poweruptype.."', pd: '"..tostring(powerdowntarget).."' because "..tostring(reason).." also he is size "..tostring(self.size))
	--self:grow()
	--return false
	
	--self.powerupstate = "small"
	--self.powerdowntargetstate = "death"
	
	self.animationmisc = self.animationstate
	if self.animation --[[and self.animation ~= "invincible"]] then
		return
	end
	local pointstoadd=1000
	local soundtoplay="mushroomeat"
	local animationtodo="grow2"
	local makeinvincible=false
	local makeunduck=false
	
	self.powerupstate = poweruptype
	self.powerdowntargetstate = powerdowntarget
	
	if poweruptype == "super" then
		if self.size == 1 then
			self.y = self.y - 12/16
			animationtodo = "grow1"
		elseif self.size > 2 then
			self.colors = mariocolors[self.playernumber]
			makeinvincible = true
			soundtoplay = "shrink"
		end
		self.quadcenterY = self.char.bigquadcenterY
		self.quadcenterX = self.char.bigquadcenterX
		self.offsetY = self.char.bigoffsetY
		self.graphic = self.biggraphic
		self.size = 2
		self.height = 24/16
	elseif poweruptype == "fire" then
		if self.size == 1 then
			self.y = self.y - 12/16
			animationtodo = "grow1"
		end
		self.size = 3
		self.quadcenterY = self.char.bigquadcenterY
		self.quadcenterX = self.char.bigquadcenterX
		self.offsetY = self.char.bigoffsetY
		self.graphic = self.biggraphic
		self.height = 24/16
		self.colors = self.char.flowercolor or flowercolor
	elseif poweruptype == "small" then
		--@WARNING: incomplete
		makeinvincible = true
		self.graphic = self.smallgraphic
		self.colors = mariocolors[self.playernumber]
		self.size = 1
		self.height = 12/16
		soundtoplay = "shrink"
		animationtodo = "shrink"
		pointstoadd = false
		
		self.raccoontimer = 0
		self.raccoonascendtimer = 0
		
		self.y = self.y + 12/16
		self.height = 12/16
	elseif poweruptype == "death" then
		animationtodo=false
		soundtoplay=false
		pointstoadd=false
		self:die(reason)
	end
	
	if self.ducking and makeunduck then
		self:duck(false)
	end
	
	if animationtodo~=false then
		self.animationtimer = 0
		self.drawable = true
		self.animation = animationtodo
		noupdate = true
	end
	if pointstoadd~=false then
		self:getscore(pointstoadd, self.x+self.width/2, self.y)
	end
	if soundtoplay~=false then
		playsound(soundtoplay, self.x, self.y, self.speedx, self.speedy)
	end
	if makeinvincible then
		self:goinvincible()
	end
end

function player:washurt(reason)
	print("Mario was hurt because '"..reason.."' also he is size "..tostring(self.size))
	if self.powerdowntargetstate=="super" then
		self:getpowerup(self.powerdowntargetstate, "small", reason)
	else
		self:getpowerup(self.powerdowntargetstate, nil, reason)
	end
end

function player:floorcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "floor") then
		return false
	end
	
	self.rainboomallowed = true
	
	local anim = self.animationstate
	local jump = self.jumping
	local fall = self.falling
	
	if self.char.dbljmppls then
		self.dbljmping = false
	end
	
	if a == "spring" then
		self:hitspring(b)
		return false
	end

	if a == "pswitch" then
		self:hitpswitch(b)
		return false
	end
	
	if self.speedx == 0 then
		self.animationstate = "idle"
	else
		if self.animationstate ~= "sliding" then
			self.animationstate = "running"
		end
	end
	
	if a == "tile" then
		local x, y = b.cox, b.coy
		self.lastground = {x, y}
		if bigmario and self.speedy > 2 then
			self:destroyblock(x, y)
			self.speedy = self.speedy/10
		end
		
		--check for invisible block
		if tilequads[map[x][y][1]]:getproperty("invisible", x, y) then
			self.jumping = jump
			self.falling = fall
			self.animationstate = anim
			return false
		end
		
		if self.falling and self.raccoontimer > 0 and self.controlsenabled then
			self.speedx = self.speedx * 0.5
			self.raccoonascendtimer = 0
		end
	end
	
	--star logic
	if self.starred or bigmario then
		if self:starcollide(a, b, c, d) then
			return false
		end
	end
	
	self.falling = false
	self.jumping = false
	
	--Make mario snap to runspeed if at walkspeed.
	--Without the ducking check, this would cause mario to slide indefinitely.
	--So if mario isn't slowing down, this might be why.
	if self.binds.control.playerRun and not self.ducking then
		if self.binds.control.playerLeft and self.speedx <= -maxwalkspeed then
			self.speedx = -maxrunspeed
			self.animationdirection = "left"
		elseif self.binds.control.playerRight and self.speedx >= maxwalkspeed then
			self.speedx = maxrunspeed
			self.animationdirection = "right"
		end
	end
	
	if b.rideable then -- Enemy Riding
		self.y = b.y - self.height
		if not self.binds.control.playerLeft and self.speedx <= b.speedx and
		self.animationstate ~= "sliding" and self.jumping == false and self.falling == false and
		self.running == false and self.walking == false	then
			self.speedx = b.speedx
			self.animationstate = "idle"
		elseif not self.binds.control.playerRight and self.speedx >= b.speedx and 
		self.animationstate ~= "sliding" and self.jumping == false and self.falling == false and
		self.running == false and self.walking == false	then
			self.speedx = b.speedx
			self.animationstate = "idle"
		end
	end
	
	if b.rideableup then -- Enemy Riding UPWARDS (verticalwiggle)
		self.y = b.y - self.height - 0.1
		if not self.binds.control.playerLeft and self.speedy <= b.verticalwigglespeed and
		self.animationstate ~= "idle" and self.jumping == false and
		self.running == false and self.walking == false	then
			self.speedy = b.verticalwigglespeed
			self.animationstate = "idle"
		elseif not self.binds.control.playerRight and self.speedy >= b.verticalwigglespeed and 
		self.animationstate ~= "idle" and self.jumping == false and 
		self.running == false and self.walking == false	then
			self.speedy = b.verticalwigglespeed
			self.animationstate = "idle"
		end
	end
	
	if b.stompable then
		self:stompenemy(a, b, c, d)
		return false
	elseif a == "tile" then
		local x, y = b.cox, b.coy
		
		if map[x][y].gels and map[x][y].gels.top == 1 then
			if self:bluegel("top") then
				return false
			end
		end
	elseif b.kills or b.killsontop then
		if self.invincible then
			self.jumping = jump
			self.falling = fall
			self.animationstate = anim
			return false
		else
			self:murder(b, b.doesdamagetype, "enemy")
			return false
		end
	elseif a == "lightbridgebody" and b.gels.top == 1 then
		if self:bluegel("top") then
			return false
		end
	end		
	
	self.combo = 1
end

function player:bluegel(dir)
	if dir == "top" then
		if self.binds.control.playerDown == false and self.speedy > gdt*yacceleration*10 then
			self.speedy = -self.speedy
			self.falling = true
			self.animationstate = "jumping"
			self:setquad()
			self.speedy = self.speedy + (self.gravity or yacceleration)*gdt
			
			return true
		end
	elseif dir == "left" then
		if self.binds.control.playerDown == false and (self.falling or self.jumping) then
			if self.speedx > horbounceminspeedx then
				self.speedx = math.min(-horbouncemaxspeedx, -self.speedx*horbouncemul)
				self.speedy = math.min(self.speedy, -horbouncespeedy)
				
				return true
			end
		end
	elseif dir == "right" then
		if self.binds.control.playerDown == false and (self.falling or self.jumping) then
			if self.speedx < -horbounceminspeedx then
				self.speedx = math.min(horbouncemaxspeedx, -self.speedx*horbouncemul)
				self.speedy = math.min(self.speedy, -horbouncespeedy)
				
				return false
			end
		end
	end
end

function player:getcombo(val, ctype, x, y, grantlife)
	val = val or 0
	x = x or self.x
	y = y or self.y
	grantlife = grantlife or false
	--print("DEBUG: givecombo called")
	if val >= 0 then
		-- I'm not sure if this logic is faster than:
		-- local comboindex = self.combo-(self.combo%#mariocombo)
		local comboindex = 1
		if combo_enums[ctype]==nil then print("WHOA: NO COMBOTYPE FOR ", ctype) end
		local maxcombo = #combo_enums[ctype]
		if self.combos[ctype] > maxcombo then
			comboindex = maxcombo
		else
			comboindex = self.combos[ctype]
		end
		
		if comboindex == maxcombo and grantlife then
			self:getlife(1, true)
		else
			self:getscore(combo_enums[ctype][comboindex], x, y)
		end
		self.combos[ctype] = self.combos[ctype] + val
		--print("NOTE: combo is", self.combo, "was", self.combo-val)
	else -- negative one, etc destroys combo
		print("DEBUG: Combo broken via getcombo.")
		self.combos[ctype] = 1
	end
end

function player:stompenemy(a, b, c, d, side)
	--[[
		crazy parameter demystification
		
		a		== type, physics calc
		b		== reference to the object stomped
		c		== ??? physics calc
		d		== ??? physics calc
		side	== a bool as to whether or not 
	]]
	if not b then
		return
	end
	
	local bounce = false
	
	b:do_damage("stomp", self) --we do this regardless of the code paths below
	
	local combonum = 1
	if b.stompcombosuppressor then
		combonum = 0
	end
	
	if b.shellanimal then
		if b.small then	
			if b.speedx == 0 then
				print("ALERT: Crazy edge case happened, just wanted you to know.")
				--[[playsound("shot", self.x, self.y, self.speedx, self.speedy)
				addpoints(500, b.x, b.y)
				self.combo = 1]]
			end
		end
		
		if b.speedx == 0 or (b.flying and b.small == false) then
			self:getcombo(combonum, "stomp", b.x, b.y, false) --@DEV: no lives because we hate america
			
			local grav = self.gravity or yacceleration
			
			local bouncespeed = math.sqrt(2*grav*bounceheight)
			
			self.speedy = -bouncespeed
			
			self.falling = true
			self.animationstate = "jumping"
			self:setquad()
			if not side then
				self.y = b.y - self.height-1/16
			end
		elseif b.x > self.x then
			b.x = self.x + b.width + self.speedx*gdt + 0.05
			local col = checkrect(b.x, b.y, b.width, b.height, {"tile"})
			if #col > 1 then
				b.x = objects[col[1] ][col[2] ].x-b.width
				bounce = true
			end
		else
			b.x = self.x - b.width + self.speedx*gdt - 0.05
			local col = checkrect(b.x, b.y, b.width, b.height, {"tile"})
			if #col > 1 then
				b.x = objects[col[1] ][col[2] ].x+1
				bounce = true
			end
		end
	elseif b.stompable then
		self:getcombo(combonum, "stomp", b.x, b.y, true)
		--@TODO: eventually we'll want to make the bounce flag controlled by the enemy as "canbounce"
		bounce = true
	end
	
	if bounce then
		local grav = self.gravity or yacceleration
		
		local bouncespeed = math.sqrt(2*grav*bounceheight)
		
		self.animationstate = "jumping"
		self.falling = true
		self:setquad()
		
		self.speedy = -bouncespeed
	end
end

function player:rightcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "right") then
		return false
	end
	
	allowskip = self.gravitydirection == math.pi/2
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
	
	--star logic
	if self.starred or bigmario then
		if self:starcollide(a, b, c, d) then
			return false
		end
	end
	
	if self.speedy > 2 and b.stompable then
		self:stompenemy(a, b, c, d, true)
		return false
	elseif b.kills or b.killsonsides or a == "bowser" then --KILLS
		if self.invincible then
			if b.shellanimal and b.small and b.speedx == 0 then
				b:do_damage("stomp", self, "right")
				--playsound("shot", self.x, self.y, self.speedx, self.speedy)
				--addpoints(500, b.x, b.y)
			end
			return false
		else
			if self.raccoonspinframe then
				b:do_damage("tailspin", self, "right")
				--b:shotted("right", true, true)
				--addpoints(firepoints[b.t] or 100, self.x, self.y)
				return false
			end
			
			if b.shellanimal and b.small and b.speedx == 0 then
				print("NOTE: Kicked a koopa shell, how exciting.")
				b:do_damage("stomp", self, "right")
				--playsound("shot", self.x, self.y, self.speedx, self.speedy)
				return false
			end
			
			--Check if Mario is walking off a ridable enemy, so that he can safely walk off.
			if b.rideable and self.y <= b.y - (.005 + (self.height - .75)) then 
				self.y = b.y - self.height
				self.speedy = 0
				print("Giving leeway to Mario's Position (Right)")
				print(self.height)
				return false
			end
			
			self:murder(b, b.doesdamagetype, "Enemy (rightcollide)")
			return false
		end
	elseif a == "tile" then
		local x, y = b.cox, b.coy
			
		if map[x][y].gels and map[x][y].gels.left == 1 then
			if self:bluegel("left") then
				return false
			end
		end
		
		--check for invisible block
		if tilequads[map[x][y][1]]:getproperty("invisible", x, y) then
			return false
		end
		
		--Check if it's a pipe with pipe pipe.
		if self.falling == false and self.jumping == false and (self.binds.control.playerRight or intermission) then --but only on ground and rightkey
			local t2 = map[x][y][2]
			if t2 and entitylist[t2] and entitylist[t2].t == "warppipe" and map[x][y][8] then
				self:pipe(x, y, "right", map[x][y])
				return
			else
				if inmap(x, y+1) then
					t2 = map[x][y+1][2]
					if t2 and entitylist[t2] and entitylist[t2].t == "warppipe" and map[x][y][8] then
						self:pipe(x, y+1, "right", map[x][y+1])
						return
					end
				end
			end
		end
		
		--Check if mario should run across a gap.
		if allowskip and inmap(x, y-1) and tilequads[map[x][y-1][1]]:getproperty("collision", x, y-1) == false and self.speedy > 0 and self.y+self.height+1 < y+spacerunroom then
			self.y = b.y - self.height
			self.speedy = 0
			self.x = b.x-self.width+0.0001
			self.falling = false
			self.animationstate = "running"
			self:setquad()
			return false
		end
		
		if bigmario then
			self:destroyblock(x, y)
			return false
		end
	elseif a == "box" and self.gravitydirection == math.pi/2 then
		if self.speedx > maxwalkspeed/2 then
			self.speedx = self.speedx - self.speedx * 6 * gdt
		end
		
		--check if box can even move
		local out = checkrect(b.x+self.speedx*gdt, b.y, b.width, b.height, {"exclude", b}, true)
		if #out == 0 then
			b.speedx = self.speedx
			return false
		end
	elseif a == "button" then
		self.y = b.y - self.height
		self.x = b.x - self.width+0.001
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "lightbridgebody" and b.gels.left == 1 then
		if self:bluegel("left") then
			return false
		end
	end
	
	if self.falling == false and self.jumping == false then
		self.animationstate = "idle"
		self:setquad()
	end
end

function player:leftcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "left") then
		return false
	end
	
	allowskip = self.gravitydirection == math.pi/2
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
	
	--star logic
	if self.starred or bigmario then
		if self:starcollide(a, b, c, d) then
			return false
		end
	end
	
	if self.speedy > 2 and b.stompable then
		self:stompenemy(a, b, c, d, true)
		return false
	elseif b.kills or b.killsonsides or a == "bowser" then --KILLS
		if self.invincible then
			if b.shellanimal and b.small and b.speedx == 0 then
				b:do_damage("stomp", self)
				--playsound("shot", self.x, self.y, self.speedx, self.speedy)
				--addpoints(500, b.x, b.y)
			end
			return false
		else
			if self.raccoonspinframe then
				b:do_damage("tailspin", self)
				--b:shotted("left", true, true)
				--addpoints(firepoints[b.t] or 100, self.x, self.y)
				return false
			end
			
			if b.shellanimal and b.small and b.speedx == 0 then
				b:do_damage("stomp", self)
				--playsound("shot", self.x, self.y, self.speedx, self.speedy)
				--addpoints(500, b.x, b.y)
				return false
			end
			
			--Check if Mario is walking off a ridable enemy, so that he can safely walk off.
			if b.rideable and self.y <= b.y - (.005 + (self.height - .75)) then 
				self.y = b.y - self.height
				self.speedy = 0
				print("Giving leeway to Mario's Position (Left)")
				print(self.height)
				return false
			end
			
			
			self:murder(b, b.doesdamagetype, "Enemy (leftcollide)")
			return false
		end
	elseif a == "tile" then
		local x, y = b.cox, b.coy
		
		if map[x][y].gels and map[x][y].gels.right == 1 then
			if self:bluegel("right") then
				return false
			end
		end
		
		--check for invisible block
		if tilequads[map[x][y][1]]:getproperty("invisible", x, y) then
			return false
		end
		
		--Check if it's a pipe with pipe pipe.
		--@WARNING: If anything breaks in an intermission, it's because we did put this here.
		if not self.falling and not self.jumping and (self.binds.control.playerLeft or intermission) then --but only on ground and leftkey
			local t2 = map[x][y][2]
			if t2 and entitylist[t2] and entitylist[t2].t == "warppipe" and map[x][y][8] then
				self:pipe(x, y, "left", map[x][y])
				return
			else
				if inmap(x, y+1) then
					t2 = map[x][y+1][2]
					if t2 and entitylist[t2] and entitylist[t2].t == "warppipe" and map[x][y+1][8] then
						self:pipe(x, y+1, "left", map[x][y+1])
						return
					end
				end
			end
		end
		
		--Check if mario should run across a gap.
		if allowskip and inmap(x, y-1) and tilequads[map[x][y-1][1]]:getproperty("collision", x, y-1) == false and self.speedy > 0 and self.y+1+self.height < y+spacerunroom then
			self.y = b.y - self.height
			self.speedy = 0
			self.x = b.x+1-0.0001
			self.falling = false
			self.animationstate = "running"
			self:setquad()
			return false
		end
	
		if bigmario then
			self:destroyblock(x, y)
			return false
		end
	elseif a == "box" and self.gravitydirection == math.pi/2 then
		if self.speedx < -maxwalkspeed/2 then
			self.speedx = self.speedx - self.speedx * 6 * gdt
		end
		
		--check if box can even move
		local out = checkrect(b.x+self.speedx*gdt, b.y, b.width, b.height, {"exclude", b}, true)
		if #out == 0 then
			b.speedx = self.speedx
			return false
		end
	elseif a == "button" then
		self.y = b.y - self.height
		self.x = b.x + b.width - 0.001
		if self.speedy > 0 then
			self.speedy = 0
		end
		return false
	elseif a == "lightbridgebody" and b.gels.right == 1 then
		if self:bluegel("right") then
			return false
		end
	end
	
	if self.falling == false and self.jumping == false then
		self.animationstate = "idle"
		self:setquad()
	end
end

function player:ceilcollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "ceil") then
		return false
	end
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
	
	--star logic
	if self.starred or bigmario then
		if self:starcollide(a, b, c, d) then
			return false
		end
	end
	
	if b.kills or b.killsonbottom then --STUFF THAT KILLS
		if b.shellanimal and b.small and b.speedx == 0 then
			self:stompenemy(a, b, c, d, true)
			return false
		end
		
		if self.invincible then
			return false
		else
			self:murder(b, b.doesdamagetype, "Enemy (Ceilcollided)")
			return false
		end
	elseif a == "tile" then
		local x, y = b.cox, b.coy
		local r = map[x][y]
		
		--check if it's an invisible block
		if tilequads[map[x][y][1]]:getproperty("invisible", x, y) then
			if self.y-self.speedy <= y-1 then
				return false
			end
		else
			if bigmario then
				self:destroyblock(x, y)
				return false
			end
			
			--Check if it should bounce the block next to it, or push mario instead (Hello, devin hitch!)
			
			if self.gravitydirection == math.pi/2 then
				if self.x < x-22/16 then
					--check if block left of it is a better fit
					if x > 1 and tilequads[map[x-1][y][1]]:getproperty("collision", x-1, y) == true then
						x = x - 1
					else
						local col = checkrect(x-28/16, self.y, self.width, self.height, {"exclude", self}, true)
						if #col == 0 then
							self.x = x-28/16
							if self.speedx > 0 then
								self.speedx = 0
							end
							return false
						end					
					end
				elseif self.x > x-6/16 then
					--check if block right of it is a better fit
					if x < mapwidth and tilequads[map[x+1][y][1]]:getproperty("collision", x+1, y) == true then
						x = x + 1
					else
						local col = checkrect(x, self.y, self.width, self.height, {"exclude", self}, true)
						if #col == 0 then
							self.x = x
							if self.speedx < 0 then
								self.speedx = 0
							end
							return false
						end	
					end
				end
			end
		end

		self:hitblock(x, y)
	end
	
	self.jumping = false
	if not self.vine then
		self.falling = true
		self.speedy = headforce
	end
end

function player:globalcollide(a, b, c, d, dir)
	self.lastcollision = {a, b, c, d, dir}
	
	if a == "platform" or a == "seesawplatform" then
		if dir == "floor" then
			if self.jumping and self.speedy < -jumpforce + 0.1 then
				return true
			end
		else
			return true
		end
	end
	
	if b.collect then
		b:collect(self)
		return true
	end
	
	if a == "screenboundary" then
		if self.x+self.width/2 > b.x then
			self.x = b.x
		else
			self.x = b.x-self.width
		end
		self.speedx = 0
		if self.falling == false and self.jumping == false then
			self.animationstate = "idle"
			self:setquad()
		end
		return true
	elseif a == "vine" then
		if self.vine == false then
			self:grabvine(b)
		end
		
		return true
	elseif a == "tile" then
		--check for spikes
		if self.invincible or self.starred then
			--super mario dadada, dada-da, dada-da. dadada, dada-da, dada-da...
		else
			dir = twistdirection(self.gravitydirection, dir)
			if dir == "ceil" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikesbottom", b.cox, b.coy) then
				self:murder(nil, "spike", "Spike (bottom)")
				return false
			elseif dir == "right" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikesleft", b.cox, b.coy) then
				self:murder(nil, "spike", "Spike (left)")
				return false
			elseif dir == "left" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikesright", b.cox, b.coy) then
				self:murder(nil, "spike", "Spike (right)")
				return false
			elseif dir == "floor" and tilequads[map[b.cox][b.coy][1]]:getproperty("spikestop", b.cox, b.coy) then
				self:murder(nil, "spike", "Spike (top)")
				return false
			end
		end
	elseif b.ispowerup then
		self:getpowerup(b.poweruptype, b.powerdowntarget, b.t)
		return true
	elseif b.givesalife then
		if b.lifeamount then
			givemestuff["lives"] = b.lifeamount
			givemestuff["lives"] = b.lifeamount
		end
		self:getlife(b.lifeamount or 1)
		return true
	elseif b.givestime then
		if b.timeamount then
			givemestuff["time"] = b.timeamount
		end
		givetime(self.playernumber, b)
		return true
	elseif b.istrophy then
		oddjobquotas[2] = 1
		gotatrophy(self.playernumber, b)
		return true
	elseif b.givecoinoncollect then
		self:getcoin(b.givecoinoncollect)--@WARNING: I left out x, y because that would collect the coin at wherever the enemy is
		return true
	elseif b.makesmariostar then
		self:star()
		return true
	end
end

function twistdirection(gravitydir, dir)
	if not gravitydir or (gravitydir > math.pi/4*1 and gravitydir <= math.pi/4*3) then
		if dir == "floor" then
			return "floor"
		elseif dir == "left" then
			return "left"
		elseif dir == "ceil" then
			return "ceil"
		elseif dir == "right" then
			return "right"
		end
	elseif gravitydir > math.pi/4*3 and gravitydir <= math.pi/4*5 then
		if dir == "floor" then
			return "left"
		elseif dir == "left" then
			return "ceil"
		elseif dir == "ceil" then
			return "right"
		elseif dir == "right" then
			return "floor"
		end
	elseif gravitydir > math.pi/4*5 and gravitydir <= math.pi/4*7 then
		if dir == "floor" then
			return "ceil"
		elseif dir == "left" then
			return "right"
		elseif dir == "ceil" then
			return "floor"
		elseif dir == "right" then
			return "left"
		end
	else
		if dir == "floor" then
			return "right"
		elseif dir == "left" then
			return "floor"
		elseif dir == "ceil" then
			return "left"
		elseif dir == "right" then
			return "ceil"
		end
	end
end

function player:passivecollide(a, b, c, d)
	if self:globalcollide(a, b, c, d, "passive") then
		return false
	end
	
	if a == "tile" then
		if tilequads[map[b.cox][b.coy][1]]:getproperty("platform", b.cox, b.coy) then
			return false
		end
	end
	
	if a == "box" then
		if self.speedx < 0 then
			if self.speedx < -maxwalkspeed/2 then
				self.speedx = self.speedx - self.speedx * 0.1
			end
			
			--check if box can even move
			local out = checkrect(b.x+self.speedx*gdt, b.y, b.width, b.height, {"exclude", b})
			if #out == 0 then	
				b.speedx = self.speedx
				return false
			end
		else
			if self.speedx > maxwalkspeed/2 then
				self.speedx = self.speedx - self.speedx * 6 * gdt
			end
			
			--check if box can even move
			local out = checkrect(b.x+self.speedx*gdt, b.y, b.width, b.height, {"exclude", b})
			if #out == 0 then	
				b.speedx = self.speedx
				return false
			end
		end
	end
	if self.passivemoved == false then
		self.passivemoved = true
		if a == "tile" or a == "portalwall" then
			if a == "tile" then
				local x, y = b.cox, b.coy
				
				--check for invisible block
				if inmap(x, y) and tilequads[map[x][y][1]]:getproperty("invisible", x, y) then
					return false
				end
			end
			if self.pointingangle < 0 then
				self.x = self.x - passivespeed*gdt
			else
				self.x = self.x + passivespeed*gdt
			end
			self.speedx = 0
		else
			--nothing, lol.
		end
	end
	
	
	self:rightcollide(a, b, c, d)
end

function player:starcollide(a, b, c, d)
	--enemies that die
	if a == "enemy" then
		b:do_damage("star",self,"right")
		--b:shotted("right", nil, nil, false, true)
		--addpoints(firepoints[b.t] or 100, self.x, self.y)
		return true
		--@DEV: we're gonna ignore those special exceptions right now
	--elseif a == "bowser" then
		--b:shotted("right")
		--return true
	--enemies (and stuff) that don't do shit
	--elseif a == "upfire" or a == "fire" or a == "hammer" or a == "fireball" or a == "castlefirefire" then
		--return true
	end
end

function player:hitspring(b)
	b:hit()
	self.springb = b
	self.springx = self.x
	self.springy = b.coy
	self.speedy = 0
	self.spring = true
	self.springhigh = false
	self.springtimer = 0
	self.gravity = 0
	self.mask[19] = true
	self.animationstate = "idle"
	self:setquad()
end

function player:hitpswitch(b)
	b:hit()
end

function player:leavespring()
	self.y = self.springy - self.height-31/16
	if self.springhigh then
		if self.springb.type == "vanilla" then  -- Regular Springboard
			self.speedy = -springhighforce
		elseif self.springb.type == "high" then  -- High Springboard
			self.speedy = -springhighhighforce
		else 
			self.speedy = -springhighforce	
		end
	else
		self.speedy = -springforce
	end
	self.animationstate = "falling"
	self:setquad()
	self.gravity = yacceleration
	self.falling = true
	self.spring = false
	self.mask[19] = false
end

function player:dropvine(dir)
	if dir == "right" then
		self.x = self.x + 8/16
	else
		self.x = self.x - 6/16
	end
	self.y = self.y - self.height + 12/16
	self.animationstate = "falling"
	self:setquad()
	self.gravity = mariogravity
	self.vine = false
	self.mask[18] = false
end

function player:grabvine(b)
	if self.ducking then
		self:duck(false)
	end
	if insideportal(self.x, self.y, self.width, self.height) then
		return
	end
	self.mask[18] = true
	self.vine = b
	self.gravity = 0
	self.speedx = 0
	self.speedy = 0
	self.animationstate = "climbing"
	self.climbframe = 2
	self.vinemovetimer = 0
	self:setquad()
	self.vinex = b.cox
	self.viney = b.coy
	if b.x > self.x then --left of vine
		self.x = b.x+b.width/2-self.width+1/16
		self.pointingangle = -math.pi/2
		self.animationdirection = "right"
		self.vineside = "left"
	else --right
		self.x = b.x+b.width/2 - 3/16
		self.pointingangle = math.pi/2
		self.animationdirection = "left"
		self.vineside = "right"
	end
end

function player:hitblock(x, y)
	hitblock(x, y, self)
end

function hitblock(x, y, t, koopa)	
	for i, v in pairs(portals) do
		if v.x1 and v.x2 and v.y1 and v.y2 then
			local x1 = v.x1
			local y1 = v.y1
			
			local x2 = v.x2
			local y2 = v.y2
			
			local x3 = x1
			local y3 = y1
			
			if v.facing1 == "up" then
				x3 = x3+1
			elseif v.facing1 == "right" then
				y3 = y3+1
			elseif v.facing1 == "down" then
				x3 = x3-1
			elseif v.facing1 == "left" then
				y3 = y3-1
			end
			
			local x4 = x2
			local y4 = y2
			
			if v.facing2 == "up" then
				x4 = x4+1
			elseif v.facing2 == "right" then
				y4 = y4+1
			elseif v.facing2 == "down" then
				x4 = x4-1
			elseif v.facing2 == "left" then
				y4 = y4-1
			end
			
			if (x == x1 and y == y1) or (x == x2 and y == y2) or (x == x3 and y == y3) or (x == x4 and y == y4) then
				return
			end
		end
	end


	if editormode then
		return
	end

	if not inmap(x, y) then
		return
	end
	
	local r = map[x][y]
	if not t or not t.infunnel then
		playsound("blockhit", x-0.5, y-1)
	end
	
	if tilequads[r[1]]:getproperty("breakable", x, y) == true or tilequads[r[1]]:getproperty("coinblock", x, y) == true then --Block should bounce!
		table.insert(blockbouncetimer, 0.000000001) --yeah it's a cheap solution to a problem but screw it.
		table.insert(blockbouncex, x)
		table.insert(blockbouncey, y)
		if #r > 1 and entitylist[r[2]] and entitylist[r[2]].t ~= "manycoins" then --block contained something!
			table.insert(blockbouncecontent, entitylist[r[2]].t)
			table.insert(blockbouncecontent2, t.size)
			if tilequads[r[1]]:getproperty("invisible", x, y) then
				if spriteset == 1 then
					map[x][y][1] = 113
				elseif spriteset == 2 then
					map[x][y][1] = 118
				else
					map[x][y][1] = 112
				end
			else
				if spriteset == 1 then
					map[x][y][1] = 113
				elseif spriteset == 2 then
					map[x][y][1] = 114
				else
					map[x][y][1] = 117
				end
			end
			if entitylist[r[2]].t == "vine" then
				--playsound("vine", x-0.5, y-1)
			else
				playsound("mushroomappear", x-0.5, y-1)
			end
		elseif #r > 1 and table.contains(enemies, r[2]) then
			table.insert(blockbouncecontent, r[2])
			table.insert(blockbouncecontent2, t.size)
			playsound("mushroomappear", x-0.5, y-1)
			
			
			if tilequads[r[1]]:getproperty("invisible", x, y) then
				if spriteset == 1 then
					map[x][y][1] = 113
				elseif spriteset == 2 then
					map[x][y][1] = 118
				else
					map[x][y][1] = 112
				end
			else
				if spriteset == 1 then
					map[x][y][1] = 113
				elseif spriteset == 2 then
					map[x][y][1] = 114
				else
					map[x][y][1] = 117
				end
			end
		else
			table.insert(blockbouncecontent, false)
			table.insert(blockbouncecontent2, t.size)
			
			if (koopa or (t and t.size > 1)) and tilequads[r[1]]:getproperty("coinblock", x, y) == false and (#r == 1 or (entitylist[r[2]] and entitylist[r[2]].t ~= "manycoins")) then --destroy block!
				destroyblock(x, y, t)
			end
		end
		
		if #r == 1 and tilequads[r[1]]:getproperty("coinblock", x, y) then --coinblock
			playsound("coin", x-0.5, y-1) --not sure if these slight offsets are correct
			if tilequads[r[1]]:getproperty("invisible", x, y) then
				if spriteset == 1 then
					map[x][y][1] = 113
				elseif spriteset == 2 then
					map[x][y][1] = 118
				else
					map[x][y][1] = 112
				end
			else
				if spriteset == 1 then
					map[x][y][1] = 113
				elseif spriteset == 2 then
					map[x][y][1] = 114
				else
					map[x][y][1] = 117
				end
			end
			if #r == 1 then
				table.insert(coinblockanimations, coinblockanimation:new(x-0.5, y-1))
				
				traceinfluence(t):getcoin(1, nil, nil, x-0.5, y-1)
				--@WARNING: These might not be right, but, who knows
			end
		end
		
		if #r > 1 and entitylist[r[2]] and entitylist[r[2]].t == "manycoins" then --block with many coins inside! yay $_$
			table.insert(coinblockanimations, coinblockanimation:new(x-0.5, y-1))
			traceinfluence(t):getcoin(1, nil, nil, x-0.5, y-1)
			
			local exists = false
			for i = 1, #coinblocktimers do
				if x == coinblocktimers[i][1] and y == coinblocktimers[i][2] then
					exists = i
				end
			end
			
			if not exists then
				table.insert(coinblocktimers, {x, y, coinblocktime})
			elseif coinblocktimers[exists][3] <= 0 then
				--@WARNING: Magic tileID transformations, this is bad.
				if spriteset == 1 then
					map[x][y][1] = 113
				elseif spriteset == 2 then
					map[x][y][1] = 114
				else
					map[x][y][1] = 117
				end
			end
		end
		
		--kill enemies on top
		for j, w in pairs(objects["enemy"]) do
			if not w.notkilledfromblocksbelow then
				local centerX = w.x + w.width/2
				if inrange(centerX, x-1, x, true) and y-1 == w.y+w.height then
					--get dir
					local dir = "right"
					if w.x+w.width/2 < x-0.5 then
						dir = "left"
					end
					
					--if w.shotted then
					--@WARNING: FLAGRANTLY DISREGARDING SAFETY
					w:do_damage("bump", traceinfluence(t), dir, true)
						--addpoints(100, w.x+w.width/2, w.y)
						--@WARNING: origin of points might not be right, but, who knows
					--end
				end
			end
		end
		
		--make items jump
		for j, w in pairs(objects["enemy"]) do
			if w.jumpsfromblocksbelow then
				local centerX = w.x + w.width/2
				if inrange(centerX, x-1, x, true) and y-1 == w.y+w.height then
					w.falling = true
					w.speedy = -(w.jumpforce or mushroomjumpforce)
					if w.x+w.width/2 < x-0.5 then
						w.speedx = -math.abs(w.speedx)
					elseif w.x+w.width/2 > x-0.5 then
						w.speedx = math.abs(w.speedx)
					end
				end
			end
		end
		
		--check for coin on top
		if inmap(x, y-1) and coinmap[x][y-1] then
			traceinfluence(t):getcoin(1, x, y-1)
			table.insert(coinblockanimations, coinblockanimation:new(x-0.5, y-1))
		end
		generatespritebatch()
	end
end

function player:goinvincible()
	self.animationstate = self.animationmisc
	self.animation = "invincible"
	self.invincible = true
	noupdate = false
	if self.size==1 then
		self.quadcenterY = self.char.smallquadcenterY
		self.quadcenterX = self.char.smallquadcenterX
		self.offsetY = self.char.smalloffsetY
	else
		self.quadcenterY = self.char.bigquadcenterY
		self.quadcenterX = self.char.bigquadcenterX
		self.offsetY = self.char.bigoffsetY
	end
	self.animationtimer = 0
	
	self.drawable = true
end

function player:destroyblock(x, y)
	return destroyblock(x, y, self)
end

function destroyblock(x, y, t)
	for i = 1, players do
		local v = objects["player"][i].portal
		local x1 = v.x1
		local y1 = v.y1
		
		local x2 = v.x2
		local y2 = v.y2
		
		local x3 = x1
		local y3 = y1
		
		if v.facing1 == "up" then
			x3 = x3+1
		elseif v.facing1 == "right" then
			y3 = y3+1
		elseif v.facing1 == "down" then
			x3 = x3-1
		elseif v.facing1 == "left" then
			y3 = y3-1
		end
		
		local x4 = x2
		local y4 = y2
		
		if v.facing2 == "up" then
			y4 = y4-1
		elseif v.facing2 == "right" then
			x4 = x4+1
		elseif v.facing2 == "down" then
			y4 = y4+1
		elseif v.facing2 == "left" then
			x4 = x4-1
		end
		
		if (x == x1 and y == y1) or (x == x2 and y == y2) or (x == x3 and y == y3) or (x == x4 and y == y4) then
			return
		end
	end
	
	map[x][y][1] = 1
	objects["tile"][x .. "-" .. y] = nil
	map[x][y]["gels"] = {}
	playsound("blockbreak", x, y) --blocks don't move, we want the position of the block
	
	traceinfluence(t):getscore(score_enum.block_break, x-0.5, y-1)
	
	blockdebris:new(x, y, "right", 1)
	blockdebris:new(x, y, "right", 0)
	blockdebris:new(x, y, "left", 1)
	blockdebris:new(x, y, "left", 0)
	
	generatespritebatch()
end

function player:faithplate(dir)
	self.animationstate = "jumping"
	self.falling = true
	self:setquad()
end

function player:startfall()
	if self.falling == false then
		self.falling = true
		self.animationstate = "falling"
		self:setquad()
	end
end
function traceinfluence(b)
	if not b then return nil end
	
	if b.getcoin then
		return b
	elseif b.lastinfluence then
		return b.lastinfluence
	else
		print("CRITICAL: Couldn't trace an influence from", b)
		return b
	end
end
function player:murder(attacker, dtype, how)
	--print("moyided", traceinfluence(attacker), dtype, how)
	killfeed.new(traceinfluence(attacker), dtype, self)
	self:die(how)
end

function player:die(how)
	print("Mario was told to die because '"..how.."' also he is size "..tostring(self.size))
	if self.dead then 
		return
	end
	if editormode then
		self.y = 0
		self.speedy = 0
		return
	end
	
	
	if how ~= "pit" and how ~= "time" then
		if self.size > 1 then
			self:washurt(how)
			return
		end
	elseif how ~= "time" then
		if bonusstage then
			levelscreen_load("sublevel", 0)
			return
		end
	end
	
	self.dead = true
	
	if self.pickup then
		self:drop_held()
	end
	
	if not arcade then
		everyonedead = true
		for i = 1, players do
			if not objects["player"][i].dead then
				everyonedead = false
			end
		end
	end
	
	self.animationmisc = false
	if everyonedead then
		self.animationmisc = "everyonedead"
		love.audio.stop()
	end
	
	playsound("death", self.x, self.y) --happens at a point, therefore velocity gets binned
	
	if how == "time" then
		noupdate = false
		self.quadcenterY = self.char.smallquadcenterY
		self.graphic = self.smallgraphic
		self.size = 1
		self.quadcenterX = self.char.smallquadcenterX
		self.offsetY = self.char.smalloffsetY
		self.drawable = true
	end
	
	if how == "pit" then
		self.animation = "deathpit"
		self.size = 1
		self.drawable = false
		self.invincible = false
	else
		self.animation = "death"
		self.drawable = true
		self.invincible = false
		self.animationstate = "dead"
		self:setquad()
		self.speedy = 0
	end
	
	self.y = self.y - 1/16
	
	self.animationx = self.x
	self.animationy = self.y
	self.infunnel = false
	self.animationtimer = 0
	self.controlsenabled = false
	self.active = false
	prevsublevel = false
	
	if not levelfinished and not testlevel and not infinitelives and mariolivecount ~= false and not arcade and not mkstation then
		self.lives = self.lives - 1
	end
	return
end

function player:laser(dir)
	if self.pickup then
		if dir == "right" and self.pointingangle < 0 then
			return
		elseif dir == "left" and self.pointingangle > 0 then
			return
		elseif dir == "up" and self.pointingangle > -math.pi/2 and self.pointingangle < math.pi/2 then
			return
		elseif dir == "down" and (self.pointingangle > math.pi/2 or self.pointingangle < -math.pi/2) then
			return
		end
	end
	self:murder(nil, "laser", "Laser")
end

function getAngleFrame(angle, rotation)
	angle = angle + rotation

	if angle > math.pi then
		angle = angle - math.pi*2
	elseif angle < -math.pi then
		angle = angle + math.pi*2
	end

	local mouseabs = math.abs(angle)
	local angleframe
	
	if mouseabs < math.pi/8 then
		angleframe = 1
	elseif mouseabs >= math.pi/8 and mouseabs < math.pi/8*3 then
		angleframe = 2
	elseif mouseabs >= math.pi/8*3 and mouseabs < math.pi/8*5 then
		angleframe = 3
	elseif mouseabs >= math.pi/8*5 and mouseabs < math.pi/8*7 then
		angleframe = 4
	elseif mouseabs >= math.pi/8*7 then
		angleframe = 4
	end
	
	return angleframe
end

function player:emancipate(a)
	self:removeportals()
	
	local delete = {}
	
	for i, v in pairs(objects["portalprojectile"]) do
		if v.payload[1] == self.playernumber then
			table.insert(delete, i)
		end
	end
	
	table.sort(delete, function(a,b) return a>b end)
	
	for i, v in pairs(delete) do
		table.remove(objects["portalprojectile"], v) --remove
	end
	
	if self.pickup then
		self.pickup:emancipate()
	end
end

function player:removeportals(i)
	if self.portalsavailable[1] or self.portalsavailable[2] then
		playsound("portalfizzle", self.x, self.y, self.speedx, self.speedy) --play locally in addition to the portal positions as confirmation that it happened, otherwise, nothing
	end
	
	if self.portalsavailable[1] then
		self.portal:removeportal(1)
	end
	if self.portalsavailable[2] then
		self.portal:removeportal(2)
	end
end

function player:use(xcenter, ycenter)
	if not xcenter then
		xcenter = self.x + 6/16 - math.sin(self.pointingangle)*userange
		ycenter = self.y + 6/16 - math.cos(self.pointingangle)*userange
	end
	
	if self.pickup then
		if self.pickup.destroy then
			self.pickup = false
		else
			self:drop_held()
			return
		end
	end
	
	-- this used to be the check userect function but we murdered it
	for i, v in pairs(objects["userect"]) do
		if aabb(
			xcenter-usesquaresize/2,
			ycenter-usesquaresize/2,
			usesquaresize, usesquaresize,
			v.x, v.y, v.width, v.height) then
			v.parent:used(self)
			break
		end
	end
end

function player:pick_up(itm)
	self.pickup = itm
end

function player:drop_held()
	self.pickup:setSpeed(self.speedx, self.speedy, 0) --@WARNING: dummied Z
	self.pickup.gravitydirection = self.gravitydirection
	
	local set = false
	
	local boxx = self.x+math.sin(-self.pointingangle)*0.3
	local boxy = self.y-math.cos(-self.pointingangle)*0.3
	
	if self.pointingangle < 0 then
		if #checkrect(self.x+self.width, self.y+self.height-12/16, 12/16, 12/16, {"exclude", self.pickup}, true) == 0 then
			self.pickup.x = self.x+self.width
			self.pickup.y = self.y+self.height-12/16
			set = true
		end
	else
		if #checkrect(self.x-12/16, self.y+self.height-12/16, 12/16, 12/16, {"exclude", self.pickup}, true) == 0 then
			self.pickup.x = self.x-12/16
			self.pickup.y = self.y+self.height-12/16
			set = true
		end
	end
	
	if set == false then
		if #checkrect(self.x+self.width, self.y+self.height-12/16, 12/16, 12/16, {"exclude", self.pickup}, true) == 0 then
			self.pickup.x = self.x+self.width
			self.pickup.y = self.y+self.height-12/16
		elseif #checkrect(self.x-12/16, self.y+self.height-12/16, 12/16, 12/16, {"exclude", self.pickup}, true) == 0 then
			self.pickup.x = self.x-12/16
			self.pickup.y = self.y+self.height-12/16
		elseif #checkrect(self.x, self.y+self.height, 12/16, 12/16, {"exclude", self.pickup}, true) == 0 then
			self.pickup.x = self.x
			self.pickup.y = self.y+self.height
		elseif #checkrect(self.x, self.y-12/16, 12/16, 12/16, {"exclude", self.pickup}, true) == 0 then
			self.pickup.x = self.x
			self.pickup.y = self.y-12/16
		else
			self.pickup.x = self.x
			self.pickup.y = self.y
		end
	end
	
	for h, u in pairs(objects["emancipationgrill"]) do
		if u.dir == "hor" then
			if inrange(self.pickup.x+6/16, u.startx-1, u.endx, true) and inrange(u.coy-14/16, boxy, self.pickup.y, true) then
				self.pickup:emancipate(h)
			end
		else
			if inrange(self.pickup.y+6/16, u.starty-1, u.endy, true) and inrange(u.cox-14/16, boxx, self.pickup.x, true) then
				self.pickup:emancipate(h)
			end
		end
	end
	self.pickup:drop()
	self.pickup = nil
end

function player:cubeemancipate()
	self.pickup = false
end

function player:duck(ducking) --goose
	if self.infunnel then
		self.ducking = false
		return
	else
		self.ducking = ducking
	end
	
	if self.ducking then
		self.raccoonspinframe = false
		self.y = self.y + 12/16
		self.height = 12/16
		self.quadcenterY = self.char.duckquadcenterY
		self.offsetY = self.char.duckoffsetY
	else
		self.y = self.y - 12/16
		self.height = 24/16
		self.quadcenterY = self.char.bigquadcenterY
		self.offsetY = self.char.bigoffsetY
	end
end

function player:pipe(x, y, dir, ex)
	if editormode then
		return
	end
	print("piped", x, y, dir, ex)

	-- ex == the pipe data
	self.active = false
	self.infunnel = false
	self.animation = "pipe_" .. dir .."_in"
	self.invincible = false
	self.drawable = true
	self.animationx = x
	self.animationy = y
	self.animationtimer = 0
	if ex then
		self.animationmisc = ex
	end
	self.controlsenabled = false
	playsound("pipe", x, y) --pipe cancels out movement, using velocity would be "throwing one's voice"
	
	if intermission then
		respawnsublevel = i
	end
	
	if dir == "down" then
		if self.size > 1 then
			self.animationy = y - self.height + 12/16
		end
		self.animationstate = "idle"
		self.customscissor = {x-4, y-3, 6, 2}
	elseif dir == "right" then
		self.y = self.animationy-1/16 - self.height
		self.animationstate = "running"
		self.customscissor = {x-2, y-5, 1, 6}
	elseif dir == "left" then
		self.y = self.animationy-1/16 - self.height
		self.animationstate = "running"
		self.customscissor = {x, y-5, 1, 6}
	elseif dir == "up" then
		self.animationy = y - 20/16
		self.animationstate = "idle"
		self.customscissor = {x+2.5, y+4, -6, -4}
	end
	
	self:setquad()
end

function player:savereplaydata()
	local i = 1
	while love.filesystem.exists("replay" .. i .. ".txt") do
		i = i + 1
	end
	
	local rep = {data=livereplaydata[self.playernumber]}
	
	local s = JSON:encode(rep)
	love.filesystem.write("replay" .. i .. ".txt", s)
	
	
	for j = 2, #rep.data do
		for k, v in pairs(rep.data[j-1]) do
			if rep.data[j][k] == nil then
				rep.data[j][k] = v
			end
		end
	end
	
	table.insert(replaydata, rep)
	
	replaytimer[#replaydata] = 0
	replayi[#replaydata] = 0
	replaychar[#replaydata] = characters.mario
	
	for i = 1, #replaydata do
		replayi[i] = 1
	end
end

function player:flag()	
	for i = 1, players do
		objects["player"][i].invincible = true
	end
	
	if levelfinished then
		return
	end
	
	self.raccoontimer = 0
	self.ducking = false
	self.animation = "flag"
	self.drawable = true
	self.controlsenabled = false
	self.animationstate = "climbing"
	self.pointingangle = -math.pi/2
	self.animationdirection = "right"
	self.animationtimer = 0
	self.speedx = 0
	self.speedy = 0
	self.x = flagx-2/16
	self.gravity = 0
	self.climbframe = 2
	self.active = false
	self.infunnel = false
	self:setquad()
	levelfinished = true
	levelfinishtype = "flag"
	subtractscore = false
	dofirework = false
	castleflagy = castleflagstarty
	objects["screenboundary"]["flag"].active = false
	
	--get score
	flagscore = flagscores[1]
	for i = 1, #flagvalues do
		if self.y < flagvalues[i]-13+flagy then
			flagscore = flagscores[i+1]
		else
			break
		end
	end
	
	self:getscore(flagscore)
	
	--get firework count
	fireworkcount = tonumber(string.sub(math.ceil(mariotime), -1, -1))
	if fireworkcount ~= 1 and fireworkcount ~= 3 and fireworkcount ~= 6 then
		fireworkcount = 0
	end
	
	if portalbackground then
		fireworkcount = 0
	end
	
	love.audio.stop()
	
	
	playsound("levelend", self.x, self.y, self.speedx, self.speedy)
end

function player:vineanimation()
	self.infunnel = false
	self.animation = "vine"
	self.invincible = false
	self.drawable = true
	self.controlsenabled = false
	self.animationx = self.x
	self.animationy = vineanimationstart
	self.animationmisc = map[self.vinex][self.viney][3]-1
	self.active = false
	self.vine = false
end

function player:star()
	self:getscore(score_enum.collect_star)
	self.startimer = 0
	self.colors = starcolors[1]
	self.starred = true
	stopmusic()
	music:play("starmusic.ogg")
end

function player:fire()
	if (not noupdate and self.animation ~= "grow1" and self.animation ~= "grow2") and self.char.raccoon and self.size >= 2 and not self.ducking and not self.raccoonspinframe then --Wiggle wiggle wag wag
		self.raccoonspinframe = 1
		self.raccoonspintimer = 0
		
		self:spinhit(self.x+self.width+.75, self.y+self.height-.5, "right")
		self:spinhit(self.x-.75, self.y+self.height-.5, "left")
	end
	if (not noupdate and self.animation ~= "grow1" and self.animation ~= "grow2") and self.controlsenabled and self.powerupstate == "fire" and self.ducking == false then
		if self.fireballcount < maxfireballs then
			local dir = "right"
			local mul = 1
			if (self.portalsavailable[1] or self.portalsavailable[2]) then
				if self.pointingangle > 0 then
					dir = "left"
					mul = -1
				end
			else
				if self.animationdirection == "left" then
					dir = "left"
					mul = -1
				end
			end
			
			fireball:new(self.x, self.y, dir, self)
			
			self.fireballcount = self.fireballcount + 1
			self.fireanimationtimer = 0
			self:setquad()
		end
	end
end

function player:spinhit(x, y, dir)
	local col = checkrect(x, y, 0, 0, "all", true)
	for i = 1, #col, 2 do
		local a = col[i]
		local b = objects[a][col[i+1]]
		if a == "tile" then
			hitblock(b.cox, b.coy, self)
		else
			b:do_damage("spin", self)
			--b:shotted(dir, true, true)
			--addpoints(b.firepoints or 200, self.x, self.y)
		end
	end
end

function player:fireballcallback()
	self.fireballcount = self.fireballcount - 1
	if self.fireballcount < 0 then
		self.fireballcount = 0
		print("NOTICE: Fireball counter was bounded up to zero.")
	end
end

function player:getscore(val, x, y)
	self.score = self.score + val
	if not x and not y then
		-- score appears above us, not anywhere else
		x = self.x
		y = self.y
	end
	--@TODO: make scrollingscores a (sane/based)entity
	
	scrollingtext:new(x, y, val)
end

function player:getlife(val, x, y)
	--@WARNING: x/y underutilized
	self.lives = self.lives + val
	for i=1, val do
		playsound("oneup", self.x, self.y, self.speedx, self.speedy)
	end
end

function player:getcoin(val, x, y, passx, passy)
	if x and y and inmap(x, y) then
		-- we collected a map coin, alter it accordingly
		coinmap[x][y] = false
	end
	self:getscore(score_enum.coin, passx, passy)
	playsound("coin", self.x, self.y, self.speedx, self.speedy) --making "stick to player" because doppler is weird
	self.coins = self.coins + (val or 1)
	
	--@WARNING: this branch of code should be moved to gamemode object
	self:getlife((self.coins - (self.coins % 100))/100, x, y)
	--@NOTE: do hook trigger here for shared lives
	self.coins = self.coins % 100
end

function player:portaled(daportal, entereddir, exitdir)
	if self.pickup then
		self.pickup:portaled()
	end
	
	-- I'm not sorry for this monster, not in the slightest.
	if cheats_active.rainboom and 
		self.rainboomallowed and 
		((exitdir == "up" and self.speedy < -rainboom.basespeed) or
		(exitdir == "left" and self.speedx < -rainboom.basespeed) or
		(exitdir == "right" and self.speedx > rainboom.basespeed) or
		(exitdir == "down" and self.speedy < -rainboom.basespeed)) then
		
		rainboom:new(self.x+self.width/2, self.y+self.height/2, exitdir, self)
	end
end

function player:respawn()
	if mariolivecount ~= false and (self.lives == 0 or levelfinished) then
		return
	end
	
	local i = 1
	while i <= players and (objects["player"][i].dead or (self.playernumber == i and not arcade)) do
		i = i + 1
	end
	
	fastestplayer = objects["player"][i]
	
	local spawnx, spawny
	
	if fastestplayer then
		for i = 2, players do
			if objects["player"][i].x > fastestplayer.x and not objects["player"][i].dead then
				fastestplayer = objects["player"][i]
			end
		end
	end
	
	if fastestplayer then
		spawnx = fastestplayer.x
		spawny = fastestplayer.y + fastestplayer.height-12/16
	elseif pipestartx then
		spawnx = pipestartx-6/16
		spawny = pipestarty-1-1-12/16
	elseif startx and startx[1] then
		spawnx = startx[1]-6/16
		spawny = starty[1]-12/16
	else
		spawnx = 3
		spawny = 12
	end
	
	--Check checkpoints to see if there was a non-all checkpoint!
	if not arcade then
		local checkid = self.playernumber
		if checkid > 4 then
			checkid = 5
		end
		
		if checkpointx[checkid] then
			local checkspawn = false
			for i = 1, 5 do
				if checkpointx[i] ~= checkpointx[checkid] or checkpointy[i] ~= checkpointy[checkid] then
					checkspawn = true
					break
				end
			end
			
			if checkspawn then
				fastestplayer = {x=checkpointx[checkid], y=checkpointy[checkid],height=0}
			end
		end
	end
	
	self.colors = mariocolors[self.playernumber]
	self.speedy = 0
	self.speedx = 0
	self.dead = false
	self.quadcenterY = self.char.smallquadcenterY
	self.height = 12/16
	self.graphic = self.smallgraphic
	self.size = 1
	self.quadcenterX = self.char.smallquadcenterX
	self.offsetY = self.char.smalloffsetY
	self.drawable = true
	self.animationstate = "idle"
	self:setquad()
	
	self.animation = "invincible"
	self.invincible = true
	self.animationtimer = 0
	
	self.y = spawny
	self.x = spawnx
	
	self.jumping = false
	self.falling = true
	self.ducking = false
	
	self.controlsenabled = true
	self.active = true
end

function player:dive(water)
	if water then
		self.gravity = uwgravity
		self.underwater = true
		self.speedx = self.speedx*waterdamping
		self.speedy = self.speedy*waterdamping
	else
		self.gravity = mariogravity
		if not underwater then
			self.underwater = false
		end
		if self.speedy < 0 then
			self.speedy = -waterjumpforce
		end
	end
	self:setquad()
end

function player:enteredfunnel(inside)
	if inside then
		if self.ducking then
			self:duck(false)
		end
		self.infunnel = true
	else
		self.infunnel = false
	end
end

function player:animationwalk(dir)
	self.animation = "animationwalk"
	self.animationstate = "running"
	self.animationmisc = dir
end

function player:stopanimation()
	self.animation = false
end

function player:portalpickup(i)
	self.lastportal = i
	
	if not self.portalsavailable[1] and not self.portalsavailable[2] then
		self.biggraphic = self.char.biganimations
		self.smallgraphic = self.char.animations
		if self.size == 1 then
			self.graphic = self.smallgraphic
		else
			self.graphic = self.biggraphic
		end
	end
	
	self.portalsavailable[i] = true
end
end end)()end;
do -- preload auto aliasing...
	local p = require("package").preload
	for k,v in pairs(p) do
		if k:find("%.init$") then
			local short = k:gsub("%.init$", "")
			if not p[short] then
			p[short] = v
			end
		end
	end
end
require("hook")
require("libs.tserial")
require("utils")
require("globals")
require("loveutils")
require("libs.cupid")
require("libs.filter")
--[[
	STEAL MY SHIT AND I'LL FUCK YOU UP
	PRETTY MUCH EVERYTHING BY MAURICE GUGAN AND IF SOMETHING ISN'T BY ME THEN IT SHOULD BE OBVIOUS OR NOBODY CARES

	Please keep in mind that for obvious reasons, I do not hold the rights to artwork, audio or trademarked elements of the game.
	This license only applies to the code and original other assets. Obviously. Duh.
	Anyway, enjoy.
	
	
	
	DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
              Version 2, December 2004

	Copyright (C) 2004 Sam Hocevar <sam@hocevar.net>

	Everyone is permitted to copy and distribute verbatim or modified
	copies of this license document, and changing it is allowed as long
	as the name is changed.

			DO WHAT THE FUCK YOU WANT TO PUBLIC LICENSE
	TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

	0. You just DO WHAT THE FUCK YOU WANT TO.
]]
--[[distance models
	none: basically everything stays the same, always
	inverse: things get quieter as you move away
	linear: basically things just move around but never fade, you get the most dopple out of this
	exponent: like inverse, except happens quicker
	x clamped: gain gets clamped
]]
love.audio.setDistanceModel("exponent clamped")

function love.run()
	love.math.setRandomSeed(os.time())
	
	
    love.load(arg)

    -- Main loop time.
    while true do
        -- Process events.
		love.event.pump()
		for e,a,b,c,d in love.event.poll() do
			if e == "quit" then
				if not love.quit() then
					love.audio.stop()
					return
				end
			end
			love.handlers[e](a,b,c,d)
		end

        -- Update dt, as we'll be passing it to update
		love.timer.step()
		local dt = love.timer.getDelta()

        -- Call update and draw
        love.update(dt) -- will pass 0 if love.timer is disabled
		love.graphics.clear()
		love.graphics.origin()
		
		--Fullscreen hack
		if not mkstation and fullscreen and gamestate ~= "intro" then
			completecanvas:clear()
			love.graphics.setScissor()
			completecanvas:renderTo(love.draw)
			love.graphics.setScissor()
			if fullscreenmode == "full" then
				love.graphics.draw(completecanvas, 0, 0, 0, desktopsize.width/(width*16*scale), desktopsize.height/(height*16*scale))
			else
				love.graphics.draw(completecanvas, 0, touchfrominsidemissing/2, 0, touchfrominsidescaling/scale, touchfrominsidescaling/scale)
				love.graphics.setColor(0, 0, 0)
				love.graphics.rectangle("fill", 0, 0, desktopsize.width, touchfrominsidemissing/2)
				love.graphics.rectangle("fill", 0, desktopsize.height-touchfrominsidemissing/2, desktopsize.width, touchfrominsidemissing/2)
				love.graphics.setColor(255, 255, 255, 255)
			end
		else
			love.graphics.setScissor()
			love.draw()
		end
		
		love.graphics.present()
		love.timer.sleep(0.001)
    end
end

function add(desc)
	print((desc or "") .. "\n" .. round((love.timer.getTime()-starttime)*1000) .. "ms\tlines " .. lastline+1 .. " - " .. debug.getinfo(2).currentline-1 .. "\n")
	lastline = debug.getinfo(2).currentline
	totaltime = totaltime + round((love.timer.getTime()-starttime)*1000)
	starttime = love.timer.getTime()
end

function love.load(args)
	hook.Call("LovePreLoad", args)
	game = {}
	debugmode = "none"
	userectdebug = true
	args = args or {}
	for k,v in pairs(args) do
		if v=="-zbs" then
			-- debug features exclusive to zerobrane
			io.stdout:setvbuf("no")
			require("mobdebug").start()
		elseif v=="-debug" then
			skipintro = true
			uploadoncrash = true
			--DEBUG = false
			--editordebug = DEBUG
			--skiplevelscreen = DEBUG
			--debugbinds = DEBUG
			--debugclasses = false
			debugmode = args[k+1] or "none"
		end
	end
	hook.Add("GameConsoleOpened", "ConsoleDisableControls", function()
		if objects and objects["player"] and objects["player"][1] then
			objects["player"][1].controlsenabled = false
		end
	end)
	hook.Add("GameConsoleClosed", "ConsoleReEnableControls", function()
		--@WARNING: This might enable someone's controls at the wrong time, like when the game is paused.
		if objects and objects["player"] and objects["player"][1] then
			objects["player"][1].controlsenabled = false
		end
	end)
	expectedconnections = 2
	if debugmode=="client" or debugmode=="server" then
		uploadoncrash = false
		hook.Add("GameLoaded", "DebugImmediate", function()
			onlinemenu_load()
		end)
		hook.Add("GameOnlineMenuLoaded", "DebugImmediate", function()
			if debugmode=="server" then
				creategame()
				hook.Add("ServerClientConnected", "DebugImmediate", function()
					expectedconnections = expectedconnections - 1
					if expectedconnections==0 then
						server_start()
					end
				end)
			elseif debugmode=="client" then
				guielements.ipentry.value = "127.0.0.1"
				joingame()
			end
		end)
	end
	marioversion = 1107
	versionstring = "version 1.0se"
	
	--version check by checking for a const that was added in 0.8.0 --todo: change to 0.9.0
	if love._version_major == nil or (love._version_minor and love._version_minor < 9) then 
		versionerror = true
		error("You have an outdated version of Love! Get 0.9.0 and retry.") 
	end

	math.mod = math.fmod
	math.random = love.math.random
	-- I'm literally doing this just so the title load text gets shaken up.
	math.random()
	for i=1,math.random(5) do
		math.random()
	end
	
	print("Loading Mari0 SE!")
	print("=======================")
	lastline = debug.getinfo(1).currentline
	starttime = love.timer.getTime()
	totaltime = 0
	JSON = require("libs.JSON")
	require "timer"
	require "notice"
	
	--Get biggest screen size
	
	local sizes = love.window.getFullscreenModes()
	desktopsize = sizes[1]
	
	for i = 2, #sizes do
		if sizes[i].width > desktopsize.width or sizes[i].height > desktopsize.height then
			desktopsize = sizes[i]
		end
	end
	
	recordtarget = 1/40
	recordskip = 1
	recordframe = 1
	
	shaderlist = love.filesystem.getDirectoryItems( "shaders/" )
	local rem
	for i, v in pairs(shaderlist) do
		if v == "init.lua" then
			rem = i
		else
			shaderlist[i] = string.sub(v, 1, string.len(v)-5)
		end
	end
	
	table.remove(shaderlist, rem)
	table.insert(shaderlist, 1, "none")
	
	love.graphics.setDefaultFilter("nearest", "nearest")
	
	overwrittenimages = {}
	imagelist = {"coinblockanimation", "coinanimation", "coinblock", "coin", "axe", "spring", "springhigh", "toad", "peach", "platform", "oddjobhud", "redcoin", "redcointall", "redcoinbig", "firework",
	"platformbonus", "scaffold", "seesaw", "vine", "bowser", "decoys", "flag", "castleflag", "bubble", "emanceparticle", "emanceside", "doorpiece", "doorcenter", "pswitch",
	"button", "pushbutton", "wallindicator", "walltimer", "lightbridge", "lightbridgeglow", "lightbridgeside", "laser", "laserside", "excursionbase", "excursionfunnel", "excursionfunnel2", "excursionfunnelend", 
	"excursionfunnel2end", "faithplateplate", "laserdetector", "gel1", "gel2", "gel3", "gel4", "gel5", "gel6", "gel1ground", "gel2ground", "gel3ground", "gel4ground", "gel5ground", "gel6ground", "geldispenser", "cubedispenser", "panel", "pedestalbase", "cursorarea", 
	"pedestalgun", "actionblock", "portal", "markbase", "markoverlay", "andgate", "notgate", "orgate", "squarewave", "rsflipflop", "portalglow", "sfxentity", "animationtarget", "musicentity", "smbtiles", "portaltiles", "transparency", "smokepuff",
	"animatedtiletrigger", "delayer", "leaf", "groundlight"}
	
	graphicspacki = 1
	graphicspack = "DEFAULT"
	graphicspacklist = {}
	--@WARNING: This will be inaccurate for any mappacks that provide a namespaced graphicspack or potential mods.
	for k,v in pairs(love.filesystem.getDirectoryItems( "graphics" )) do
		if love.filesystem.isDirectory("graphics/"..v) and string.upper(v)==v then
			table.insert(graphicspacklist, v)
		end
	end
	
	soundpacki = 1
	soundpack = "DEFAULT"
	soundpacklist = {}
	--@WARNING: Same goes for me.
	for k,v in pairs(love.filesystem.getDirectoryItems( "sounds" )) do
		if love.filesystem.isDirectory("graphics/"..v) and string.upper(v)==v then
			table.insert(soundpacklist, v)
		end
	end
	
	add("Variables, shaderlist")
	
	local suc, err = pcall(loadconfig)
	if not suc then
		players = 1
		defaultconfig()
		print("== FAILED TO LOAD CONFIG ==")
		print(err)
	end
	
	--@DEBUG: here are some vars that are used elsewhere, maybe
	physicsdebug = false
	incognito = false
	portalwalldebug = false
	speeddebug = false
	
	frameskip = false -- false/0     true is not valid, so stop accidentally writing that.
	
	replaysystem = false
	drawreplays = false
	drawalllinks = false
	bdrawui = true
	skippedframes = 0
	
	width = 25	--! default 25
	height = 14
	fsaa = 0
	
	steptimer = 0
	targetdt = 1/60
	
	--Calculate relative scaling factor
	touchfrominsidescaling = math.min(desktopsize.width/(width*16), desktopsize.height/(height*16))
	touchfrominsidemissing = desktopsize.height-height*16*touchfrominsidescaling
	
	add("Variables")
	changescale(scale, true)
	add("Resolution change")
	require "characterloader"
	add("Characterloader")
	
	dlclist = {}
	
	hatcount = #love.filesystem.getDirectoryItems("graphics/standardhats")
	saveconfig()
	love.window.setTitle( "Marin0 SE" )
	
	love.graphics.setBackgroundColor(0, 0, 0)
	
	cursorareaquads = {}
	for i = 1, 4 do
		cursorareaquads[i] = love.graphics.newQuad((i-1)*18, 0, 18, 18, 72, 18)
	end
	
	--[[@DEV:
		I'm getting really tired of |nonstandard global containers| for entities, so
		to reduce the number of crazy all-over-the-place codepoints I'm creating an
		iterable whitelist of entities that adhere to a specific standard.
		Those being:
			* **being located in** _"/entities/classname.lua"_
			* **a classname that matches the filename, ex:** `classname = class:("classname")`
			* **a function creation signature of** `classname:init(x, y, r)`
				* if not placable in maps, then this isn't entirely necessary, but it helps
			* **having instances stored in the array** `objects["classname"]`
	]]
	saneents = {
		"sfxentity", "portalwall", "tile", "vine", "door", "button",
		"groundlight", "wallindicator", "animatedtiletrigger", "delayer",
		"walltimer", "notgate", "rsflipflop", "orgate", "andgate",
		"musicentity", "enemyspawner", "squarewave", "lightbridge",
		"faithplate", "laser", "noportal", "bulletbill", "animationtarget", 
		"portalprojectile", "portalprojectileparticle", "portalparticle",
		"laserdetector", "gel", "geldispenser", "pushbutton",
		"cubedispenser", "platform", "castlefire", "platformspawner",
		"bowser", "spring", "seesawplatform", "checkpoint", "seesaw",
		"ceilblocker", "funnel", "panel", "scaffold", "axe",
		"regiontrigger", "animationtrigger", "castlefirefire", "portalent",
		"portalent", "actionblock", "leaf", "enemy", "lightbridgebody", "weapon",
		"pedestal", "textentity", "firework", "emancipationgrill", "redcoin",
		"generatorwind", "generatorbullet", "generatorcheeps", "generatorflames",
		"pswitch", "smokepuff", "emancipateanimation", "userect"
	}
	-- we made weapon a saneent because tracing mario's draw is REALLY TOUGH
	-- testing removal of "fireball",
	
	--[[ here are a list of entities that have BROKEN THE LAW ]]
	insaneents = {
		"player", --discrepency in class names
		"warppipe", --this doesn't have any code, it's just a marker
		"spawn", --"  "
		"manycoins", --"  "
		"pipespawn", --"  "
		"axe", --"  "
		"flag", --"  "
		
		"mazestart", "mazeend", --doesn't have its own logic, is implicit and global
		"firestart", "fireend", --"  "
		"flyingfishstart", "flyingfishend", --"  "
		"bulletbillstart", "bulletbillend", --"  "
		"windstart", "windend", --"  "
		"lakitoend", --"  ", except it doesn't even have a start?!
		
		"gel", --this alters the map when loaded, which is an extreme anomoly
	}
	
	-- this is for global allocation of images + quads
	globalimages = {}
	--[[structure:{
			imagename = {
				dims = {xdim, ydim}, --size of a single graphic
				frames = num, --how many times dims fits in the image
				quads = {},
				img = imgdata,
			}
		}
		
		if errors ever arise in reference to this, it's because an entity
		is trying to reach this when its assets have been unloaded for mysterious reasons
	]]
	
	add("Variables")
	
	--require ALL the files!
	require("libs.lube")
	class = require("libs.middleclass")
	require("libs.neubind")
	nb = neubind:new(neuControlTable)
	TLbind = require("libs.TLbind")
	binds, controls = TLbind.giveInstance(controlTable)
	require("libs.monocle")
	Monocle.new({
		isActive=false,
		customPrinter=false,
		customColor = {0, 128, 0, 255},
		debugToggle = 'f1',
		filesToWatch = {}
	})
	--[[watchfunction = function()
		local str = "n/a"
		if activeeditortool then
			str=  ""
			for k,v in pairs(activeeditortool) do str=str..tostring(k).."="..tostring(v).."\n" end
		end
		return str
	end]]
	--Monocle.watch("misc", watchfunction)
	
	require("libs.von")
	--require "netplay2"
	require "netplay"
	--require "client"
	require "server"
	require "lobby"
	
	require "shaders"
	require "variables"
	
	-- gui elements??
	require "gui.onlinemenu"
	require "gui.killfeed"
	require "gui.nodetree"
	require "gui.maptree"
	require "gui.tiletree"
	
	reloadGraphics()
	reloadSounds()
	
	spritebatches = {} --global spritebatch array, keyed by tileset name
	
	fontglyphs = "0123456789abcdefghijklmnopqrstuvwxyz.:/,\"C-_A* !{}?'()+=><#%"
	fontquads = {}
	for i = 1, string.len(fontglyphs) do
		fontquads[string.sub(fontglyphs, i, i)] = love.graphics.newQuad((i-1)*8, 0, 8, 8, fontimage:getWidth(), fontimage:getHeight())
	end
	fontquadsback = {}
	for i = 1, string.len(fontglyphs) do
		fontquadsback[string.sub(fontglyphs, i, i)] = love.graphics.newQuad((i-1)*10, 0, 10, 10, fontimageback:getWidth(), fontimageback:getHeight())
	end
	
	-- injecting this here, I'm sorry
		love.graphics.clear()
		love.graphics.setColor(100, 100, 100)
		loadingtext = loadingtexts[math.random(1,#loadingtexts)]
		
		local logoscale = scale
		if logoscale <= 1 then
			logoscale = 0.5
		else
			logoscale = 1
		end
		
		love.graphics.setColor(255, 255, 255)
		
		love.graphics.draw(logo, love.graphics.getWidth()/2, love.graphics.getHeight()/2, 0, logoscale, logoscale, 142, 150)
		love.graphics.setColor(150, 150, 150)
		properprint(loading_header, love.graphics.getWidth()/2-string.len(loading_header)*4*scale, love.graphics.getHeight()/2-170*logoscale-7*scale)
		love.graphics.setColor(50, 50, 50)
		properprint(loadingtext, love.graphics.getWidth()/2-string.len(loadingtext)*4*scale, love.graphics.getHeight()/2+165*logoscale)
		love.graphics.present()
	-- whew, that's over with
	require("libs.sha1")
	require "magic"
	require "camera"
	require "baseentity"
	require "entity"
	
	local mixins = love.filesystem.getDirectoryItems("basedmixins")

	for k,v in pairs(mixins) do
		require("basedmixins."..v:sub(0,-5))
		
		-- precache all the images used by this entity type, eventually this will be dynamic
		--for k2,v2 in pairs(_G[basedents[k]].image_sigs) do
		--	allocate_image(k2, v2[1], v2[2])
		--end]]
	end
	
	-- basedents are used for the transition from saneents to entities that actually inherit and have some common ground
	-- this is very confusing and I'm sorry for that but it's what must be done
	basedents = love.filesystem.getDirectoryItems("basedents")

	for k,v in pairs(basedents) do
		basedents[k] = v:sub(0,-5)
		require("basedents."..basedents[k])
		
		-- precache all the images used by this entity type, eventually this will be dynamic
		--for k2,v2 in pairs(_G[basedents[k]].image_sigs) do
		--	allocate_image(k2, v2[1], v2[2])
		--end]]
	end
	
	
	
	-- we don't use the saneents list here because entity name weirdness 
	--for _,v in pairs(love.filesystem.getDirectoryItems("entities")) do
	for _,v in pairs(saneents) do
		-- we're doing sub because I forgot how not to \o/
		--require("entities."..v:sub(0, -5))
		require("entities."..v)
	end
	require("weapons.portalgun")
	require("weapons.gelcannon")
	
	require "animatedquad"
	require "intro"
	require "menu"
	require "levelscreen"
	require "game"
	require "editor"
	require "animationguiline"
	require "physics"
	require "quad"
	require "hatconfigs"
	require "bighatconfigs"
	require "customhats"
	require "coinblockanimation"
	require "screenboundary"
	require "gui"
	require "musicloader"
	require "rightclickmenu"
	require "animation"
	require "animationsystem"
	require "regiondrag"
	require "animatedtimer"
	require "entitylistitem"
	require "entitytooltip"
	require "imgurupload"
	
	require "player"
	require "fire"
	require "portal"
	require "dialogbox"
	require "itemanimation"
	
	require "enemies"
	add("Requires")
	
	http = require("socket.http")
	http.PORT = 55555
	http.TIMEOUT = 1
	
	updatenotification = false
	if getupdate() then
		updatenotification = true
	end
	http.TIMEOUT = 4
	
	playertypei = 1
	playertype = playertypelist[playertypei] --portal, gelcannon
	
	if volume == 0 then
		soundenabled = false
	else
		soundenabled = true
	end
	love.filesystem.createDirectory( "mappacks" )
	editormode = false
	yoffset = 0
	love.graphics.setPointSize(3*scale)
	love.graphics.setLineWidth(2*scale)
	
	uispace = math.floor(width*16*scale/4)
	guielements = {}
	
	--limit hats
	for playerno = 1, players do
		for i = 1, #mariohats[playerno] do
			if mariohats[playerno][i] > hatcount then
				mariohats[playerno][i] = hatcount
			end
		end
	end
	
	--Backgroundcolors
	backgroundcolor = {
						{92, 148, 252},
						{0, 0, 0},
						{32, 56, 236},
						{158, 219, 248},
						{210, 159, 229},
						{237, 241, 243},
						{244, 178, 92},
						{253, 246, 175},
						{249, 183, 206},
					}
	add("Update Check, variables")
	
	--tiles
	tilequads = {}
	rgblist = {}
	
	--add smb tiles
	local imgwidth, imgheight = smbtilesimg:getWidth(), smbtilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata = love.image.newImageData("smbtiles.png")
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(smbtilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	smbtilecount = width*height
	
	--add portal tiles
	local imgwidth, imgheight = portaltilesimg:getWidth(), portaltilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata = love.image.newImageData("portaltiles.png")
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(portaltilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	portaltilecount = width*height
	
	--add entities
	entityquads = {}
	local imgwidth, imgheight = entitiesimg:getWidth(), entitiesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata = love.image.newImageData("/guihud/entities.png")
	
	for y = 1, height do
		for x = 1, width do
			table.insert(entityquads, entity:new(entitiesimg, x, y, imgwidth, imgheight))
			entityquads[#entityquads]:sett(#entityquads)
		end
	end
	entitiescount = width*height
	
	-- overload table because we can't change the timing of the above
	for k,v in pairs(entityquad_overloads) do
		entityquads[k] = v
	end
	
	numberglyphs = "0123456789"
	font2quads = {}
	for i = 1, 10 do
		font2quads[string.sub(numberglyphs, i, i)] = love.graphics.newQuad((i-1)*4, 0, 4, 8, 40, 8)
	end

	symbolglyphs = "0123"
	font3quads = {}
	for i = 1, 4 do
		font3quads[string.sub(symbolglyphs, i, i)] = love.graphics.newQuad((i-1)*4, 0, 4, 8, 40, 8)
	end
	
	popupfontquads = {}
	for i = 1, 6 do
		popupfontquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 8, 96, 8)
	end

	fireworkquads = {}
	for i = 1, 4 do
		fireworkquads[i] = love.graphics.newQuad((i-1)*32, 0, 32, 32, 128, 32)
	end
	
	oddjobhudquads = {}
	for i = 1, 5 do
		oddjobhudquads[i] = love.graphics.newQuad((i-1)*8, 0, 8, 8, 40, 8)
	end
	
	coinblockanimationquads = {}
	for i = 1, 30 do
		coinblockanimationquads[i] = love.graphics.newQuad((i-1)*8, 0, 8, 52, 256, 64)
	end
	
	coinanimationquads = {}
	for j = 1, 4 do
		coinanimationquads[j] = {}
		for i = 1, 5 do
			coinanimationquads[j][i] = love.graphics.newQuad((i-1)*5, (j-1)*8, 5, 8, 25, 32)
		end
	end
	
	--coinblock
	coinblockquads = {}
	for j = 1, 4 do
		coinblockquads[j] = {}
		for i = 1, 5 do
			coinblockquads[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*16, 16, 16, 80, 64)
		end
	end
	
	--coin
	coinquads = {}
	for j = 1, 4 do
		coinquads[j] = {}
		for i = 1, 5 do
			coinquads[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*16, 16, 16, 80, 64)
		end
	end

	--redcoin
	redcoinquads = {}
	for i = 1, 4 do
		redcoinquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end	
	
	redcointallquads = {}
	for i = 1, 4 do
		redcointallquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 32, 64, 32)
	end	
	
	redcoinbigquads = {}
	for i = 1, 4 do
		redcoinbigquads[i] = love.graphics.newQuad((i-1)*32, 0, 32, 32, 128, 32)
	end	
	
	--smoke puff
	smokepuffquads = {}
	for i = 1, 4 do
		smokepuffquads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end	
	
	--leaf
	leafquad = {}
	for y = 1, 4 do
		leafquad[y] = {}
		for x = 1, 2 do
			leafquad[y][x] = love.graphics.newQuad((x-1)*8, (y-1)*8, 8, 8, 16, 32)
		end
	end
	
	--axe
	axequads = {}
	for i = 1, 5 do
		axequads[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 80, 16)
	end
	
	--spring
	springquads = {}
	for i = 1, 4 do
		springquads[i] = {}
		for j = 1, 3 do
			springquads[i][j] = love.graphics.newQuad((j-1)*16, (i-1)*32, 16, 32, 48, 128)
		end
	end
	
	-- pswitch
	pswitchquads = {}
	for i = 1, 2 do
		pswitchquads[i] = {}
		for j = 1, 4 do
			pswitchquads[i][j] = love.graphics.newQuad((j-1)*16, (i-1)*16, 16, 16, 64, 32)
		end	
	end
	
	seesawquad = {}
	for i = 1, 4 do
		seesawquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end
	
	starquad = {}
	for i = 1, 4 do
		starquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end
	
	flowerquad = {}
	for i = 1, 4 do
		flowerquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 64, 16)
	end
	
	vinequad = {}
	for i = 1, 4 do
		vinequad[i] = {}
		for j = 1, 2 do
			vinequad[i][j] = love.graphics.newQuad((j-1)*16, (i-1)*16, 16, 16, 32, 64) 
		end
	end
	
	--enemies
	goombaquad = {}
	
	for y = 1, 4 do
		goombaquad[y] = {}
		for x = 1, 2 do
			goombaquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*16, 16, 16, 32, 64)
		end
	end
		
	spikeyquad = {}
	for y = 1, 4 do
		spikeyquad[y] = {}
		for x = 1, 4 do
			spikeyquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*16, 16, 16, 64, 64)
		end
	end
	
	lakitoquad = {}
	for y = 1, 4 do
		lakitoquad[y] = {}
		for x = 1, 2 do
			lakitoquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*24, 16, 24, 32, 96)
		end
	end
	
	koopaquad = {}
	
	for y = 1, 4 do
		koopaquad[y] = {}
		for x = 1, 5 do
			koopaquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*24, 16, 24, 80, 96)
		end
	end
	
	singlequad = love.graphics.newQuad(0, 0, 16, 16, 16, 16)
	
	cheepcheepquad = {}
	
	cheepcheepquad[1] = {}
	cheepcheepquad[1][1] = love.graphics.newQuad(0, 0, 16, 16, 32, 32)
	cheepcheepquad[1][2] = love.graphics.newQuad(16, 0, 16, 16, 32, 32)
	
	cheepcheepquad[2] = {}
	cheepcheepquad[2][1] = love.graphics.newQuad(0, 16, 16, 16, 32, 32)
	cheepcheepquad[2][2] = love.graphics.newQuad(16, 16, 16, 16, 32, 32)
	
	squidquad = {}
	for x = 1, 2 do
		squidquad[x] = love.graphics.newQuad((x-1)*16, 0, 16, 24, 32, 24)
	end
	
	bulletbillquad = {}
	
	for y = 1, 4 do
		bulletbillquad[y] = love.graphics.newQuad(0, (y-1)*16, 16, 16, 16, 64)
	end
	
	hammerbrosquad = {}
	for y = 1, 4 do
		hammerbrosquad[y] = {}
		for x = 1, 4 do
			hammerbrosquad[y][x] = love.graphics.newQuad((x-1)*16, (y-1)*34, 16, 34, 64, 136)
		end
	end	
	
	hammerquad = {}
	for j = 1, 4 do
		hammerquad[j] = {}
		for i = 1, 4 do
			hammerquad[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*16, 16, 16, 64, 64)
		end
	end
	
	plantquads = {}
	for j = 1, 4 do
		plantquads[j] = {}
		for i = 1, 2 do
			plantquads[j][i] = love.graphics.newQuad((i-1)*16, (j-1)*23, 16, 23, 32, 92)
		end
	end
	
	firequad = {love.graphics.newQuad(0, 0, 24, 8, 48, 8), love.graphics.newQuad(24, 0, 24, 8, 48, 8)}
	
	
	bowserquad = {}
	bowserquad[1] = {love.graphics.newQuad(0, 0, 32, 32, 64, 64), love.graphics.newQuad(32, 0, 32, 32, 64, 64)}
	bowserquad[2] = {love.graphics.newQuad(0, 32, 32, 32, 64, 64), love.graphics.newQuad(32, 32, 32, 32, 64, 64)}
	
	decoysquad = {}
	for y = 1, 7 do
		decoysquad[y] = love.graphics.newQuad(0, (y-1)*32, 32, 32, 64, 256)
	end
	
	--magic!
	magicquad = {}
	for x = 1, 6 do
		magicquad[x] = love.graphics.newQuad((x-1)*9, 0, 9, 9, 54, 9)
	end
	
	--GUI
	checkboxquad = {{love.graphics.newQuad(0, 0, 9, 9, 18, 18), love.graphics.newQuad(9, 0, 9, 9, 18, 18)}, {love.graphics.newQuad(0, 9, 9, 9, 18, 18), love.graphics.newQuad(9, 9, 9, 9, 18, 18)}}
	
	--portals
	portalquad = {}
	for i = 0, 7 do
		portalquad[i] = love.graphics.newQuad(0, i*4, 32, 4, 32, 28)
	end
	
	--Portal props	
	buttonquad = {love.graphics.newQuad(0, 0, 32, 5, 64, 5), love.graphics.newQuad(32, 0, 32, 5, 64, 5)}
	
	pushbuttonquad = {love.graphics.newQuad(0, 0, 16, 16, 32, 16), love.graphics.newQuad(16, 0, 16, 16, 32, 16)}
	
	wallindicatorquad = {love.graphics.newQuad(0, 0, 16, 16, 32, 16), love.graphics.newQuad(16, 0, 16, 16, 32, 16)}
	
	walltimerquad = {}
	for i = 1, 10 do
		walltimerquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 160, 16)
	end
	
	groundlightquad = {}
	for i = 1, 6 do
		groundlightquad[i] = love.graphics.newQuad((i-1)*16, 0, 16, 16, 96, 16)
	end
	
	directionsquad = {}
	for x = 1, 6 do
		directionsquad[x] = love.graphics.newQuad((x-1)*7, 0, 7, 7, 42, 7)
	end
	
	excursionquad = {}
	for x = 1, 8 do
		excursionquad[x] = love.graphics.newQuad((x-1)*8, 0, 8, 32, 64, 32)
	end
	
	faithplatequad = {love.graphics.newQuad(0, 0, 32, 16, 32, 32), love.graphics.newQuad(0, 16, 32, 16, 32, 32)}
	
	gelquad = {love.graphics.newQuad(0, 0, 12, 12, 36, 12), love.graphics.newQuad(12, 0, 12, 12, 36, 12), love.graphics.newQuad(24, 0, 12, 12, 36, 12)}
	
	panelquad = {}
	for x = 1, 2 do
		panelquad[x] = love.graphics.newQuad((x-1)*16, 0, 16, 16, 32, 16)
	end
	
	add("Images, quads")
	
	--AUDIO
	delaylist = {}
	delaylist["blockhit"] = 0.2
	
	musicname = "overworld.ogg"
	
	add("Sounds")
	shaders:init()
	add("Shaders init")
	
	for i, v in pairs(dlclist) do
		delete_mappack(v)
	end
	
	firstload = true
	
	--@DEV: Copied this over, too. Probably making a mess.
	magicdns_session_chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	magicdns_session = ""
	for i = 1, 8 do
		rand = math.random(string.len(magicdns_session_chars))
		magicdns_session = magicdns_session .. string.sub(magicdns_session_chars, rand, rand)
	end
	--use love.filesystem.getIdentity() when it works
	magicdns_identity = love.filesystem.getSaveDirectory():split("/")
	magicdns_identity = string.upper(magicdns_identity[#magicdns_identity])
	
	add("Intro Load")
	print("TOTAL: " .. totaltime .. "ms")
	
	mycamera = camera:new()
	mycamera:zoomTo(0.4)
	
	skipintro=true
	if skipintro then
		menu_load()
	else
		intro_load()
	end
	
	hook.Call("LovePostLoad", args)
end

function love.update(dt)
	hook.Call("LovePreUpdate", dt)
	if music then
		music:update()
	end
	timer.Update(dt)
	Monocle.update()
	nb:update(dt)
	TLbind:update()
	binds:update()
	controlsUpdate(dt)
	realdt = dt
	dt = math.min(0.5, dt) --ignore any dt higher than half a second
	
	if recording then
		dt = recordtarget
	end
	
	steptimer = steptimer + dt
	dt = targetdt
	
	if skipupdate then
		steptimer = 0
		skipupdate = false
		return
	end
	
	--speed
	if bullettime and speed ~= speedtarget then
		if speed > speedtarget then
			speed = math.max(speedtarget, speed+(speedtarget-speed)*dt*5)
		elseif speed < speedtarget then
			speed = math.min(speedtarget, speed+(speedtarget-speed)*dt*5)
		end
		
		if math.abs(speed-speedtarget) < 0.02 then
			speed = speedtarget
		end
		
		if speed > 0 then
			for i, v in pairs(soundlist) do
				v.source:setPitch( speed )
			end
			music.pitch = speed
			love.audio.setVolume(volume)
		else	
			love.audio.setVolume(0)
		end
	end
	
	while steptimer >= targetdt do
		steptimer = steptimer - targetdt
		
		if frameskip then
			if frameskip > skippedframes then
				skippedframes = skippedframes + 1
				return
			else
				skippedframes = 0
			end
		end
		
		keyprompt_update()
		
		if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" or gamestate == "lobby" then
			menu_update(dt)
		elseif gamestate == "levelscreen" or gamestate == "gameover" or gamestate == "sublevelscreen" or gamestate == "mappackfinished" then
			levelscreen_update(dt)
		elseif gamestate == "game" then
			game_update(dt)	
		elseif gamestate == "intro" then
			intro_update(dt)	
		end
		if onlinemp then
			if clientisnetworkhost then
				server_update(dt)
			end
			network_update(dt)
		end
		
		for i, v in pairs(guielements) do
			v:update(dt)
		end
		
		--netplay_update(dt)
		
		notice.update(dt)
		killfeed.update(dt)
		
		love.window.setTitle("NCN:"..networkclientnumber.."; FPS:" .. love.timer.getFPS())
	end
	hook.Call("LovePostUpdate", dt)
end

function love.draw()
	hook.Call("LovePreDraw")
	shaders:predraw()
	
	--mycamera:attach()
	if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" or gamestate == "lobby" then
		menu_draw()
	elseif gamestate == "levelscreen" or gamestate == "gameover" or gamestate == "mappackfinished" then
		levelscreen_draw()
	elseif gamestate == "game" then
		game_draw()
	elseif gamestate == "intro" then
		intro_draw()
	end
	
	notice.draw()
	killfeed.draw()
	
	--mycamera:detach()
	
	shaders:postdraw()
		
	love.graphics.setColor(255, 255,255)
	
	if recording then
		screenshotimagedata = love.graphics.newScreenshot( )
		screenshotimagedata:encode("recording/" .. recordframe .. ".png")
		recordframe = recordframe + 1
		screenshotimagedata = nil
		
		if recordframe%100 == 0 then
			collectgarbage("collect")
		end
	end
	Monocle.draw()
	hook.Call("LovePostDraw")
end

function saveconfig()
	if CLIENT or SERVER then
		return
	end
	
	local s = ""
	for i = 1, #oldcontrols do
		s = s .. "playercontrols:" .. i .. ":"
		local count = 0
		for j, k in pairs(oldcontrols[i]) do
			local c = ""
			for l = 1, #oldcontrols[i][j] do
				c = c .. oldcontrols[i][j][l]
				if l ~= #oldcontrols[i][j] then
					c = c ..  "-"
				end
			end
			s = s .. j .. "-" .. c
			count = count + 1
			if count == 12 then
				s = s .. ";"
			else
				s = s .. ","
			end
		end
	end	
	
	for i = 1, #mariocolors do --players
		s = s .. "playercolors:" .. i .. ":"
		if #mariocolors[i] > 0 then
			for j = 1, #mariocolors[i] do --colorsets (dynamic)
				for k = 1, 3 do --R, G or B values
					s = s .. mariocolors[i][j][k]
					if j == #mariocolors[i] and k == 3 then
						s = s .. ";"
					else
						s = s .. ","
					end
				end
			end
		else
			s = s .. ";"
		end
	end
	
	for i = 1, #mariocharacter do
		s = s .. "mariocharacter:" .. i .. ":"
		s = s .. mariocharacter[i]
		s = s .. ";"
	end
	
	for i = 1, #portalhues do
		s = s .. "portalhues:" .. i .. ":"
		s = s .. round(portalhues[i][1], 4) .. "," .. round(portalhues[i][2], 4) .. ";"
	end
	
	for i = 1, #mariohats do
		s = s .. "mariohats:" .. i
		if #mariohats[i] > 0 then
			s = s .. ":"
		end
		for j = 1, #mariohats[i] do
			s = s .. mariohats[i][j]
			if j == #mariohats[i] then
				s = s .. ";"
			else
				s = s .. ","
			end
		end
		
		if #mariohats[i] == 0 then
			s = s .. ";"
		end
	end
	
	s = s .. "scale:" .. scale .. ";"
	
	s = s .. "shader1:" .. shaderlist[currentshaderi1] .. ";"
	s = s .. "shader2:" .. shaderlist[currentshaderi2] .. ";"
	
	s = s .. "graphicspack:" .. graphicspacklist[graphicspacki] .. ";"
	s = s .. "soundpack:" .. soundpacklist[soundpacki] .. ";"
	
	s = s .. "volume:" .. volume .. ";"
	s = s .. "mouseowner:" .. mouseowner .. ";"
	
	s = s .. "mappack:" .. mappack .. ";"
	
	if vsync then
		s = s .. "vsync;"
	end
	
	if gamefinished then
		s = s .. "gamefinished;"
	end
	
	s = s .. "fullscreen:" .. tostring(fullscreen) .. ";"
	s = s .. "fullscreenmode:" .. fullscreenmode .. ";"
	
	--reached worlds
	for i, v in pairs(reachedworlds) do
		s = s .. "reachedworlds:" .. i .. ":"
		for j = 1, 8 do
			if v[j] then
				s = s .. 1
			else
				s = s .. 0
			end
			
			if j == 8 then
				s = s .. ";"
			else
				s = s .. ","
			end
		end
	end
	
	love.filesystem.write("options.txt", s)
end

function loadconfig()
	players = 1
	defaultconfig()
	
	if not love.filesystem.exists("options.txt") then
		return
	end
	
	local s = love.filesystem.read("options.txt")
	s1 = s:split(";")
	
	for i = 1, #s1-1 do
		s2 = s1[i]:split(":")
		if s2[1] == "playercontrols" then
			if oldcontrols[tonumber(s2[2])] == nil then
				oldcontrols[tonumber(s2[2])] = {}
			end
			
			s3 = s2[3]:split(",")
			for j = 1, #s3 do
				s4 = s3[j]:split("-")
				oldcontrols[tonumber(s2[2])][s4[1]] = {}
				for k = 2, #s4 do
					if tonumber(s4[k]) ~= nil then
						oldcontrols[tonumber(s2[2])][s4[1]][k-1] = tonumber(s4[k])
					else
						oldcontrols[tonumber(s2[2])][s4[1]][k-1] = s4[k]
					end
				end
			end
			players = math.max(players, tonumber(s2[2]))
			
		elseif s2[1] == "playercolors" then
			if mariocolors[tonumber(s2[2])] == nil then
				mariocolors[tonumber(s2[2])] = {}
			end
			s3 = s2[3]:split(",")
			mariocolors[tonumber(s2[2])] = {}
			for i = 1, #s3/3 do
				mariocolors[tonumber(s2[2])][i] = {tonumber(s3[1+(i-1)*3]), tonumber(s3[2+(i-1)*3]), tonumber(s3[3+(i-1)*3])}
			end
		elseif s2[1] == "portalhues" then
			if portalhues[tonumber(s2[2])] == nil then
				portalhues[tonumber(s2[2])] = {}
			end
			s3 = s2[3]:split(",")
			portalhues[tonumber(s2[2])] = {tonumber(s3[1]), tonumber(s3[2])}
		
		elseif s2[1] == "mariohats" then
			local playerno = tonumber(s2[2])
			mariohats[playerno] = {}
			
			if s2[3] == "mariohats" then --SAVING WENT WRONG OMG
			
			elseif s2[3] then
				s3 = s2[3]:split(",")
				for i = 1, #s3 do
					local hatno = tonumber(s3[i])
					mariohats[playerno][i] = hatno
				end
			end
			
		elseif s2[1] == "scale" then
			scale = tonumber(s2[2])
			
		elseif s2[1] == "shader1" then
			for i = 1, #shaderlist do
				if shaderlist[i] == s2[2] then
					currentshaderi1 = i
				end
			end
		elseif s2[1] == "shader2" then
			for i = 1, #shaderlist do
				if shaderlist[i] == s2[2] then
					currentshaderi2 = i
				end
			end
		elseif s2[1] == "graphicspack" then
			for i = 1, #graphicspacklist do
				if graphicspacklist[i] == s2[2] then
					graphicspacki = i
					graphicspack = s2[2]
				end
			end
		elseif s2[1] == "soundpack" then
			for i = 1, #soundpacklist do
				if soundpacklist[i] == s2[2] then
					soundpacki = i
					soundpack = s2[2]
				end
			end
		elseif s2[1] == "volume" then
			volume = tonumber(s2[2])
			love.audio.setVolume( volume )
		elseif s2[1] == "mouseowner" then
			mouseowner = tonumber(s2[2])
		elseif s2[1] == "mappack" then
			if love.filesystem.exists("mappacks/" .. s2[2] .. "/settings.txt") then
				mappack = s2[2]
			end
		elseif s2[1] == "gamefinished" then
			gamefinished = true
		elseif s2[1] == "vsync" then
			vsync = true
		elseif s2[1] == "reachedworlds" then
			reachedworlds[s2[2]] = {}
			local s3 = s2[3]:split(",")
			for i = 1, #s3 do
				if tonumber(s3[i]) == 1 then
					reachedworlds[s2[2]][i] = true
				end
			end
		elseif s2[1] == "mariocharacter" then
			mariocharacter[tonumber(s2[2])] = s2[3]
		elseif s2[1] == "fullscreen" then
			fullscreen = s2[2] == "true"
		elseif s2[1] == "fullscreenmode" then
			fullscreenmode = s2[2]
		end
	end
	
	for i = 1, math.max(4, players) do
		portalcolor[i] = {getrainbowcolor(portalhues[i][1]), getrainbowcolor(portalhues[i][2])}
	end
	
	players = 1
end

function defaultconfig()
	--------------
	-- CONTORLS --
	--------------
	
	-- Joystick stuff:
	-- joy, #, hat, #, direction (r, u, ru, etc)
	-- joy, #, axe, #, pos/neg
	-- joy, #, but, #
	-- You cannot set Hats and Axes as the jump button. Bummer.
	
	mouseowner = 1
	
	oldcontrols = {}
	
	local i = 1
	oldcontrols[i] = {}
	oldcontrols[i]["right"] = {"d"}
	oldcontrols[i]["left"] = {"a"}
	oldcontrols[i]["down"] = {"s"}
	oldcontrols[i]["up"] = {"w"}
	oldcontrols[i]["run"] = {"lshift"}
	oldcontrols[i]["jump"] = {" "}
	oldcontrols[i]["aimx"] = {""} --mouse aiming, so no need
	oldcontrols[i]["aimy"] = {""}
	oldcontrols[i]["portal1"] = {""}
	oldcontrols[i]["portal2"] = {""}
	oldcontrols[i]["reload"] = {"r"}
	oldcontrols[i]["use"] = {"e"}
	
	for i = 2, 4 do
		oldcontrols[i] = {}		
		oldcontrols[i]["right"] = {"joy", i-1, "hat", 1, "r"}
		oldcontrols[i]["left"] = {"joy", i-1, "hat", 1, "l"}
		oldcontrols[i]["down"] = {"joy", i-1, "hat", 1, "d"}
		oldcontrols[i]["up"] = {"joy", i-1, "hat", 1, "u"}
		oldcontrols[i]["run"] = {"joy", i-1, "but", 3}
		oldcontrols[i]["jump"] = {"joy", i-1, "but", 1}
		oldcontrols[i]["aimx"] = {"joy", i-1, "axe", 5, "neg"}
		oldcontrols[i]["aimy"] = {"joy", i-1, "axe", 4, "neg"}
		oldcontrols[i]["portal1"] = {"joy", i-1, "but", 5}
		oldcontrols[i]["portal2"] = {"joy", i-1, "but", 6}
		oldcontrols[i]["reload"] = {"joy", i-1, "but", 4}
		oldcontrols[i]["use"] = {"joy", i-1, "but", 2}
	end
	-------------------
	-- PORTAL COLORS --
	-------------------
	
	portalhues = {}
	portalcolor = {}
	for i = 1, 4 do
		local players = 4
		portalhues[i] = {(i-1)*(1/players), (i-1)*(1/players)+0.5/players}
		portalcolor[i] = {getrainbowcolor(portalhues[i][1]), getrainbowcolor(portalhues[i][2])}
	end
	
	--hats.
	mariohats = {}
	for i = 1, 4 do
		mariohats[i] = {1}
	end
	
	------------------
	-- MARIO COLORS --
	------------------
	--1: hat, pants (red)
	--2: shirt, shoes (brown-green)
	--3: skin (yellow-orange)
	
	mariocolors = {}
	mariocolors[1] = {{224,  32,   0}, {136, 112,   0}, {252, 152,  56}}
	mariocolors[2] = {{255, 255, 255}, {  0, 160,   0}, {252, 152,  56}}
	mariocolors[3] = {{  0,   0,   0}, {200,  76,  12}, {252, 188, 176}}
	mariocolors[4] = {{ 32,  56, 236}, {  0, 128, 136}, {252, 152,  56}}
	for i = 5, players do
		mariocolors[i] = mariocolors[math.random(4)]
	end
	
	--STARCOLORS
	starcolors = {}
	starcolors[1] = {{  0,   0,   0}, {200,  76,  12}, {252, 188, 176}}
	starcolors[2] = {{  0, 168,   0}, {252, 152,  56}, {252, 252, 252}}
	starcolors[3] = {{252, 216, 168}, {216,  40,   0}, {252, 152,  56}}
	starcolors[4] = {{216,  40,   0}, {252, 152,  56}, {252, 252, 252}}
	
	flowercolor = {{252, 216, 168}, {216,  40,   0}, {252, 152,  56}}
	
	--CHARACTERS
	mariocharacter = {"mario", "mario", "mario", "mario"}
	
	--options
	scale = 2
	volume = 1
	mappack = "smb"
	vsync = false
	currentshaderi1 = 1
	currentshaderi2 = 1
	graphicspacki = 1
	graphicspack = "DEFAULT"
	soundpacki = 1
	soundpack = "DEFAULT"
	firstpersonview = false
	firstpersonrotate = false
	seethroughportals = false
	fullscreen = false
	fullscreenmode = "letterbox"
	
	reachedworlds = {}
end

function loadcustomimages(path)
	for i = 1, #overwrittenimages do
		local s = overwrittenimages[i]
		_G[s .. "img"] = _G["default" .. s .. "img"]
	end
	overwrittenimages = {}

	local fl = love.filesystem.getDirectoryItems(path)
	for i = 1, #fl do
		local v = fl[i]
		if love.filesystem.isFile(path .. "/" .. v) then
			local s = string.sub(v, 1, -5)
			if table.contains(imagelist, s) then
				_G[s .. "img"] = love.graphics.newImage(path .. "/" .. v)
				table.insert(overwrittenimages, s)
			end
		end
	end
	
	--tiles
	tilequads = {}
	rgblist = {}
	
	--add smb tiles
	local imgwidth, imgheight = smbtilesimg:getWidth(), smbtilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata
	if love.filesystem.isFile(path .. "/smbtiles.png") then
		imgdata = love.image.newImageData(path .. "/smbtiles.png")
	else
		imgdata = love.image.newImageData("graphics/DEFAULT/smbtiles.png")
	end
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(smbtilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	smbtilecount = width*height
	
	--add portal tiles
	local imgwidth, imgheight = portaltilesimg:getWidth(), portaltilesimg:getHeight()
	local width = math.floor(imgwidth/17)
	local height = math.floor(imgheight/17)
	local imgdata
	if love.filesystem.isFile(path .. "/portaltiles.png") then
		imgdata = love.image.newImageData(path .. "/portaltiles.png")
	else
		imgdata = love.image.newImageData("graphics/DEFAULT/portaltiles.png")
	end
	
	for y = 1, height do
		for x = 1, width do
			table.insert(tilequads, quad:new(portaltilesimg, imgdata, x, y, imgwidth, imgheight))
			local r, g, b = getaveragecolor(imgdata, x, y)
			table.insert(rgblist, {r, g, b})
		end
	end
	portaltilecount = width*height
end

--[[function suspendgame()
	local s = ""
	if marioworld == "M" then
		marioworld = 1
		mariolevel = 3
	end
	s = s .. "a/" .. marioworld .. "|"
	s = s .. "b/" .. mariolevel .. "|"
	s = s .. "c/" .. mariocoincount .. "|"
	s = s .. "d/" .. marioscore .. "|"
	s = s .. "e/" .. players .. "|"
	for i = 1, players do
		if mariolivecount ~= false then
			s = s .. "f/" .. i .. "/" .. mariolives[i] .. "|"
		end
		if objects["player"][i] then
			s = s .. "g/" .. i .. "/" .. objects["player"][i].size .. "|"
		else
			s = s .. "g/" .. i .."/1|"
		end
	end
	s = s .. "h/" .. mappack
	
	love.filesystem.write("suspend.txt", s)
	
	love.audio.stop()
	menu_load()
end]]

--[[function continuegame()
	if not love.filesystem.exists("suspend.txt") then
		return
	end
	
	local s = love.filesystem.read("suspend.txt")
	
	mariosizes = {}
	mariolives = {}
	
	local split = s:split("|")
	--@TODO: Gotta make room for currentmap = "1-1" in the save.
	for i = 1, #split do
		local split2 = split[i]:split("/")
		if split2[1] == "a" then
			marioworld = tonumber(split2[2])
		elseif split2[1] == "b" then
			mariolevel = tonumber(split2[2])
		elseif split2[1] == "c" then
			mariocoincount = tonumber(split2[2])
		elseif split2[1] == "d" then
			marioscore = tonumber(split2[2])
		elseif split2[1] == "e" then
			players = tonumber(split2[2])
		elseif split2[1] == "f" and mariolivecount ~= false then
			mariolives[tonumber(split2[2])] = tonumber(split2[3])
		elseif split2[1] == "g" then
			mariosizes[tonumber(split2[2])] = tonumber(split2[3])
		elseif split2[1] == "h" then
			mappack = split2[2]
		end
	end
	
	love.filesystem.remove("suspend.txt")
end]]

function changescale(s, init)
	scale = s
	
	if not init then
		if width*16*scale > desktopsize.width then
			if fullscreen and fullscreenmode == "full" then
				scale = scale - 1
				return
			end
			
			if fullscreen and fullscreenmode == "touchfrominside" then
				fullscreenmode = "full"
				scale = scale - 1
				return
			end
			
			if love.graphics.isSupported("canvas") then
				fullscreen = true
			end
			
			scale = scale - 1
			fullscreenmode = "touchfrominside"
			
		elseif fullscreen then
			if fullscreenmode == "full" then
				fullscreenmode = "touchfrominside"
				scale = scale + 1
				return
			else
				fullscreen = false
			end
			scale = scale + 1
			fullscreenmode = "full"
			
		end
	end
	
	if fullscreen then
		love.window.setMode(desktopsize.width, desktopsize.height, {fullscreen=fullscreen, vsync=vsync, fsaa=fsaa})
	else
		uispace = math.floor(width*16*scale/4)
		love.window.setMode(width*16*scale, height*16*scale, {fullscreen=fullscreen, vsync=vsync, fsaa=fsaa}) --25x14 blocks (15 blocks actual height)
	end
	
	if love.graphics.isSupported("canvas") then
		completecanvas = love.graphics.newCanvas()
		completecanvas:setFilter("linear", "linear")
	end
	
	gamewidth = love.window.getWidth()
	gameheight = love.window.getHeight()
	
	if shaders then
		shaders:refresh()
	end
	
	if generatespritebatch then
		generatespritebatch()
	end
end
function screenshotUploadWrap(iname, idata)
	local t=upload_imagedata(iname, idata)
	if t.success then
		print("Your image was uploaded to: "..t.data.link)
		love.system.setClipboardText(t.data.link)
		notice.new("screenshot uploaded")
		--love.filesystem.write("screenshot_url.txt", t.data.link)
		--openImage(t.data.link)
	else
		print("Your image upload failed, please upload '"..outname.."' manually.")
		notice.new("upload failed, try manually")
		openSaveFolder()
	end
end

function controlsUpdate(dt)
	if controls.tap.gameScreenshot then
		screenshotUploadWrap("screenshot.png", love.graphics.newScreenshot())
	end
	
	if controls.tap.editorGetMousePosition then
		local x, y = getMouseTile(mouse.getX(), mouse.getY())
		print("mouse position", x, y)
	end
	
	if controls.debugModifier then
		
		if controls.tap.recordToggle then
			recording = not recording
		end
		if replaysystem and controls.tap.replaySave then
			objects["player"][1]:savereplaydata()
		end
		if controls.tap.debugLua then
			debug.debug()
		end
		if controls.tap.debugCrash then
			totallynonexistantfunction()
		end
	end
	
	if controls.tap.gameGrabMouseToggle then
		love.mouse.setGrabbed(not love.mouse.isGrabbed())
	end
	
	if gamestate == "lobby" or gamestate == "onlinemenu" then
		if controls.tap.menuBack then
			net_quit()
			return
		end
	end
	
	if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" then
		menu_controlupdate(dt)
	elseif gamestate == "game" then
		game_controlupdate(dt)
	elseif gamestate == "intro" then
		intro_skip()
	end
end

function love.keypressed(key, isrepeat)
	if keyprompt then
		keypromptenter("key", key)
		return
	end

	--@WARNING: This is the sample of code that causes the online lobby to edit all textboxes at once.
	for i, v in pairs(guielements) do
		if v:keypress(string.lower(key)) then
			--return
		end
	end
	
	if testbed then
		for k,v in pairs(testbed) do
			if v.active then
				v:keypressed(key)
			end
		end
	end
	
	
	if gamestate == "menu" or gamestate == "mappackmenu" or gamestate == "onlinemenu" or gamestate == "options" then
		table.insert(konamitable, key)
		table.remove(konamitable, 1)
		local s = ""
		for i = 1, #konamitable do
			s = s .. konamitable[i]
		end
		
		if sha1(s) == konamihash then --Before you wonder how dumb this is; This used to be a different code than konami because I thought it'd be fun to make people figure it out before they can tell others how to easily unlock cheats (without editing files). It wasn't, really.
			playsound("konami") --allowed global
			gamefinished = true
			saveconfig()
			notice.new("Cheats unlocked!")
		end
	elseif gamestate == "game" and editormode and rightclickm then
		-- aside from the transplanted code above, this was the only thing left in the editor's keypressed
		rightclickm:keypressed(key)
	elseif gamestate == "intro" then
		intro_skip()
	end
end

function getMousePos()
	--[[local x, y = love.mouse.getX(), love.mouse.getY()
	if fullscreen then
		if fullscreenmode == "full" then
			x, y = x/(desktopsize.width/(width*16*scale)), y/(desktopsize.height/(height*16*scale))
		else
			x, y = x/(touchfrominsidescaling/scale), y/(touchfrominsidescaling/scale)-touchfrominsidemissing/2
		end
	end]]
	return mouse.getX(), mouse.getY()
end

function love.mousepressed(ox, oy, button)
	local x, y = getMousePos()
	if gamestate == "intro" then
		intro_skip()
	end
	
	--editor transplant because I guess the editor doesn't use the standard guielements array
	
	--editor transplant because ???
	if rightclickm then
		allowdrag = false
		if button == "r" or not rightclickm:mousepressed(x, y, button) then
			closerightclickmenu()
			return
		else
			return
		end
	end
	
	if testbed then
		for k,v in pairs(testbed) do
			if v.active then
				v:mousepressed(x, y, button)
			end
		end
	end
	
	for i, v in pairs(guielements) do
		if v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
	
	for i, v in pairs(guielements) do
		if not v.priority then
			if v:click(x, y, button) then
				return
			end
		end
	end
end

function love.mousereleased(ox, oy, button)
	local x, y = getMousePos()
	--desktopsize.width/(width*16*scale)*x, desktopsize.height/(height*16*scale)*y
	
	for i, v in pairs(guielements) do
		v:unclick(x, y, button)
	end
	
	if testbed then
		for k,v in pairs(testbed) do
			if v.active then
				v:mousereleased(x, y, button)
			end
		end
	end
	
	--same as above
	if rightclickm then
		rightclickm:mousereleased(x, y, button)
	end
end

function round(num, idp) --Not by me
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

function keyPromptSignal(itype, ...)
	
end

function getrainbowcolor(i)
	local whiteness = 255
	local r, g, b
	if i < 1/6 then
		r = 1
		g = i*6
		b = 0
	elseif i >= 1/6 and i < 2/6 then
		r = (1/6-(i-1/6))*6
		g = 1
		b = 0
	elseif i >= 2/6 and i < 3/6 then
		r = 0
		g = 1
		b = (i-2/6)*6
	elseif i >= 3/6 and i < 4/6 then
		r = 0
		g = (1/6-(i-3/6))*6
		b = 1
	elseif i >= 4/6 and i < 5/6 then
		r = (i-4/6)*6
		g = 0
		b = 1
	else
		r = 1
		g = 0
		b = (1/6-(i-5/6))*6
	end
	
	return {round(r*whiteness), round(g*whiteness), round(b*whiteness), 255}
end

function newRecoloredImage(path, tablein, tableout)
	local imagedata = love.image.newImageData( path )
	local width, height = imagedata:getWidth(), imagedata:getHeight()
	
	for y = 0, height-1 do
		for x = 0, width-1 do
			local oldr, oldg, oldb, olda = imagedata:getPixel(x, y)
			
			if olda > 128 then
				for i = 1, #tablein do
					if oldr == tablein[i][1] and oldg == tablein[i][2] and oldb == tablein[i][3] then
						local r, g, b = unpack(tableout[i])
						imagedata:setPixel(x, y, r, g, b, olda)
					end
				end
			end
		end
	end
	
	return love.graphics.newImage(imagedata)
end

function getaveragecolor(imgdata, cox, coy)	
	local xstart = (cox-1)*17
	local ystart = (coy-1)*17
	
	local r, g, b = 0, 0, 0
	
	local count = 0
	
	for x = xstart, xstart+15 do
		for y = ystart, ystart+15 do
			local pr, pg, pb, a = imgdata:getPixel(x, y)
			if a > 127 then
				r, g, b = r+pr, g+pg, b+pb
				count = count + 1
			end
		end
	end
	
	r, g, b = r/count, g/count, b/count
	
	return r, g, b
end

function keyprompt_update()
	if keyprompt then
		for i = 1, prompt.joysticks do
			for j = 1, #prompt.joystick[i].validhats do
				local dir = love.joystick.getHat(i, prompt.joystick[i].validhats[j])
				if dir ~= "c" then
					keypromptenter("joyhat", i, prompt.joystick[i].validhats[j], dir)
					return
				end
			end
			
			for j = 1, prompt.joystick[i].axes do
				local value = love.joystick.getAxis(i, j)
				if value > prompt.joystick[i].axisposition[j] + joystickdeadzone then
					keypromptenter("joyaxis", i, j, "pos")
					return
				elseif value < prompt.joystick[i].axisposition[j] - joystickdeadzone then
					keypromptenter("joyaxis", i, j, "neg")
					return
				end
			end
		end
	end
end

function print_r (t, indent) --Not by me
	local indent=indent or ''
	for key,value in pairs(t) do
		io.write(indent,'[',tostring(key),']') 
		if type(value)=="table" then io.write(':\n') print_r(value,indent..'\t')
		else io.write(' = ',tostring(value),'\n') end
	end
end

--[[function love.focus(f)
	if not f and gamestate == "game"and not editormode and not levelfinished and not everyonedead  then
		pausemenuopen = true
		love.audio.pause()
	end
end]]
function openImage(img)
	local path = love.filesystem.getSaveDirectory()
	
	local cmdstr
	local successval = 0
	
	if os.getenv("WINDIR") then -- windows
		cmdstr = "Explorer \"%s\""
	elseif os.getenv("HOME") then
		if path:match("/Library/Application Support") then -- OSX
			cmdstr = "open \"%s\""
		else -- linux?
			cmdstr = "xdg-open \"%s\""
		end
	end
	
	os.execute(cmdstr:format(img))
	return cmdstr~=nil
end
function openSaveFolder(subfolder) --By Slime
	local path = love.filesystem.getSaveDirectory()
	path = subfolder and path.."/"..subfolder or path
	
	local cmdstr
	local successval = 0
	
	if os.getenv("WINDIR") then -- lolwindows
		--cmdstr = "Explorer /root,%s"
		if path:match("LOVE") then --hardcoded to fix ISO characters in usernames and made sure release mode doesn't mess anything up -saso
			cmdstr = "Explorer %%appdata%%\\LOVE\\Marin0SE"
		else
			cmdstr = "Explorer %%appdata%%\\Marin0SE"
		end
		path = path:gsub("/", "\\")
		successval = 1
	elseif os.getenv("HOME") then
		if path:match("/Library/Application Support") then -- OSX
			cmdstr = "open \"%s\""
		else -- linux?
			cmdstr = "xdg-open \"%s\""
		end
	end
	
	-- returns true if successfully opened folder
	return cmdstr and os.execute(cmdstr:format(path)) == successval
end

function getupdate()
	local onlinedata, code = http.request("http://server.stabyourself.net/mari0/?mode=mappacks")
	if code ~= 200 then
		return false
	elseif not onlinedata then
		return false
	end
	
	local latestversion
	
	local split1 = onlinedata:split("<")
	for i = 2, #split1 do
		local split2 = split1[i]:split(">")
		if split2[1] == "latestversion" then
			latestversion = tonumber(split2[2])
		end
	end
	
	if latestversion and latestversion > marioversion then
		return true
	end
	return false
end

function properprint(s, x, y, sc)
	local scale = sc or scale
	local startx = x
	local skip = 0
	for i = 1, string.len(tostring(s)) do
		if skip > 0 then
			skip = skip - 1
		else
			local char = string.sub(s, i, i)
			if string.sub(s, i, i+3) == "_dir" and tonumber(string.sub(s, i+4, i+4)) then
				love.graphics.draw(directionsimg, directionsquad[tonumber(string.sub(s, i+4, i+4))], x+((i-1)*8+1)*scale, y, 0, scale, scale)
				skip = 4
			elseif char == "|" then
				x = startx-((i)*8)*scale
				y = y + 10*scale
			elseif fontquads[char] then
				love.graphics.draw(fontimage, fontquads[char], x+((i-1)*8)*scale, y, 0, scale, scale)
			end
		end
	end
end

function properprintbackground(s, ox, oy, include, dcolor, sc)
	--[[if type(s)~="string" then
		print("WARNING: Tried to properprint a non-string.")
		return
	end]]
	local scale = sc or scale
	local x = ox
	local y = oy
	local startx = x
	local dcolor = dcolor or {255,255,255}
	local skip = 0
	local precolor = {love.graphics.getColor()}
	love.graphics.setColor(unpack(dcolor))
	for i = 1, string.len(tostring(s)) do
		if skip > 0 then
			skip = skip - 1
		else
			local char = string.sub(s, i, i)
			if char == "|" then
				x = startx-((i)*8)*scale
				y = y + 10*scale
			elseif fontquadsback[char] then
				love.graphics.draw(fontimageback, fontquadsback[char], x+((i-1)*8)*scale, y-1*scale, 0, scale, scale)
			end
		end
	end
	love.graphics.setColor(unpack(precolor))
	if include ~= false then
		properprint(s, ox, oy, scale)
	end
end

function loadcustombackgrounds()
	custombackgrounds = {}

	custombackgroundimg = {}
	custombackgroundwidth = {}
	custombackgroundheight = {}
	local fl = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/backgrounds")
	
	for i = 1, #fl do
		local v = "mappacks/" .. mappack .. "/backgrounds/" .. fl[i]
		
		if love.filesystem.isFile(v) then
			if string.sub(v, -5, -5) == "1" then
				local name = string.sub(fl[i], 1, -6)
				local bg = string.sub(v, 1, -6)
				local i = 1
				
				custombackgroundimg[name] = {}
				custombackgroundwidth[name] = {}
				custombackgroundheight[name] = {}
					
				while love.filesystem.exists(bg .. i .. ".png") do
					print("background", bg, "index", i)
					custombackgroundimg[name][i] = love.graphics.newImage(bg .. i .. ".png")
					custombackgroundwidth[name][i] = custombackgroundimg[name][i]:getWidth()/16
					custombackgroundheight[name][i] = custombackgroundimg[name][i]:getHeight()/16
					i = i + 1
				end
				table.insert(custombackgrounds, name)
			--[[else
				local name = string.sub(fl[i], 1, -5)
				local bg = string.sub(v, 1, -5)
				
				custombackgroundimg[name] = {love.graphics.newImage(bg .. ".png")}
				custombackgroundwidth[name] = {custombackgroundimg[name][1]:getWidth()/16}
				custombackgroundheight[name] = {custombackgroundimg[name][1]:getHeight()/16}
				
				table.insert(custombackgrounds, name)]]
			end
		end
	end
end

function loadlevelscreens()
	levelscreens = {}
	
	local fl = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/levelscreens")
	
	for i = 1, #fl do
		local v = "mappacks/" .. mappack .. "/levelscreens/" .. fl[i]
		if love.filesystem.isFile(v) then
			table.insert(levelscreens, string.lower(string.sub(fl[i], 1, -5)))
		end
	end
end

function loadcustommusics()
	musiclist = {"none.ogg", "overworld.ogg", "underground.ogg", "castle.ogg", "underwater.ogg", "starmusic.ogg", "athletic.ogg",}
	local fl = love.filesystem.getDirectoryItems("mappacks/" .. mappack .. "/music")
	custommusics = {}
	
	for i = 1, #fl do
		local v = fl[i]
		if (v:match(".ogg") or v:match(".mp3")) and v:sub(-9, -5) ~= "-fast" then
			table.insert(musiclist, v)
			--music:load(v) --Sometimes I come back to code and wonder why things are commented out. This is one of those cases. But it works so eh.
		end
	end
end

function loadanimatedtiles()
	if animatedtilecount then
		for i = 1, animatedtilecount do
			tilequads["a" .. i] = nil
		end
	end
	
	local function loadfolder(folder)
		local fl = love.filesystem.getDirectoryItems(folder)
		
		local i = 1
		while love.filesystem.isFile(folder .. "/" .. i .. ".png") do
			local v = folder .. "/" .. i .. ".png"
			if love.filesystem.isFile(v) and string.sub(v, -4) == ".png" then
				if love.filesystem.isFile(string.sub(v, 1, -5) .. ".txt") then
					animatedtilecount = animatedtilecount + 1
					local number = animatedtilecount+10000
					local t = animatedquad:new(v, love.filesystem.read(string.sub(v, 1, -5) .. ".txt"), number)
					tilequads[number] = t
					table.insert(animatedtiles, t)
				end
			end
			i = i + 1
		end
	end
	
	animatedtilecount = 0
	animatedtiles = {}
	loadfolder("graphics/animated")
	loadfolder("mappacks/" .. mappack .. "/animated")
end

function loadcustomtiles()
	if love.filesystem.exists("mappacks/" .. mappack .. "/tiles.png") then
		customtiles = true
		customtilesimg = love.graphics.newImage("mappacks/" .. mappack .. "/tiles.png")
		local imgwidth, imgheight = customtilesimg:getWidth(), customtilesimg:getHeight()
		local width = math.floor(imgwidth/17)
		local height = math.floor(imgheight/17)
		local imgdata = love.image.newImageData("mappacks/" .. mappack .. "/tiles.png")
		
		for y = 1, height do
			for x = 1, width do
				table.insert(tilequads, quad:new(customtilesimg, imgdata, x, y, imgwidth, imgheight))
				local r, g, b = getaveragecolor(imgdata, x, y)
				table.insert(rgblist, {r, g, b})
			end
		end
		customtilecount = width*height
	else
		customtiles = false
		customtilecount = 0
	end
end

function reloadGraphics()
	-- this doesn't rebuild quads so if any of these change resolution we're royally hosed
	iconimg = love.image.newImageData("/guihud/icon.gif")
	love.window.setIcon(iconimg)

	fontimage = love.graphics.newImage("/guihud/font.png")
	fontimageback = love.graphics.newImage("/guihud/fontback.png")
	
	logo = love.graphics.newImage("/guihud/stabyourself.png")
	logoblood = love.graphics.newImage("/guihud/stabyourselfblood.png")
	
	for _, v in pairs(imagelist) do
		_G[v .. "img"] = love.graphics.newImage( v .. ".png")
	end
	
	transparencyimg:setWrap("repeat", "repeat")
	
	menuselection = love.graphics.newImage("/guihud/menuselect.png")
	mappackback = love.graphics.newImage("/guihud/mappackback.png")
	mappacknoicon = love.graphics.newImage("/guihud/mappacknoicon.png")
	mappackoverlay = love.graphics.newImage("/guihud/mappackoverlay.png")
	mappackhighlight = love.graphics.newImage("/guihud/mappackhighlight.png")
	
	mappackscrollbar = love.graphics.newImage("/guihud/mappackscrollbar.png")
	
	fontimage2 = love.graphics.newImage("/guihud/smallfont.png")
	fontimage3 = love.graphics.newImage("/guihud/smallsymbols.png")
	
	entitiesimg = love.graphics.newImage("/guihud/entities.png")
	
	popupfontimage = love.graphics.newImage("/guihud/popupfont.png")
	
	linktoolpointerimg = love.graphics.newImage("/guihud/linktoolpointer.png")
	
	titleimage = love.graphics.newImage("/guihud/title.png")
	playerselectimg = love.graphics.newImage("/guihud/playerselectarrow.png")
	
	magicimg = love.graphics.newImage("/guihud/magic.png")
	
	checkboximg = love.graphics.newImage("/guihud/checkbox.png")
	
	dropdownarrowimg = love.graphics.newImage("/guihud/dropdownarrow.png")
	
	portalparticleimg = love.graphics.newImage("portalparticle.png")
	portalcrosshairimg = love.graphics.newImage("portalcrosshair.png")
	portaldotimg = love.graphics.newImage("portaldot.png")
	portalprojectileimg = love.graphics.newImage("portalprojectile.png")
	portalprojectileparticleimg = love.graphics.newImage("portalprojectileparticle.png")
	portalbackgroundimg = love.graphics.newImage("portalbackground.png")
	
	--Menu shit
	huebarimg = love.graphics.newImage("/guihud/huebar.png")
	huebarmarkerimg = love.graphics.newImage("/guihud/huebarmarker.png")
	volumesliderimg = love.graphics.newImage("/guihud/volumeslider.png")
	directionsimg = love.graphics.newImage("/guihud/directions.png")
	
	gradientimg = love.graphics.newImage("/guihud/gradient.png")
	gradientimg:setFilter("linear", "linear")
	
	--@WARNING: This code is a bad influence because icons that don't already exist can't be introduced by a modpack. I'll fix it later.
	killfeed.icons = {}
	killfeed.exicons = {}
	local gdir = "graphics/DEFAULT/"
	local idir = "ui/icons/kill"
	for h,s in ipairs(love.filesystem.getDirectoryItems(gdir..idir)) do
		if love.filesystem.isFile(gdir..idir.."/"..s) then
			killfeed.icons[s:sub(0,-5)] = love.graphics.newImage(gdir..idir.."/"..s)
		end
	end
	idir = "ui/icons"
	for h,s in ipairs(love.filesystem.getDirectoryItems(gdir..idir)) do
		if love.filesystem.isFile(gdir..idir.."/"..s) then
			killfeed.exicons[s:sub(0,-5)] = love.graphics.newImage(gdir..idir.."/"..s)
		end
	end
	
end

function reloadSounds() -- mastersfx, master list of sounds current being looked at.
	soundstoload = {"none", "jump", "jumpbig", "stomp", "shot", "blockhit", "blockbreak", "coin", "pipe", "boom", "mushroomappear", "mushroomeat", "shrink", "death", "gameover", "fireball", "redcoin1", "redcoin2", "redcoin3", "redcoin4", "redcoin5", "boss_spit", "enemy_hit", "rainboom", "kirbyenemy",
					"oneup", "levelend", "castleend", "scorering", "intermission", "fire", "bridgebreak", "bowserfall", "vine", "swim", "konami", "pause", "bulletbill", "addtime", "throw", "trophy", "switch",
					"lowtime", "tailwag", "planemode", "stab", "spring", "portal1open", "portal2open", "portalenter", "portalfizzle"}
				
	soundlist = {}
	
	for i, v in pairs(soundstoload) do
		local dat = love.sound.newSoundData(v..".ogg")
		soundlist[v] = {}
		soundlist[v].duration = dat:getDuration()
		soundlist[v].samplecount = dat:getSampleCount()
		soundlist[v].samplerate = dat:getSampleRate()
		soundlist[v].source = love.audio.newSource(dat)
		soundlist[v].lastplayed = 0
	end
	
	soundlist["scorering"].source:setLooping(true)
	soundlist["planemode"].source:setLooping(true)
	soundlist["portal1open"].source:setVolume(0.3)
	soundlist["portal2open"].source:setVolume(0.3)
	soundlist["portalenter"].source:setVolume(0.3)
	soundlist["portalfizzle"].source:setVolume(0.3)
end

function love.quit()
	
end

function savestate(i)
	serializetable(_G)
end

function serializetable(t)
	tablestodo = {t}
	tableindex = {}
	repeat
		nexttablestodo = {}
		for i, v in pairs(tablestodo) do
			if type(v) == "table" then
				local tableexists = false
				for j, k in pairs(tableindex) do
					if k == v then
						tableexists = true
					end
				end
				
				if tableexists then
					
				else
					table.insert(nexttablestodo, v)
					table.insert(tableindex, v)
				end
			end
		end
		tablestodo = nexttablestodo
	until #tablestodo == 0
end

mouse = {}

function mouse.getPosition()
	if fullscreen then
		if fullscreenmode == "full" then
			return love.mouse.getX()/(desktopsize.width/(width*16*scale)), love.mouse.getY()/(desktopsize.height/(height*16*scale))
		else
			return love.mouse.getX()/(touchfrominsidescaling/scale), love.mouse.getY()/(touchfrominsidescaling/scale)-touchfrominsidemissing/2
		end
	else
		return love.mouse.getPosition()
	end
end

function mouse.getX()
	if fullscreen then
		if fullscreenmode == "full" then
			return love.mouse.getX()/(desktopsize.width/(width*16*scale))
		else
			return love.mouse.getX()/(touchfrominsidescaling/scale)
		end
	else
		return love.mouse.getX()
	end
end

function mouse.getY()
	if fullscreen then
		if fullscreenmode == "full" then
			return love.mouse.getY()/(desktopsize.height/(height*16*scale))
		else
			return love.mouse.getY()/(touchfrominsidescaling/scale)-touchfrominsidemissing/2
		end
	else
		return love.mouse.getY()
	end
end

function net_quit()
	gamestate = "menu"
	guielements = {}
	if onlinemp then
		if not clientisnetworkhost then
			local unconnectedstring = tostring(udp)
			local splitstring = unconnectedstring:split(":")
			if splitstring[1] == "udp{connected}" then
				udp:send("clientquit;" .. networkclientnumber)
			end
		else
			server_shutserver()
			print("shutting server")
		end
		if clientisnetworkhost then
			magicdns_remove()
		end
	end
end